<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Reactive Applications :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.8">
    <link rel="stylesheet" href="../../_/css/site.css">

<link href="../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>
<link rel="stylesheet" href="../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://spring.io">
        <img id="springlogo" class="block" src="../../_/img/spring-logo.svg" alt="Spring">
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item navbar-item-special" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
            <a class="navbar-item navbar-item-special-2" href="https://start.spring.io">Spring Initializr <svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><polyline points="15 10.94 15 15 1 15 1 1 5.06 1" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><polyline points="8.93 1 15 1 15 7.07" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></polyline><line x1="15" y1="1" x2="8" y2="8" fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="2"></line></svg></a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable is-community">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="" data-version="5.5">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Features</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../features/authentication/supported.html">Authentication</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/authentication/password-storage.html">Password Storage</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Protection Against Exploits</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/headers.html">HTTP Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../features/exploits/http.html">HTTP Requests</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../modules.html">Project Modules and Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/architecture.html">The Big Picture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../servlet/authentication/index.html">Authentication</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/architecture.html">Authentication Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../servlet/authentication/passwords/index.html">Username/Password</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reading Username/Password</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/form.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/basic.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/digest.html">Digest</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Password Storage</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/in-memory.html">In Memory</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/user-details.html">UserDetails</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/user-details-service.html">UserDetailsService</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/password-encoder.html">PasswordEncoder</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/dao-authentication-provider.html">DaoAuthenticationProvider</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/passwords/ldap.html">LDAP</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/session-management.html">Session Management</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/rememberme.html">Remember Me</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/openid.html">OpenID Support</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/anonymous.html">Anonymous</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/preauth.html">Pre-Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/jaas.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/cas.html">CAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/x509.html">X509</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/runas.html">Run-As</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/logout.html">Logout</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/events.html">Authentication Events</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../servlet/authorization/index.html">Authorization</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/architecture.html">Authorization Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/authorize-requests.html">Authorize HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/expression-based.html">Expression-Based Access Control</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/secure-objects.html">Secure Object Implementations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/method-security.html">Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/acls.html">Domain Object Security (ACLs)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-login.html">OAuth2 Log In</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-client.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-resourceserver.html">OAuth2 Resource Server</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/saml2/index.html">SAML 2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../servlet/exploits/index.html">Protection Against Exploits</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/exploits/headers.html">HTTP Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/exploits/http.html">HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/exploits/firewall.html">Firewall</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integrations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/servlet-api.html">Servlet APIs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/data.html">Spring Data</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/concurrency.html">Java&#8217;s Concurrency APIs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/jackson.html">Jackson</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/localization.html">Localization</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/mvc.html">Spring MVC</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/websocket.html">WebSocket</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/cors.html">Spring CORS Support</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/integrations/jsp-taglibs.html">JSP Taglib</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/java-configuration/index.html">Java Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/kotlin-configuration/index.html">Kotlin Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/namespace/index.html">Security Namespace Configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Testing</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/test/method.html">Testing Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/test/mockmvc.html">Spring MVC Test Integration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/cryptography.html">Cryptography</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Appendix</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/appendix/proxy-server.html">Proxy Server Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/appendix/database-schema.html">Security Database Schema</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/appendix/namespace.html">The Security Namespace</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/appendix/faq.html">Spring Security FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reactive Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="webflux.html">WebFlux Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Project Against Exploits</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/csrf.html">CSRF</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/headers.html">Headers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="exploits/http.html">HTTP Requests</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/login.html">OAuth 2.0 Login</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/access-token.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="oauth2/resource-server.html">OAuth 2.0 Resource Server</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="registered-oauth2-authorized-client.html">@RegisteredOAuth2AuthorizedClient</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="x509.html">X.509</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="webclient.html">WebClient</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="method.html">EnableReactiveMethodSecurity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="cors.html">CORS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="test.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="rsocket.html">RSocket</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.5</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../index.html">5.6</a>
        </li>
        <li class="version is-current">
          <a href="../index.html">5.5</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../session/index.html">Spring Session</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../session/index.html">2.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Security</a></li>
    <li><a href="index.html">Reactive Applications</a></li>
  </ul>
</nav>
<div class="search">
  <input id="search-input" type="text" placeholder="Search docs">
</div>

<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">5.5</button>
  <div class="version-menu">
    <a class="version" href="../../reactive/index.html">5.6</a>
    <a class="version is-current" href="index.html">5.5</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-security/edit/antora/5.5.x/docs/modules/ROOT/pages/reactive/index.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="admonitionblock important">
  <table>
    <tbody><tr>
      <td class="icon">
        <i class="fa icon-important" title="Important"></i>
      </td>
      <td class="content">
        <div class="paragraph">
          <p>There is a newer version available. Please update to <a href="../../reactive/index.html">Spring Security 5.6</a>!</p>
        </div>
      </td>
    </tr></tbody>
  </table>
</div>
<h1 id="page-title" class="page">Reactive Applications</h1>
<div class="sect1">
<h2 id="jc-webflux"><a class="anchor" href="#jc-webflux"></a>WebFlux Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security&#8217;s WebFlux support relies on a <code>WebFilter</code> and works the same for Spring WebFlux and Spring WebFlux.Fn.
You can find a few sample applications that demonstrate the code below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello WebFlux {gh-samples-url}/reactive/webflux/java/hello-security[hellowebflux]</p>
</li>
<li>
<p>Hello WebFlux.Fn {gh-samples-url}/reactive/webflux-fn/hello-security[hellowebfluxfn]</p>
</li>
<li>
<p>Hello WebFlux Method {gh-samples-url}/reactive/webflux/java/method[hellowebflux-method]</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_minimal_webflux_security_configuration"><a class="anchor" href="#_minimal_webflux_security_configuration"></a>Minimal WebFlux Security Configuration</h3>
<div class="paragraph">
<p>You can find a minimal WebFlux Security configuration below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Minimal WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configuration provides form and http basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default log in page and a default log out page, sets up security related HTTP headers, CSRF protection, and more.</p>
</div>
</div>
<div class="sect2">
<h3 id="_explicit_webflux_security_configuration"><a class="anchor" href="#_explicit_webflux_security_configuration"></a>Explicit WebFlux Security Configuration</h3>
<div class="paragraph">
<p>You can find an explicit version of the minimal WebFlux Security configuration below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Explicit WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange(exchanges -&gt; exchanges
			    .anyExchange().authenticated()
			)
			.httpBasic(withDefaults())
			.formLogin(withDefaults());
		return http.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }

    @Bean
    fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            formLogin { }
            httpBasic { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configuration explicitly sets up all the same things as our minimal configuration.
From here you can easily make the changes to the defaults.</p>
</div>
<div class="paragraph">
<p>You can find more examples of explicit configuration in unit tests, by searching <a href="https://github.com/spring-projects/spring-security/search?q=path%3Aconfig%2Fsrc%2Ftest%2F+EnableWebFluxSecurity">EnableWebFluxSecurity in the <code>config/src/test/</code> directory</a>.</p>
</div>
<div class="sect3">
<h4 id="jc-webflux-multiple-filter-chains"><a class="anchor" href="#jc-webflux-multiple-filter-chains"></a>Multiple Chains Support</h4>
<div class="paragraph">
<p>You can configure multiple <code>SecurityWebFilterChain</code> instances to separate configuration by <code>RequestMatcher</code> s.</p>
</div>
<div class="paragraph">
<p>For example, you can isolate configuration for URLs that start with <code>/api</code>, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebFluxSecurity
static class MultiSecurityHttpConfig {

    @Order(Ordered.HIGHEST_PRECEDENCE)                                                      <i class="conum" data-value="1"></i><b>(1)</b>
    @Bean
    SecurityWebFilterChain apiHttpSecurity(ServerHttpSecurity http) {
        http
            .securityMatcher(new PathPatternParserServerWebExchangeMatcher("/api/**"))      <i class="conum" data-value="2"></i><b>(2)</b>
            .authorizeExchange((exchanges) -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);                           <i class="conum" data-value="3"></i><b>(3)</b>
        return http.build();
    }

    @Bean
    SecurityWebFilterChain webHttpSecurity(ServerHttpSecurity http) {                       <i class="conum" data-value="4"></i><b>(4)</b>
        http
            .authorizeExchange((exchanges) -&gt; exchanges
                .anyExchange().authenticated()
            )
            .httpBasic(withDefaults())                                                      <i class="conum" data-value="5"></i><b>(5)</b>
        return http.build();
    }

    @Bean
    ReactiveUserDetailsService userDetailsService() {
        return new MapReactiveUserDetailsService(
                PasswordEncodedUser.user(), PasswordEncodedUser.admin());
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure a <code>SecurityWebFilterChain</code> with an <code>@Order</code> to specify which <code>SecurityWebFilterChain</code> Spring Security should consider first</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>PathPatternParserServerWebExchangeMatcher</code> to state that this <code>SecurityWebFilterChain</code> will only apply to URL paths that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specify the authentication mechanisms that will be used for <code>/api/**</code> endpoints</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>SecurityWebFilterChain</code> with lower precedence to match all other URLs</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specify the authentication mechanisms that will be used for the rest of the application</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security will select one <code>SecurityWebFilterChain</code> <code>@Bean</code> for each request.
It will match the requests in order by the <code>securityMatcher</code> definition.</p>
</div>
<div class="paragraph">
<p>In this case, that means that if the URL path starts with <code>/api</code>, then Spring Security will use <code>apiHttpSecurity</code>.
If the URL does not start with <code>/api</code> then Spring Security will default to <code>webHttpSecurity</code>, which has an implied <code>securityMatcher</code> that matches any request.</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/reactive/index.adoc - include::exploits/index.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/reactive/index.adoc - include::oauth2/index.adoc[]</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-roac"><a class="anchor" href="#webflux-roac"></a>@RegisteredOAuth2AuthorizedClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security allows resolving an access token using <code>@RegisteredOAuth2AuthorizedClient</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A working example can be found in {gh-samples-url}/reactive/webflux/java/oauth2/webclient[<strong>OAuth 2.0 WebClient WebFlux sample</strong>].</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After configuring Spring Security for <a href="#webflux-oauth2-login">OAuth2 Login</a> or as an <a href="#webflux-oauth2-client">OAuth2 Client</a>, an <code>OAuth2AuthorizedClient</code> can be resolved using the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This integrates into Spring Security to provide the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security will automatically refresh expired tokens (if a refresh token is present)</p>
</li>
<li>
<p>If an access token is requested and not present, Spring Security will automatically request the access token.</p>
<div class="ulist">
<ul>
<li>
<p>For <code>authorization_code</code> this involves performing the redirect and then replaying the original request</p>
</li>
<li>
<p>For <code>client_credentials</code> the token is simply requested and saved</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the user authenticated using <code>oauth2Login()</code>, then the <code>client-id</code> is optional.
For example, the following would work:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/implicit")
Mono&lt;String&gt; implicit(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/implicit")
fun implicit(@RegisteredOAuth2AuthorizedClient authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is convenient if the user always authenticates with OAuth2 Login and an access token from the same authorization server is needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-x509"><a class="anchor" href="#reactive-x509"></a>Reactive X.509 Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Similar to <a href="#servlet-x509">Servlet X.509 authentication</a>, reactive x509 authentication filter allows extracting an authentication token from a certificate provided by a client.</p>
</div>
<div class="paragraph">
<p>Below is an example of a reactive x509 security configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
	http
		.x509(withDefaults())
		.authorizeExchange(exchanges -&gt; exchanges
		    .anyExchange().permitAll()
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the configuration above, when neither <code>principalExtractor</code> nor <code>authenticationManager</code> is provided defaults will be used. The default principal extractor is <code>SubjectDnX509PrincipalExtractor</code> which extracts the CN (common name) field from a certificate provided by a client. The default authentication manager is <code>ReactivePreAuthenticatedAuthenticationManager</code> which performs user account validation, checking that user account with a name extracted by <code>principalExtractor</code> exists and it is not locked, disabled, or expired.</p>
</div>
<div class="paragraph">
<p>The next example demonstrates how these defaults can be overridden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
	SubjectDnX509PrincipalExtractor principalExtractor =
	        new SubjectDnX509PrincipalExtractor();

	principalExtractor.setSubjectDnRegex("OU=(.*?)(?:,|$)");

	ReactiveAuthenticationManager authenticationManager = authentication -&gt; {
		authentication.setAuthenticated("Trusted Org Unit".equals(authentication.getName()));
		return Mono.just(authentication);
	};

	http
		.x509(x509 -&gt; x509
		    .principalExtractor(principalExtractor)
		    .authenticationManager(authenticationManager)
		)
		.authorizeExchange(exchanges -&gt; exchanges
		    .anyExchange().authenticated()
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, a username is extracted from the OU field of a client certificate instead of CN, and account lookup using <code>ReactiveUserDetailsService</code> is not performed at all. Instead, if the provided certificate issued to an OU named "Trusted Org Unit", a request will be authenticated.</p>
</div>
<div class="paragraph">
<p>For an example of configuring Netty and <code>WebClient</code> or <code>curl</code> command-line tool to use mutual TLS and enable X.509 authentication, please refer to <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509" class="bare">https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_webclient"><a class="anchor" href="#_webclient"></a>WebClient</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following documentation is for use within Reactive environments.
For Servlet environments, refer to <a href="#oauth2Client-webclient-servlet">WebClient for Servlet</a> environments.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Framework has built in support for setting a Bearer token.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">webClient.get()
    .headers(h -&gt; h.setBearerAuth(token))
    ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">webClient.get()
    .headers { it.setBearerAuth(token) }
    ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security builds on this support to provide additional benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security will automatically refresh expired tokens (if a refresh token is present)</p>
</li>
<li>
<p>If an access token is requested and not present, Spring Security will automatically request the access token.</p>
<div class="ulist">
<ul>
<li>
<p>For authorization_code this involves performing the redirect and then replaying the original request</p>
</li>
<li>
<p>For client_credentials the token is simply requested and saved</p>
</li>
</ul>
</div>
</li>
<li>
<p>Support for the ability to transparently include the current OAuth token or explicitly select which token should be used.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="webclient-setup"><a class="anchor" href="#webclient-setup"></a>WebClient OAuth2 Setup</h3>
<div class="paragraph">
<p>The first step is ensuring to setup the <code>WebClient</code> correctly.
An example of setting up <code>WebClient</code> in a fully reactive environment can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(ReactiveClientRegistrationRepository clientRegistrations,
		ServerOAuth2AuthorizedClientRepository authorizedClients) {
	ServerOAuth2AuthorizedClientExchangeFilterFunction oauth =
			new ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients);
	// (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
	// oauth.setDefaultOAuth2AuthorizedClient(true);
	// (optional) set a default ClientRegistration.registrationId
	// oauth.setDefaultClientRegistrationId("client-registration-id");
	return WebClient.builder()
			.filter(oauth)
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(clientRegistrations: ReactiveClientRegistrationRepository,
              authorizedClients: ServerOAuth2AuthorizedClientRepository): WebClient {
    val oauth = ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients)
    // (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
    // oauth.setDefaultOAuth2AuthorizedClient(true)
    // (optional) set a default ClientRegistration.registrationId
    // oauth.setDefaultClientRegistrationId("client-registration-id")
    return WebClient.builder()
            .filter(oauth)
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-implicit"><a class="anchor" href="#webclient-implicit"></a>Implicit OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>If we set <code>defaultOAuth2AuthorizedClient</code> to <code>true</code> in our setup and the user authenticated with oauth2Login (i.e. OIDC), then the current authentication is used to automatically provide the access token.
Alternatively,  if we set <code>defaultClientRegistrationId</code> to a valid <code>ClientRegistration</code> id, that registration is used to provide the access token.
This is convenient, but in environments where not all endpoints should get the access token, it is dangerous (you might provide the wrong access token to an endpoint).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; body = this.webClient
		.get()
		.uri(this.uri)
		.retrieve()
		.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val body: Mono&lt;String&gt; = webClient
        .get()
        .uri(this.uri)
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-explicit"><a class="anchor" href="#webclient-explicit"></a>Explicit OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClient</code> can be explicitly provided by setting it on the requests attributes.
In the example below we resolve the <code>OAuth2AuthorizedClient</code> using Spring WebFlux or Spring MVC argument resolver support.
However, it does not matter how the <code>OAuth2AuthorizedClient</code> is resolved.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
	return this.webClient
			.get()
			.uri(this.uri)
			.attributes(oauth2AuthorizedClient(authorizedClient))
			.retrieve()
			.bodyToMono(String.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    return this.webClient
            .get()
            .uri(uri)
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-clientregistrationid"><a class="anchor" href="#webclient-clientregistrationid"></a>clientRegistrationId</h3>
<div class="paragraph">
<p>Alternatively, it is possible to specify the <code>clientRegistrationId</code> on the request attributes and the <code>WebClient</code> will attempt to lookup the <code>OAuth2AuthorizedClient</code>.
If it is not found, one will automatically be acquired.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; body = this.webClient
		.get()
		.uri(this.uri)
		.attributes(clientRegistrationId("client-id"))
		.retrieve()
		.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val body: Mono&lt;String&gt; = this.webClient
        .get()
        .uri(uri)
        .attributes(clientRegistrationId("client-id"))
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-erms"><a class="anchor" href="#jc-erms"></a>EnableReactiveMethodSecurity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security supports method security using <a href="https://projectreactor.io/docs/core/release/reference/#context">Reactor&#8217;s Context</a> which is setup using <code>ReactiveSecurityContextHolder</code>.
For example, this demonstrates how to retrieve the currently logged in user&#8217;s message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For this to work the return type of the method must be a <code>org.reactivestreams.Publisher</code> (i.e. <code>Mono</code>/<code>Flux</code>) or the function must be a Kotlin coroutine function.
This is necessary to integrate with Reactor&#8217;s <code>Context</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication authentication = new TestingAuthenticationToken("user", "password", "ROLE_USER");

Mono&lt;String&gt; messageByUsername = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername)
	// In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication));

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val authentication: Authentication = TestingAuthenticationToken("user", "password", "ROLE_USER")

val messageByUsername: Mono&lt;String&gt; = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername) // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication))

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>with <code>this::findMessageByUsername</code> defined as:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; findMessageByUsername(String username) {
	return Mono.just("Hi " + username);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun findMessageByUsername(username: String): Mono&lt;String&gt; {
	return Mono.just("Hi $username")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Below is a minimal method security configuration when using method security in reactive applications.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableReactiveMethodSecurity
public class SecurityConfig {
	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build();
		UserDetails admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER","ADMIN")
			.build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableReactiveMethodSecurity
class SecurityConfig {
	@Bean
	fun userDetailsService(): MapReactiveUserDetailsService {
		val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()
		val rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build()
		val admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER", "ADMIN")
			.build()
		return MapReactiveUserDetailsService(rob, admin)
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Consider the following class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	public Mono&lt;String&gt; findMessage() {
		return Mono.just("Hello World!");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	fun findMessage(): Mono&lt;String&gt; {
		return Mono.just("Hello World!")
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, the following class using Kotlin coroutines:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class HelloWorldMessageService {
    @PreAuthorize("hasRole('ADMIN')")
    suspend fun findMessage(): String {
        delay(10)
        return "Hello World!"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Combined with our configuration above, <code>@PreAuthorize("hasRole('ADMIN')")</code> will ensure that <code>findByMessage</code> is only invoked by a user with the role <code>ADMIN</code>.
It is important to note that any of the expressions in standard method security work for <code>@EnableReactiveMethodSecurity</code>.
However, at this time we only support return type of <code>Boolean</code> or <code>boolean</code> of the expression.
This means that the expression must not block.</p>
</div>
<div class="paragraph">
<p>When integrating with <a href="#jc-webflux">WebFlux Security</a>, the Reactor Context is automatically established by Spring Security according to the authenticated user.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {

	@Bean
	SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {
		return http
			// Demonstrate that method security works
			// Best practice to use both for defense in depth
			.authorizeExchange(exchanges -&gt; exchanges
				.anyExchange().permitAll()
			)
			.httpBasic(withDefaults())
			.build();
	}

	@Bean
	MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build();
		UserDetails admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER","ADMIN")
			.build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
class SecurityConfig {
	@Bean
	open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			authorizeExchange {
				authorize(anyExchange, permitAll)
			}
			httpBasic { }
		}
	}

	@Bean
	fun userDetailsService(): MapReactiveUserDetailsService {
		val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()
		val rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build()
		val admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER", "ADMIN")
			.build()
		return MapReactiveUserDetailsService(rob, admin)
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find a complete sample in {gh-samples-url}/reactive/webflux/java/method[hellowebflux-method]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a>CORS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework provides <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-cors-intro">first class support for CORS</a>.
CORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the <code>JSESSIONID</code>).
If the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it.</p>
</div>
<div class="paragraph">
<p>The easiest way to ensure that CORS is handled first is to use the <code>CorsWebFilter</code>.
Users can integrate the <code>CorsWebFilter</code> with Spring Security by providing a <code>CorsConfigurationSource</code>.
For example, the following will integrate CORS support within Spring Security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
CorsConfigurationSource corsConfigurationSource() {
	CorsConfiguration configuration = new CorsConfiguration();
	configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
	configuration.setAllowedMethods(Arrays.asList("GET","POST"));
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	source.registerCorsConfiguration("/**", configuration);
	return source;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following will disable the CORS integration within Spring Security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.cors(cors -&gt; cors.disable());
	return http.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-webflux"><a class="anchor" href="#test-webflux"></a>Reactive Test Support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="test-erms"><a class="anchor" href="#test-erms"></a>Testing Reactive Method Security</h3>
<div class="paragraph">
<p>For example, we can test our example from <a href="#jc-erms">EnableReactiveMethodSecurity</a> using the same setup and annotations we did in <a href="#test-method">[test-method]</a>.
Here is a minimal sample of what we can do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWorldMessageServiceTests {
	@Autowired
	HelloWorldMessageService messages;

	@Test
	public void messagesWhenNotAuthenticatedThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser
	public void messagesWhenUserThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser(roles = "ADMIN")
	public void messagesWhenAdminThenOk() {
		StepVerifier.create(this.messages.findMessage())
			.expectNext("Hello World!")
			.verifyComplete();
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-webtestclient"><a class="anchor" href="#test-webtestclient"></a>WebTestClientSupport</h3>
<div class="paragraph">
<p>Spring Security provides integration with <code>WebTestClient</code>.
The basic setup looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWebfluxMethodApplicationTests {
	@Autowired
	ApplicationContext context;

	WebTestClient rest;

	@Before
	public void setup() {
		this.rest = WebTestClient
			.bindToApplicationContext(this.context)
			// add Spring Security test Support
			.apply(springSecurity())
			.configureClient()
			.filter(basicAuthentication())
			.build();
	}
	// ...
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_authentication"><a class="anchor" href="#_authentication"></a>Authentication</h4>
<div class="paragraph">
<p>After applying the Spring Security support to <code>WebTestClient</code> we can use either annotations or <code>mutateWith</code> support.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void messageWhenNotAuthenticated() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isUnauthorized();
}

// --- WithMockUser ---

@Test
@WithMockUser
public void messageWhenWithMockUserThenForbidden() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
@WithMockUser(roles = "ADMIN")
public void messageWhenWithMockAdminThenOk() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}

// --- mutateWith mockUser ---

@Test
public void messageWhenMutateWithMockUserThenForbidden() throws Exception {
	this.rest
		.mutateWith(mockUser())
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
public void messageWhenMutateWithMockAdminThenOk() throws Exception {
	this.rest
		.mutateWith(mockUser().roles("ADMIN"))
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_csrf_support"><a class="anchor" href="#_csrf_support"></a>CSRF Support</h4>
<div class="paragraph">
<p>Spring Security also provides support for CSRF testing with <code>WebTestClient</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest
	// provide a valid CSRF token
	.mutateWith(csrf())
	.post()
	.uri("/login")
	...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2"><a class="anchor" href="#webflux-testing-oauth2"></a>Testing OAuth 2.0</h4>
<div class="paragraph">
<p>When it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>For example, for a controller that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(Principal user) {
    return Mono.just(user.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s nothing OAuth2-specific about it, so you will likely be able to simply <a href="#test-erms">use <code>@WithMockUser</code></a> and be fine.</p>
</div>
<div class="paragraph">
<p>But, in cases where your controllers are bound to some aspect of Spring Security&#8217;s OAuth 2.0 support, like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser user) {
    return Mono.just(user.getIdToken().getSubject());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then Spring Security&#8217;s test support can come in handy.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oidc-login"><a class="anchor" href="#webflux-testing-oidc-login"></a>Testing OIDC Login</h4>
<div class="paragraph">
<p>Testing the method above with <code>WebTestClient</code> would require simulating some kind of grant flow with an authorization server.
Certainly this would be a daunting task, which is why Spring Security ships with support for removing this boilerplate.</p>
</div>
<div class="paragraph">
<p>For example, we can tell Spring Security to include a default <code>OidcUser</code> using the <code>SecurityMockServerConfigurers#oidcLogin</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()).get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockServerRequest</code> with an <code>OidcUser</code> that includes a simple <code>OidcIdToken</code>, <code>OidcUserInfo</code>, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include an <code>OidcIdToken</code> with a <code>sub</code> claim set to <code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>an <code>OidcUserInfo</code> with no claims set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getUserInfo().getClaims()).isEmpty();</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OidcUser</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OidcUser</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits into a mock <code>ServerOAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#webflux-testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>..</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-authorities"><a class="anchor" href="#webflux-testing-oidc-login-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-claims"><a class="anchor" href="#webflux-testing-oidc-login-claims"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> claim that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that claim with the <code>idToken()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .idToken(token -&gt; token.claim("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>since <code>OidcUser</code> collects its claims from <code>OidcIdToken</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-user"><a class="anchor" href="#webflux-testing-oidc-login-user"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>userInfo(OidcUserInfo.Builder)</code> - For configuring the <code>OidcUserInfo</code> instance</p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oidcUser(OidcUser)</code> - For configuring the complete <code>OidcUser</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OidcUser</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OidcUser</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-login"><a class="anchor" href="#webflux-testing-oauth2-login"></a>Testing OAuth 2.0 Login</h4>
<div class="paragraph">
<p>As with <a href="#webflux-testing-oidc-login">testing OIDC login</a>, testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow.
And because of that, Spring Security also has test support for non-OIDC use cases.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that gets the logged-in user as an <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return Mono.just(oauth2User.getAttribute("sub"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>OAuth2User</code> using the <code>SecurityMockServerConfigurers#oauth2User</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockServerRequest</code> with an <code>OAuth2User</code> that includes a simple <code>Map</code> of attributes and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat((String) user.getAttribute("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OAuth2User</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OAuth2User</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits in a mock <code>ServerOAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#webflux-testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-authorities"><a class="anchor" href="#webflux-testing-oauth2-login-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-claims"><a class="anchor" href="#webflux-testing-oauth2-login-claims"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-user"><a class="anchor" href="#webflux-testing-oauth2-login-user"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oauth2User(OAuth2User)</code> - For configuring the complete <code>OAuth2User</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OAuth2User</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OAuth2User</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-client"><a class="anchor" href="#webflux-testing-oauth2-client"></a>Testing OAuth 2.0 Clients</h4>
<div class="paragraph">
<p>Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.
For example, your controller may be relying on the client credentials grant to get a token that isn&#8217;t associated with the user at all:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulating this handshake with the authorization server could be cumbersome.
Instead, you can use <code>SecurityMockServerConfigurers#oauth2Client</code> to add a <code>OAuth2AuthorizedClient</code> into a mock <code>ServerOAuth2AuthorizedClientRepository</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is create an <code>OAuth2AuthorizedClient</code> that has a simple <code>ClientRegistration</code>, <code>OAuth2AccessToken</code>, and resource owner name.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>ClientRegistration</code> with a client id of "test-client" and client secret of "test-secret":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p>a resource owner name of "user":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and an <code>OAuth2AccessToken</code> with just one scope, <code>read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client can then be retrieved as normal using <code>@RegisteredOAuth2AuthorizedClient</code> in a controller method.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-scopes"><a class="anchor" href="#webflux-testing-oauth2-client-scopes"></a>Configuring Scopes</h5>
<div class="paragraph">
<p>In many circumstances, the OAuth 2.0 access token comes with a set of scopes.
If your controller inspects these, say like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set&lt;String&gt; scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class);
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then you can configure the scope using the <code>accessToken()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read"))))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-registration"><a class="anchor" href="#webflux-testing-oauth2-client-registration"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principalName(String)</code> - For configuring the resource owner name</p>
</li>
<li>
<p><code>clientRegistration(Consumer&lt;ClientRegistration.Builder&gt;)</code> - For configuring the associated <code>ClientRegistration</code></p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the complete <code>ClientRegistration</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you want to use a real <code>ClientRegistration</code></p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that you are wanting to use one of your app&#8217;s <code>ClientRegistration</code> definitions, as specified in your <code>application.yml</code>.</p>
</div>
<div class="paragraph">
<p>In that case, your test can autowire the <code>ReactiveClientRegistrationRepository</code> and look up the one your test needs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
ReactiveClientRegistrationRepository clientRegistrationRepository;

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))
    )
    .get().uri("/exchange").exchange();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-jwt"><a class="anchor" href="#webflux-testing-jwt"></a>Testing JWT Authentication</h4>
<div class="paragraph">
<p>In order to make an authorized request on a resource server, you need a bearer token.
If your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification.
All of this can be quite daunting, especially when this isn&#8217;t the focus of your test.</p>
</div>
<div class="paragraph">
<p>Fortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.
We&#8217;ll look at two of them now:</p>
</div>
<div class="sect4">
<h5 id="_mockjwt_webtestclientconfigurer"><a class="anchor" href="#_mockjwt_webtestclientconfigurer"></a><code>mockJwt() WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>The first way is via a <code>WebTestClientConfigurer</code>.
The simplest of these would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is create a mock <code>Jwt</code>, passing it correctly through any authentication APIs so that it&#8217;s available for your authorization mechanisms to verify.</p>
</div>
<div class="paragraph">
<p>By default, the <code>JWT</code> that it creates has the following characteristics:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the resulting <code>Jwt</code>, were it tested, would pass in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>These values can, of course be configured.</p>
</div>
<div class="paragraph">
<p>Any headers or claims can be configured with their corresponding methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().jwt(jwt -&gt; jwt.header("kid", "one")
		.claim("iss", "https://idp.example.org")))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().jwt(jwt -&gt; jwt.claims(claims -&gt; claims.remove("scope"))))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>scope</code> and <code>scp</code> claims are processed the same way here as they are in a normal bearer token request.
However, this can be overridden simply by providing the list of <code>GrantedAuthority</code> instances that you need for your test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages")))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, if you have a custom <code>Jwt</code> to <code>Collection&lt;GrantedAuthority&gt;</code> converter, you can also use that to derive the authorities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(jwt().authorities(new MyConverter()))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify a complete <code>Jwt</code>, for which <code>{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[Jwt.Builder]</code> comes quite handy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

client
	.mutateWith(mockJwt().jwt(jwt))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_authentication_webtestclientconfigurer"><a class="anchor" href="#_authentication_webtestclientconfigurer"></a><code>authentication()</code> <code>WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>The second way is by using the <code>authentication()</code> <code>Mutator</code>.
Essentially, you can instantiate your own <code>JwtAuthenticationToken</code> and provide it in your test, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

client
	.mutateWith(authentication(token))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to these, you can also mock the <code>ReactiveJwtDecoder</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-opaque-token"><a class="anchor" href="#webflux-testing-opaque-token"></a>Testing Opaque Token Authentication</h4>
<div class="paragraph">
<p>Similar to <a href="#webflux-testing-jwt">JWTs</a>, opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult.
To help with that, Spring Security has test support for opaque tokens.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that retrieves the authentication as a <code>BearerTokenAuthentication</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    return Mono.just((String) authentication.getTokenAttributes("sub"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>BearerTokenAuthentication</code> using the <code>SecurityMockServerConfigurers#opaqueToken</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockHttpServletRequest</code> with a <code>BearerTokenAuthentication</code> that includes a simple <code>OAuth2AuthenticatedPrincipal</code>, <code>Map</code> of attributes, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>BearerTokenAuthentication</code> instance is available for your controller methods.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-authorities"><a class="anchor" href="#webflux-testing-opaque-token-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-attributes"><a class="anchor" href="#webflux-testing-opaque-token-attributes"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-principal"><a class="anchor" href="#webflux-testing-opaque-token-principal"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects.</p>
</div>
<div class="paragraph">
<p>One such is <code>principal(OAuth2AuthenticatedPrincipal)</code>, which you can use to configure the complete <code>OAuth2AuthenticatedPrincipal</code> instance that underlies the <code>BearerTokenAuthentication</code></p>
</div>
<div class="paragraph">
<p>It&#8217;s handy if you:
1. Have your own implementation of <code>OAuth2AuthenticatedPrincipal</code>, or
2. Want to specify a different principal name</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> attribute instead of the <code>sub</code> attribute.
In that case, you can configure an <code>OAuth2AuthenticatedPrincipal</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to using <code>mockOpaqueToken()</code> test support, you can also mock the <code>OpaqueTokenIntrospector</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket"><a class="anchor" href="#rsocket"></a>RSocket Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security&#8217;s RSocket support relies on a <code>SocketAcceptorInterceptor</code>.
The main entry point into security is found in the <code>PayloadSocketAcceptorInterceptor</code> which adapts the RSocket APIs to allow intercepting a <code>PayloadExchange</code> with <code>PayloadInterceptor</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can find a few sample applications that demonstrate the code below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello RSocket {gh-samples-url}/reactive/rsocket/hello-security[hellorsocket]</p>
</li>
<li>
<p><a href="https://github.com/rwinch/spring-flights/tree/security">Spring Flights</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_minimal_rsocket_security_configuration"><a class="anchor" href="#_minimal_rsocket_security_configuration"></a>Minimal RSocket Security Configuration</h3>
<div class="paragraph">
<p>You can find a minimal RSocket Security configuration below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRSocketSecurity
public class HelloRSocketSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration enables <a href="#rsocket-authentication-simple">simple authentication</a> and sets up <a href="#rsocket-authorization">rsocket-authorization</a> to require an authenticated user for any request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_securitysocketacceptorinterceptor"><a class="anchor" href="#_adding_securitysocketacceptorinterceptor"></a>Adding SecuritySocketAcceptorInterceptor</h3>
<div class="paragraph">
<p>For Spring Security to work we need to apply <code>SecuritySocketAcceptorInterceptor</code> to the <code>ServerRSocketFactory</code>.
This is what connects our <code>PayloadSocketAcceptorInterceptor</code> we created with the RSocket infrastructure.
In a Spring Boot application this is done automatically using <code>RSocketSecurityAutoConfiguration</code> with the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
RSocketServerCustomizer springSecurityRSocketSecurity(SecuritySocketAcceptorInterceptor interceptor) {
    return (server) -&gt; server.interceptors((registry) -&gt; registry.forSocketAcceptor(interceptor));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authentication"><a class="anchor" href="#rsocket-authentication"></a>RSocket Authentication</h3>
<div class="paragraph">
<p>RSocket authentication is performed with <code>AuthenticationPayloadInterceptor</code> which acts as a controller to invoke a <code>ReactiveAuthenticationManager</code> instance.</p>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-setup-vs-request"><a class="anchor" href="#rsocket-authentication-setup-vs-request"></a>Authentication at Setup vs Request Time</h4>
<div class="paragraph">
<p>Generally, authentication can occur at setup time and/or request time.</p>
</div>
<div class="paragraph">
<p>Authentication at setup time makes sense in a few scenarios.
A common scenarios is when a single user (i.e. mobile connection) is leveraging an RSocket connection.
In this case only a single user is leveraging the connection, so authentication can be done once at connection time.</p>
</div>
<div class="paragraph">
<p>In a scenario where the RSocket connection is shared it makes sense to send credentials on each request.
For example, a web application that connects to an RSocket server as a downstream service would make a single connection that all users leverage.
In this case, if the RSocket server needs to perform authorization based on the web application&#8217;s users credentials per request makes sense.</p>
</div>
<div class="paragraph">
<p>In some scenarios authentication at setup and per request makes sense.
Consider a web application as described previously.
If we need to restrict the connection to the web application itself, we can provide a credential with a <code>SETUP</code> authority at connection time.
Then each user would have different authorities but not the <code>SETUP</code> authority.
This means that individual users can make requests but not make additional connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-simple"><a class="anchor" href="#rsocket-authentication-simple"></a>Simple Authentication</h4>
<div class="paragraph">
<p>Spring Security has support for <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Simple.md">Simple Authentication Metadata Extension</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Basic Authentication drafts evolved into Simple Authentication and is only supported for backward compatibility.
See <code>RSocketSecurity.basicAuthentication(Customizer)</code> for setting it up.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The RSocket receiver can decode the credentials using <code>AuthenticationPayloadExchangeConverter</code> which is automatically setup using the <code>simpleAuthentication</code> portion of the DSL.
An explicit configuration can be found below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize -&gt;
			authorize
					.anyRequest().authenticated()
					.anyExchange().permitAll()
		)
		.simpleAuthentication(Customizer.withDefaults());
	return rsocket.build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The RSocket sender can send credentials using <code>SimpleAuthenticationEncoder</code> which can be added to Spring&#8217;s <code>RSocketStrategies</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RSocketStrategies.Builder strategies = ...;
strategies.encoder(new SimpleAuthenticationEncoder());</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can then be used to send a username and password to the receiver in the setup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
	.setupMetadata(credentials, authenticationMimeType)
	.rsocketStrategies(strategies.build())
	.connectTcp(host, port);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively or additionally, a username and password can be sent in a request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;RSocketRequester&gt; requester;
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");

public Mono&lt;AirportLocation&gt; findRadar(String code) {
	return this.requester.flatMap(req -&gt;
		req.route("find.radar.{code}", code)
			.metadata(credentials, authenticationMimeType)
			.retrieveMono(AirportLocation.class)
	);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-jwt"><a class="anchor" href="#rsocket-authentication-jwt"></a>JWT</h4>
<div class="paragraph">
<p>Spring Security has support for <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Bearer.md">Bearer Token Authentication Metadata Extension</a>.
The support comes in the form of authenticating a JWT (determining the JWT is valid) and then using the JWT to make authorization decisions.</p>
</div>
<div class="paragraph">
<p>The RSocket receiver can decode the credentials using <code>BearerPayloadExchangeConverter</code> which is automatically setup using the <code>jwt</code> portion of the DSL.
An example configuration can be found below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize -&gt;
			authorize
				.anyRequest().authenticated()
				.anyExchange().permitAll()
		)
		.jwt(Customizer.withDefaults());
	return rsocket.build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration above relies on the existence of a <code>ReactiveJwtDecoder</code> <code>@Bean</code> being present.
An example of creating one from the issuer can be found below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
	return ReactiveJwtDecoders
		.fromIssuerLocation("https://example.com/auth/realms/demo");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The RSocket sender does not need to do anything special to send the token because the value is just a simple String.
For example, the token can be sent at setup time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
BearerTokenMetadata token = ...;
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
	.setupMetadata(token, authenticationMimeType)
	.connectTcp(host, port);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively or additionally, the token can be sent in a request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
Mono&lt;RSocketRequester&gt; requester;
BearerTokenMetadata token = ...;

public Mono&lt;AirportLocation&gt; findRadar(String code) {
	return this.requester.flatMap(req -&gt;
		req.route("find.radar.{code}", code)
	        .metadata(token, authenticationMimeType)
			.retrieveMono(AirportLocation.class)
	);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authorization"><a class="anchor" href="#rsocket-authorization"></a>RSocket Authorization</h3>
<div class="paragraph">
<p>RSocket authorization is performed with <code>AuthorizationPayloadInterceptor</code> which acts as a controller to invoke a <code>ReactiveAuthorizationManager</code> instance.
The DSL can be used to setup authorization rules based upon the <code>PayloadExchange</code>.
An example configuration can be found below:</p>
</div>
<div id="source" class="listingblock">
<div class="content">
<pre>rsocket
	.authorizePayload(authorize -&gt;
		authz
			.setup().hasRole("SETUP") <i class="conum" data-value="1"></i><b>(1)</b>
			.route("fetch.profile.me").authenticated() <i class="conum" data-value="2"></i><b>(2)</b>
			.matcher(payloadExchange -&gt; isMatch(payloadExchange)) <i class="conum" data-value="3"></i><b>(3)</b>
				.hasRole("CUSTOM")
			.route("fetch.profile.{username}") <i class="conum" data-value="4"></i><b>(4)</b>
				.access((authentication, context) -&gt; checkFriends(authentication, context))
			.anyRequest().authenticated() <i class="conum" data-value="5"></i><b>(5)</b>
			.anyExchange().permitAll() <i class="conum" data-value="6"></i><b>(6)</b>
	)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting up a connection requires the authority <code>ROLE_SETUP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the route is <code>fetch.profile.me</code> authorization only requires the user be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In this rule we setup a custom matcher where authorization requires the user to have the authority <code>ROLE_CUSTOM</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This rule leverages custom authorization.
The matcher expresses a variable with the name <code>username</code> that is made available in the <code>context</code>.
A custom authorization rule is exposed in the <code>checkFriends</code> method.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This rule ensures that request that does not already have a rule will require the user to be authenticated.
A request is where the metadata is included.
It would not include additional payloads.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This rule ensures that any exchange that does not already have a rule is allowed for anyone.
In this example, it means that payloads that have no metadata have no authorization rules.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is important to understand that authorization rules are performed in order.
Only the first authorization rule that matches will be invoked.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer flex">
    <div id="spring-links flex">
        <img id="springlogo" src="../../_/img/spring-logo.svg" alt="Spring">
        <p class="smallest antialiased">© <script>var d = new Date();
        document.write(d.getFullYear());</script> <a href="https://www.vmware.com/">VMware</a>, Inc. or its affiliates. <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> • <a href="https://www.vmware.com/help/privacy.html" rel="noopener noreferrer">Privacy</a> • <a href="https://spring.io/trademarks">Trademark Guidelines</a> <span id="thank-you-mobile">• <a href="https://spring.io/thank-you">Thank you</a></span> • <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> • <a class="ot-sdk-show-settings">Cookie Settings</a> <span id="teconsent"></span></p>
        <p class="smallest antialiased">Apache®, Apache Tomcat®, Apache Kafka®, Apache Cassandra&trade;, and Apache Geode&trade; are trademarks or registered trademarks of the Apache Software Foundation in the United States and/or other countries. Java&trade;, Java&trade; SE, Java&trade; EE, and OpenJDK&trade; are trademarks of Oracle and/or its affiliates. Kubernetes® is a registered trademark of the Linux Foundation in the United States and other countries. Linux® is the registered trademark of Linus Torvalds in the United States and other countries. Windows® and Microsoft® Azure are registered trademarks of Microsoft Corporation. “AWS” and “Amazon Web Services” are trademarks or registered trademarks of Amazon.com Inc. or its affiliates. All other trademarks and copyrights are property of their respective owners and are only mentioned for informative purposes. Other names may be trademarks of their respective owners.</p>
    </div>
    <div id="social-icons" class="flex jc-between">
        <a href="https://www.youtube.com/user/SpringSourceDev" title="Youtube"><svg id="youtube-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle class="cls-1" cx="20" cy="20" r="20"/><path class="cls-2" d="M30.91,14.53a2.89,2.89,0,0,0-2-2C27.12,12,20,12,20,12s-7.12,0-8.9.47a2.9,2.9,0,0,0-2,2A30.56,30.56,0,0,0,8.63,20a30.44,30.44,0,0,0,.46,5.47,2.89,2.89,0,0,0,2,2C12.9,28,20,28,20,28s7.12,0,8.9-.47a2.87,2.87,0,0,0,2-2A30.56,30.56,0,0,0,31.37,20,28.88,28.88,0,0,0,30.91,14.53ZM17.73,23.41V16.59L23.65,20Z"/></svg></a>
        <a href="https://github.com/spring-projects" title="Github"><svg id="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><path class="cls-1" d="M38,0a38,38,0,1,0,38,38A38,38,0,0,0,38,0Z"/></g><path class="cls-2" d="M38,15.59A22.95,22.95,0,0,0,30.71,60.3c1.15.21,1.57-.5,1.57-1.11s0-2,0-3.9c-6.38,1.39-7.73-3.07-7.73-3.07A6.09,6.09,0,0,0,22,48.86c-2.09-1.42.15-1.39.15-1.39a4.81,4.81,0,0,1,3.52,2.36c2,3.5,5.37,2.49,6.67,1.91a4.87,4.87,0,0,1,1.46-3.07c-5.09-.58-10.45-2.55-10.45-11.34a8.84,8.84,0,0,1,2.36-6.15,8.29,8.29,0,0,1,.23-6.07s1.92-.62,6.3,2.35a21.82,21.82,0,0,1,11.49,0c4.38-3,6.3-2.35,6.3-2.35a8.29,8.29,0,0,1,.23,6.07,8.84,8.84,0,0,1,2.36,6.15c0,8.81-5.37,10.75-10.48,11.32a5.46,5.46,0,0,1,1.56,4.25c0,3.07,0,5.54,0,6.29s.42,1.33,1.58,1.1A22.94,22.94,0,0,0,38,15.59Z"/></svg></a>
        <a href="https://twitter.com/springcentral" title="Twitter"><svg id="twitter-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><circle class="cls-1" cx="37.97" cy="37.97" r="37.97"/><path id="Twitter-2" data-name="Twitter" class="cls-2" d="M55.2,22.73a15.43,15.43,0,0,1-4.88,1.91,7.56,7.56,0,0,0-5.61-2.49A7.78,7.78,0,0,0,37,30a7.56,7.56,0,0,0,.2,1.79,21.63,21.63,0,0,1-15.84-8.23,8,8,0,0,0,2.37,10.52,7.66,7.66,0,0,1-3.48-1v.09A7.84,7.84,0,0,0,26.45,41a7.54,7.54,0,0,1-2,.28A7.64,7.64,0,0,1,23,41.09a7.71,7.71,0,0,0,7.18,5.47,15.21,15.21,0,0,1-9.55,3.37,15.78,15.78,0,0,1-1.83-.11,21.41,21.41,0,0,0,11.78,3.54c14.13,0,21.86-12,21.86-22.42,0-.34,0-.68,0-1a15.67,15.67,0,0,0,3.83-4.08,14.9,14.9,0,0,1-4.41,1.24A7.8,7.8,0,0,0,55.2,22.73Z"/></svg></a>
    </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/tabs.js"></script>
<script src="../../_/js/vendor/docsearch.min.js"></script>
<script src="../../_/js/vendor/switchtheme.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  apiKey: '82c7ead946afbac3cf98c32446154691',
  appId: '244V8V9FGG',
  indexName: 'spring-docs',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>
  </body>
</html>
