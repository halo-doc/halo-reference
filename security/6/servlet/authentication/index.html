<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Authentication :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../../_/css/site.css">

<link href="../../../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">
        <img id="springlogo" class="block" src="../../../../_/img/spring-logo.svg" alt="Spring" width="140px">
      </a>
        <span class="title-divider">/</span>
        <div class="navbar-project">
          <span class="title">Spring Security</span>
        </div>
      <div>
          <span class="title-divider">/</span>
          <div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">6</button>
  <div class="version-menu">
    <a class="version is-current" href="index.html">6</a>
    <a class="version" href="../../../5.6/servlet/authentication/index.html">5.6</a>
  </div>
</div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../overview/prerequisites.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/index.html">Servet Security: The Big Picture</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore" style="display: none;">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../overview/prerequisites.html">6</a>
        </li>
        <li class="version">
          <a href="../../../5.6/overview/index.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="" role="navigation">
<button class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Authentication</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides comprehensive support for <a href="#authentication">[authentication]</a>.
This section discusses:</p>
</div>
<div id="servlet-authentication-architecture" class="paragraph">
<p><strong>Architecture Components</strong></p>
</div>
<div class="paragraph">
<p>This section describes the main architectural components of Spring Security&#8217;s used in Servlet authentication.
If you need concrete flows that explain how these pieces fit together, look at the <a href="#servlet-authentication-mechanisms">Authentication Mechanism</a> specific sections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> - The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-securitycontext">SecurityContext</a> - is obtained from the <code>SecurityContextHolder</code> and contains the <code>Authentication</code> of the currently authenticated user.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication</a> - Can be the input to <code>AuthenticationManager</code> to provide the credentials a user has provided to authenticate or the current user from the <code>SecurityContext</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-granted-authority">GrantedAuthority</a> - An authority that is granted to the principal on the <code>Authentication</code> (i.e. roles, scopes, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationmanager">AuthenticationManager</a> -  the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-providermanager">ProviderManager</a> -  the most common implementation of <code>AuthenticationManager</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> - used by <code>ProviderManager</code> to perform a specific type of authentication.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationentrypoint">Request Credentials with <code>AuthenticationEntryPoint</code></a> - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a <code>WWW-Authenticate</code> response, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a> - a base <code>Filter</code> used for authentication.
This also gives a good idea of the high level flow of authentication and how pieces work together.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-mechanisms" class="paragraph">
<p><strong>Authentication Mechanisms</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-unpwd">Username and Password</a> - how to authenticate with a username/password</p>
</li>
<li>
<p><a href="#oauth2login">OAuth 2.0 Login</a> - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)</p>
</li>
<li>
<p><a href="#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 Log In</p>
</li>
<li>
<p><a href="#servlet-cas">Central Authentication Server (CAS)</a> - Central Authentication Server (CAS) Support</p>
</li>
<li>
<p><a href="#servlet-rememberme">Remember Me</a> - How to remember a user past session expiration</p>
</li>
<li>
<p><a href="#servlet-jaas">JAAS Authentication</a> - Authenticate with JAAS</p>
</li>
<li>
<p><a href="#servlet-openid">OpenID</a> - OpenID Authentication (not to be confused with OpenID Connect)</p>
</li>
<li>
<p><a href="#servlet-preauth">Pre-Authentication Scenarios</a> - Authenticate with an external mechanism such as <a href="https://www.siteminder.com/">SiteMinder</a> or Java EE security but still use Spring Security for authorization and protection against common exploits.</p>
</li>
<li>
<p><a href="#servlet-x509">X509 Authentication</a> - X509 Authentication</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-securitycontextholder"><a class="anchor" href="#servlet-authentication-securitycontextholder"></a>SecurityContextHolder</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the heart of Spring Security&#8217;s authentication model is the <code>SecurityContextHolder</code>.
It contains the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/securitycontextholder.png" alt="securitycontextholder">
</div>
</div>
<div class="paragraph">
<p>The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.
Spring Security does not care how the <code>SecurityContextHolder</code> is populated.
If it contains a value, then it is used as the currently authenticated user.</p>
</div>
<div class="paragraph">
<p>The simplest way to indicate a user is authenticated is to set the <code>SecurityContextHolder</code> directly.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Setting <code>SecurityContextHolder</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext(); <i class="conum" data-value="1"></i><b>(1)</b>
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); <i class="conum" data-value="2"></i><b>(2)</b>
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context: SecurityContext = SecurityContextHolder.createEmptyContext() <i class="conum" data-value="1"></i><b>(1)</b>
val authentication: Authentication = TestingAuthenticationToken("username", "password", "ROLE_USER") <i class="conum" data-value="2"></i><b>(2)</b>
context.authentication = authentication

SecurityContextHolder.setContext(context) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start by creating an empty <code>SecurityContext</code>.
It is important to create a new <code>SecurityContext</code> instance instead of using <code>SecurityContextHolder.getContext().setAuthentication(authentication)</code> to avoid race conditions across multiple threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next we create a new <a href="#servlet-authentication-authentication"><code>Authentication</code></a> object.
Spring Security does not care what type of <code>Authentication</code> implementation is set on the <code>SecurityContext</code>.
Here we use <code>TestingAuthenticationToken</code> because it is very simple.
A more common production scenario is <code>UsernamePasswordAuthenticationToken(userDetails, password, authorities)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, we set the <code>SecurityContext</code> on the <code>SecurityContextHolder</code>.
Spring Security will use this information for <a href="#servlet-authorization">authorization</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to obtain information about the authenticated principal, you can do so by accessing the <code>SecurityContextHolder</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Access Currently Authenticated User</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context = SecurityContextHolder.getContext()
val authentication = context.authentication
val username = authentication.name
val principal = authentication.principal
val authorities = authentication.authorities</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContextHolder</code> uses a <code>ThreadLocal</code> to store these details, which means that the <code>SecurityContext</code> is always available to methods in the same thread, even if the <code>SecurityContext</code> is not explicitly passed around as an argument to those methods.
Using a <code>ThreadLocal</code> in this way is quite safe if care is taken to clear the thread after the present principal&#8217;s request is processed.
Spring Security&#8217;s <a href="#servlet-filterchainproxy">FilterChainProxy</a> ensures that the <code>SecurityContext</code> is always cleared.</p>
</div>
<div class="paragraph">
<p>Some applications aren&#8217;t entirely suitable for using a <code>ThreadLocal</code>, because of the specific way they work with threads.
For example, a Swing client might want all threads in a Java Virtual Machine to use the same security context.
<code>SecurityContextHolder</code> can be configured with a strategy on startup to specify how you would like the context to be stored.
For a standalone application you would use the <code>SecurityContextHolder.MODE_GLOBAL</code> strategy.
Other applications might want to have threads spawned by the secure thread also assume the same security identity.
This is achieved by using <code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>.
You can change the mode from the default <code>SecurityContextHolder.MODE_THREADLOCAL</code> in two ways.
The first is to set a system property, the second is to call a static method on <code>SecurityContextHolder</code>.
Most applications won&#8217;t need to change from the default, but if you do, take a look at the JavaDoc for <code>SecurityContextHolder</code> to learn more.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-securitycontext"><a class="anchor" href="#servlet-authentication-securitycontext"></a>SecurityContext</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/core/context/SecurityContext.html[<code>SecurityContext</code>] is obtained from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>SecurityContext</code> contains an <a href="#servlet-authentication-authentication">Authentication</a> object.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authentication"><a class="anchor" href="#servlet-authentication-authentication"></a>Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/core/Authentication.html[<code>Authentication</code>] serves two main purposes within Spring Security:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An input to <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to provide the credentials a user has provided to authenticate.
When used in this scenario, <code>isAuthenticated()</code> returns <code>false</code>.</p>
</li>
<li>
<p>Represents the currently authenticated user.
The current <code>Authentication</code> can be obtained from the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Authentication</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principal</code> - identifies the user.
When authenticating with a username/password this is often an instance of <a href="#servlet-authentication-userdetails"><code>UserDetails</code></a>.</p>
</li>
<li>
<p><code>credentials</code> - Often a password.
In many cases this will be cleared after the user is authenticated to ensure it is not leaked.</p>
</li>
<li>
<p><code>authorities</code> - the <a href="#servlet-authentication-granted-authority"><code>GrantedAuthority</code>s</a> are high level permissions the user is granted.
A few examples are roles or scopes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-granted-authority"><a class="anchor" href="#servlet-authentication-granted-authority"></a>GrantedAuthority</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/GrantedAuthority.html[<code>GrantedAuthority</code>s] are high level permissions the user is granted. A few examples are roles or scopes.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code>s can be obtained from the <a href="#servlet-authentication-authentication"><code>Authentication.getAuthorities()</code></a> method.
This method provides a <code>Collection</code> of <code>GrantedAuthority</code> objects.
A <code>GrantedAuthority</code> is, not surprisingly, an authority that is granted to the principal.
Such authorities are usually "roles", such as <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>.
These roles are later on configured for web authorization, method authorization and domain object authorization.
Other parts of Spring Security are capable of interpreting these authorities, and expect them to be present.
When using username/password based authentication <code>GrantedAuthority</code>s are usually loaded by the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>.</p>
</div>
<div class="paragraph">
<p>Usually the <code>GrantedAuthority</code> objects are application-wide permissions.
They are not specific to a given domain object.
Thus, you wouldn&#8217;t likely have a <code>GrantedAuthority</code> to represent a permission to <code>Employee</code> object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user).
Of course, Spring Security is expressly designed to handle this common requirement, but you&#8217;d instead use the project&#8217;s domain object security capabilities for this purpose.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationmanager"><a class="anchor" href="#servlet-authentication-authenticationmanager"></a>AuthenticationManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/AuthenticationManager.html[<code>AuthenticationManager</code>] is the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.
The <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is then set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> by the controller (i.e. <a href="#servlet-security-filters">Spring Security&#8217;s <code>Filters</code>s</a>) that invoked the <code>AuthenticationManager</code>.
If you are not integrating with <em>Spring Security&#8217;s <code>Filters</code>s</em> you can set the <code>SecurityContextHolder</code> directly and are not required to use an <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>While the implementation of <code>AuthenticationManager</code> could be anything, the most common implementation is <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-providermanager"><a class="anchor" href="#servlet-authentication-providermanager"></a>ProviderManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/ProviderManager.html[<code>ProviderManager</code>] is the most commonly used implementation of <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>.
<code>ProviderManager</code> delegates to a <code>List</code> of <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code>s</a>.
Each <code>AuthenticationProvider</code> has an opportunity to indicate that authentication should be successful, fail, or indicate it cannot make a decision and allow a downstream <code>AuthenticationProvider</code> to decide.
If none of the configured <code>AuthenticationProvider</code>s can authenticate, then authentication will fail with a <code>ProviderNotFoundException</code> which is a special <code>AuthenticationException</code> that indicates the <code>ProviderManager</code> was not configured to support the type of <code>Authentication</code> that was passed into it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanager.png" alt="providermanager">
</div>
</div>
<div class="paragraph">
<p>In practice each <code>AuthenticationProvider</code> knows how to perform a specific type of authentication.
 For example, one <code>AuthenticationProvider</code> might be able to validate a username/password, while another might be able to authenticate a SAML assertion.
This allows each <code>AuthenticationProvider</code> to do a very specific type of authentication, while supporting multiple types of authentication and only exposing a single <code>AuthenticationManager</code> bean.</p>
</div>
<div class="paragraph">
<p><code>ProviderManager</code> also allows configuring an optional parent <code>AuthenticationManager</code> which is consulted in the event that no <code>AuthenticationProvider</code> can perform authentication.
The parent can be any type of <code>AuthenticationManager</code>, but it is often an instance of <code>ProviderManager</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanager-parent.png" alt="providermanager parent">
</div>
</div>
<div class="paragraph">
<p>In fact, multiple <code>ProviderManager</code> instances might share the same parent <code>AuthenticationManager</code>.
This is somewhat common in scenarios where there are multiple <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> instances that have some authentication in common (the shared parent <code>AuthenticationManager</code>), but also different authentication mechanisms (the different <code>ProviderManager</code> instances).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanagers-parent.png" alt="providermanagers parent">
</div>
</div>
<div id="servlet-authentication-providermanager-erasing-credentials" class="paragraph">
<p>By default <code>ProviderManager</code> will attempt to clear any sensitive credentials information from the <code>Authentication</code> object which is returned by a successful authentication request.
This prevents information like passwords being retained longer than necessary in the <code>HttpSession</code>.</p>
</div>
<div class="paragraph">
<p>This may cause issues when you are using a cache of user objects, for example, to improve performance in a stateless application.
If the <code>Authentication</code> contains a reference to an object in the cache (such as a <code>UserDetails</code> instance) and this has its credentials removed, then it will no longer be possible to authenticate against the cached value.
You need to take this into account if you are using a cache.
An obvious solution is to make a copy of the object first, either in the cache implementation or in the <code>AuthenticationProvider</code> which creates the returned <code>Authentication</code> object.
Alternatively, you can disable the <code>eraseCredentialsAfterAuthentication</code> property on <code>ProviderManager</code>.
See the {security-api-url}org/springframework/security/authentication/ProviderManager.html[Javadoc] for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationprovider"><a class="anchor" href="#servlet-authentication-authenticationprovider"></a>AuthenticationProvider</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multiple {security-api-url}org/springframework/security/authentication/AuthenticationProvider.html[<code>AuthenticationProvider</code>s] can be injected into <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.
Each <code>AuthenticationProvider</code> performs a specific type of authentication.
For example, <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> supports username/password based authentication while <code>JwtAuthenticationProvider</code> supports authenticating a JWT token.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationentrypoint"><a class="anchor" href="#servlet-authentication-authenticationentrypoint"></a>Request Credentials with <code>AuthenticationEntryPoint</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>{security-api-url}org/springframework/security/web/AuthenticationEntryPoint.html[<code>AuthenticationEntryPoint</code>] is used to send an HTTP response that requests credentials from a client.</p>
</div>
<div class="paragraph">
<p>Sometimes a client will proactively include credentials such as a username/password to request a resource.
In these cases, Spring Security does not need to provide an HTTP response that requests credentials from the client since they are already included.</p>
</div>
<div class="paragraph">
<p>In other cases, a client will make an unauthenticated request to a resource that they are not authorized to access.
In this case, an implementation of <code>AuthenticationEntryPoint</code> is used to request credentials from the client.
The <code>AuthenticationEntryPoint</code> implementation might perform a <a href="#servlet-authentication-form">redirect to a log in page</a>, respond with an <a href="#servlet-authentication-basic">WWW-Authenticate</a> header, etc.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-abstractprocessingfilter"><a class="anchor" href="#servlet-authentication-abstractprocessingfilter"></a>AbstractAuthenticationProcessingFilter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{security-api-url}org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html[<code>AbstractAuthenticationProcessingFilter</code>] is used as a base <code>Filter</code> for authenticating a user&#8217;s credentials.
Before the credentials can be authenticated, Spring Security typically requests the credentials using <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>.</p>
</div>
<div class="paragraph">
<p>Next, the <code>AbstractAuthenticationProcessingFilter</code> can authenticate any authentication requests that are submitted to it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter">
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their credentials, the <code>AbstractAuthenticationProcessingFilter</code> creates an <a href="#servlet-authentication-authentication"><code>Authentication</code></a> from the <code>HttpServletRequest</code> to be authenticated.
The type of <code>Authentication</code> created depends on the subclass of <code>AbstractAuthenticationProcessingFilter</code>.
For example, <a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a> creates a <code>UsernamePasswordAuthenticationToken</code> from a <em>username</em> and <em>password</em> that are submitted in the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> is passed into the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to be authenticated.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionAuthenticationStrategy</code> is notified of a new log in.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
Later the <code>SecurityContextPersistenceFilter</code> saves the <code>SecurityContext</code> to the <code>HttpSession</code>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> publishes an <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p><code>AuthenticationSuccessHandler</code> is invoked.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-unpwd"><a class="anchor" href="#servlet-authentication-unpwd"></a>Username/Password Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the most common ways to authenticate a user is by validating a username and password.
As such, Spring Security provides comprehensive support for authenticating with a username and password.</p>
</div>
<div id="servlet-authentication-unpwd-input" class="paragraph">
<p><strong>Reading the Username &amp; Password</strong></p>
</div>
<div class="paragraph">
<p>Spring Security provides the following built in mechanisms for reading a username and password from the <code>HttpServletRequest</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-form">Form Login</a></p>
</li>
<li>
<p><a href="#servlet-authentication-basic">Basic Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-digest">Digest Authentication</a></p>
</li>
</ul>
</div>
<div id="servlet-authentication-unpwd-storage" class="paragraph">
<p><strong>Storage Mechanisms</strong></p>
</div>
<div class="paragraph">
<p>Each of the supported mechanisms for reading a username and password can leverage any of the supported storage mechanisms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple Storage with <a href="#servlet-authentication-inmemory">In-Memory Authentication</a></p>
</li>
<li>
<p>Relational Databases with <a href="#servlet-authentication-jdbc">JDBC Authentication</a></p>
</li>
<li>
<p>Custom data stores with <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a></p>
</li>
<li>
<p>LDAP storage with <a href="#servlet-authentication-ldap">LDAP Authentication</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="servlet-authentication-form"><a class="anchor" href="#servlet-authentication-form"></a>Form Login</h3>
<div class="paragraph">
<p>Spring Security provides support for username and password being provided through an html form.
This section provides details on how form based authentication works within Spring Security.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how form based log in works within Spring Security.
First, we see how the user is redirected to the log in form.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/loginurlauthenticationentrypoint.png" alt="loginurlauthenticationentrypoint">
</div>
<div class="title">Figure 1. Redirecting to the Log In Page</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em> and sends a redirect to the log in page with the configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>.
In most cases the <code>AuthenticationEntryPoint</code> is an instance of {security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[<code>LoginUrlAuthenticationEntryPoint</code>].</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> The browser will then request the log in page that it was redirected to.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> Something within the application, must <a href="#servlet-authentication-form-custom">render the log in page</a>.</p>
</div>
<div id="servlet-authentication-usernamepasswordauthenticationfilter" class="paragraph">
<p>When the username and password are submitted, the <code>UsernamePasswordAuthenticationFilter</code> authenticates the username and password.
The <code>UsernamePasswordAuthenticationFilter</code> extends <a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a>, so this diagram should look pretty similar.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/usernamepasswordauthenticationfilter.png" alt="usernamepasswordauthenticationfilter">
</div>
<div class="title">Figure 2. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their username and password, the <code>UsernamePasswordAuthenticationFilter</code> creates a <code>UsernamePasswordAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the username and password from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>UsernamePasswordAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> look like depend on how the <a href="#servlet-authentication-unpwd-storage">user information is stored</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionAuthenticationStrategy</code> is notified of a new log in.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> publishes an <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p>The <code>AuthenticationSuccessHandler</code> is invoked. Typically this is a <code>SimpleUrlAuthenticationSuccessHandler</code> which will redirect to a request saved by <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> when we redirect to the log in page.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-form-min" class="paragraph">
<p>Spring Security form log in is enabled by default.
However, as soon as any servlet based configuration is provided, form based log in must be explicitly provided.
A minimal, explicit Java configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Form Log In</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
	http
		// ...
		.formLogin(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;form-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin { }
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration Spring Security will render a default log in page.
Most production applications will require a custom log in form.</p>
</div>
<div id="servlet-authentication-form-custom" class="paragraph">
<p>The configuration below demonstrates how to provide a custom log in form.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Custom Log In Form Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.formLogin(form -&gt; form
			.loginPage("/login")
			.permitAll()
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;intercept-url pattern="/login" access="permitAll" /&gt;
	&lt;form-login login-page="/login" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin {
			loginPage = "/login"
			permitAll()
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div id="servlet-authentication-form-custom-html" class="paragraph">
<p>When the login page is specified in the Spring Security configuration, you are responsible for rendering the page.
Below is a <a href="https://www.thymeleaf.org/">Thymeleaf</a> template that produces an HTML login form that complies with a login page of <code>/login</code>.:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Log In Form</div>
<div class="content">
<div class="listingblock">
<div class="title">src/main/resources/templates/login.html</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org"&gt;
	&lt;head&gt;
		&lt;title&gt;Please Log In&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Please Log In&lt;/h1&gt;
		&lt;div th:if="${param.error}"&gt;
			Invalid username and password.&lt;/div&gt;
		&lt;div th:if="${param.logout}"&gt;
			You have been logged out.&lt;/div&gt;
		&lt;form th:action="@{/login}" method="post"&gt;
			&lt;div&gt;
			&lt;input type="text" name="username" placeholder="Username"/&gt;
			&lt;/div&gt;
			&lt;div&gt;
			&lt;input type="password" name="password" placeholder="Password"/&gt;
			&lt;/div&gt;
			&lt;input type="submit" value="Log in" /&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are a few key points about the default HTML form:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The form should perform a <code>post</code> to <code>/login</code></p>
</li>
<li>
<p>The form will need to include a <a href="#servlet-csrf">CSRF Token</a> which is <a href="#servlet-csrf-include-form-auto">automatically included</a> by Thymeleaf.</p>
</li>
<li>
<p>The form should specify the username in a parameter named <code>username</code></p>
</li>
<li>
<p>The form should specify the password in a parameter named <code>password</code></p>
</li>
<li>
<p>If the HTTP parameter error is found, it indicates the user failed to provide a valid username / password</p>
</li>
<li>
<p>If the HTTP parameter logout is found, it indicates the user has logged out successfully</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many users will not need much more than to customize the log in page.
However, if needed everything above can be customized with additional configuration.</p>
</div>
<div id="servlet-authentication-form-custom-controller" class="paragraph">
<p>If you are using Spring MVC, you will need a controller that maps <code>GET /login</code> to the login template we created.
A minimal sample <code>LoginController</code> can be see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. LoginController</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
class LoginController {
	@GetMapping("/login")
	String login() {
		return "login";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class LoginController {
    @GetMapping("/login")
    fun login(): String {
        return "login"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-basic"><a class="anchor" href="#servlet-authentication-basic"></a>Basic Authentication</h3>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for <a href="https://tools.ietf.org/html/rfc7617">Basic HTTP Authentication</a> for servlet based applications.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how HTTP Basic Authentication works within Spring Security.
First, we see the <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a> header is sent back to an unauthenticated client.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/basicauthenticationentrypoint.png" alt="basicauthenticationentrypoint">
</div>
<div class="title">Figure 3. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/web/authentication/www/BasicAuthenticationEntryPoint.html[<code>BasicAuthenticationEntryPoint</code>] which sends a WWW-Authenticate header.
The <code>RequestCache</code> is typically a <code>NullRequestCache</code> that does not save the request since the client is capable of replaying the requests it originally requested.</p>
</div>
<div class="paragraph">
<p>When a client receives the WWW-Authenticate header it knows it should retry with a username and password.
Below is the flow for the username and password being processed.</p>
</div>
<div id="servlet-authentication-basicauthenticationfilter" class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/basicauthenticationfilter.png" alt="basicauthenticationfilter">
</div>
<div class="title">Figure 4. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their username and password, the <code>BasicAuthenticationFilter</code> creates a <code>UsernamePasswordAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the username and password from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>UsernamePasswordAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> look like depend on how the <a href="#servlet-authentication-unpwd-storage">user information is stored</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationEntryPoint</code> is invoked to trigger the WWW-Authenticate to be sent again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p>The <code>BasicAuthenticationFilter</code> invokes <code>FilterChain.doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s HTTP Basic Authentication support in is enabled by default.
However, as soon as any servlet based configuration is provided, HTTP Basic must be explicitly provided.</p>
</div>
<div class="paragraph">
<p>A minimal, explicit configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Explicit HTTP Basic Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
	http
		// ...
		.httpBasic(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		httpBasic { }
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-digest"><a class="anchor" href="#servlet-authentication-digest"></a>Digest Authentication</h3>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for <a href="https://tools.ietf.org/html/rfc2617">Digest Authentication</a> which is provided <code>DigestAuthenticationFilter</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You should not use Digest Authentication in modern applications because it is not considered secure.
The most obvious problem is that you must store your passwords in plaintext, encrypted, or an MD5 format.
All of these storage formats are considered insecure.
Instead, you should store credentials using a one way adaptive password hash (i.e. bCrypt, PBKDF2, SCrypt, etc) which is not supported by Digest Authentication.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Digest Authentication attempts to solve many of the weaknesses of <a href="#servlet-authentication-basic">Basic authentication</a>, specifically by ensuring credentials are never sent in clear text across the wire.
Many <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest#Browser_compatibility">browsers support Digest Authentication</a>.</p>
</div>
<div class="paragraph">
<p>The standard governing HTTP Digest Authentication is defined by <a href="https://tools.ietf.org/html/rfc2617">RFC 2617</a>, which updates an earlier version of the Digest Authentication standard prescribed by <a href="https://tools.ietf.org/html/rfc2069">RFC 2069</a>.
Most user agents implement RFC 2617.
Spring Security&#8217;s Digest Authentication support is compatible with the &#8220;auth&#8221; quality of protection (<code>qop</code>) prescribed by RFC 2617, which also provides backward compatibility with RFC 2069.
Digest Authentication was seen as a more attractive option if you need to use unencrypted HTTP (i.e. no TLS/HTTPS) and wish to maximise security of the authentication process.
However, everyone should use <a href="#http">HTTPS</a>.</p>
</div>
<div class="paragraph">
<p>Central to Digest Authentication is a "nonce".
This is a value the server generates.
Spring Security&#8217;s nonce adopts the following format:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Digest Syntax</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You will need to ensure you <a href="#authentication-password-storage-configuration">configure</a> insecure plain text <a href="#authentication-password-storage">Password Storage</a> using NoOpPasswordEncoder`.
The following provides an example of configuring Digest Authentication with Java Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Digest Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
UserDetailsService userDetailsService;

DigestAuthenticationEntryPoint entryPoint() {
	DigestAuthenticationEntryPoint result = new DigestAuthenticationEntryPoint();
	result.setRealmName("My App Relam");
	result.setKey("3028472b-da34-4501-bfd8-a355c42bdf92");
}

DigestAuthenticationFilter digestAuthenticationFilter() {
	DigestAuthenticationFilter result = new DigestAuthenticationFilter();
	result.setUserDetailsService(userDetailsService);
	result.setAuthenticationEntryPoint(entryPoint());
}

protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.exceptionHandling(e -&gt; e.authenticationEntryPoint(authenticationEntryPoint()))
		.addFilterBefore(digestFilter());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean id="digestFilter"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationFilter"
    p:userDetailsService-ref="jdbcDaoImpl"
    p:authenticationEntryPoint-ref="digestEntryPoint"
/&gt;

&lt;b:bean id="digestEntryPoint"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"
    p:realmName="My App Realm"
	p:key="3028472b-da34-4501-bfd8-a355c42bdf92"
/&gt;

&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;custom-filter ref="userFilter" position="DIGEST_AUTH_FILTER"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-inmemory"><a class="anchor" href="#servlet-authentication-inmemory"></a>In-Memory Authentication</h3>
<div class="paragraph">
<p>Spring Security&#8217;s <code>InMemoryUserDetailsManager</code> implements <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> to provide support for username/password based authentication that is retrieved in memory.
<code>InMemoryUserDetailsManager</code> provides management of <code>UserDetails</code> by implementing the <code>UserDetailsManager</code> interface.
<code>UserDetails</code> based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.</p>
</div>
<div class="paragraph">
<p>In this sample we use <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a> to encode the password of <code>password</code> and get the encoded password of <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. InMemoryUserDetailsManager Java Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UserDetailsService users() {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user-service&gt;
	&lt;user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    val user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build()
    val admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The samples above store the passwords in a secure format, but leave a lot to be desired in terms of getting started experience.</p>
</div>
<div class="paragraph">
<p>In the sample below we leverage <a href="#authentication-password-storage-dep-getting-started">User.withDefaultPasswordEncoder</a> to ensure that the password stored in memory is protected.
However, it does not protect against obtaining the password by decompiling the source code.
For this reason, <code>User.withDefaultPasswordEncoder</code> should only be used for "getting started" and is not intended for production.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. InMemoryUserDetailsManager with User.withDefaultPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UserDetailsService users() {
	// The builder will ensure the passwords are encoded before saving in memory
	UserBuilder users = User.withDefaultPasswordEncoder();
	UserDetails user = users
		.username("user")
		.password("password")
		.roles("USER")
		.build();
	UserDetails admin = users
		.username("admin")
		.password("password")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    // The builder will ensure the passwords are encoded before saving in memory
    val users = User.withDefaultPasswordEncoder()
    val user = users
        .username("user")
        .password("password")
        .roles("USER")
        .build()
    val admin = users
        .username("admin")
        .password("password")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There is no simple way to use <code>User.withDefaultPasswordEncoder</code> with XML based configuration.
For demos or just getting started, you can choose to prefix the password with <code>{noop}</code> to indicate <a href="#authentication-password-storage-dpe-format">no encoding should be used</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. &lt;user-service&gt; <code>{noop}</code> XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user-service&gt;
	&lt;user name="user"
		password="{noop}password"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{noop}password"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-jdbc"><a class="anchor" href="#servlet-authentication-jdbc"></a>JDBC Authentication</h3>
<div class="paragraph">
<p>Spring Security&#8217;s <code>JdbcDaoImpl</code> implements <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> to provide support for username/password based authentication that is retrieved using JDBC.
<code>JdbcUserDetailsManager</code> extends <code>JdbcDaoImpl</code> to provide management of <code>UserDetails</code> through the <code>UserDetailsManager</code> interface.
<code>UserDetails</code> based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.</p>
</div>
<div class="paragraph">
<p>In the following sections we will discuss:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-jdbc-schema">Default Schema</a> used by Spring Security JDBC Authentication</p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-datasource">Setting up a DataSource</a></p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-bean">JdbcUserDetailsManager Bean</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-authentication-jdbc-schema"><a class="anchor" href="#servlet-authentication-jdbc-schema"></a>Default Schema</h4>
<div class="paragraph">
<p>Spring Security provides default queries for JDBC based authentication.
This section provides the corresponding default schemas used with the default queries.
You will need to adjust the schema to match any customizations to the queries and the database dialect you are using.</p>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-schema-user"><a class="anchor" href="#servlet-authentication-jdbc-schema-user"></a>User Schema</h5>
<div class="paragraph">
<p><code>JdbcDaoImpl</code> requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.
The default schema required can be found below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default schema is also exposed as a classpath resource named <code>org/springframework/security/core/userdetails/jdbc/users.ddl</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 13. Default User Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(500) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Oracle is a popular database choice, but requires a slightly different schema.
You can find the default Oracle Schema for users below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Default User Schema for Oracle Databases</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-schema-group"><a class="anchor" href="#servlet-authentication-jdbc-schema-group"></a>Group Schema</h5>
<div class="paragraph">
<p>If your application is leveraging groups, you will need to provide the groups schema.
The default schema for groups can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Default Group Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-jdbc-datasource"><a class="anchor" href="#servlet-authentication-jdbc-datasource"></a>Setting up a DataSource</h4>
<div class="paragraph">
<p>Before we configure <code>JdbcUserDetailsManager</code>, we must create a <code>DataSource</code>.
In our example, we will setup an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support">embedded DataSource</a> that is initialized with the <a href="#servlet-authentication-jdbc-schema">default user schema</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Embedded Data Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
DataSource dataSource() {
	return new EmbeddedDatabaseBuilder()
		.setType(H2)
		.addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
		.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jdbc:embedded-database&gt;
	&lt;jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/&gt;
&lt;/jdbc:embedded-database&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
        .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In a production environment, you will want to ensure you setup a connection to an external database.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-jdbc-bean"><a class="anchor" href="#servlet-authentication-jdbc-bean"></a>JdbcUserDetailsManager Bean</h4>
<div class="paragraph">
<p>In this sample we use <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a> to encode the password of <code>password</code> and get the encoded password of <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code>.
See the <a href="#authentication-password-storage">PasswordEncoder</a> section for more details about how to store passwords.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. JdbcUserDetailsManager</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
UserDetailsManager users(DataSource dataSource) {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
	users.createUser(user);
	users.createUser(admin);
	return users;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jdbc-user-service&gt;
	&lt;user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/jdbc-user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(dataSource: DataSource): UserDetailsManager {
    val user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
    val admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
    val users = JdbcUserDetailsManager(dataSource)
    users.createUser(user)
    users.createUser(admin)
    return users
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-userdetails"><a class="anchor" href="#servlet-authentication-userdetails"></a>UserDetails</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/userdetails/UserDetails.html[<code>UserDetails</code>] is returned by the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>.
The <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> validates the <code>UserDetails</code> and then returns an <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that has a principal that is the <code>UserDetails</code> returned by the configured <code>UserDetailsService</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-userdetailsservice"><a class="anchor" href="#servlet-authentication-userdetailsservice"></a>UserDetailsService</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/userdetails/UserDetailsService.html[<code>UserDetailsService</code>] is used by <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> for retrieving a username, password, and other attributes for authenticating with a username and password.
Spring Security provides <a href="#servlet-authentication-inmemory">in-memory</a> and <a href="#servlet-authentication-jdbc">JDBC</a> implementations of <code>UserDetailsService</code>.</p>
</div>
<div class="paragraph">
<p>You can define custom authentication by exposing a custom <code>UserDetailsService</code> as a bean.
For example, the following will customize authentication assuming that <code>CustomUserDetailsService</code> implements <code>UserDetailsService</code>:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is only used if the <code>AuthenticationManagerBuilder</code> has not been populated and no <code>AuthenticationProviderBean</code> is defined.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 18. Custom UserDetailsService Bean</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
CustomUserDetailsService customUserDetailsService() {
	return new CustomUserDetailsService();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;b:bean class="example.CustomUserDetailsService"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun customUserDetailsService() = CustomUserDetailsService()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-password-storage"><a class="anchor" href="#servlet-authentication-password-storage"></a>PasswordEncoder</h3>
<div class="paragraph">
<p>Spring Security&#8217;s servlet support storing passwords securely by integrating with <a href="#authentication-password-storage"><code>PasswordEncoder</code></a>.
Customizing the <code>PasswordEncoder</code> implementation used by Spring Security can be done by <a href="#authentication-password-storage-configuration">exposing a <code>PasswordEncoder</code> Bean</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-daoauthenticationprovider"><a class="anchor" href="#servlet-authentication-daoauthenticationprovider"></a>DaoAuthenticationProvider</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/dao/DaoAuthenticationProvider.html[<code>DaoAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> and <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a> to authenticate a username and password.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>DaoAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#servlet-authentication-unpwd-input">Reading the Username &amp; Password</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/daoauthenticationprovider.png" alt="daoauthenticationprovider">
</div>
<div class="title">Figure 5. <code>DaoAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#servlet-authentication-unpwd-input">Reading the Username &amp; Password</a> passes a <code>UsernamePasswordAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> of type <code>DaoAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>DaoAuthenticationProvider</code> looks up the <code>UserDetails</code> from the <code>UserDetailsService</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> <code>DaoAuthenticationProvider</code> then uses the <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a> to validate the password on the <code>UserDetails</code> returned in the previous step.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>UsernamePasswordAuthenticationToken</code> and has a principal that is the <code>UserDetails</code> returned by the configured <code>UserDetailsService</code>.
Ultimately, the returned <code>UsernamePasswordAuthenticationToken</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-ldap"><a class="anchor" href="#servlet-authentication-ldap"></a>LDAP Authentication</h3>
<div class="paragraph">
<p>LDAP is often used by organizations as a central repository for user information and as an authentication service.
It can also be used to store the role information for application users.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s LDAP based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.
However, despite leveraging a username/password for authentication it does not integrate using <code>UserDetailsService</code> because in <a href="#servlet-authentication-ldap-bind">bind authentication</a> the LDAP server does not return the password so the application cannot perform validation of the password.</p>
</div>
<div class="paragraph">
<p>There are many different scenarios for how an LDAP server may be configured so Spring Security&#8217;s LDAP provider is fully configurable.
It uses separate strategy interfaces for authentication and role retrieval and provides default implementations which can be configured to handle a wide range of situations.</p>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-prerequisites"><a class="anchor" href="#servlet-authentication-ldap-prerequisites"></a>Prerequisites</h4>
<div class="paragraph">
<p>You should be familiar with LDAP before trying to use it with Spring Security.
The following link provides a good introduction to the concepts involved and a guide to setting up a directory using the free LDAP server OpenLDAP: <a href="https://www.zytrax.com/books/ldap/" class="bare">https://www.zytrax.com/books/ldap/</a>.
Some familiarity with the JNDI APIs used to access LDAP from Java may also be useful.
We don&#8217;t use any third-party LDAP libraries (Mozilla, JLDAP etc.) in the LDAP provider, but extensive use is made of Spring LDAP, so some familiarity with that project may be useful if you plan on adding your own customizations.</p>
</div>
<div class="paragraph">
<p>When using LDAP authentication, it is important to ensure that you configure LDAP connection pooling properly.
If you are unfamiliar with how to do this, you can refer to the <a href="https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html">Java LDAP documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-embedded"><a class="anchor" href="#servlet-authentication-ldap-embedded"></a>Setting up an Embedded LDAP Server</h4>
<div class="paragraph">
<p>The first thing you will need to do is to ensure that you have an LDAP Server to point your configuration to.
For simplicity, it often best to start with an embedded LDAP Server.
Spring Security supports using either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-unboundid">Embedded UnboundID Server</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-apacheds">Embedded ApacheDS Server</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the samples below, we expose the following as <code>users.ldif</code> as a classpath resource to initialize the embedded LDAP server with the users <code>user</code> and <code>admin</code> both of which have a password of <code>password</code>.</p>
</div>
<div class="listingblock">
<div class="title">users.ldif</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ldif hljs" data-lang="ldif">dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-unboundid"><a class="anchor" href="#servlet-authentication-ldap-unboundid"></a>Embedded UnboundID Server</h5>
<div class="paragraph">
<p>If you wish to use <a href="https://ldap.com/unboundid-ldap-sdk-for-java/">UnboundID</a>, then specify the following dependencies:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. UnboundID Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.unboundid&lt;/groupId&gt;
	&lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;
	&lt;version&gt;{unboundid-ldapsdk-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">depenendencies {
	runtimeOnly "com.unboundid:unboundid-ldapsdk:{unboundid-ldapsdk-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can then configure the Embedded LDAP Server</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. Embedded LDAP Server Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
UnboundIdContainer ldapContainer() {
	return new UnboundIdContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.UnboundIdContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun ldapContainer(): UnboundIdContainer {
    return UnboundIdContainer("dc=springframework,dc=org","classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-apacheds"><a class="anchor" href="#servlet-authentication-ldap-apacheds"></a>Embedded ApacheDS Server</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security uses ApacheDS 1.x which is no longer maintained.
Unfortunately, ApacheDS 2.x has only released milestone versions with no stable release.
Once a stable release of ApacheDS 2.x is available, we will consider updating.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to use <a href="https://directory.apache.org/apacheds/">Apache DS</a>, then specify the following dependencies:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. ApacheDS Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
	&lt;artifactId&gt;apacheds-core&lt;/artifactId&gt;
	&lt;version&gt;{apacheds-core-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
	&lt;artifactId&gt;apacheds-server-jndi&lt;/artifactId&gt;
	&lt;version&gt;{apacheds-core-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">depenendencies {
	runtimeOnly "org.apache.directory.server:apacheds-core:{apacheds-core-version}"
	runtimeOnly "org.apache.directory.server:apacheds-server-jndi:{apacheds-core-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can then configure the Embedded LDAP Server</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Embedded LDAP Server Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ApacheDSContainer ldapContainer() {
	return new ApacheDSContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.ApacheDSContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun ldapContainer(): ApacheDSContainer {
    return ApacheDSContainer("dc=springframework,dc=org", "classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-contextsource"><a class="anchor" href="#servlet-authentication-ldap-contextsource"></a>LDAP ContextSource</h4>
<div class="paragraph">
<p>Once you have an LDAP Server to point your configuration to, you need configure Spring Security to point to an LDAP server that should be used to authenticate users.
This is done by creating an LDAP <code>ContextSource</code>, which is the equivalent of a JDBC <code>DataSource</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. LDAP Context Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ContextSource contextSource(UnboundIdContainer container) {
	return new DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-server
	url="ldap://localhost:53389/dc=springframework,dc=org" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun contextSource(container: UnboundIdContainer): ContextSource {
    return DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-authentication"><a class="anchor" href="#servlet-authentication-ldap-authentication"></a>Authentication</h4>
<div class="paragraph">
<p>Spring Security&#8217;s LDAP support does not use the <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> because LDAP bind authentication does not allow clients to read the password or even a hashed version of the password.
This means there is no way a password to be read and then authenticated by Spring Security.</p>
</div>
<div class="paragraph">
<p>For this reason, LDAP support is implemented using the <code>LdapAuthenticator</code> interface.
The <code>LdapAuthenticator</code> is also responsible for retrieving any required user attributes.
This is because the permissions on the attributes may depend on the type of authentication being used.
For example, if binding as the user, it may be necessary to read them with the user&#8217;s own permissions.</p>
</div>
<div class="paragraph">
<p>There are two <code>LdapAuthenticator</code> implementations supplied with Spring Security:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-bind">Using Bind Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-pwd">Using Password Authentication</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-bind"><a class="anchor" href="#servlet-authentication-ldap-bind"></a>Using Bind Authentication</h4>
<div class="paragraph">
<p><a href="https://ldap.com/the-ldap-bind-operation/">Bind Authentication</a> is the most common mechanism for authenticating users with LDAP.
In bind authentication the users credentials (i.e. username/password) are submitted to the LDAP server which authenticates them.
The advantage to using bind authentication is that the user&#8217;s secrets (i.e. password) do not need to be exposed to clients which helps to protect them from leaking.</p>
</div>
<div class="paragraph">
<p>An example of bind authentication configuration can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Bind Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	BindAuthenticator authenticator = new BindAuthenticator(contextSource);
	authenticator.setUserDnPatterns(new String[] { "uid={0},ou=people" });
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserDnPatterns(arrayOf("uid={0},ou=people"))
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This simple example would obtain the DN for the user by substituting the user login name in the supplied pattern and attempting to bind as that user with the login password.
This is OK if all your users are stored under a single node in the directory.
If instead you wished to configure an LDAP search filter to locate the user, you could use the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Bind Authentication with Search Filter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	String searchBase = "ou=people";
	String filter = "(uid={0})";
	FilterBasedLdapUserSearch search =
		new FilterBasedLdapUserSearch(searchBase, filter, contextSource);
	BindAuthenticator authenticator = new BindAuthenticator(contextSource);
	authenticator.setUserSearch(search);
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-search-filter="(uid={0})"
	user-search-base="ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val searchBase = "ou=people"
    val filter = "(uid={0})"
    val search = FilterBasedLdapUserSearch(searchBase, filter, contextSource)
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserSearch(search)
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If used with the <code>ContextSource</code> <a href="#servlet-authentication-ldap-contextsource">definition above</a>, this would perform a search under the DN <code>ou=people,dc=springframework,dc=org</code> using <code>(uid={0})</code> as a filter.
Again the user login name is substituted for the parameter in the filter name, so it will search for an entry with the <code>uid</code> attribute equal to the user name.
If a user search base isn&#8217;t supplied, the search will be performed from the root.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap-pwd"><a class="anchor" href="#servlet-authentication-ldap-pwd"></a>Using Password Authentication</h4>
<div class="paragraph">
<p>Password comparison is when the password supplied by the user is compared with the one stored in the repository.
This can either be done by retrieving the value of the password attribute and checking it locally or by performing an LDAP "compare" operation, where the supplied password is passed to the server for comparison and the real password value is never retrieved.
An LDAP compare cannot be done when the password is properly hashed with a random salt.</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Minimal Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	return new PasswordComparisonAuthenticator(contextSource);
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people"&gt;
	&lt;password-compare /&gt;
&lt;/ldap-authentication-provider&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    return PasswordComparisonAuthenticator(contextSource)
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A more advanced configuration with some customizations can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	PasswordComparisonAuthenticator authenticator =
		new PasswordComparisonAuthenticator(contextSource);
	authenticator.setPasswordAttributeName("pwd"); <i class="conum" data-value="1"></i><b>(1)</b>
	authenticator.setPasswordEncoder(new BCryptPasswordEncoder()); <i class="conum" data-value="2"></i><b>(2)</b>
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people"&gt;
	&lt;password-compare password-attribute="pwd"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
		&lt;password-encoder ref="passwordEncoder" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
	&lt;/password-compare&gt;
&lt;/ldap-authentication-provider&gt;
&lt;b:bean id="passwordEncoder"
	class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    val authenticator = PasswordComparisonAuthenticator(contextSource)
    authenticator.setPasswordAttributeName("pwd") <i class="conum" data-value="1"></i><b>(1)</b>
    authenticator.setPasswordEncoder(BCryptPasswordEncoder()) <i class="conum" data-value="2"></i><b>(2)</b>
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the password attribute as <code>pwd</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>BCryptPasswordEncoder</code></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ldapauthoritiespopulator"><a class="anchor" href="#_ldapauthoritiespopulator"></a>LdapAuthoritiesPopulator</h4>
<div class="paragraph">
<p>Spring Security&#8217;s <code>LdapAuthoritiesPopulator</code> is used to determine what authorites are returned for the user.</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. LdapAuthoritiesPopulator Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
	String groupSearchBase = "";
	DefaultLdapAuthoritiesPopulator authorities =
		new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
	authorities.setGroupSearchFilter("member={0}");
	return authorities;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator, LdapAuthoritiesPopulator authorities) {
	return new LdapAuthenticationProvider(authenticator, authorities);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"
	group-search-filter="member={0}"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    val groupSearchBase = ""
    val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase)
    authorities.setGroupSearchFilter("member={0}")
    return authorities
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator, authorities: LdapAuthoritiesPopulator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator, authorities)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_active_directory"><a class="anchor" href="#_active_directory"></a>Active Directory</h4>
<div class="paragraph">
<p>Active Directory supports its own non-standard authentication options, and the normal usage pattern doesn&#8217;t fit too cleanly with the standard <code>LdapAuthenticationProvider</code>.
Typically authentication is performed using the domain username (in the form <code>user@domain</code>), rather than using an LDAP distinguished name.
To make this easier, Spring Security has an authentication provider which is customized for a typical Active Directory setup.</p>
</div>
<div class="paragraph">
<p>Configuring <code>ActiveDirectoryLdapAuthenticationProvider</code> is quite straightforward.
You just need to supply the domain name and an LDAP URL supplying the address of the server <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.
An example configuration can be seen below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Example Active Directory Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ActiveDirectoryLdapAuthenticationProvider authenticationProvider() {
	return new ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="authenticationProvider"
        class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&gt;
	&lt;constructor-arg value="example.com" /&gt;
	&lt;constructor-arg value="ldap://company.example.com/" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider {
    return ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="session-mgmt"><a class="anchor" href="#session-mgmt"></a>Session Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP session related functionality is handled by a combination of the <code>SessionManagementFilter</code> and the <code>SessionAuthenticationStrategy</code> interface, which the filter delegates to.
Typical usage includes session-fixation protection attack prevention, detection of session timeouts and restrictions on how many sessions an authenticated user may have open concurrently.</p>
</div>
<div class="sect2">
<h3 id="_detecting_timeouts"><a class="anchor" href="#_detecting_timeouts"></a>Detecting Timeouts</h3>
<div class="paragraph">
<p>You can configure Spring Security to detect the submission of an invalid session ID and redirect the user to an appropriate URL.
This is achieved through the <code>session-management</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management invalid-session-url="/invalidSession.htm" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you use this mechanism to detect session timeouts, it may falsely report an error if the user logs out and then logs back in without closing the browser.
This is because the session cookie is not cleared when you invalidate the session and will be resubmitted even if the user has logged out.
You may be able to explicitly delete the JSESSIONID cookie on logging out, for example by using the following syntax in the logout handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;logout delete-cookies="JSESSIONID" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately this can&#8217;t be guaranteed to work with every servlet container, so you will need to test it in your environment</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are running your application behind a proxy, you may also be able to remove the session cookie by configuring the proxy server.
For example, using Apache HTTPD&#8217;s mod_headers, the following directive would delete the <code>JSESSIONID</code> cookie by expiring it in the response to a logout request (assuming the application is deployed under the path <code>/tutorial</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;LocationMatch "/tutorial/logout"&gt;
Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
&lt;/LocationMatch&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ns-concurrent-sessions"><a class="anchor" href="#ns-concurrent-sessions"></a>Concurrent Session Control</h3>
<div class="paragraph">
<p>If you wish to place constraints on a single user&#8217;s ability to log in to your application, Spring Security supports this out of the box with the following simple additions.
First you need to add the following listener to your <code>web.xml</code> file to keep Spring Security updated about session lifecycle events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the following lines to your application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will prevent a user from logging in multiple times - a second login will cause the first to be invalidated.
Often you would prefer to prevent a second login, in which case you can use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" error-if-maximum-exceeded="true" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second login will then be rejected.
By "rejected", we mean that the user will be sent to the <code>authentication-failure-url</code> if form-based login is being used.
If the second authentication takes place through another non-interactive mechanism, such as "remember-me", an "unauthorized" (401) error will be sent to the client.
If instead you want to use an error page, you can add the attribute <code>session-authentication-error-url</code> to the <code>session-management</code> element.</p>
</div>
<div class="paragraph">
<p>If you are using a customized authentication filter for form-based login, then you have to configure concurrent session control support explicitly.
More details can be found in the <a href="#session-mgmt">Session Management chapter</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-session-fixation"><a class="anchor" href="#ns-session-fixation"></a>Session Fixation Attack Protection</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session fixation</a> attacks are a potential risk where it is possible for a malicious attacker to create a session by accessing a site, then persuade another user to log in with the same session (by sending them a link containing the session identifier as a parameter, for example).
Spring Security protects against this automatically by creating a new session or otherwise changing the session ID when a user logs in.
If you don&#8217;t require this protection, or it conflicts with some other requirement, you can control the behavior using the <code>session-fixation-protection</code> attribute on <code>&lt;session-management&gt;</code>, which has four options</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> - Don&#8217;t do anything.
The original session will be retained.</p>
</li>
<li>
<p><code>newSession</code> - Create a new "clean" session, without copying the existing session data (Spring Security-related attributes will still be copied).</p>
</li>
<li>
<p><code>migrateSession</code> - Create a new session and copy all existing session attributes to the new session.
This is the default in Servlet 3.0 or older containers.</p>
</li>
<li>
<p><code>changeSessionId</code> - Do not create a new session.
Instead, use the session fixation protection provided by the Servlet container (<code>HttpServletRequest#changeSessionId()</code>).
This option is only available in Servlet 3.1 (Java EE 7) and newer containers.
Specifying it in older containers will result in an exception.
This is the default in Servlet 3.1 and newer containers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When session fixation protection occurs, it results in a <code>SessionFixationProtectionEvent</code> being published in the application context.
If you use <code>changeSessionId</code>, this protection will <em>also</em> result in any  <code>javax.servlet.http.HttpSessionIdListener</code> s being notified, so use caution if your code listens for both events.
See the <a href="#session-mgmt">Session Management</a> chapter for additional information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sessionmanagementfilter"><a class="anchor" href="#_sessionmanagementfilter"></a>SessionManagementFilter</h3>
<div class="paragraph">
<p>The <code>SessionManagementFilter</code> checks the contents of the <code>SecurityContextRepository</code> against the current contents of the <code>SecurityContextHolder</code> to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me  <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.
If the repository contains a security context, the filter does nothing.
If it doesn&#8217;t, and the thread-local <code>SecurityContext</code> contains a (non-anonymous) <code>Authentication</code> object, the filter assumes they have been authenticated by a previous filter in the stack.
It will then invoke the configured <code>SessionAuthenticationStrategy</code>.</p>
</div>
<div class="paragraph">
<p>If the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured <code>InvalidSessionStrategy</code>, if one is set.
The most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation <code>SimpleRedirectInvalidSessionStrategy</code>.
The latter is also used when configuring an invalid session URL through the namespace,<a href="#session-mgmt">as described earlier</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sessionauthenticationstrategy"><a class="anchor" href="#_sessionauthenticationstrategy"></a>SessionAuthenticationStrategy</h3>
<div class="paragraph">
<p><code>SessionAuthenticationStrategy</code> is used by both <code>SessionManagementFilter</code> and <code>AbstractAuthenticationProcessingFilter</code>, so if you are using a customized form-login class, for example, you will need to inject it into both of these.
In this case, a typical configuration, combining the namespace and custom beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
	&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
	...
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class=
"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the use of the default, <code>SessionFixationProtectionStrategy</code> may cause issues if you are storing beans in the session which implement <code>HttpSessionBindingListener</code>, including Spring session-scoped beans.
See the Javadoc for this class for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent-sessions"><a class="anchor" href="#concurrent-sessions"></a>Concurrency Control</h3>
<div class="paragraph">
<p>Spring Security is able to prevent a principal from concurrently authenticating to the same application more than a specified number of times.
Many ISVs take advantage of this to enforce licensing, whilst network administrators like this feature because it helps prevent people from sharing login names.
You can, for example, stop user "Batman" from logging onto the web application from two different sessions.
You can either expire their previous login or you can report an error when they try to log in again, preventing the second login.
Note that if you are using the second approach, a user who has not explicitly logged out (but who has just closed their browser, for example) will not be able to log in again until their original session expires.</p>
</div>
<div class="paragraph">
<p>Concurrency control is supported by the namespace, so please check the earlier namespace chapter for the simplest configuration.
Sometimes you need to customize things though.</p>
</div>
<div class="paragraph">
<p>The implementation uses a specialized version of <code>SessionAuthenticationStrategy</code>, called <code>ConcurrentSessionControlAuthenticationStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Previously the concurrent authentication check was made by the <code>ProviderManager</code>, which could be injected with a <code>ConcurrentSessionController</code>.
The latter would check if the user was attempting to exceed the number of permitted sessions.
However, this approach required that an HTTP session be created in advance, which is undesirable.
In Spring Security 3, the user is first authenticated by the <code>AuthenticationManager</code> and once they are successfully authenticated, a session is created and the check is made whether they are allowed to have another session open.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use concurrent session support, you&#8217;ll need to add the following to <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
	&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
	&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you will need to add the <code>ConcurrentSessionFilter</code> to your <code>FilterChainProxy</code>.
The <code>ConcurrentSessionFilter</code> requires two constructor arguments, <code>sessionRegistry</code>, which generally points to an instance of <code>SessionRegistryImpl</code>, and <code>sessionInformationExpiredStrategy</code>, which defines the strategy to apply when a session has expired.
A configuration using the namespace to create the <code>FilterChainProxy</code> and other default beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="redirectSessionInformationExpiredStrategy"
class="org.springframework.security.web.session.SimpleRedirectSessionInformationExpiredStrategy"&gt;
&lt;beans:constructor-arg name="invalidSessionUrl" value="/session-expired.htm" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="concurrencyFilter"
class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
&lt;beans:constructor-arg name="sessionRegistry" ref="sessionRegistry" /&gt;
&lt;beans:constructor-arg name="sessionInformationExpiredStrategy" ref="redirectSessionInformationExpiredStrategy" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
&lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class="org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"&gt;
&lt;beans:constructor-arg&gt;
	&lt;beans:list&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
		&lt;beans:property name="maximumSessions" value="1" /&gt;
		&lt;beans:property name="exceptionIfMaximumExceeded" value="true" /&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
	&lt;/beans:bean&gt;
	&lt;/beans:list&gt;
&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sessionRegistry"
	class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding the listener to <code>web.xml</code> causes an <code>ApplicationEvent</code> to be published to the Spring <code>ApplicationContext</code> every time a <code>HttpSession</code> commences or ends.
This is critical, as it allows the <code>SessionRegistryImpl</code> to be notified when a session ends.
Without it, a user will never be able to log back in again once they have exceeded their session allowance, even if they log out of another session or it times out.</p>
</div>
<div class="sect3">
<h4 id="list-authenticated-principals"><a class="anchor" href="#list-authenticated-principals"></a>Querying the SessionRegistry for currently authenticated users and their sessions</h4>
<div class="paragraph">
<p>Setting up concurrency-control, either through the namespace or using plain beans has the useful side effect of providing you with a reference to the <code>SessionRegistry</code> which you can use directly within your application, so even if you don&#8217;t want to restrict the number of sessions a user may have, it may be worth setting up the infrastructure anyway.
You can set the <code>maximumSession</code> property to -1 to allow unlimited sessions.
If you&#8217;re using the namespace, you can set an alias for the internally-created <code>SessionRegistry</code> using the <code>session-registry-alias</code> attribute, providing a reference which you can inject into your own beans.</p>
</div>
<div class="paragraph">
<p>The <code>getAllPrincipals()</code> method supplies you with a list of the currently authenticated users.
You can list a user&#8217;s sessions by calling the <code>getAllSessions(Object principal, boolean includeExpiredSessions)</code> method, which returns a list of <code>SessionInformation</code> objects.
You can also expire a user&#8217;s session by calling <code>expireNow()</code> on a <code>SessionInformation</code> instance.
When the user returns to the application, they will be prevented from proceeding.
You may find these methods useful in an administration application, for example.
Have a look at the Javadoc for more information.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-rememberme"><a class="anchor" href="#servlet-rememberme"></a>Remember-Me Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="remember-me-overview"><a class="anchor" href="#remember-me-overview"></a>Overview</h3>
<div class="paragraph">
<p>Remember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions.
This is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place.
Spring Security provides the necessary hooks for these operations to take place, and has two concrete remember-me implementations.
One uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens.</p>
</div>
<div class="paragraph">
<p>Note that both implementations require a <code>UserDetailsService</code>.
If you are using an authentication provider which doesn&#8217;t use a <code>UserDetailsService</code> (for example, the LDAP provider) then it won&#8217;t work unless you also have a <code>UserDetailsService</code> bean in your application context.</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-hash-token"><a class="anchor" href="#remember-me-hash-token"></a>Simple Hash-Based Token Approach</h3>
<div class="paragraph">
<p>This approach uses hashing to achieve a useful remember-me strategy.
In essence a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token</code></pre>
</div>
</div>
<div class="paragraph">
<p>As such the remember-me token is valid only for the period specified, and provided that the username, password and key does not change.
Notably, this has a potential security issue in that a captured remember-me token will be usable from any user agent until such time as the token expires.
This is the same issue as with digest authentication.
If a principal is aware a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue.
If more significant security is needed you should use the approach described in the next section.
Alternatively remember-me services should simply not be used at all.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the topics discussed in the chapter on <a href="#ns-config">namespace configuration</a>, you can enable remember-me authentication just by adding the <code>&lt;remember-me&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me key="myAppKey"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UserDetailsService</code> will normally be selected automatically.
If you have more than one in your application context, you need to specify which one should be used with the <code>user-service-ref</code> attribute, where the value is the name of your <code>UserDetailsService</code> bean.</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-persistent-token"><a class="anchor" href="#remember-me-persistent-token"></a>Persistent Token Approach</h3>
<div class="paragraph">
<p>This approach is based on the article <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> with some minor modifications  <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.
To use the this approach with namespace configuration, you would supply a datasource reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me data-source-ref="someDataSource"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The database should contain a <code>persistent_logins</code> table, created using the following SQL (or equivalent):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">create table persistent_logins (username varchar(64) not null,
								series varchar(64) primary key,
								token varchar(64) not null,
								last_used timestamp not null)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-impls"><a class="anchor" href="#remember-me-impls"></a>Remember-Me Interfaces and Implementations</h3>
<div class="paragraph">
<p>Remember-me is used with <code>UsernamePasswordAuthenticationFilter</code>, and is implemented via hooks in the <code>AbstractAuthenticationProcessingFilter</code> superclass.
It is also used within <code>BasicAuthenticationFilter</code>.
The hooks will invoke a concrete <code>RememberMeServices</code> at the appropriate times.
The interface looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response,
	Authentication successfulAuthentication);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the Javadoc for a fuller discussion on what the methods do, although note at this stage that <code>AbstractAuthenticationProcessingFilter</code> only calls the <code>loginFail()</code> and <code>loginSuccess()</code> methods.
The <code>autoLogin()</code> method is called by <code>RememberMeAuthenticationFilter</code> whenever the <code>SecurityContextHolder</code> does not contain an <code>Authentication</code>.
This interface therefore provides the underlying remember-me implementation with sufficient notification of authentication-related events, and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered.
This design allows any number of remember-me implementation strategies.
We&#8217;ve seen above that Spring Security provides two implementations.
We&#8217;ll look at these in turn.</p>
</div>
<div class="sect3">
<h4 id="_tokenbasedremembermeservices"><a class="anchor" href="#_tokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>This implementation supports the simpler approach described in <a href="#remember-me-hash-token">Simple Hash-Based Token Approach</a>.
<code>TokenBasedRememberMeServices</code> generates a <code>RememberMeAuthenticationToken</code>, which is processed by <code>RememberMeAuthenticationProvider</code>.
A <code>key</code> is shared between this authentication provider and the <code>TokenBasedRememberMeServices</code>.
In addition, <code>TokenBasedRememberMeServices</code> requires A UserDetailsService from which it can retrieve the username and password for signature comparison purposes, and generate the <code>RememberMeAuthenticationToken</code> to contain the correct <code>GrantedAuthority</code> s.
Some sort of logout command should be provided by the application that invalidates the cookie if the user requests this.
<code>TokenBasedRememberMeServices</code> also implements Spring Security&#8217;s <code>LogoutHandler</code> interface so can be used with <code>LogoutFilter</code> to have the cookie cleared automatically.</p>
</div>
<div class="paragraph">
<p>The beans required in an application context to enable remember-me services are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rememberMeFilter" class=
"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"&gt;
&lt;property name="rememberMeServices" ref="rememberMeServices"/&gt;
&lt;property name="authenticationManager" ref="theAuthenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeServices" class=
"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"&gt;
&lt;property name="userDetailsService" ref="myUserDetailsService"/&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeAuthenticationProvider" class=
"org.springframework.security.authentication.RememberMeAuthenticationProvider"&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to add your <code>RememberMeServices</code> implementation to your <code>UsernamePasswordAuthenticationFilter.setRememberMeServices()</code> property, include the <code>RememberMeAuthenticationProvider</code> in your <code>AuthenticationManager.setProviders()</code> list, and add <code>RememberMeAuthenticationFilter</code> into your <code>FilterChainProxy</code> (typically immediately after your <code>UsernamePasswordAuthenticationFilter</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_persistenttokenbasedremembermeservices"><a class="anchor" href="#_persistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>This class can be used in the same way as <code>TokenBasedRememberMeServices</code>, but it additionally needs to be configured with a <code>PersistentTokenRepository</code> to store the tokens.
There are two standard implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenRepositoryImpl</code> which is intended for testing only.</p>
</li>
<li>
<p><code>JdbcTokenRepositoryImpl</code> which stores the tokens in a database.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The database schema is described above in <a href="#remember-me-persistent-token">Persistent Token Approach</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-openid"><a class="anchor" href="#servlet-openid"></a>OpenID Support</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The OpenID 1.0 and 2.0 protocols have been deprecated and users are encouraged to migrate to OpenID Connect, which is supported by spring-security-oauth2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The namespace supports <a href="https://openid.net/">OpenID</a> login either instead of, or in addition to normal form-based login, with a simple change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;openid-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should then register yourself with an OpenID provider (such as myopenid.com), and add the user information to your in-memory <code>&lt;user-service&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user name="https://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to login using the <code>myopenid.com</code> site to authenticate.
It is also possible to select a specific <code>UserDetailsService</code> bean for use OpenID by setting the <code>user-service-ref</code> attribute on the <code>openid-login</code> element.
Note that we have omitted the password attribute from the above user configuration, since this set of user data is only being used to load the authorities for the user.
A random password will be generated internally, preventing you from accidentally using this user data as an authentication source elsewhere in your configuration.</p>
</div>
<div class="sect2">
<h3 id="_attribute_exchange"><a class="anchor" href="#_attribute_exchange"></a>Attribute Exchange</h3>
<div class="paragraph">
<p>Support for OpenID <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html">attribute exchange</a>.
As an example, the following configuration would attempt to retrieve the email and full name from the OpenID provider, for use by the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;openid-login&gt;
&lt;attribute-exchange&gt;
	&lt;openid-attribute name="email" type="https://axschema.org/contact/email" required="true"/&gt;
	&lt;openid-attribute name="name" type="https://axschema.org/namePerson"/&gt;
&lt;/attribute-exchange&gt;
&lt;/openid-login&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "type" of each OpenID attribute is a URI, determined by a particular schema, in this case <a href="https://axschema.org/">https://axschema.org/</a>.
If an attribute must be retrieved for successful authentication, the <code>required</code> attribute can be set.
The exact schema and attributes supported will depend on your OpenID provider.
The attribute values are returned as part of the authentication process and can be accessed afterwards using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenIDAuthenticationToken token =
	(OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can obtain the <code>OpenIDAuthenticationToken</code> from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>OpenIDAttribute</code> contains the attribute type and the retrieved value (or values in the case of multi-valued attributes).
You can supply multiple <code>attribute-exchange</code> elements, using an <code>identifier-matcher</code> attribute on each.
This contains a regular expression which will be matched against the OpenID identifier supplied by the user.
See the OpenID sample application in the codebase for an example configuration, providing different attribute lists for the Google, Yahoo and MyOpenID providers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anonymous"><a class="anchor" href="#anonymous"></a>Anonymous Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="anonymous-overview"><a class="anchor" href="#anonymous-overview"></a>Overview</h3>
<div class="paragraph">
<p>It&#8217;s generally considered good security practice to adopt a "deny-by-default" where you explicitly specify what is allowed and disallow everything else.
Defining what is accessible to unauthenticated users is a similar situation, particularly for web applications.
Many sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages).
In this case it is easiest to define access configuration attributes for these specific URLs rather than have for every secured resource.
Put differently, sometimes it is nice to say <code>ROLE_SOMETHING</code> is required by default and only allow certain exceptions to this rule, such as for login, logout and home pages of an application.
You could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users.</p>
</div>
<div class="paragraph">
<p>This is what we mean by anonymous authentication.
Note that there is no real conceptual difference between a user who is "anonymously authenticated" and an unauthenticated user.
Spring Security&#8217;s anonymous authentication just gives you a more convenient way to configure your access-control attributes.
Calls to servlet API calls such as <code>getCallerPrincipal</code>, for example, will still return null even though there is actually an anonymous authentication object in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>There are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the <code>SecurityContextHolder</code> to identify which principal was responsible for a given operation.
Classes can be authored more robustly if they know the <code>SecurityContextHolder</code> always contains an <code>Authentication</code> object, and never <code>null</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-config"><a class="anchor" href="#anonymous-config"></a>Configuration</h3>
<div class="paragraph">
<p>Anonymous authentication support is provided automatically when using the HTTP configuration Spring Security 3.0 and can be customized (or disabled) using the <code>&lt;anonymous&gt;</code> element.
You don&#8217;t need to configure the beans described here unless you are using traditional bean configuration.</p>
</div>
<div class="paragraph">
<p>Three classes that together provide the anonymous authentication feature.
<code>AnonymousAuthenticationToken</code> is an implementation of <code>Authentication</code>, and stores the <code>GrantedAuthority</code> s which apply to the anonymous principal.
There is a corresponding <code>AnonymousAuthenticationProvider</code>, which is chained into the <code>ProviderManager</code> so that <code>AnonymousAuthenticationToken</code> s are accepted.
Finally, there is an <code>AnonymousAuthenticationFilter</code>, which is chained after the normal authentication mechanisms and automatically adds an <code>AnonymousAuthenticationToken</code> to the <code>SecurityContextHolder</code> if there is no existing <code>Authentication</code> held there.
The definition of the filter and authentication provider appears as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="anonymousAuthFilter"
	class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
	class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>key</code> is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>.
The <code>userAttribute</code> is expressed in the form of <code>usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code>.
This is the same syntax as used after the equals sign for the <code>userMap</code> property of <code>InMemoryDaoImpl</code>.</p>
</div>
<div class="paragraph">
<p>As explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
&lt;property name="securityMetadata"&gt;
	&lt;security:filter-security-metadata-source&gt;
	&lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
	&lt;/security:filter-security-metadata-source&gt;" +
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-auth-trust-resolver"><a class="anchor" href="#anonymous-auth-trust-resolver"></a>AuthenticationTrustResolver</h3>
<div class="paragraph">
<p>Rounding out the anonymous authentication discussion is the <code>AuthenticationTrustResolver</code> interface, with its corresponding <code>AuthenticationTrustResolverImpl</code> implementation.
This interface provides an <code>isAnonymous(Authentication)</code> method, which allows interested classes to take into account this special type of authentication status.
The <code>ExceptionTranslationFilter</code> uses this interface in processing <code>AccessDeniedException</code> s.
If an <code>AccessDeniedException</code> is thrown, and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter will instead commence the <code>AuthenticationEntryPoint</code> so the principal can authenticate properly.
This is a necessary distinction, otherwise principals would always be deemed "authenticated" and never be given an opportunity to login via form, basic, digest or some other normal authentication mechanism.</p>
</div>
<div class="paragraph">
<p>You will often see the <code>ROLE_ANONYMOUS</code> attribute in the above interceptor configuration replaced with <code>IS_AUTHENTICATED_ANONYMOUSLY</code>, which is effectively the same thing when defining access controls.
This is an example of the use of the <code>AuthenticatedVoter</code> which we will see in the <a href="#authz-authenticated-voter">authorization chapter</a>.
It uses an <code>AuthenticationTrustResolver</code> to process this particular configuration attribute and grant access to anonymous users.
The <code>AuthenticatedVoter</code> approach is more powerful, since it allows you to differentiate between anonymous, remember-me and fully-authenticated users.
If you don&#8217;t need this functionality though, then you can stick with <code>ROLE_ANONYMOUS</code>, which will be processed by Spring Security&#8217;s standard <code>RoleVoter</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-preauth"><a class="anchor" href="#servlet-preauth"></a>Pre-Authentication Scenarios</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are situations where you want to use Spring Security for authorization, but the user has already been reliably authenticated by some external system prior to accessing the application.
We refer to these situations as "pre-authenticated" scenarios.
Examples include X.509, Siteminder and authentication by the Java EE container in which the application is running.
When using pre-authentication, Spring Security has to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the user making the request.</p>
</li>
<li>
<p>Obtain the authorities for the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The details will depend on the external authentication mechanism.
A user might be identified by their certificate information in the case of X.509, or by an HTTP request header in the case of Siteminder.
If relying on container authentication, the user will be identified by calling the <code>getUserPrincipal()</code> method on the incoming HTTP request.
In some cases, the external mechanism may supply role/authority information for the user but in others the authorities must be obtained from a separate source, such as a <code>UserDetailsService</code>.</p>
</div>
<div class="sect2">
<h3 id="_pre_authentication_framework_classes"><a class="anchor" href="#_pre_authentication_framework_classes"></a>Pre-Authentication Framework Classes</h3>
<div class="paragraph">
<p>Because most pre-authentication mechanisms follow the same pattern, Spring Security has a set of classes which provide an internal framework for implementing pre-authenticated authentication providers.
This removes duplication and allows new implementations to be added in a structured fashion, without having to write everything from scratch.
You don&#8217;t need to know about these classes if you want to use something like <a href="#servlet-x509">X.509 authentication</a>, as it already has a namespace configuration option which is simpler to use and get started with.
If you need to use explicit bean configuration or are planning on writing your own implementation then an understanding of how the provided implementations work will be useful.
You will find classes under the <code>org.springframework.security.web.authentication.preauth</code>.
We just provide an outline here so you should consult the Javadoc and source where appropriate.</p>
</div>
<div class="sect3">
<h4 id="_abstractpreauthenticatedprocessingfilter"><a class="anchor" href="#_abstractpreauthenticatedprocessingfilter"></a>AbstractPreAuthenticatedProcessingFilter</h4>
<div class="paragraph">
<p>This class will check the current contents of the security context and, if empty, it will attempt to extract user information from the HTTP request and submit it to the <code>AuthenticationManager</code>.
Subclasses override the following methods to obtain this information:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. Override AbstractPreAuthenticatedProcessingFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?

protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After calling these, the filter will create a <code>PreAuthenticatedAuthenticationToken</code> containing the returned data and submit it for authentication.
By "authentication" here, we really just mean further processing to perhaps load the user&#8217;s authorities, but the standard Spring Security authentication architecture is followed.</p>
</div>
<div class="paragraph">
<p>Like other Spring Security authentication filters, the pre-authentication filter has an <code>authenticationDetailsSource</code> property which by default will create a <code>WebAuthenticationDetails</code> object to store additional information such as the session-identifier and originating IP address in the <code>details</code> property of the <code>Authentication</code> object.
In cases where user role information can be obtained from the pre-authentication mechanism, the data is also stored in this property, with the details implementing the <code>GrantedAuthoritiesContainer</code> interface.
This enables the authentication provider to read the authorities which were externally allocated to the user.
We&#8217;ll look at a concrete example next.</p>
</div>
<div class="sect4">
<h5 id="j2ee-preauth-details"><a class="anchor" href="#j2ee-preauth-details"></a>J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</h5>
<div class="paragraph">
<p>If the filter is configured with an <code>authenticationDetailsSource</code> which is an instance of this class, the authority information is obtained by calling the <code>isUserInRole(String role)</code> method for each of a pre-determined set of "mappable roles".
The class gets these from a configured <code>MappableAttributesRetriever</code>.
Possible implementations include hard-coding a list in the application context and reading the role information from the <code>&lt;security-role&gt;</code> information in a <code>web.xml</code> file.
The pre-authentication sample application uses the latter approach.</p>
</div>
<div class="paragraph">
<p>There is an additional stage where the roles (or attributes) are mapped to Spring Security <code>GrantedAuthority</code> objects using a configured <code>Attributes2GrantedAuthoritiesMapper</code>.
The default will just add the usual <code>ROLE_</code> prefix to the names, but it gives you full control over the behaviour.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_preauthenticatedauthenticationprovider"><a class="anchor" href="#_preauthenticatedauthenticationprovider"></a>PreAuthenticatedAuthenticationProvider</h4>
<div class="paragraph">
<p>The pre-authenticated provider has little more to do than load the <code>UserDetails</code> object for the user.
It does this by delegating to an <code>AuthenticationUserDetailsService</code>.
The latter is similar to the standard <code>UserDetailsService</code> but takes an <code>Authentication</code> object rather than just user name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface AuthenticationUserDetailsService {
	UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface may have also other uses but with pre-authentication it allows access to the authorities which were packaged in the <code>Authentication</code> object, as we saw in the previous section.
The <code>PreAuthenticatedGrantedAuthoritiesUserDetailsService</code> class does this.
Alternatively, it may delegate to a standard <code>UserDetailsService</code> via the <code>UserDetailsByNameServiceWrapper</code> implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_http403forbiddenentrypoint"><a class="anchor" href="#_http403forbiddenentrypoint"></a>Http403ForbiddenEntryPoint</h4>
<div class="paragraph">
<p>The <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is responsible for kick-starting the authentication process for an unauthenticated user (when they try to access a protected resource), but in the pre-authenticated case this doesn&#8217;t apply.
You would only configure the <code>ExceptionTranslationFilter</code> with an instance of this class if you aren&#8217;t using pre-authentication in combination with other authentication mechanisms.
It will be called if the user is rejected by the <code>AbstractPreAuthenticatedProcessingFilter</code> resulting in a null authentication.
It always returns a <code>403</code>-forbidden response code if called.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_concrete_implementations"><a class="anchor" href="#_concrete_implementations"></a>Concrete Implementations</h3>
<div class="paragraph">
<p>X.509 authentication is covered in its <a href="#servlet-x509">own chapter</a>.
Here we&#8217;ll look at some classes which provide support for other pre-authenticated scenarios.</p>
</div>
<div class="sect3">
<h4 id="_request_header_authentication_siteminder"><a class="anchor" href="#_request_header_authentication_siteminder"></a>Request-Header Authentication (Siteminder)</h4>
<div class="paragraph">
<p>An external authentication system may supply information to the application by setting specific headers on the HTTP request.
A well-known example of this is Siteminder, which passes the username in a header called <code>SM_USER</code>.
This mechanism is supported by the class <code>RequestHeaderAuthenticationFilter</code> which simply extracts the username from the header.
It defaults to using the name <code>SM_USER</code> as the header name.
See the Javadoc for more details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that when using a system like this, the framework performs no authentication checks at all and it is <em>extremely</em> important that the external system is configured properly and protects all access to the application.
If an attacker is able to forge the headers in their original request without this being detected then they could potentially choose any username they wished.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_siteminder_example_configuration"><a class="anchor" href="#_siteminder_example_configuration"></a>Siteminder Example Configuration</h5>
<div class="paragraph">
<p>A typical configuration using this filter would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http&gt;
&lt;!-- Additional http configuration omitted --&gt;
&lt;security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter"&gt;
&lt;property name="principalRequestHeader" value="SM_USER"/&gt;
&lt;property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
&lt;property name="preAuthenticatedUserDetailsService"&gt;
	&lt;bean id="userDetailsServiceWrapper"
		class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;property name="userDetailsService" ref="userDetailsService"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
&lt;/security:authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve assumed here that the <a href="#ns-config">security namespace</a> is being used for configuration.
It&#8217;s also assumed that you have added a <code>UserDetailsService</code> (called "userDetailsService") to your configuration to load the user&#8217;s roles.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_java_ee_container_authentication"><a class="anchor" href="#_java_ee_container_authentication"></a>Java EE Container Authentication</h4>
<div class="paragraph">
<p>The class <code>J2eePreAuthenticatedProcessingFilter</code> will extract the username from the <code>userPrincipal</code> property of the <code>HttpServletRequest</code>.
Use of this filter would usually be combined with the use of Java EE roles as described above in <a href="#j2ee-preauth-details">J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</a>.</p>
</div>
<div class="paragraph">
<p>There is a sample application in the codebase which uses this approach, so get hold of the code from github and have a look at the application context file if you are interested.
The code is in the <code>samples/xml/preauth</code> directory.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-jaas"><a class="anchor" href="#servlet-jaas"></a>Java Authentication and Authorization Service (JAAS) Provider</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h3>
<div class="paragraph">
<p>Spring Security provides a package able to delegate authentication requests to the Java Authentication and Authorization Service (JAAS).
This package is discussed in detail below.</p>
</div>
</div>
<div class="sect2">
<h3 id="jaas-abstractjaasauthenticationprovider"><a class="anchor" href="#jaas-abstractjaasauthenticationprovider"></a>AbstractJaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>AbstractJaasAuthenticationProvider</code> is the basis for the provided JAAS <code>AuthenticationProvider</code> implementations.
Subclasses must implement a method that creates the <code>LoginContext</code>.
The <code>AbstractJaasAuthenticationProvider</code> has a number of dependencies that can be injected into it that are discussed below.</p>
</div>
<div class="sect3">
<h4 id="jaas-callbackhandler"><a class="anchor" href="#jaas-callbackhandler"></a>JAAS CallbackHandler</h4>
<div class="paragraph">
<p>Most JAAS <code>LoginModule</code> s require a callback of some sort.
These callbacks are usually used to obtain the username and password from the user.</p>
</div>
<div class="paragraph">
<p>In a Spring Security deployment, Spring Security is responsible for this user interaction (via the authentication mechanism).
Thus, by the time the authentication request is delegated through to JAAS, Spring Security&#8217;s authentication mechanism will already have fully-populated an <code>Authentication</code> object containing all the information required by the JAAS <code>LoginModule</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, the JAAS package for Spring Security provides two default callback handlers, <code>JaasNameCallbackHandler</code> and <code>JaasPasswordCallbackHandler</code>.
Each of these callback handlers implement <code>JaasAuthenticationCallbackHandler</code>.
In most cases these callback handlers can simply be used without understanding the internal mechanics.</p>
</div>
<div class="paragraph">
<p>For those needing full control over the callback behavior, internally <code>AbstractJaasAuthenticationProvider</code> wraps these <code>JaasAuthenticationCallbackHandler</code> s with an <code>InternalCallbackHandler</code>.
The <code>InternalCallbackHandler</code> is the class that actually implements JAAS normal <code>CallbackHandler</code> interface.
Any time that the JAAS <code>LoginModule</code> is used, it is passed a list of application context configured <code>InternalCallbackHandler</code> s.
If the <code>LoginModule</code> requests a callback against the <code>InternalCallbackHandler</code> s, the callback is in-turn passed to the <code>JaasAuthenticationCallbackHandler</code> s being wrapped.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-authoritygranter"><a class="anchor" href="#jaas-authoritygranter"></a>JAAS AuthorityGranter</h4>
<div class="paragraph">
<p>JAAS works with principals.
Even "roles" are represented as principals in JAAS.
Spring Security, on the other hand, works with <code>Authentication</code> objects.
Each <code>Authentication</code> object contains a single principal, and multiple <code>GrantedAuthority</code> s.
To facilitate mapping between these different concepts, Spring Security&#8217;s JAAS package includes an <code>AuthorityGranter</code> interface.</p>
</div>
<div class="paragraph">
<p>An <code>AuthorityGranter</code> is responsible for inspecting a JAAS principal and returning a set of <code>String</code> s, representing the authorities assigned to the principal.
For each returned authority string, the <code>AbstractJaasAuthenticationProvider</code> creates a <code>JaasGrantedAuthority</code> (which implements Spring Security&#8217;s <code>GrantedAuthority</code> interface) containing the authority string and the JAAS principal that the <code>AuthorityGranter</code> was passed.
The <code>AbstractJaasAuthenticationProvider</code> obtains the JAAS principals by firstly successfully authenticating the user&#8217;s credentials using the JAAS <code>LoginModule</code>, and then accessing the <code>LoginContext</code> it returns.
A call to <code>LoginContext.getSubject().getPrincipals()</code> is made, with each resulting principal passed to each <code>AuthorityGranter</code> defined against the <code>AbstractJaasAuthenticationProvider.setAuthorityGranters(List)</code> property.</p>
</div>
<div class="paragraph">
<p>Spring Security does not include any production <code>AuthorityGranter</code> s given that every JAAS principal has an implementation-specific meaning.
However, there is a <code>TestAuthorityGranter</code> in the unit tests that demonstrates a simple <code>AuthorityGranter</code> implementation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-defaultjaasauthenticationprovider"><a class="anchor" href="#jaas-defaultjaasauthenticationprovider"></a>DefaultJaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>DefaultJaasAuthenticationProvider</code> allows a JAAS <code>Configuration</code> object to be injected into it as a dependency.
It then creates a <code>LoginContext</code> using the injected JAAS <code>Configuration</code>.
This means that <code>DefaultJaasAuthenticationProvider</code> is not bound any particular implementation of <code>Configuration</code> as <code>JaasAuthenticationProvider</code> is.</p>
</div>
<div class="sect3">
<h4 id="jaas-inmemoryconfiguration"><a class="anchor" href="#jaas-inmemoryconfiguration"></a>InMemoryConfiguration</h4>
<div class="paragraph">
<p>In order to make it easy to inject a <code>Configuration</code> into <code>DefaultJaasAuthenticationProvider</code>, a default in-memory implementation named <code>InMemoryConfiguration</code> is provided.
The implementation constructor accepts a <code>Map</code> where each key represents a login configuration name and the value represents an <code>Array</code> of <code>AppConfigurationEntry</code> s.
<code>InMemoryConfiguration</code> also supports a default <code>Array</code> of <code>AppConfigurationEntry</code> objects that will be used if no mapping is found within the provided <code>Map</code>.
For details, refer to the class level javadoc of <code>InMemoryConfiguration</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-djap-config"><a class="anchor" href="#jaas-djap-config"></a>DefaultJaasAuthenticationProvider Example Configuration</h4>
<div class="paragraph">
<p>While the Spring configuration for <code>InMemoryConfiguration</code> can be more verbose than the standard JAAS configuration files, using it in conjunction with <code>DefaultJaasAuthenticationProvider</code> is more flexible than <code>JaasAuthenticationProvider</code> since it not dependant on the default <code>Configuration</code> implementation.</p>
</div>
<div class="paragraph">
<p>An example configuration of <code>DefaultJaasAuthenticationProvider</code> using <code>InMemoryConfiguration</code> is provided below.
Note that custom implementations of <code>Configuration</code> can easily be injected into <code>DefaultJaasAuthenticationProvider</code> as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthProvider"
class="org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider"&gt;
&lt;property name="configuration"&gt;
&lt;bean class="org.springframework.security.authentication.jaas.memory.InMemoryConfiguration"&gt;
&lt;constructor-arg&gt;
	&lt;map&gt;
	&lt;!--
	SPRINGSECURITY is the default loginContextName
	for AbstractJaasAuthenticationProvider
	--&gt;
	&lt;entry key="SPRINGSECURITY"&gt;
	&lt;array&gt;
	&lt;bean class="javax.security.auth.login.AppConfigurationEntry"&gt;
		&lt;constructor-arg value="sample.SampleLoginModule" /&gt;
		&lt;constructor-arg&gt;
		&lt;util:constant static-field=
			"javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED"/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg&gt;
		&lt;map&gt;&lt;/map&gt;
		&lt;/constructor-arg&gt;
		&lt;/bean&gt;
	&lt;/array&gt;
	&lt;/entry&gt;
	&lt;/map&gt;
	&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
&lt;list&gt;
	&lt;!-- You will need to write your own implementation of AuthorityGranter --&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-jaasauthenticationprovider"><a class="anchor" href="#jaas-jaasauthenticationprovider"></a>JaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>JaasAuthenticationProvider</code> assumes the default <code>Configuration</code> is an instance of <a href="https://download.oracle.com/javase/1.4.2/docs/guide/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html"> ConfigFile</a>.
This assumption is made in order to attempt to update the <code>Configuration</code>.
The <code>JaasAuthenticationProvider</code> then uses the default <code>Configuration</code> to create the <code>LoginContext</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a JAAS login configuration file, <code>/WEB-INF/login.conf</code>, with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">JAASTest {
	sample.SampleLoginModule required;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like all Spring Security beans, the <code>JaasAuthenticationProvider</code> is configured via the application context.
The following definitions would correspond to the above JAAS login configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthenticationProvider"
class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
&lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
&lt;property name="loginContextName" value="JAASTest"/&gt;
&lt;property name="callbackHandlers"&gt;
&lt;list&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
	&lt;list&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
	&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-apiprovision"><a class="anchor" href="#jaas-apiprovision"></a>Running as a Subject</h3>
<div class="paragraph">
<p>If configured, the <code>JaasApiIntegrationFilter</code> will attempt to run as the <code>Subject</code> on the <code>JaasAuthenticationToken</code>.
This means that the <code>Subject</code> can be accessed using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Subject subject = Subject.getSubject(AccessController.getContext());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This integration can easily be configured using the <a href="#nsa-http-jaas-api-provision">jaas-api-provision</a> attribute.
This feature is useful when integrating with legacy or external API&#8217;s that rely on the JAAS Subject being populated.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-cas"><a class="anchor" href="#servlet-cas"></a>CAS Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cas-overview"><a class="anchor" href="#cas-overview"></a>Overview</h3>
<div class="paragraph">
<p>JA-SIG produces an enterprise-wide single sign on system known as CAS.
Unlike other initiatives, JA-SIG&#8217;s Central Authentication Service is open source, widely used, simple to understand, platform independent, and supports proxy capabilities.
Spring Security fully supports CAS, and provides an easy migration path from single-application deployments of Spring Security through to multiple-application deployments secured by an enterprise-wide CAS server.</p>
</div>
<div class="paragraph">
<p>You can learn more about CAS at <a href="https://www.apereo.org" class="bare">https://www.apereo.org</a>.
You will also need to visit this site to download the CAS Server files.</p>
</div>
</div>
<div class="sect2">
<h3 id="cas-how-it-works"><a class="anchor" href="#cas-how-it-works"></a>How CAS Works</h3>
<div class="paragraph">
<p>Whilst the CAS web site contains documents that detail the architecture of CAS, we present the general overview again here within the context of Spring Security.
Spring Security 3.x supports CAS 3.
At the time of writing, the CAS server was at version 3.4.</p>
</div>
<div class="paragraph">
<p>Somewhere in your enterprise you will need to setup a CAS server.
The CAS server is simply a standard WAR file, so there isn&#8217;t anything difficult about setting up your server.
Inside the WAR file you will customise the login and other single sign on pages displayed to users.</p>
</div>
<div class="paragraph">
<p>When deploying a CAS 3.4 server, you will also need to specify an <code>AuthenticationHandler</code> in the <code>deployerConfigContext.xml</code> included with CAS.
The <code>AuthenticationHandler</code> has a simple method that returns a boolean as to whether a given set of Credentials is valid.
Your <code>AuthenticationHandler</code> implementation will need to link into some type of backend authentication repository, such as an LDAP server or database.
CAS itself includes numerous <code>AuthenticationHandler</code> s out of the box to assist with this.
When you download and deploy the server war file, it is set up to successfully authenticate users who enter a password matching their username, which is useful for testing.</p>
</div>
<div class="paragraph">
<p>Apart from the CAS server itself, the other key players are of course the secure web applications deployed throughout your enterprise.
These web applications are known as "services".
There are three types of services.
Those that authenticate service tickets, those that can obtain proxy tickets, and those that authenticate proxy tickets.
Authenticating a proxy ticket differs because the list of proxies must be validated and often times a proxy ticket can be reused.</p>
</div>
<div class="sect3">
<h4 id="cas-sequence"><a class="anchor" href="#cas-sequence"></a>Spring Security and CAS Interaction Sequence</h4>
<div class="paragraph">
<p>The basic interaction between a web browser, CAS server and a Spring Security-secured service is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The web user is browsing the service&#8217;s public pages.
CAS or Spring Security is not involved.</p>
</li>
<li>
<p>The user eventually requests a page that is either secure or one of the beans it uses is secure.
Spring Security&#8217;s <code>ExceptionTranslationFilter</code> will detect the <code>AccessDeniedException</code> or <code>AuthenticationException</code>.</p>
</li>
<li>
<p>Because the user&#8217;s <code>Authentication</code> object (or lack thereof) caused an <code>AuthenticationException</code>, the <code>ExceptionTranslationFilter</code> will call the configured <code>AuthenticationEntryPoint</code>.
If using CAS, this will be the <code>CasAuthenticationEntryPoint</code> class.</p>
</li>
<li>
<p>The <code>CasAuthenticationEntryPoint</code> will redirect the user&#8217;s browser to the CAS server.
It will also indicate a <code>service</code> parameter, which is the callback URL for the Spring Security service (your application).
For example, the URL to which the browser is redirected might be <a href="https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas" class="bare">https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas</a>.</p>
</li>
<li>
<p>After the user&#8217;s browser redirects to CAS, they will be prompted for their username and password.
If the user presents a session cookie which indicates they&#8217;ve previously logged on, they will not be prompted to login again (there is an exception to this procedure, which we&#8217;ll cover later).
CAS will use the <code>PasswordHandler</code> (or <code>AuthenticationHandler</code> if using CAS 3.0) discussed above to decide whether the username and password is valid.</p>
</li>
<li>
<p>Upon successful login, CAS will redirect the user&#8217;s browser back to the original service.
It will also include a <code>ticket</code> parameter, which is an opaque string representing the "service ticket".
Continuing our earlier example, the URL the browser is redirected to might be <a href="https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ" class="bare">https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ</a>.</p>
</li>
<li>
<p>Back in the service web application, the <code>CasAuthenticationFilter</code> is always listening for requests to <code>/login/cas</code> (this is configurable, but we&#8217;ll use the defaults in this introduction).
The processing filter will construct a <code>UsernamePasswordAuthenticationToken</code> representing the service ticket.
The principal will be equal to <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>, whilst the credentials will be the service ticket opaque value.
This authentication request will then be handed to the configured <code>AuthenticationManager</code>.</p>
</li>
<li>
<p>The <code>AuthenticationManager</code> implementation will be the <code>ProviderManager</code>, which is in turn configured with the <code>CasAuthenticationProvider</code>.
The <code>CasAuthenticationProvider</code> only responds to <code>UsernamePasswordAuthenticationToken</code> s containing the CAS-specific principal (such as <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>) and <code>CasAuthenticationToken</code> s (discussed later).</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will validate the service ticket using a <code>TicketValidator</code> implementation.
This will typically be a <code>Cas20ServiceTicketValidator</code> which is one of the classes included in the CAS client library.
In the event the application needs to validate proxy tickets, the <code>Cas20ProxyTicketValidator</code> is used.
The <code>TicketValidator</code> makes an HTTPS request to the CAS server in order to validate the service ticket.
It may also include a proxy callback URL, which is included in this example: <a href="https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor" class="bare">https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor</a>.</p>
</li>
<li>
<p>Back on the CAS server, the validation request will be received.
If the presented service ticket matches the service URL the ticket was issued to, CAS will provide an affirmative response in XML indicating the username.
If any proxy was involved in the authentication (discussed below), the list of proxies is also included in the XML response.</p>
</li>
<li>
<p>[OPTIONAL] If the request to the CAS validation service included the proxy callback URL (in the <code>pgtUrl</code> parameter), CAS will include a <code>pgtIou</code> string in the XML response.
This <code>pgtIou</code> represents a proxy-granting ticket IOU.
The CAS server will then create its own HTTPS connection back to the <code>pgtUrl</code>.
This is to mutually authenticate the CAS server and the claimed service URL.
The HTTPS connection will be used to send a proxy granting ticket to the original web application.
For example, <a href="https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH" class="bare">https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH</a>.</p>
</li>
<li>
<p>The <code>Cas20TicketValidator</code> will parse the XML received from the CAS server.
It will return to the <code>CasAuthenticationProvider</code> a <code>TicketResponse</code>, which includes the username (mandatory), proxy list (if any were involved), and proxy-granting ticket IOU (if the proxy callback was requested).</p>
</li>
<li>
<p>Next <code>CasAuthenticationProvider</code> will call a configured <code>CasProxyDecider</code>.
The <code>CasProxyDecider</code> indicates whether the proxy list in the <code>TicketResponse</code> is acceptable to the service.
Several implementations are provided with Spring Security: <code>RejectProxyTickets</code>, <code>AcceptAnyCasProxy</code> and <code>NamedCasProxyDecider</code>.
These names are largely self-explanatory, except <code>NamedCasProxyDecider</code> which allows a <code>List</code> of trusted proxies to be provided.</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will next request a <code>AuthenticationUserDetailsService</code> to load the <code>GrantedAuthority</code> objects that apply to the user contained in the <code>Assertion</code>.</p>
</li>
<li>
<p>If there were no problems, <code>CasAuthenticationProvider</code> constructs a <code>CasAuthenticationToken</code> including the details contained in the <code>TicketResponse</code> and the <code>GrantedAuthority</code>s.</p>
</li>
<li>
<p>Control then returns to <code>CasAuthenticationFilter</code>, which places the created <code>CasAuthenticationToken</code> in the security context.</p>
</li>
<li>
<p>The user&#8217;s browser is redirected to the original page that caused the <code>AuthenticationException</code> (or a custom destination depending on the configuration).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s good that you&#8217;re still here!
Let&#8217;s now look at how this is configured</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cas-client"><a class="anchor" href="#cas-client"></a>Configuration of CAS Client</h3>
<div class="paragraph">
<p>The web application side of CAS is made easy due to Spring Security.
It is assumed you already know the basics of using Spring Security, so these are not covered again below.
We&#8217;ll assume a namespace based configuration is being used and add in the CAS beans as required.
Each section builds upon the previous section.
A full CAS sample application can be found in the Spring Security <a href="#samples">Samples</a>.</p>
</div>
<div class="sect3">
<h4 id="cas-st"><a class="anchor" href="#cas-st"></a>Service Ticket Authentication</h4>
<div class="paragraph">
<p>This section describes how to setup Spring Security to authenticate Service Tickets.
Often times this is all a web application requires.
You will need to add a <code>ServiceProperties</code> bean to your application context.
This represents your CAS service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
&lt;property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/&gt;
&lt;property name="sendRenew" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>service</code> must equal a URL that will be monitored by the <code>CasAuthenticationFilter</code>.
The <code>sendRenew</code> defaults to false, but should be set to true if your application is particularly sensitive.
What this parameter does is tell the CAS login service that a single sign on login is unacceptable.
Instead, the user will need to re-enter their username and password in order to gain access to the service.</p>
</div>
<div class="paragraph">
<p>The following beans should be configured to commence the CAS authentication process (assuming you&#8217;re using a namespace configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:custom-filter position="CAS_FILTER" ref="casFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
&lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For CAS to operate, the <code>ExceptionTranslationFilter</code> must have its <code>authenticationEntryPoint</code> property set to the <code>CasAuthenticationEntryPoint</code> bean.
This can easily be done using <a href="#nsa-http-entry-point-ref">entry-point-ref</a> as is done in the example above.
The <code>CasAuthenticationEntryPoint</code> must refer to the <code>ServiceProperties</code> bean (discussed above), which provides the URL to the enterprise&#8217;s CAS login server.
This is where the user&#8217;s browser will be redirected.</p>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationFilter</code> has very similar properties to the <code>UsernamePasswordAuthenticationFilter</code> (used for form-based logins).
You can use these properties to customize things like behavior for authentication success and failure.</p>
</div>
<div class="paragraph">
<p>Next you need to add a <code>CasAuthenticationProvider</code> and its collaborators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
&lt;property name="authenticationUserDetailsService"&gt;
	&lt;bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;constructor-arg ref="userService" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="serviceProperties" ref="serviceProperties" /&gt;
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
	&lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
&lt;/bean&gt;

&lt;security:user-service id="userService"&gt;
&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used.
This is not safe for production, but makes reading
in samples easier.
Normally passwords should be hashed using BCrypt --&gt;
&lt;security:user name="joe" password="{noop}joe" authorities="ROLE_USER" /&gt;
...
&lt;/security:user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> uses a <code>UserDetailsService</code> instance to load the authorities for a user, once they have been authenticated by CAS.
We&#8217;ve shown a simple in-memory setup here.
Note that the <code>CasAuthenticationProvider</code> does not actually use the password for authentication, but it does use the authorities.</p>
</div>
<div class="paragraph">
<p>The beans are all reasonably self-explanatory if you refer back to the <a href="#cas-how-it-works">How CAS Works</a> section.</p>
</div>
<div class="paragraph">
<p>This completes the most basic configuration for CAS.
If you haven&#8217;t made any mistakes, your web application should happily work within the framework of CAS single sign on.
No other parts of Spring Security need to be concerned about the fact CAS handled authentication.
In the following sections we will discuss some (optional) more advanced configurations.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-singlelogout"><a class="anchor" href="#cas-singlelogout"></a>Single Logout</h4>
<div class="paragraph">
<p>The CAS protocol supports Single Logout and can be easily added to your Spring Security configuration.
Below are updates to the Spring Security configuration that handle Single Logout</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:logout logout-success-url="/cas-logout.jsp"/&gt;
&lt;security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt;
&lt;security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt;
&lt;/security:http&gt;

&lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt;
&lt;bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt;

&lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt;
&lt;bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt;
&lt;constructor-arg value="https://localhost:9443/cas/logout"/&gt;
&lt;constructor-arg&gt;
	&lt;bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt;
&lt;/constructor-arg&gt;
&lt;property name="filterProcessesUrl" value="/logout/cas"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>logout</code> element logs the user out of the local application, but does not end the session with the CAS server or any other applications that have been logged into.
The <code>requestSingleLogoutFilter</code> filter will allow the URL of <code>/spring_security_cas_logout</code> to be requested to redirect the application to the configured CAS Server logout URL.
Then the CAS Server will send a Single Logout request to all the services that were signed into.
The <code>singleLogoutFilter</code> handles the Single Logout request by looking up the <code>HttpSession</code> in a static <code>Map</code> and then invalidating it.</p>
</div>
<div class="paragraph">
<p>It might be confusing why both the <code>logout</code> element and the <code>singleLogoutFilter</code> are needed.
It is considered best practice to logout locally first since the <code>SingleSignOutFilter</code> just stores the <code>HttpSession</code> in a static <code>Map</code> in order to call invalidate on it.
With the configuration above, the flow of logout would be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user requests <code>/logout</code> which would log the user out of the local application and send the user to the logout success page.</p>
</li>
<li>
<p>The logout success page, <code>/cas-logout.jsp</code>, should instruct the user to click a link pointing to <code>/logout/cas</code> in order to logout out of all applications.</p>
</li>
<li>
<p>When the user clicks the link, the user is redirected to the CAS single logout URL (<a href="https://localhost:9443/cas/logout" class="bare">https://localhost:9443/cas/logout</a>).</p>
</li>
<li>
<p>On the CAS Server side, the CAS single logout URL then submits single logout requests to all the CAS Services.
On the CAS Service side, JASIG&#8217;s <code>SingleSignOutFilter</code> processes the logout request by invalidating the original session.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next step is to add the following to your web.xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.CharacterEncodingFilter
&lt;/filter-class&gt;
&lt;init-param&gt;
	&lt;param-name&gt;encoding&lt;/param-name&gt;
	&lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
&lt;listener-class&gt;
	org.jasig.cas.client.session.SingleSignOutHttpSessionListener
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the SingleSignOutFilter you might encounter some encoding issues.
Therefore it is recommended to add the <code>CharacterEncodingFilter</code> to ensure that the character encoding is correct when using the <code>SingleSignOutFilter</code>.
Again, refer to JASIG&#8217;s documentation for details.
The <code>SingleSignOutHttpSessionListener</code> ensures that when an <code>HttpSession</code> expires, the mapping used for single logout is removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt-client"><a class="anchor" href="#cas-pt-client"></a>Authenticating to a Stateless Service with CAS</h4>
<div class="paragraph">
<p>This section describes how to authenticate to a service using CAS.
In other words, this section discusses how to setup a client that uses a service that authenticates with CAS.
The next section describes how to setup a stateless service to Authenticate using CAS.</p>
</div>
<div class="sect4">
<h5 id="cas-pt-client-config"><a class="anchor" href="#cas-pt-client-config"></a>Configuring CAS to Obtain Proxy Granting Tickets</h5>
<div class="paragraph">
<p>In order to authenticate to a stateless service, the application needs to obtain a proxy granting ticket (PGT).
This section describes how to configure Spring Security to obtain a PGT building upon thencas-st[Service Ticket Authentication] configuration.</p>
</div>
<div class="paragraph">
<p>The first step is to include a <code>ProxyGrantingTicketStorage</code> in your Spring Security configuration.
This is used to store PGT&#8217;s that are obtained by the <code>CasAuthenticationFilter</code> so that they can be used to obtain proxy tickets.
An example configuration is shown below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!--
NOTE: In a real application you should not use an in memory implementation.
You will also want to ensure to clean up expired tickets by calling
ProxyGrantingTicketStorage.cleanup()
--&gt;
&lt;bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to update the <code>CasAuthenticationProvider</code> to be able to obtain proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
The <code>proxyCallbackUrl</code> should be set to a URL that the application will receive PGT&#8217;s at.
Last, the configuration should also reference the <code>ProxyGrantingTicketStorage</code> so it can use a PGT to obtain proxy tickets.
You can find an example of the configuration changes that should be made below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
		&lt;property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/&gt;
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last step is to update the <code>CasAuthenticationFilter</code> to accept PGT and to store them in the <code>ProxyGrantingTicketStorage</code>.
It is important the <code>proxyReceptorUrl</code> matches the <code>proxyCallbackUrl</code> of the <code>Cas20ProxyTicketValidator</code>.
An example configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
	...
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt-client-sample"><a class="anchor" href="#cas-pt-client-sample"></a>Calling a Stateless Service Using a Proxy Ticket</h5>
<div class="paragraph">
<p>Now that Spring Security obtains PGTs, you can use them to create proxy tickets which can be used to authenticate to a stateless service.
The CAS <a href="#samples">sample application</a> contains a working example in the <code>ProxyTicketSampleServlet</code>.
Example code can be found below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt"><a class="anchor" href="#cas-pt"></a>Proxy Ticket Authentication</h4>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> distinguishes between stateful and stateless clients.
A stateful client is considered any that submits to the <code>filterProcessUrl</code> of the <code>CasAuthenticationFilter</code>.
A stateless client is any that presents an authentication request to <code>CasAuthenticationFilter</code> on a URL other than the <code>filterProcessUrl</code>.</p>
</div>
<div class="paragraph">
<p>Because remoting protocols have no way of presenting themselves within the context of an <code>HttpSession</code>, it isn&#8217;t possible to rely on the default practice of storing the security context in the session between requests.
Furthermore, because the CAS server invalidates a ticket after it has been validated by the <code>TicketValidator</code>, presenting the same proxy ticket on subsequent requests will not work.</p>
</div>
<div class="paragraph">
<p>One obvious option is to not use CAS at all for remoting protocol clients.
However, this would eliminate many of the desirable features of CAS.
As a middle-ground, the <code>CasAuthenticationProvider</code> uses a <code>StatelessTicketCache</code>.
This is used solely for stateless clients which use a principal equal to <code>CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER</code>.
What happens is the <code>CasAuthenticationProvider</code> will store the resulting <code>CasAuthenticationToken</code> in the <code>StatelessTicketCache</code>, keyed on the proxy ticket.
Accordingly, remoting protocol clients can present the same proxy ticket and the <code>CasAuthenticationProvider</code> will not need to contact the CAS server for validation (aside from the first request).
Once authenticated, the proxy ticket could be used for URLs other than the original target service.</p>
</div>
<div class="paragraph">
<p>This section builds upon the previous sections to accommodate proxy ticket authentication.
The first step is to specify to authenticate all artifacts as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
...
&lt;property name="authenticateAllArtifacts" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to specify <code>serviceProperties</code> and the <code>authenticationDetailsSource</code> for the <code>CasAuthenticationFilter</code>.
The <code>serviceProperties</code> property instructs the <code>CasAuthenticationFilter</code> to attempt to authenticate all artifacts instead of only ones present on the <code>filterProcessUrl</code>.
The <code>ServiceAuthenticationDetailsSource</code> creates a <code>ServiceAuthenticationDetails</code> that ensures the current URL, based upon the <code>HttpServletRequest</code>, is used as the service URL when validating the ticket.
The method for generating the service URL can be customized by injecting a custom <code>AuthenticationDetailsSource</code> that returns a custom <code>ServiceAuthenticationDetails</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
...
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;property name="authenticationDetailsSource"&gt;
	&lt;bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"&gt;
	&lt;constructor-arg ref="serviceProperties"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also need to update the <code>CasAuthenticationProvider</code> to handle proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
You will need to configure the <code>statelessTicketCache</code> and which proxies you want to accept.
You can find an example of the updates required to accept all proxies below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
	&lt;property name="acceptAnyProxy" value="true"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="statelessTicketCache"&gt;
	&lt;bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache"&gt;
	&lt;property name="cache"&gt;
		&lt;bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose"&gt;
		&lt;constructor-arg value="casTickets"/&gt;
		&lt;constructor-arg value="50"/&gt;
		&lt;constructor-arg value="true"/&gt;
		&lt;constructor-arg value="false"/&gt;
		&lt;constructor-arg value="3600"/&gt;
		&lt;constructor-arg value="900"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-x509"><a class="anchor" href="#servlet-x509"></a>X.509 Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="x509-overview"><a class="anchor" href="#x509-overview"></a>Overview</h3>
<div class="paragraph">
<p>The most common use of X.509 certificate authentication is in verifying the identity of a server when using SSL, most commonly when using HTTPS from a browser.
The browser will automatically check that the certificate presented by a server has been issued (ie digitally signed) by one of a list of trusted certificate authorities which it maintains.</p>
</div>
<div class="paragraph">
<p>You can also use SSL with "mutual authentication"; the server will then request a valid certificate from the client as part of the SSL handshake.
The server will authenticate the client by checking that its certificate is signed by an acceptable authority.
If a valid certificate has been provided, it can be obtained through the servlet API in an application.
Spring Security X.509 module extracts the certificate using a filter.
It maps the certificate to an application user and loads that user&#8217;s set of granted authorities for use with the standard Spring Security infrastructure.</p>
</div>
<div class="paragraph">
<p>You should be familiar with using certificates and setting up client authentication for your servlet container before attempting to use it with Spring Security.
Most of the work is in creating and installing suitable certificates and keys.
For example, if you&#8217;re using Tomcat then read the instructions here <a href="https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html</a>.
It&#8217;s important that you get this working before trying it out with Spring Security</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_x_509_authentication_to_your_web_application"><a class="anchor" href="#_adding_x_509_authentication_to_your_web_application"></a>Adding X.509 Authentication to Your Web Application</h3>
<div class="paragraph">
<p>Enabling X.509 client authentication is very straightforward.
Just add the <code>&lt;x509/&gt;</code> element to your http security namespace configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
	&lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The element has two optional attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject-principal-regex</code>.
The regular expression used to extract a username from the certificate&#8217;s subject name.
The default value is shown above.
This is the username which will be passed to the <code>UserDetailsService</code> to load the authorities for the user.</p>
</li>
<li>
<p><code>user-service-ref</code>.
This is the bean Id of the <code>UserDetailsService</code> to be used with X.509.
It isn&#8217;t needed if there is only one defined in your application context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>subject-principal-regex</code> should contain a single group.
For example the default expression "CN=(.*?)," matches the common name field.
So if the subject name in the certificate is "CN=Jimi Hendrix, OU=&#8230;&#8203;", this will give a user name of "Jimi Hendrix".
The matches are case insensitive.
So "emailAddress=(.*?)," will match "EMAILADDRESS=<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>,CN=&#8230;&#8203;" giving a user name "<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>".
If the client presents a certificate and a valid username is successfully extracted, then there should be a valid <code>Authentication</code> object in the security context.
If no certificate is found, or no corresponding user could be found then the security context will remain empty.
This means that you can easily use X.509 authentication with other options such as a form-based login.</p>
</div>
</div>
<div class="sect2">
<h3 id="x509-ssl-config"><a class="anchor" href="#x509-ssl-config"></a>Setting up SSL in Tomcat</h3>
<div class="paragraph">
<p>There are some pre-generated certificates in the <code>samples/certificate</code> directory in the Spring Security project.
You can use these to enable SSL for testing if you don&#8217;t want to generate your own.
The file <code>server.jks</code> contains the server certificate, private key and the issuing certificate authority certificate.
There are also some client certificate files for the users from the sample applications.
You can install these in your browser to enable SSL client authentication.</p>
</div>
<div class="paragraph">
<p>To run tomcat with SSL support, drop the <code>server.jks</code> file into the tomcat <code>conf</code> directory and add the following connector to the <code>server.xml</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
			clientAuth="true" sslProtocol="TLS"
			keystoreFile="${catalina.home}/conf/server.jks"
			keystoreType="JKS" keystorePass="password"
			truststoreFile="${catalina.home}/conf/server.jks"
			truststoreType="JKS" truststorePass="password"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientAuth</code> can also be set to <code>want</code> if you still want SSL connections to succeed even if the client doesn&#8217;t provide a certificate.
Clients which don&#8217;t present a certificate won&#8217;t be able to access any objects secured by Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="runas"><a class="anchor" href="#runas"></a>Run-As Authentication Replacement</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="runas-overview"><a class="anchor" href="#runas-overview"></a>Overview</h3>
<div class="paragraph">
<p>The <code>AbstractSecurityInterceptor</code> is able to temporarily replace the <code>Authentication</code> object in the <code>SecurityContext</code> and <code>SecurityContextHolder</code> during the secure object callback phase.
This only occurs if the original <code>Authentication</code> object was successfully processed by the <code>AuthenticationManager</code> and <code>AccessDecisionManager</code>.
The <code>RunAsManager</code> will indicate the replacement <code>Authentication</code> object, if any, that should be used during the <code>SecurityInterceptorCallback</code>.</p>
</div>
<div class="paragraph">
<p>By temporarily replacing the <code>Authentication</code> object during the secure object callback phase, the secured invocation will be able to call other objects which require different authentication and authorization credentials.
It will also be able to perform any internal security checks for specific <code>GrantedAuthority</code> objects.
Because Spring Security provides a number of helper classes that automatically configure remoting protocols based on the contents of the <code>SecurityContextHolder</code>, these run-as replacements are particularly useful when calling remote web services</p>
</div>
</div>
<div class="sect2">
<h3 id="runas-config"><a class="anchor" href="#runas-config"></a>Configuration</h3>
<div class="paragraph">
<p>A <code>RunAsManager</code> interface is provided by Spring Security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication buildRunAs(Authentication authentication, Object object,
	List&lt;ConfigAttribute&gt; config);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first method returns the <code>Authentication</code> object that should replace the existing <code>Authentication</code> object for the duration of the method invocation.
If the method returns <code>null</code>, it indicates no replacement should be made.
The second method is used by the <code>AbstractSecurityInterceptor</code> as part of its startup validation of configuration attributes.
The <code>supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code>RunAsManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
<div class="paragraph">
<p>One concrete implementation of a <code>RunAsManager</code> is provided with Spring Security.
The <code>RunAsManagerImpl</code> class returns a replacement <code>RunAsUserToken</code> if any <code>ConfigAttribute</code> starts with <code>RUN_AS_</code>.
If any such <code>ConfigAttribute</code> is found, the replacement <code>RunAsUserToken</code> will contain the same principal, credentials and granted authorities as the original <code>Authentication</code> object, along with a new <code>SimpleGrantedAuthority</code> for each <code>RUN_AS_</code> <code>ConfigAttribute</code>.
Each new <code>SimpleGrantedAuthority</code> will be prefixed with <code>ROLE_</code>, followed by the <code>RUN_AS</code> <code>ConfigAttribute</code>.
For example, a <code>RUN_AS_SERVER</code> will result in the replacement <code>RunAsUserToken</code> containing a <code>ROLE_RUN_AS_SERVER</code> granted authority.</p>
</div>
<div class="paragraph">
<p>The replacement <code>RunAsUserToken</code> is just like any other <code>Authentication</code> object.
It needs to be authenticated by the <code>AuthenticationManager</code>, probably via delegation to a suitable <code>AuthenticationProvider</code>.
The <code>RunAsImplAuthenticationProvider</code> performs such authentication.
It simply accepts as valid any <code>RunAsUserToken</code> presented.</p>
</div>
<div class="paragraph">
<p>To ensure malicious code does not create a <code>RunAsUserToken</code> and present it for guaranteed acceptance by the <code>RunAsImplAuthenticationProvider</code>, the hash of a key is stored in all generated tokens.
The <code>RunAsManagerImpl</code> and <code>RunAsImplAuthenticationProvider</code> is created in the bean context with the same key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="runAsManager"
	class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
	class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the same key, each <code>RunAsUserToken</code> can be validated it was created by an approved <code>RunAsManagerImpl</code>.
The <code>RunAsUserToken</code> is immutable after creation for security reasons</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-logout"><a class="anchor" href="#jc-logout"></a>Handling Logouts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="logout-java-configuration"><a class="anchor" href="#logout-java-configuration"></a>Logout Java/Kotlin Configuration</h3>
<div class="paragraph">
<p>When using the <code>{security-api-url}org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html[WebSecurityConfigurerAdapter]</code>, logout capabilities are automatically applied.
The default is that accessing the URL <code>/logout</code> will log the user out by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invalidating the HTTP Session</p>
</li>
<li>
<p>Cleaning up any RememberMe authentication that was configured</p>
</li>
<li>
<p>Clearing the <code>SecurityContextHolder</code></p>
</li>
<li>
<p>Redirect to <code>/login?logout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar to configuring login capabilities, however, you also have various options to further customize your logout requirements:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. Logout Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        .logout(logout -&gt; logout                                                <i class="conum" data-value="1"></i><b>(1)</b>
            .logoutUrl("/my/logout")                                            <i class="conum" data-value="2"></i><b>(2)</b>
            .logoutSuccessUrl("/my/index")                                      <i class="conum" data-value="3"></i><b>(3)</b>
            .logoutSuccessHandler(logoutSuccessHandler)                         <i class="conum" data-value="4"></i><b>(4)</b>
            .invalidateHttpSession(true)                                        <i class="conum" data-value="5"></i><b>(5)</b>
            .addLogoutHandler(logoutHandler)                                    <i class="conum" data-value="6"></i><b>(6)</b>
            .deleteCookies(cookieNamesToClear)                                  <i class="conum" data-value="7"></i><b>(7)</b>
        )
        ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        logout {
            logoutUrl = "/my/logout"                              <i class="conum" data-value="1"></i><b>(1)</b>
            logoutSuccessUrl = "/my/index"                        <i class="conum" data-value="2"></i><b>(2)</b>
            logoutSuccessHandler = customLogoutSuccessHandler     <i class="conum" data-value="3"></i><b>(3)</b>
            invalidateHttpSession = true                          <i class="conum" data-value="4"></i><b>(4)</b>
            addLogoutHandler(logoutHandler)                       <i class="conum" data-value="5"></i><b>(5)</b>
            deleteCookies(cookieNamesToClear)                     <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Provides logout support.
This is automatically applied when using <code>WebSecurityConfigurerAdapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The URL that triggers log out to occur (default is <code>/logout</code>).
If CSRF protection is enabled (default), then the request must also be a POST.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The URL to redirect to after logout has occurred.
The default is <code>/login?logout</code>.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Let&#8217;s you specify a custom <code>LogoutSuccessHandler</code>.
If this is specified, <code>logoutSuccessUrl()</code> is ignored.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specify whether to invalidate the <code>HttpSession</code> at the time of logout.
This is <strong>true</strong> by default.
Configures the <code>SecurityContextLogoutHandler</code> under the covers.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Adds a <code>LogoutHandler</code>.
<code>SecurityContextLogoutHandler</code> is added as the last <code>LogoutHandler</code> by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Allows specifying the names of cookies to be removed on logout success.
This is a shortcut for adding a <code>CookieClearingLogoutHandler</code> explicitly.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Logouts can of course also be configured using the XML Namespace notation.
Please see the documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section for further details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Generally, in order to customize logout functionality, you can add
<code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]</code>
and/or
<code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[LogoutSuccessHandler]</code>
implementations.
For many common scenarios, these handlers are applied under the
covers when using the fluent API.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-logout"><a class="anchor" href="#ns-logout"></a>Logout XML Configuration</h3>
<div class="paragraph">
<p>The <code>logout</code> element adds support for logging out by navigating to a particular URL.
The default logout URL is <code>/logout</code>, but you can set it to something else using the <code>logout-url</code> attribute.
More information on other available attributes may be found in the namespace appendix.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-handler"><a class="anchor" href="#jc-logout-handler"></a>LogoutHandler</h3>
<div class="paragraph">
<p>Generally, <code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]</code>
implementations indicate classes that are able to participate in logout handling.
They are expected to be invoked to perform necessary clean-up.
As such they should
not throw exceptions.
Various implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html[PersistentTokenBasedRememberMeServices]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html[TokenBasedRememberMeServices]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html[CookieClearingLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/csrf/CsrfLogoutHandler.html[CsrfLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[SecurityContextLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/HeaderWriterLogoutHandler.html[HeaderWriterLogoutHandler]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please see <a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a> for details.</p>
</div>
<div class="paragraph">
<p>Instead of providing <code>LogoutHandler</code> implementations directly, the fluent API also provides shortcuts that provide the respective <code>LogoutHandler</code> implementations under the covers.
E.g. <code>deleteCookies()</code> allows specifying the names of one or more cookies to be removed on logout success.
This is a shortcut compared to adding a <code>CookieClearingLogoutHandler</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-success-handler"><a class="anchor" href="#jc-logout-success-handler"></a>LogoutSuccessHandler</h3>
<div class="paragraph">
<p>The <code>LogoutSuccessHandler</code> is called after a successful logout by the <code>LogoutFilter</code>, to handle e.g.
redirection or forwarding to the appropriate destination.
Note that the interface is almost the same as the <code>LogoutHandler</code> but may raise an exception.</p>
</div>
<div class="paragraph">
<p>The following implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html[SimpleUrlLogoutSuccessHandler]</p>
</li>
<li>
<p>HttpStatusReturningLogoutSuccessHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned above, you don&#8217;t need to specify the <code>SimpleUrlLogoutSuccessHandler</code> directly.
Instead, the fluent API provides a shortcut by setting the <code>logoutSuccessUrl()</code>.
This will setup the <code>SimpleUrlLogoutSuccessHandler</code> under the covers.
The provided URL will be redirected to after a logout has occurred.
The default is <code>/login?logout</code>.</p>
</div>
<div class="paragraph">
<p>The <code>HttpStatusReturningLogoutSuccessHandler</code> can be interesting in REST API type scenarios.
Instead of redirecting to a URL upon the successful logout, this <code>LogoutSuccessHandler</code> allows you to provide a plain HTTP status code to be returned.
If not configured a status code 200 will be returned by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-references"><a class="anchor" href="#jc-logout-references"></a>Further Logout-Related References</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#ns-logout">Logout Handling</a></p>
</li>
<li>
<p><a href="#test-logout">Testing Logout</a></p>
</li>
<li>
<p><a href="#servletapi-logout">HttpServletRequest.logout()</a></p>
</li>
<li>
<p><a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a></p>
</li>
<li>
<p><a href="#servlet-considerations-csrf-logout">Logging Out</a> in section CSRF Caveats</p>
</li>
<li>
<p>Section <a href="#cas-singlelogout">Single Logout</a> (CAS protocol)</p>
</li>
<li>
<p>Documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-events"><a class="anchor" href="#servlet-events"></a>Authentication Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For each authentication that succeeds or fails, a <code>AuthenticationSuccessEvent</code> or <code>AuthenticationFailureEvent</code> is fired, respectively.</p>
</div>
<div class="paragraph">
<p>To listen for these events, you must first publish an <code>AuthenticationEventPublisher</code>.
Spring Security&#8217;s <code>DefaultAuthenticationEventPublisher</code> will probably do fine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    return new DefaultAuthenticationEventPublisher(applicationEventPublisher);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    return DefaultAuthenticationEventPublisher(applicationEventPublisher)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, you can use Spring&#8217;s <code>@EventListener</code> support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class AuthenticationEvents {
	@EventListener
    public void onSuccess(AuthenticationSuccessEvent success) {
		// ...
    }

    @EventListener
    public void onFailure(AuthenticationFailureEvent failures) {
		// ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class AuthenticationEvents {
    @EventListener
    fun onSuccess(success: AuthenticationSuccessEvent?) {
        // ...
    }

    @EventListener
    fun onFailure(failures: AbstractAuthenticationFailureEvent?) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While similar to <code>AuthenticationSuccessHandler</code> and <code>AuthenticationFailureHandler</code>, these are nice in that they can be used independently from the servlet API.</p>
</div>
<div class="sect2">
<h3 id="_adding_exception_mappings"><a class="anchor" href="#_adding_exception_mappings"></a>Adding Exception Mappings</h3>
<div class="paragraph">
<p><code>DefaultAuthenticationEventPublisher</code> by default will publish an <code>AuthenticationFailureEvent</code> for the following events:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadCredentialsException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernameNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AccountExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ProviderNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureProviderNotFoundEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisabledException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureDisabledEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LockedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureLockedEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationServiceException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureServiceExceptionEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CredentialsExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureCredentialsExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidBearerTokenException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The publisher does an exact <code>Exception</code> match, which means that sub-classes of these exceptions won&#8217;t also produce events.</p>
</div>
<div class="paragraph">
<p>To that end, you may want to supply additional mappings to the publisher via the <code>setAdditionalExceptionMappings</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    Map&lt;Class&lt;? extends AuthenticationException&gt;,
        Class&lt;? extends AuthenticationFailureEvent&gt;&gt; mapping =
            Collections.singletonMap(FooException.class, FooEvent.class);
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val mapping: Map&lt;Class&lt;out AuthenticationException&gt;, Class&lt;out AbstractAuthenticationFailureEvent&gt;&gt; =
            mapOf(Pair(FooException::class.java, FooEvent::class.java))
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_default_event"><a class="anchor" href="#_default_event"></a>Default Event</h3>
<div class="paragraph">
<p>And, you can supply a catch-all event to fire in the case of any <code>AuthenticationException</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent
        (GenericAuthenticationFailureEvent.class);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent(GenericAuthenticationFailureEvent::class.java)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. It is also possible to obtain the server&#8217;s IP address using a DNS lookup. This is not currently supported, but hopefully will be in a future version.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Authentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by <code>SessionManagementFilter</code>, as the filter will not be invoked during the authenticating request. Session-management functionality has to be handled separately in these cases.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Essentially, the username is not included in the cookie, to prevent exposing a valid login name unecessarily. There is a discussion on this in the comments section of this article.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. The use of the <code>key</code> property should not be regarded as providing any real security here. It is merely a book-keeping exercise. If you are sharing a <code>ProviderManager</code> which contains an <code>AnonymousAuthenticationProvider</code> in a scenario where it is possible for an authenticating client to construct the <code>Authentication</code> object (such as with RMI invocations), then a malicious client could submit an <code>AnonymousAuthenticationToken</code> which it had created itself (with chosen username and authority list). If the <code>key</code> is guessable or can be found out, then the token would be accepted by the anonymous provider. This isn&#8217;t a problem with normal usage but if you are using RMI you would be best to use a customized <code>ProviderManager</code> which omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms.
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/vendor/tabs.js"></script>
  </body>
</html>
