<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Servlet Applications :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="5.6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../overview/prerequisites.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview/samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture/index.html">Servet Security: The Big Picture</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../6/overview/prerequisites.html">6</a>
        </li>
        <li class="version is-current">
          <a href="../overview/prerequisites.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../framework/5.3/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../overview/prerequisites.html">Spring Security</a></li>
    <li><a href="index.html">Servlet Applications</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">5.6</button>
  <div class="version-menu">
    <a class="version" href="../../6/servlet/index.html">6</a>
    <a class="version is-current" href="index.html">5.6</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-security/edit/antora-2.x/docs/modules/ROOT/pages/servlet/index.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Servlet Applications</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security integrates with the Servlet Container by using a standard Servlet <code>Filter</code>. This means it works with any application that runs in a Servlet Container. More concretely, you do not need to use Spring in your Servlet-based application to take advantage of Spring Security.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-hello"><a class="anchor" href="#servlet-hello"></a>Hello Spring Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers the minimum setup for how to use Spring Security with Spring Boot.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The completed application can be found at {gh-samples-url}/boot/helloworld[samples/boot/helloworld]
For your convenience, you can download a minimal Spring Boot + Spring Security application by <a href="https://start.spring.io/starter.zip?type=maven-project&amp;language=java&amp;packaging=jar&amp;jvmVersion=1.8&amp;groupId=example&amp;artifactId=hello-security&amp;name=hello-security&amp;description=Hello%20Security&amp;packageName=example.hello-security&amp;dependencies=web,security">clicking here</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="servlet-hello-dependencies"><a class="anchor" href="#servlet-hello-dependencies"></a>Updating Dependencies</h3>
<div class="paragraph">
<p>The only step you need to do is update the dependencies by using <a href="#getting-maven-boot">Maven</a> or <a href="#getting-gradle-boot">Gradle</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-hello-starting"><a class="anchor" href="#servlet-hello-starting"></a>Starting Hello Spring Security Boot</h3>
<div class="paragraph">
<p>You can now <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-running-with-the-maven-plugin">run the Spring Boot application</a> by using the Maven Plugin&#8217;s <code>run</code> goal.
The following example shows how to do so (and the beginning of the output from doing so):</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Running Spring Boot Application</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./mvn spring-boot:run
...
INFO 23689 --- [  restartedMain] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336

...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-hello-auto-configuration"><a class="anchor" href="#servlet-hello-auto-configuration"></a>Spring Boot Auto Configuration</h3>
<div class="paragraph">
<p>Spring Boot automatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Enables Spring Security&#8217;s default configuration, which creates a servlet <code>Filter</code> as a bean named <code>springSecurityFilterChain</code>.
This bean is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application.</p>
</li>
<li>
<p>Creates a <code>UserDetailsService</code> bean with a username of <code>user</code> and a randomly generated password that is logged to the console.</p>
</li>
<li>
<p>Registers the <code>Filter</code> with a bean named <code>springSecurityFilterChain</code> with the Servlet container for every request.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot is not configuring much, but it does a lot.
A summary of the features follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Require an authenticated user for any interaction with the application</p>
</li>
<li>
<p>Generate a default login form for you</p>
</li>
<li>
<p>Let the user with a username of <code>user</code> and a password that is logged to the console to authenticate with form-based authentication (in the preceding example, the password is <code>8e557245-73e2-4286-969a-ff57fe326336</code>)</p>
</li>
<li>
<p>Protects the password storage with BCrypt</p>
</li>
<li>
<p>Lets the user log out</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF attack</a> prevention</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session Fixation</a> protection</p>
</li>
<li>
<p>Security Header integration</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a> for secure requests</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> integration</p>
</li>
<li>
<p>Cache Control (can be overridden later by your application to allow caching of your static resources)</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> integration</p>
</li>
<li>
<p>X-Frame-Options integration to help prevent <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Integrate with the following Servlet API methods:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()"><code>HttpServletRequest#getRemoteUser()</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()"><code>HttpServletRequest.html#getUserPrincipal()</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)"><code>HttpServletRequest.html#isUserInRole(java.lang.String)</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)"><code>HttpServletRequest.html#login(java.lang.String, java.lang.String)</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()"><code>HttpServletRequest.html#logout()</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-architecture"><a class="anchor" href="#servlet-architecture"></a>Servlet Security: The Big Picture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses Spring Security&#8217;s high level architecture within Servlet based applications.
We build on this high level understanding within <a href="#servlet-authentication">Authentication</a>, <a href="#servlet-authorization">Authorization</a>, <a href="#servlet-exploits">Protection Against Exploits</a> sections of the reference.</p>
</div>
<div class="sect2">
<h3 id="servlet-filters-review"><a class="anchor" href="#servlet-filters-review"></a>A Review of <code>Filter</code>s</h3>
<div class="paragraph">
<p>Spring Security&#8217;s Servlet support is based on Servlet <code>Filter</code>s, so it is helpful to look at the role of <code>Filter</code>s generally first.
The picture below shows the typical layering of the handlers for a single HTTP request.</p>
</div>
<div id="servlet-filterchain-figure" class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/filterchain.png" alt="filterchain">
</div>
<div class="title">Figure 1. FilterChain</div>
</div>
<div class="paragraph">
<p>The client sends a request to the application, and the container creates a <code>FilterChain</code> which contains the <code>Filter</code>s and <code>Servlet</code> that should process the <code>HttpServletRequest</code> based on the path of the request URI.
In a Spring MVC application the <code>Servlet</code> is an instance of <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet"><code>DispatcherServlet</code></a>.
At most one <code>Servlet</code> can handle a single <code>HttpServletRequest</code> and <code>HttpServletResponse</code>.
However, more than one <code>Filter</code> can be used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Prevent downstream <code>Filter</code>s or the <code>Servlet</code> from being invoked.
In this instance the <code>Filter</code> will typically write the <code>HttpServletResponse</code>.</p>
</li>
<li>
<p>Modify the <code>HttpServletRequest</code> or <code>HttpServletResponse</code> used by the downstream <code>Filter</code>s and <code>Servlet</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The power of the <code>Filter</code> comes from the <code>FilterChain</code> that is passed into it.</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. <code>FilterChain</code> Usage Example</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
	// do something before the rest of the application
    chain.doFilter(request, response); // invoke the rest of the application
    // do something after the rest of the application
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
    // do something before the rest of the application
    chain.doFilter(request, response) // invoke the rest of the application
    // do something after the rest of the application
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since a <code>Filter</code> only impacts downstream <code>Filter</code>s and the <code>Servlet</code>, the order each <code>Filter</code> is invoked is extremely important.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-delegatingfilterproxy"><a class="anchor" href="#servlet-delegatingfilterproxy"></a>DelegatingFilterProxy</h3>
<div class="paragraph">
<p>Spring provides a <code>Filter</code> implementation named {security-api-url}org/springframework/web/filter/DelegatingFilterProxy.html/[<code>DelegatingFilterProxy</code>] that allows bridging between the Servlet container&#8217;s lifecycle and Spring&#8217;s <code>ApplicationContext</code>.
The Servlet container allows registering <code>Filter</code>s using its own standards, but it is not aware of Spring defined Beans.
<code>DelegatingFilterProxy</code> can be registered via standard Servlet container mechanisms, but delegate all the work to a Spring Bean that implements <code>Filter</code>.</p>
</div>
<div class="paragraph">
<p>Here is a picture of how <code>DelegatingFilterProxy</code> fits into the <a href="#servlet-filters-review"><code>Filter</code>s and the <code>FilterChain</code></a>.</p>
</div>
<div id="servlet-delegatingfilterproxy-figure" class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/delegatingfilterproxy.png" alt="delegatingfilterproxy">
</div>
<div class="title">Figure 2. DelegatingFilterProxy</div>
</div>
<div class="paragraph">
<p><code>DelegatingFilterProxy</code> looks up <em>Bean Filter<sub>0</sub></em> from the <code>ApplicationContext</code> and then invokes <em>Bean Filter<sub>0</sub></em>.
The pseudo code of <code>DelegatingFilterProxy</code> can be seen below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. <code>DelegatingFilterProxy</code> Pseudo Code</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
	// Lazily get Filter that was registered as a Spring Bean
	// For the example in <a href="#servlet-delegatingfilterproxy-figure">DelegatingFilterProxy</a> <code>delegate</code> is an instance of <em>Bean Filter<sub>0</sub></em>
	Filter delegate = getFilterBean(someBeanName);
	// delegate work to the Spring Bean
	delegate.doFilter(request, response);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
	// Lazily get Filter that was registered as a Spring Bean
	// For the example in <a href="#servlet-delegatingfilterproxy-figure">DelegatingFilterProxy</a> <code>delegate</code> is an instance of <em>Bean Filter<sub>0</sub></em>
	val delegate: Filter = getFilterBean(someBeanName)
	// delegate work to the Spring Bean
	delegate.doFilter(request, response)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another benefit of <code>DelegatingFilterProxy</code> is that it allows delaying looking <code>Filter</code> bean instances.
This is important because the container needs to register the <code>Filter</code> instances before the container can startup.
However, Spring typically uses a <code>ContextLoaderListener</code> to load the Spring Beans which will not be done until after the <code>Filter</code> instances need to be registered.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-filterchainproxy"><a class="anchor" href="#servlet-filterchainproxy"></a>FilterChainProxy</h3>
<div class="paragraph">
<p>Spring Security&#8217;s Servlet support is contained within <code>FilterChainProxy</code>.
<code>FilterChainProxy</code> is a special <code>Filter</code> provided by Spring Security that allows delegating to many <code>Filter</code> instances through <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a>.
Since <code>FilterChainProxy</code> is a Bean, it is typically wrapped in a <a href="#servlet-delegatingfilterproxy">DelegatingFilterProxy</a>.</p>
</div>
<div id="servlet-filterchainproxy-figure" class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/filterchainproxy.png" alt="filterchainproxy">
</div>
<div class="title">Figure 3. FilterChainProxy</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-securityfilterchain"><a class="anchor" href="#servlet-securityfilterchain"></a>SecurityFilterChain</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/web/SecurityFilterChain.html[<code>SecurityFilterChain</code>] is used by <a href="#servlet-filterchainproxy">FilterChainProxy</a> to determine which Spring Security <code>Filter</code>s should be invoked for this request.</p>
</div>
<div id="servlet-securityfilterchain-figure" class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/securityfilterchain.png" alt="securityfilterchain">
</div>
<div class="title">Figure 4. SecurityFilterChain</div>
</div>
<div class="paragraph">
<p>The <a href="#servlet-security-filters">Security Filters</a> in <code>SecurityFilterChain</code> are typically Beans, but they are registered with <code>FilterChainProxy</code> instead of <a href="#servlet-delegatingfilterproxy">DelegatingFilterProxy</a>.
<code>FilterChainProxy</code> provides a number of advantages to registering directly with the Servlet container or <a href="#servlet-delegatingfilterproxy">DelegatingFilterProxy</a>.
First, it provides a starting point for all of Spring Security&#8217;s Servlet support.
For that reason, if you are attempting to troubleshoot Spring Security&#8217;s Servlet support, adding a debug point in <code>FilterChainProxy</code> is a great place to start.</p>
</div>
<div class="paragraph">
<p>Second, since <code>FilterChainProxy</code> is central to Spring Security usage it can perform tasks that are not viewed as optional.
For example, it clears out the <code>SecurityContext</code> to avoid memory leaks.
It also applies Spring Security&#8217;s <a href="#servlet-httpfirewall"><code>HttpFirewall</code></a> to protect applications against certain types of attacks.</p>
</div>
<div class="paragraph">
<p>In addition, it provides more flexibility in determining when a <code>SecurityFilterChain</code> should be invoked.
In a Servlet container, <code>Filter</code>s are invoked based upon the URL alone.
However, <code>FilterChainProxy</code> can determine invocation based upon anything in the <code>HttpServletRequest</code> by leveraging the <code>RequestMatcher</code> interface.</p>
</div>
<div class="paragraph">
<p>In fact, <code>FilterChainProxy</code> can be used to determine which <code>SecurityFilterChain</code> should be used.
This allows providing a totally separate configuration for different <em>slices</em> of your application.</p>
</div>
<div id="servlet-multi-securityfilterchain-figure" class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/multi-securityfilterchain.png" alt="multi securityfilterchain">
</div>
<div class="title">Figure 5. Multiple SecurityFilterChain</div>
</div>
<div class="paragraph">
<p>In the <a href="#servlet-multi-securityfilterchain-figure">Multiple SecurityFilterChain</a> Figure <code>FilterChainProxy</code> decides which <code>SecurityFilterChain</code> should be used.
Only the first <code>SecurityFilterChain</code> that matches will be invoked.
If a URL of <code>/api/messages/</code> is requested, it will first match on <code>SecurityFilterChain<sub>0</sub></code>'s pattern of <code>/api/**</code>, so only <code>SecurityFilterChain<sub>0</sub></code> will be invoked even though it also matches on <code>SecurityFilterChain<sub>n</sub></code>.
If a URL of <code>/messages/</code> is requested, it will not match on <code>SecurityFilterChain<sub>0</sub></code>'s pattern of <code>/api/**</code>, so <code>FilterChainProxy</code> will continue trying each <code>SecurityFilterChain</code>.
Assuming that no other, <code>SecurityFilterChain</code> instances match <code>SecurityFilterChain<sub>n</sub></code> will be invoked.</p>
</div>
<div class="paragraph">
<p>Notice that <code>SecurityFilterChain<sub>0</sub></code> has only three security <code>Filter</code>s instances configured.
However, <code>SecurityFilterChain<sub>n</sub></code> has four security <code>Filter</code>s configured.
It is important to note that each <code>SecurityFilterChain</code> can be unique and configured in isolation.
In fact, a <code>SecurityFilterChain</code> might have zero security <code>Filter</code>s if the application wants Spring Security to ignore certain requests.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-security-filters"><a class="anchor" href="#servlet-security-filters"></a>Security Filters</h3>
<div class="paragraph">
<p>The Security Filters are inserted into the <a href="#servlet-filterchainproxy">FilterChainProxy</a> with the <a href="#servlet-securityfilterchain">SecurityFilterChain</a> API.
The <a href="#servlet-filters-review">order of <code>Filter</code></a>s matters.
It is typically not necessary to know the ordering of Spring Security&#8217;s <code>Filter</code>s.
However, there are times that it is beneficial to know the ordering</p>
</div>
<div class="paragraph">
<p>Below is a comprehensive list of Spring Security Filter ordering:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ChannelProcessingFilter</p>
</li>
<li>
<p>WebAsyncManagerIntegrationFilter</p>
</li>
<li>
<p>SecurityContextPersistenceFilter</p>
</li>
<li>
<p>HeaderWriterFilter</p>
</li>
<li>
<p>CorsFilter</p>
</li>
<li>
<p>CsrfFilter</p>
</li>
<li>
<p>LogoutFilter</p>
</li>
<li>
<p>OAuth2AuthorizationRequestRedirectFilter</p>
</li>
<li>
<p>Saml2WebSsoAuthenticationRequestFilter</p>
</li>
<li>
<p>X509AuthenticationFilter</p>
</li>
<li>
<p>AbstractPreAuthenticatedProcessingFilter</p>
</li>
<li>
<p>CasAuthenticationFilter</p>
</li>
<li>
<p>OAuth2LoginAuthenticationFilter</p>
</li>
<li>
<p>Saml2WebSsoAuthenticationFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a></p>
</li>
<li>
<p>OpenIDAuthenticationFilter</p>
</li>
<li>
<p>DefaultLoginPageGeneratingFilter</p>
</li>
<li>
<p>DefaultLogoutPageGeneratingFilter</p>
</li>
<li>
<p>ConcurrentSessionFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-digest"><code>DigestAuthenticationFilter</code></a></p>
</li>
<li>
<p>BearerTokenAuthenticationFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-basic"><code>BasicAuthenticationFilter</code></a></p>
</li>
<li>
<p>RequestCacheAwareFilter</p>
</li>
<li>
<p>SecurityContextHolderAwareRequestFilter</p>
</li>
<li>
<p>JaasApiIntegrationFilter</p>
</li>
<li>
<p>RememberMeAuthenticationFilter</p>
</li>
<li>
<p>AnonymousAuthenticationFilter</p>
</li>
<li>
<p>OAuth2AuthorizationCodeGrantFilter</p>
</li>
<li>
<p>SessionManagementFilter</p>
</li>
<li>
<p><a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a></p>
</li>
<li>
<p><a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a></p>
</li>
<li>
<p>SwitchUserFilter</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-exceptiontranslationfilter"><a class="anchor" href="#servlet-exceptiontranslationfilter"></a>Handling Security Exceptions</h3>
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/web/access/ExceptionTranslationFilter.html[<code>ExceptionTranslationFilter</code>] allows translation of {security-api-url}org/springframework/security/access/AccessDeniedException.html[<code>AccessDeniedException</code>] and {security-api-url}/org/springframework/security/core/AuthenticationException.html[<code>AuthenticationException</code>] into HTTP responses.</p>
</div>
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code> is inserted into the <a href="#servlet-filterchainproxy">FilterChainProxy</a> as one of the <a href="#servlet-security-filters">Security Filters</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/servlet/architecture/exceptiontranslationfilter.png" alt="exceptiontranslationfilter">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="../_images/icons/number_1.png" alt="number 1"></span> First, the <code>ExceptionTranslationFilter</code> invokes <code>FilterChain.doFilter(request, response)</code> to invoke the rest of the application.</p>
</li>
<li>
<p><span class="image"><img src="../_images/icons/number_2.png" alt="number 2"></span> If the user is not authenticated or it is an <code>AuthenticationException</code>, then <em>Start Authentication</em>.</p>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out</p>
</li>
<li>
<p>The <code>HttpServletRequest</code> is saved in the {security-api-url}org/springframework/security/web/savedrequest/RequestCache.html[<code>RequestCache</code>].
When the user successfully authenticates, the <code>RequestCache</code> is used to replay the original request.</p>
</li>
<li>
<p>The <code>AuthenticationEntryPoint</code> is used to request credentials from the client.
For example, it might redirect to a log in page or send a <code>WWW-Authenticate</code> header.</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="image"><img src="../_images/icons/number_3.png" alt="number 3"></span> Otherwise if it is an <code>AccessDeniedException</code>, then <em>Access Denied</em>.
The <code>AccessDeniedHandler</code> is invoked to handle access denied.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the application does not throw an <code>AccessDeniedException</code> or an <code>AuthenticationException</code>, then <code>ExceptionTranslationFilter</code> does not do anything.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The pseudocode for <code>ExceptionTranslationFilter</code> looks something like this:</p>
</div>
<div class="listingblock">
<div class="title">ExceptionTranslationFilter pseudocode</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
	filterChain.doFilter(request, response); <i class="conum" data-value="1"></i><b>(1)</b>
} catch (AccessDeniedException | AuthenticationException ex) {
	if (!authenticated || ex instanceof AuthenticationException) {
		startAuthentication(); <i class="conum" data-value="2"></i><b>(2)</b>
	} else {
		accessDenied(); <i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You will recall from <a href="#servlet-filters-review">A Review of <code>Filter</code>s</a> that invoking <code>FilterChain.doFilter(request, response)</code> is the equivalent of invoking the rest of the application.
This means that if another part of the application, (i.e. <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> or method security) throws an <code>AuthenticationException</code> or <code>AccessDeniedException</code> it will be caught and handled here.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the user is not authenticated or it is an <code>AuthenticationException</code>, then <em>Start Authentication</em>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Otherwise, <em>Access Denied</em></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication"><a class="anchor" href="#servlet-authentication"></a>Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides comprehensive support for <a href="#authentication">[authentication]</a>.
This section discusses:</p>
</div>
<div id="servlet-authentication-architecture" class="paragraph">
<p><strong>Architecture Components</strong></p>
</div>
<div class="paragraph">
<p>This section describes the main architectural components of Spring Security&#8217;s used in Servlet authentication.
If you need concrete flows that explain how these pieces fit together, look at the <a href="#servlet-authentication-mechanisms">Authentication Mechanism</a> specific sections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> - The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-securitycontext">SecurityContext</a> - is obtained from the <code>SecurityContextHolder</code> and contains the <code>Authentication</code> of the currently authenticated user.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication</a> - Can be the input to <code>AuthenticationManager</code> to provide the credentials a user has provided to authenticate or the current user from the <code>SecurityContext</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-granted-authority">GrantedAuthority</a> - An authority that is granted to the principal on the <code>Authentication</code> (i.e. roles, scopes, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationmanager">AuthenticationManager</a> -  the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-providermanager">ProviderManager</a> -  the most common implementation of <code>AuthenticationManager</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> - used by <code>ProviderManager</code> to perform a specific type of authentication.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationentrypoint">Request Credentials with <code>AuthenticationEntryPoint</code></a> - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a <code>WWW-Authenticate</code> response, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a> - a base <code>Filter</code> used for authentication.
This also gives a good idea of the high level flow of authentication and how pieces work together.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-mechanisms" class="paragraph">
<p><strong>Authentication Mechanisms</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-unpwd">Username and Password</a> - how to authenticate with a username/password</p>
</li>
<li>
<p><a href="#oauth2login">OAuth 2.0 Login</a> - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)</p>
</li>
<li>
<p><a href="#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 Log In</p>
</li>
<li>
<p><a href="#servlet-cas">Central Authentication Server (CAS)</a> - Central Authentication Server (CAS) Support</p>
</li>
<li>
<p><a href="#servlet-rememberme">Remember Me</a> - How to remember a user past session expiration</p>
</li>
<li>
<p><a href="#servlet-jaas">JAAS Authentication</a> - Authenticate with JAAS</p>
</li>
<li>
<p><a href="#servlet-openid">OpenID</a> - OpenID Authentication (not to be confused with OpenID Connect)</p>
</li>
<li>
<p><a href="#servlet-preauth">Pre-Authentication Scenarios</a> - Authenticate with an external mechanism such as <a href="https://www.siteminder.com/">SiteMinder</a> or Java EE security but still use Spring Security for authorization and protection against common exploits.</p>
</li>
<li>
<p><a href="#servlet-x509">X509 Authentication</a> - X509 Authentication</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="servlet-authentication-securitycontextholder"><a class="anchor" href="#servlet-authentication-securitycontextholder"></a>SecurityContextHolder</h3>
<div class="paragraph">
<p>At the heart of Spring Security&#8217;s authentication model is the <code>SecurityContextHolder</code>.
It contains the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/securitycontextholder.png" alt="securitycontextholder">
</div>
</div>
<div class="paragraph">
<p>The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.
Spring Security does not care how the <code>SecurityContextHolder</code> is populated.
If it contains a value, then it is used as the currently authenticated user.</p>
</div>
<div class="paragraph">
<p>The simplest way to indicate a user is authenticated is to set the <code>SecurityContextHolder</code> directly.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Setting <code>SecurityContextHolder</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext(); <i class="conum" data-value="1"></i><b>(1)</b>
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); <i class="conum" data-value="2"></i><b>(2)</b>
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context: SecurityContext = SecurityContextHolder.createEmptyContext() <i class="conum" data-value="1"></i><b>(1)</b>
val authentication: Authentication = TestingAuthenticationToken("username", "password", "ROLE_USER") <i class="conum" data-value="2"></i><b>(2)</b>
context.authentication = authentication

SecurityContextHolder.setContext(context) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start by creating an empty <code>SecurityContext</code>.
It is important to create a new <code>SecurityContext</code> instance instead of using <code>SecurityContextHolder.getContext().setAuthentication(authentication)</code> to avoid race conditions across multiple threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next we create a new <a href="#servlet-authentication-authentication"><code>Authentication</code></a> object.
Spring Security does not care what type of <code>Authentication</code> implementation is set on the <code>SecurityContext</code>.
Here we use <code>TestingAuthenticationToken</code> because it is very simple.
A more common production scenario is <code>UsernamePasswordAuthenticationToken(userDetails, password, authorities)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, we set the <code>SecurityContext</code> on the <code>SecurityContextHolder</code>.
Spring Security will use this information for <a href="#servlet-authorization">authorization</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to obtain information about the authenticated principal, you can do so by accessing the <code>SecurityContextHolder</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Access Currently Authenticated User</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context = SecurityContextHolder.getContext()
val authentication = context.authentication
val username = authentication.name
val principal = authentication.principal
val authorities = authentication.authorities</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContextHolder</code> uses a <code>ThreadLocal</code> to store these details, which means that the <code>SecurityContext</code> is always available to methods in the same thread, even if the <code>SecurityContext</code> is not explicitly passed around as an argument to those methods.
Using a <code>ThreadLocal</code> in this way is quite safe if care is taken to clear the thread after the present principal&#8217;s request is processed.
Spring Security&#8217;s <a href="#servlet-filterchainproxy">FilterChainProxy</a> ensures that the <code>SecurityContext</code> is always cleared.</p>
</div>
<div class="paragraph">
<p>Some applications aren&#8217;t entirely suitable for using a <code>ThreadLocal</code>, because of the specific way they work with threads.
For example, a Swing client might want all threads in a Java Virtual Machine to use the same security context.
<code>SecurityContextHolder</code> can be configured with a strategy on startup to specify how you would like the context to be stored.
For a standalone application you would use the <code>SecurityContextHolder.MODE_GLOBAL</code> strategy.
Other applications might want to have threads spawned by the secure thread also assume the same security identity.
This is achieved by using <code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>.
You can change the mode from the default <code>SecurityContextHolder.MODE_THREADLOCAL</code> in two ways.
The first is to set a system property, the second is to call a static method on <code>SecurityContextHolder</code>.
Most applications won&#8217;t need to change from the default, but if you do, take a look at the JavaDoc for <code>SecurityContextHolder</code> to learn more.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-securitycontext"><a class="anchor" href="#servlet-authentication-securitycontext"></a>SecurityContext</h3>
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/core/context/SecurityContext.html[<code>SecurityContext</code>] is obtained from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>SecurityContext</code> contains an <a href="#servlet-authentication-authentication">Authentication</a> object.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authentication"><a class="anchor" href="#servlet-authentication-authentication"></a>Authentication</h3>
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/core/Authentication.html[<code>Authentication</code>] serves two main purposes within Spring Security:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An input to <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to provide the credentials a user has provided to authenticate.
When used in this scenario, <code>isAuthenticated()</code> returns <code>false</code>.</p>
</li>
<li>
<p>Represents the currently authenticated user.
The current <code>Authentication</code> can be obtained from the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Authentication</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principal</code> - identifies the user.
When authenticating with a username/password this is often an instance of <a href="#servlet-authentication-userdetails"><code>UserDetails</code></a>.</p>
</li>
<li>
<p><code>credentials</code> - Often a password.
In many cases this will be cleared after the user is authenticated to ensure it is not leaked.</p>
</li>
<li>
<p><code>authorities</code> - the <a href="#servlet-authentication-granted-authority"><code>GrantedAuthority</code>s</a> are high level permissions the user is granted.
A few examples are roles or scopes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-granted-authority"><a class="anchor" href="#servlet-authentication-granted-authority"></a>GrantedAuthority</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/GrantedAuthority.html[<code>GrantedAuthority</code>s] are high level permissions the user is granted. A few examples are roles or scopes.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code>s can be obtained from the <a href="#servlet-authentication-authentication"><code>Authentication.getAuthorities()</code></a> method.
This method provides a <code>Collection</code> of <code>GrantedAuthority</code> objects.
A <code>GrantedAuthority</code> is, not surprisingly, an authority that is granted to the principal.
Such authorities are usually "roles", such as <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>.
These roles are later on configured for web authorization, method authorization and domain object authorization.
Other parts of Spring Security are capable of interpreting these authorities, and expect them to be present.
When using username/password based authentication <code>GrantedAuthority</code>s are usually loaded by the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>.</p>
</div>
<div class="paragraph">
<p>Usually the <code>GrantedAuthority</code> objects are application-wide permissions.
They are not specific to a given domain object.
Thus, you wouldn&#8217;t likely have a <code>GrantedAuthority</code> to represent a permission to <code>Employee</code> object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user).
Of course, Spring Security is expressly designed to handle this common requirement, but you&#8217;d instead use the project&#8217;s domain object security capabilities for this purpose.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationmanager"><a class="anchor" href="#servlet-authentication-authenticationmanager"></a>AuthenticationManager</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/AuthenticationManager.html[<code>AuthenticationManager</code>] is the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.
The <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is then set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> by the controller (i.e. <a href="#servlet-security-filters">Spring Security&#8217;s <code>Filters</code>s</a>) that invoked the <code>AuthenticationManager</code>.
If you are not integrating with <em>Spring Security&#8217;s <code>Filters</code>s</em> you can set the <code>SecurityContextHolder</code> directly and are not required to use an <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>While the implementation of <code>AuthenticationManager</code> could be anything, the most common implementation is <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-providermanager"><a class="anchor" href="#servlet-authentication-providermanager"></a>ProviderManager</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/ProviderManager.html[<code>ProviderManager</code>] is the most commonly used implementation of <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>.
<code>ProviderManager</code> delegates to a <code>List</code> of <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code>s</a>.
Each <code>AuthenticationProvider</code> has an opportunity to indicate that authentication should be successful, fail, or indicate it cannot make a decision and allow a downstream <code>AuthenticationProvider</code> to decide.
If none of the configured <code>AuthenticationProvider</code>s can authenticate, then authentication will fail with a <code>ProviderNotFoundException</code> which is a special <code>AuthenticationException</code> that indicates the <code>ProviderManager</code> was not configured to support the type of <code>Authentication</code> that was passed into it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanager.png" alt="providermanager">
</div>
</div>
<div class="paragraph">
<p>In practice each <code>AuthenticationProvider</code> knows how to perform a specific type of authentication.
 For example, one <code>AuthenticationProvider</code> might be able to validate a username/password, while another might be able to authenticate a SAML assertion.
This allows each <code>AuthenticationProvider</code> to do a very specific type of authentication, while supporting multiple types of authentication and only exposing a single <code>AuthenticationManager</code> bean.</p>
</div>
<div class="paragraph">
<p><code>ProviderManager</code> also allows configuring an optional parent <code>AuthenticationManager</code> which is consulted in the event that no <code>AuthenticationProvider</code> can perform authentication.
The parent can be any type of <code>AuthenticationManager</code>, but it is often an instance of <code>ProviderManager</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanager-parent.png" alt="providermanager parent">
</div>
</div>
<div class="paragraph">
<p>In fact, multiple <code>ProviderManager</code> instances might share the same parent <code>AuthenticationManager</code>.
This is somewhat common in scenarios where there are multiple <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> instances that have some authentication in common (the shared parent <code>AuthenticationManager</code>), but also different authentication mechanisms (the different <code>ProviderManager</code> instances).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/providermanagers-parent.png" alt="providermanagers parent">
</div>
</div>
<div id="servlet-authentication-providermanager-erasing-credentials" class="paragraph">
<p>By default <code>ProviderManager</code> will attempt to clear any sensitive credentials information from the <code>Authentication</code> object which is returned by a successful authentication request.
This prevents information like passwords being retained longer than necessary in the <code>HttpSession</code>.</p>
</div>
<div class="paragraph">
<p>This may cause issues when you are using a cache of user objects, for example, to improve performance in a stateless application.
If the <code>Authentication</code> contains a reference to an object in the cache (such as a <code>UserDetails</code> instance) and this has its credentials removed, then it will no longer be possible to authenticate against the cached value.
You need to take this into account if you are using a cache.
An obvious solution is to make a copy of the object first, either in the cache implementation or in the <code>AuthenticationProvider</code> which creates the returned <code>Authentication</code> object.
Alternatively, you can disable the <code>eraseCredentialsAfterAuthentication</code> property on <code>ProviderManager</code>.
See the {security-api-url}org/springframework/security/authentication/ProviderManager.html[Javadoc] for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationprovider"><a class="anchor" href="#servlet-authentication-authenticationprovider"></a>AuthenticationProvider</h3>
<div class="paragraph">
<p>Multiple {security-api-url}org/springframework/security/authentication/AuthenticationProvider.html[<code>AuthenticationProvider</code>s] can be injected into <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.
Each <code>AuthenticationProvider</code> performs a specific type of authentication.
For example, <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> supports username/password based authentication while <code>JwtAuthenticationProvider</code> supports authenticating a JWT token.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationentrypoint"><a class="anchor" href="#servlet-authentication-authenticationentrypoint"></a>Request Credentials with <code>AuthenticationEntryPoint</code></h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/web/AuthenticationEntryPoint.html[<code>AuthenticationEntryPoint</code>] is used to send an HTTP response that requests credentials from a client.</p>
</div>
<div class="paragraph">
<p>Sometimes a client will proactively include credentials such as a username/password to request a resource.
In these cases, Spring Security does not need to provide an HTTP response that requests credentials from the client since they are already included.</p>
</div>
<div class="paragraph">
<p>In other cases, a client will make an unauthenticated request to a resource that they are not authorized to access.
In this case, an implementation of <code>AuthenticationEntryPoint</code> is used to request credentials from the client.
The <code>AuthenticationEntryPoint</code> implementation might perform a <a href="#servlet-authentication-form">redirect to a log in page</a>, respond with an <a href="#servlet-authentication-basic">WWW-Authenticate</a> header, etc.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-abstractprocessingfilter"><a class="anchor" href="#servlet-authentication-abstractprocessingfilter"></a>AbstractAuthenticationProcessingFilter</h3>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html[<code>AbstractAuthenticationProcessingFilter</code>] is used as a base <code>Filter</code> for authenticating a user&#8217;s credentials.
Before the credentials can be authenticated, Spring Security typically requests the credentials using <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>.</p>
</div>
<div class="paragraph">
<p>Next, the <code>AbstractAuthenticationProcessingFilter</code> can authenticate any authentication requests that are submitted to it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter">
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their credentials, the <code>AbstractAuthenticationProcessingFilter</code> creates an <a href="#servlet-authentication-authentication"><code>Authentication</code></a> from the <code>HttpServletRequest</code> to be authenticated.
The type of <code>Authentication</code> created depends on the subclass of <code>AbstractAuthenticationProcessingFilter</code>.
For example, <a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a> creates a <code>UsernamePasswordAuthenticationToken</code> from a <em>username</em> and <em>password</em> that are submitted in the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> is passed into the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to be authenticated.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionAuthenticationStrategy</code> is notified of a new log in.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
Later the <code>SecurityContextPersistenceFilter</code> saves the <code>SecurityContext</code> to the <code>HttpSession</code>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> publishes an <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p><code>AuthenticationSuccessHandler</code> is invoked.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-unpwd"><a class="anchor" href="#servlet-authentication-unpwd"></a>Username/Password Authentication</h3>
<div class="paragraph">
<p>One of the most common ways to authenticate a user is by validating a username and password.
As such, Spring Security provides comprehensive support for authenticating with a username and password.</p>
</div>
<div id="servlet-authentication-unpwd-input" class="paragraph">
<p><strong>Reading the Username &amp; Password</strong></p>
</div>
<div class="paragraph">
<p>Spring Security provides the following built in mechanisms for reading a username and password from the <code>HttpServletRequest</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-form">Form Login</a></p>
</li>
<li>
<p><a href="#servlet-authentication-basic">Basic Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-digest">Digest Authentication</a></p>
</li>
</ul>
</div>
<div id="servlet-authentication-unpwd-storage" class="paragraph">
<p><strong>Storage Mechanisms</strong></p>
</div>
<div class="paragraph">
<p>Each of the supported mechanisms for reading a username and password can leverage any of the supported storage mechanisms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple Storage with <a href="#servlet-authentication-inmemory">In-Memory Authentication</a></p>
</li>
<li>
<p>Relational Databases with <a href="#servlet-authentication-jdbc">JDBC Authentication</a></p>
</li>
<li>
<p>Custom data stores with <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a></p>
</li>
<li>
<p>LDAP storage with <a href="#servlet-authentication-ldap">LDAP Authentication</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-authentication-form"><a class="anchor" href="#servlet-authentication-form"></a>Form Login</h4>
<div class="paragraph">
<p>Spring Security provides support for username and password being provided through an html form.
This section provides details on how form based authentication works within Spring Security.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how form based log in works within Spring Security.
First, we see how the user is redirected to the log in form.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/loginurlauthenticationentrypoint.png" alt="loginurlauthenticationentrypoint">
</div>
<div class="title">Figure 6. Redirecting to the Log In Page</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em> and sends a redirect to the log in page with the configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>.
In most cases the <code>AuthenticationEntryPoint</code> is an instance of {security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[<code>LoginUrlAuthenticationEntryPoint</code>].</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> The browser will then request the log in page that it was redirected to.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> Something within the application, must <a href="#servlet-authentication-form-custom">render the log in page</a>.</p>
</div>
<div id="servlet-authentication-usernamepasswordauthenticationfilter" class="paragraph">
<p>When the username and password are submitted, the <code>UsernamePasswordAuthenticationFilter</code> authenticates the username and password.
The <code>UsernamePasswordAuthenticationFilter</code> extends <a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a>, so this diagram should look pretty similar.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/usernamepasswordauthenticationfilter.png" alt="usernamepasswordauthenticationfilter">
</div>
<div class="title">Figure 7. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their username and password, the <code>UsernamePasswordAuthenticationFilter</code> creates a <code>UsernamePasswordAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the username and password from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>UsernamePasswordAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> look like depend on how the <a href="#servlet-authentication-unpwd-storage">user information is stored</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionAuthenticationStrategy</code> is notified of a new log in.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> publishes an <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p>The <code>AuthenticationSuccessHandler</code> is invoked. Typically this is a <code>SimpleUrlAuthenticationSuccessHandler</code> which will redirect to a request saved by <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> when we redirect to the log in page.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-form-min" class="paragraph">
<p>Spring Security form log in is enabled by default.
However, as soon as any servlet based configuration is provided, form based log in must be explicitly provided.
A minimal, explicit Java configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Form Log In</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
	http
		// ...
		.formLogin(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;form-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin { }
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration Spring Security will render a default log in page.
Most production applications will require a custom log in form.</p>
</div>
<div id="servlet-authentication-form-custom" class="paragraph">
<p>The configuration below demonstrates how to provide a custom log in form.</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Custom Log In Form Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.formLogin(form -&gt; form
			.loginPage("/login")
			.permitAll()
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;intercept-url pattern="/login" access="permitAll" /&gt;
	&lt;form-login login-page="/login" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin {
			loginPage = "/login"
			permitAll()
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div id="servlet-authentication-form-custom-html" class="paragraph">
<p>When the login page is specified in the Spring Security configuration, you are responsible for rendering the page.
Below is a <a href="https://www.thymeleaf.org/">Thymeleaf</a> template that produces an HTML login form that complies with a login page of <code>/login</code>.:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Log In Form</div>
<div class="content">
<div class="listingblock">
<div class="title">src/main/resources/templates/login.html</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org"&gt;
	&lt;head&gt;
		&lt;title&gt;Please Log In&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Please Log In&lt;/h1&gt;
		&lt;div th:if="${param.error}"&gt;
			Invalid username and password.&lt;/div&gt;
		&lt;div th:if="${param.logout}"&gt;
			You have been logged out.&lt;/div&gt;
		&lt;form th:action="@{/login}" method="post"&gt;
			&lt;div&gt;
			&lt;input type="text" name="username" placeholder="Username"/&gt;
			&lt;/div&gt;
			&lt;div&gt;
			&lt;input type="password" name="password" placeholder="Password"/&gt;
			&lt;/div&gt;
			&lt;input type="submit" value="Log in" /&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are a few key points about the default HTML form:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The form should perform a <code>post</code> to <code>/login</code></p>
</li>
<li>
<p>The form will need to include a <a href="#servlet-csrf">CSRF Token</a> which is <a href="#servlet-csrf-include-form-auto">automatically included</a> by Thymeleaf.</p>
</li>
<li>
<p>The form should specify the username in a parameter named <code>username</code></p>
</li>
<li>
<p>The form should specify the password in a parameter named <code>password</code></p>
</li>
<li>
<p>If the HTTP parameter error is found, it indicates the user failed to provide a valid username / password</p>
</li>
<li>
<p>If the HTTP parameter logout is found, it indicates the user has logged out successfully</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many users will not need much more than to customize the log in page.
However, if needed everything above can be customized with additional configuration.</p>
</div>
<div id="servlet-authentication-form-custom-controller" class="paragraph">
<p>If you are using Spring MVC, you will need a controller that maps <code>GET /login</code> to the login template we created.
A minimal sample <code>LoginController</code> can be see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. LoginController</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
class LoginController {
	@GetMapping("/login")
	String login() {
		return "login";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class LoginController {
    @GetMapping("/login")
    fun login(): String {
        return "login"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-basic"><a class="anchor" href="#servlet-authentication-basic"></a>Basic Authentication</h4>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for <a href="https://tools.ietf.org/html/rfc7617">Basic HTTP Authentication</a> for servlet based applications.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how HTTP Basic Authentication works within Spring Security.
First, we see the <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a> header is sent back to an unauthenticated client.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/basicauthenticationentrypoint.png" alt="basicauthenticationentrypoint">
</div>
<div class="title">Figure 8. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/web/authentication/www/BasicAuthenticationEntryPoint.html[<code>BasicAuthenticationEntryPoint</code>] which sends a WWW-Authenticate header.
The <code>RequestCache</code> is typically a <code>NullRequestCache</code> that does not save the request since the client is capable of replaying the requests it originally requested.</p>
</div>
<div class="paragraph">
<p>When a client receives the WWW-Authenticate header it knows it should retry with a username and password.
Below is the flow for the username and password being processed.</p>
</div>
<div id="servlet-authentication-basicauthenticationfilter" class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/basicauthenticationfilter.png" alt="basicauthenticationfilter">
</div>
<div class="title">Figure 9. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their username and password, the <code>BasicAuthenticationFilter</code> creates a <code>UsernamePasswordAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the username and password from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>UsernamePasswordAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> look like depend on how the <a href="#servlet-authentication-unpwd-storage">user information is stored</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationEntryPoint</code> is invoked to trigger the WWW-Authenticate to be sent again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p>The <code>BasicAuthenticationFilter</code> invokes <code>FilterChain.doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s HTTP Basic Authentication support in is enabled by default.
However, as soon as any servlet based configuration is provided, HTTP Basic must be explicitly provided.</p>
</div>
<div class="paragraph">
<p>A minimal, explicit configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Explicit HTTP Basic Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
	http
		// ...
		.httpBasic(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
	http {
		// ...
		httpBasic { }
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-digest"><a class="anchor" href="#servlet-authentication-digest"></a>Digest Authentication</h4>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for <a href="https://tools.ietf.org/html/rfc2617">Digest Authentication</a> which is provided <code>DigestAuthenticationFilter</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You should not use Digest Authentication in modern applications because it is not considered secure.
The most obvious problem is that you must store your passwords in plaintext, encrypted, or an MD5 format.
All of these storage formats are considered insecure.
Instead, you should store credentials using a one way adaptive password hash (i.e. bCrypt, PBKDF2, SCrypt, etc) which is not supported by Digest Authentication.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Digest Authentication attempts to solve many of the weaknesses of <a href="#servlet-authentication-basic">Basic authentication</a>, specifically by ensuring credentials are never sent in clear text across the wire.
Many <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest#Browser_compatibility">browsers support Digest Authentication</a>.</p>
</div>
<div class="paragraph">
<p>The standard governing HTTP Digest Authentication is defined by <a href="https://tools.ietf.org/html/rfc2617">RFC 2617</a>, which updates an earlier version of the Digest Authentication standard prescribed by <a href="https://tools.ietf.org/html/rfc2069">RFC 2069</a>.
Most user agents implement RFC 2617.
Spring Security&#8217;s Digest Authentication support is compatible with the &#8220;auth&#8221; quality of protection (<code>qop</code>) prescribed by RFC 2617, which also provides backward compatibility with RFC 2069.
Digest Authentication was seen as a more attractive option if you need to use unencrypted HTTP (i.e. no TLS/HTTPS) and wish to maximise security of the authentication process.
However, everyone should use <a href="#http">HTTPS</a>.</p>
</div>
<div class="paragraph">
<p>Central to Digest Authentication is a "nonce".
This is a value the server generates.
Spring Security&#8217;s nonce adopts the following format:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Digest Syntax</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You will need to ensure you <a href="#authentication-password-storage-configuration">configure</a> insecure plain text <a href="#authentication-password-storage">Password Storage</a> using NoOpPasswordEncoder`.
The following provides an example of configuring Digest Authentication with Java Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Digest Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
UserDetailsService userDetailsService;

DigestAuthenticationEntryPoint entryPoint() {
	DigestAuthenticationEntryPoint result = new DigestAuthenticationEntryPoint();
	result.setRealmName("My App Relam");
	result.setKey("3028472b-da34-4501-bfd8-a355c42bdf92");
}

DigestAuthenticationFilter digestAuthenticationFilter() {
	DigestAuthenticationFilter result = new DigestAuthenticationFilter();
	result.setUserDetailsService(userDetailsService);
	result.setAuthenticationEntryPoint(entryPoint());
}

protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.exceptionHandling(e -&gt; e.authenticationEntryPoint(authenticationEntryPoint()))
		.addFilterBefore(digestFilter());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean id="digestFilter"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationFilter"
    p:userDetailsService-ref="jdbcDaoImpl"
    p:authenticationEntryPoint-ref="digestEntryPoint"
/&gt;

&lt;b:bean id="digestEntryPoint"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"
    p:realmName="My App Realm"
	p:key="3028472b-da34-4501-bfd8-a355c42bdf92"
/&gt;

&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;custom-filter ref="userFilter" position="DIGEST_AUTH_FILTER"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-inmemory"><a class="anchor" href="#servlet-authentication-inmemory"></a>In-Memory Authentication</h4>
<div class="paragraph">
<p>Spring Security&#8217;s <code>InMemoryUserDetailsManager</code> implements <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> to provide support for username/password based authentication that is retrieved in memory.
<code>InMemoryUserDetailsManager</code> provides management of <code>UserDetails</code> by implementing the <code>UserDetailsManager</code> interface.
<code>UserDetails</code> based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.</p>
</div>
<div class="paragraph">
<p>In this sample we use <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a> to encode the password of <code>password</code> and get the encoded password of <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. InMemoryUserDetailsManager Java Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UserDetailsService users() {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user-service&gt;
	&lt;user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    val user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build()
    val admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The samples above store the passwords in a secure format, but leave a lot to be desired in terms of getting started experience.</p>
</div>
<div class="paragraph">
<p>In the sample below we leverage <a href="#authentication-password-storage-dep-getting-started">User.withDefaultPasswordEncoder</a> to ensure that the password stored in memory is protected.
However, it does not protect against obtaining the password by decompiling the source code.
For this reason, <code>User.withDefaultPasswordEncoder</code> should only be used for "getting started" and is not intended for production.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. InMemoryUserDetailsManager with User.withDefaultPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UserDetailsService users() {
	// The builder will ensure the passwords are encoded before saving in memory
	UserBuilder users = User.withDefaultPasswordEncoder();
	UserDetails user = users
		.username("user")
		.password("password")
		.roles("USER")
		.build();
	UserDetails admin = users
		.username("admin")
		.password("password")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    // The builder will ensure the passwords are encoded before saving in memory
    val users = User.withDefaultPasswordEncoder()
    val user = users
        .username("user")
        .password("password")
        .roles("USER")
        .build()
    val admin = users
        .username("admin")
        .password("password")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There is no simple way to use <code>User.withDefaultPasswordEncoder</code> with XML based configuration.
For demos or just getting started, you can choose to prefix the password with <code>{noop}</code> to indicate <a href="#authentication-password-storage-dpe-format">no encoding should be used</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. &lt;user-service&gt; <code>{noop}</code> XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user-service&gt;
	&lt;user name="user"
		password="{noop}password"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{noop}password"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-jdbc"><a class="anchor" href="#servlet-authentication-jdbc"></a>JDBC Authentication</h4>
<div class="paragraph">
<p>Spring Security&#8217;s <code>JdbcDaoImpl</code> implements <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> to provide support for username/password based authentication that is retrieved using JDBC.
<code>JdbcUserDetailsManager</code> extends <code>JdbcDaoImpl</code> to provide management of <code>UserDetails</code> through the <code>UserDetailsManager</code> interface.
<code>UserDetails</code> based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.</p>
</div>
<div class="paragraph">
<p>In the following sections we will discuss:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-jdbc-schema">Default Schema</a> used by Spring Security JDBC Authentication</p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-datasource">Setting up a DataSource</a></p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-bean">JdbcUserDetailsManager Bean</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-schema"><a class="anchor" href="#servlet-authentication-jdbc-schema"></a>Default Schema</h5>
<div class="paragraph">
<p>Spring Security provides default queries for JDBC based authentication.
This section provides the corresponding default schemas used with the default queries.
You will need to adjust the schema to match any customizations to the queries and the database dialect you are using.</p>
</div>
<div class="sect5">
<h6 id="servlet-authentication-jdbc-schema-user"><a class="anchor" href="#servlet-authentication-jdbc-schema-user"></a>User Schema</h6>
<div class="paragraph">
<p><code>JdbcDaoImpl</code> requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.
The default schema required can be found below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default schema is also exposed as a classpath resource named <code>org/springframework/security/core/userdetails/jdbc/users.ddl</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 16. Default User Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(500) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Oracle is a popular database choice, but requires a slightly different schema.
You can find the default Oracle Schema for users below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Default User Schema for Oracle Databases</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-jdbc-schema-group"><a class="anchor" href="#servlet-authentication-jdbc-schema-group"></a>Group Schema</h6>
<div class="paragraph">
<p>If your application is leveraging groups, you will need to provide the groups schema.
The default schema for groups can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Default Group Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-datasource"><a class="anchor" href="#servlet-authentication-jdbc-datasource"></a>Setting up a DataSource</h5>
<div class="paragraph">
<p>Before we configure <code>JdbcUserDetailsManager</code>, we must create a <code>DataSource</code>.
In our example, we will setup an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support">embedded DataSource</a> that is initialized with the <a href="#servlet-authentication-jdbc-schema">default user schema</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Embedded Data Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
DataSource dataSource() {
	return new EmbeddedDatabaseBuilder()
		.setType(H2)
		.addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
		.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jdbc:embedded-database&gt;
	&lt;jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/&gt;
&lt;/jdbc:embedded-database&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
        .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In a production environment, you will want to ensure you setup a connection to an external database.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-bean"><a class="anchor" href="#servlet-authentication-jdbc-bean"></a>JdbcUserDetailsManager Bean</h5>
<div class="paragraph">
<p>In this sample we use <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a> to encode the password of <code>password</code> and get the encoded password of <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code>.
See the <a href="#authentication-password-storage">PasswordEncoder</a> section for more details about how to store passwords.</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. JdbcUserDetailsManager</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
UserDetailsManager users(DataSource dataSource) {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
	users.createUser(user);
	users.createUser(admin);
	return users;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jdbc-user-service&gt;
	&lt;user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" /&gt;
	&lt;user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/jdbc-user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun users(dataSource: DataSource): UserDetailsManager {
    val user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
    val admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
    val users = JdbcUserDetailsManager(dataSource)
    users.createUser(user)
    users.createUser(admin)
    return users
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-userdetails"><a class="anchor" href="#servlet-authentication-userdetails"></a>UserDetails</h4>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/userdetails/UserDetails.html[<code>UserDetails</code>] is returned by the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>.
The <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> validates the <code>UserDetails</code> and then returns an <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that has a principal that is the <code>UserDetails</code> returned by the configured <code>UserDetailsService</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-userdetailsservice"><a class="anchor" href="#servlet-authentication-userdetailsservice"></a>UserDetailsService</h4>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/core/userdetails/UserDetailsService.html[<code>UserDetailsService</code>] is used by <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> for retrieving a username, password, and other attributes for authenticating with a username and password.
Spring Security provides <a href="#servlet-authentication-inmemory">in-memory</a> and <a href="#servlet-authentication-jdbc">JDBC</a> implementations of <code>UserDetailsService</code>.</p>
</div>
<div class="paragraph">
<p>You can define custom authentication by exposing a custom <code>UserDetailsService</code> as a bean.
For example, the following will customize authentication assuming that <code>CustomUserDetailsService</code> implements <code>UserDetailsService</code>:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is only used if the <code>AuthenticationManagerBuilder</code> has not been populated and no <code>AuthenticationProviderBean</code> is defined.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 21. Custom UserDetailsService Bean</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
CustomUserDetailsService customUserDetailsService() {
	return new CustomUserDetailsService();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;b:bean class="example.CustomUserDetailsService"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun customUserDetailsService() = CustomUserDetailsService()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-password-storage"><a class="anchor" href="#servlet-authentication-password-storage"></a>PasswordEncoder</h4>
<div class="paragraph">
<p>Spring Security&#8217;s servlet support storing passwords securely by integrating with <a href="#authentication-password-storage"><code>PasswordEncoder</code></a>.
Customizing the <code>PasswordEncoder</code> implementation used by Spring Security can be done by <a href="#authentication-password-storage-configuration">exposing a <code>PasswordEncoder</code> Bean</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-daoauthenticationprovider"><a class="anchor" href="#servlet-authentication-daoauthenticationprovider"></a>DaoAuthenticationProvider</h4>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/authentication/dao/DaoAuthenticationProvider.html[<code>DaoAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> and <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a> to authenticate a username and password.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>DaoAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#servlet-authentication-unpwd-input">Reading the Username &amp; Password</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authentication/unpwd/daoauthenticationprovider.png" alt="daoauthenticationprovider">
</div>
<div class="title">Figure 10. <code>DaoAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#servlet-authentication-unpwd-input">Reading the Username &amp; Password</a> passes a <code>UsernamePasswordAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> of type <code>DaoAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>DaoAuthenticationProvider</code> looks up the <code>UserDetails</code> from the <code>UserDetailsService</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> <code>DaoAuthenticationProvider</code> then uses the <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a> to validate the password on the <code>UserDetails</code> returned in the previous step.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>UsernamePasswordAuthenticationToken</code> and has a principal that is the <code>UserDetails</code> returned by the configured <code>UserDetailsService</code>.
Ultimately, the returned <code>UsernamePasswordAuthenticationToken</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap"><a class="anchor" href="#servlet-authentication-ldap"></a>LDAP Authentication</h4>
<div class="paragraph">
<p>LDAP is often used by organizations as a central repository for user information and as an authentication service.
It can also be used to store the role information for application users.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s LDAP based authentication is used by Spring Security when it is configured to <a href="#servlet-authentication-unpwd-input">accept a username/password</a> for authentication.
However, despite leveraging a username/password for authentication it does not integrate using <code>UserDetailsService</code> because in <a href="#servlet-authentication-ldap-bind">bind authentication</a> the LDAP server does not return the password so the application cannot perform validation of the password.</p>
</div>
<div class="paragraph">
<p>There are many different scenarios for how an LDAP server may be configured so Spring Security&#8217;s LDAP provider is fully configurable.
It uses separate strategy interfaces for authentication and role retrieval and provides default implementations which can be configured to handle a wide range of situations.</p>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-prerequisites"><a class="anchor" href="#servlet-authentication-ldap-prerequisites"></a>Prerequisites</h5>
<div class="paragraph">
<p>You should be familiar with LDAP before trying to use it with Spring Security.
The following link provides a good introduction to the concepts involved and a guide to setting up a directory using the free LDAP server OpenLDAP: <a href="https://www.zytrax.com/books/ldap/" class="bare">https://www.zytrax.com/books/ldap/</a>.
Some familiarity with the JNDI APIs used to access LDAP from Java may also be useful.
We don&#8217;t use any third-party LDAP libraries (Mozilla, JLDAP etc.) in the LDAP provider, but extensive use is made of Spring LDAP, so some familiarity with that project may be useful if you plan on adding your own customizations.</p>
</div>
<div class="paragraph">
<p>When using LDAP authentication, it is important to ensure that you configure LDAP connection pooling properly.
If you are unfamiliar with how to do this, you can refer to the <a href="https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html">Java LDAP documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-embedded"><a class="anchor" href="#servlet-authentication-ldap-embedded"></a>Setting up an Embedded LDAP Server</h5>
<div class="paragraph">
<p>The first thing you will need to do is to ensure that you have an LDAP Server to point your configuration to.
For simplicity, it often best to start with an embedded LDAP Server.
Spring Security supports using either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-unboundid">Embedded UnboundID Server</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-apacheds">Embedded ApacheDS Server</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the samples below, we expose the following as <code>users.ldif</code> as a classpath resource to initialize the embedded LDAP server with the users <code>user</code> and <code>admin</code> both of which have a password of <code>password</code>.</p>
</div>
<div class="listingblock">
<div class="title">users.ldif</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ldif hljs" data-lang="ldif">dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-ldap-unboundid"><a class="anchor" href="#servlet-authentication-ldap-unboundid"></a>Embedded UnboundID Server</h6>
<div class="paragraph">
<p>If you wish to use <a href="https://ldap.com/unboundid-ldap-sdk-for-java/">UnboundID</a>, then specify the following dependencies:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. UnboundID Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.unboundid&lt;/groupId&gt;
	&lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;
	&lt;version&gt;{unboundid-ldapsdk-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">depenendencies {
	runtimeOnly "com.unboundid:unboundid-ldapsdk:{unboundid-ldapsdk-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can then configure the Embedded LDAP Server</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Embedded LDAP Server Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
UnboundIdContainer ldapContainer() {
	return new UnboundIdContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.UnboundIdContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun ldapContainer(): UnboundIdContainer {
    return UnboundIdContainer("dc=springframework,dc=org","classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-ldap-apacheds"><a class="anchor" href="#servlet-authentication-ldap-apacheds"></a>Embedded ApacheDS Server</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security uses ApacheDS 1.x which is no longer maintained.
Unfortunately, ApacheDS 2.x has only released milestone versions with no stable release.
Once a stable release of ApacheDS 2.x is available, we will consider updating.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to use <a href="https://directory.apache.org/apacheds/">Apache DS</a>, then specify the following dependencies:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. ApacheDS Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
	&lt;artifactId&gt;apacheds-core&lt;/artifactId&gt;
	&lt;version&gt;{apacheds-core-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
	&lt;artifactId&gt;apacheds-server-jndi&lt;/artifactId&gt;
	&lt;version&gt;{apacheds-core-version}&lt;/version&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">depenendencies {
	runtimeOnly "org.apache.directory.server:apacheds-core:{apacheds-core-version}"
	runtimeOnly "org.apache.directory.server:apacheds-server-jndi:{apacheds-core-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can then configure the Embedded LDAP Server</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Embedded LDAP Server Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ApacheDSContainer ldapContainer() {
	return new ApacheDSContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.ApacheDSContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun ldapContainer(): ApacheDSContainer {
    return ApacheDSContainer("dc=springframework,dc=org", "classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-contextsource"><a class="anchor" href="#servlet-authentication-ldap-contextsource"></a>LDAP ContextSource</h5>
<div class="paragraph">
<p>Once you have an LDAP Server to point your configuration to, you need configure Spring Security to point to an LDAP server that should be used to authenticate users.
This is done by creating an LDAP <code>ContextSource</code>, which is the equivalent of a JDBC <code>DataSource</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. LDAP Context Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ContextSource contextSource(UnboundIdContainer container) {
	return new DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-server
	url="ldap://localhost:53389/dc=springframework,dc=org" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun contextSource(container: UnboundIdContainer): ContextSource {
    return DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-authentication"><a class="anchor" href="#servlet-authentication-ldap-authentication"></a>Authentication</h5>
<div class="paragraph">
<p>Spring Security&#8217;s LDAP support does not use the <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> because LDAP bind authentication does not allow clients to read the password or even a hashed version of the password.
This means there is no way a password to be read and then authenticated by Spring Security.</p>
</div>
<div class="paragraph">
<p>For this reason, LDAP support is implemented using the <code>LdapAuthenticator</code> interface.
The <code>LdapAuthenticator</code> is also responsible for retrieving any required user attributes.
This is because the permissions on the attributes may depend on the type of authentication being used.
For example, if binding as the user, it may be necessary to read them with the user&#8217;s own permissions.</p>
</div>
<div class="paragraph">
<p>There are two <code>LdapAuthenticator</code> implementations supplied with Spring Security:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-bind">Using Bind Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-pwd">Using Password Authentication</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-bind"><a class="anchor" href="#servlet-authentication-ldap-bind"></a>Using Bind Authentication</h5>
<div class="paragraph">
<p><a href="https://ldap.com/the-ldap-bind-operation/">Bind Authentication</a> is the most common mechanism for authenticating users with LDAP.
In bind authentication the users credentials (i.e. username/password) are submitted to the LDAP server which authenticates them.
The advantage to using bind authentication is that the user&#8217;s secrets (i.e. password) do not need to be exposed to clients which helps to protect them from leaking.</p>
</div>
<div class="paragraph">
<p>An example of bind authentication configuration can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Bind Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	BindAuthenticator authenticator = new BindAuthenticator(contextSource);
	authenticator.setUserDnPatterns(new String[] { "uid={0},ou=people" });
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserDnPatterns(arrayOf("uid={0},ou=people"))
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This simple example would obtain the DN for the user by substituting the user login name in the supplied pattern and attempting to bind as that user with the login password.
This is OK if all your users are stored under a single node in the directory.
If instead you wished to configure an LDAP search filter to locate the user, you could use the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Bind Authentication with Search Filter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	String searchBase = "ou=people";
	String filter = "(uid={0})";
	FilterBasedLdapUserSearch search =
		new FilterBasedLdapUserSearch(searchBase, filter, contextSource);
	BindAuthenticator authenticator = new BindAuthenticator(contextSource);
	authenticator.setUserSearch(search);
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-search-filter="(uid={0})"
	user-search-base="ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val searchBase = "ou=people"
    val filter = "(uid={0})"
    val search = FilterBasedLdapUserSearch(searchBase, filter, contextSource)
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserSearch(search)
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If used with the <code>ContextSource</code> <a href="#servlet-authentication-ldap-contextsource">definition above</a>, this would perform a search under the DN <code>ou=people,dc=springframework,dc=org</code> using <code>(uid={0})</code> as a filter.
Again the user login name is substituted for the parameter in the filter name, so it will search for an entry with the <code>uid</code> attribute equal to the user name.
If a user search base isn&#8217;t supplied, the search will be performed from the root.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-pwd"><a class="anchor" href="#servlet-authentication-ldap-pwd"></a>Using Password Authentication</h5>
<div class="paragraph">
<p>Password comparison is when the password supplied by the user is compared with the one stored in the repository.
This can either be done by retrieving the value of the password attribute and checking it locally or by performing an LDAP "compare" operation, where the supplied password is passed to the server for comparison and the real password value is never retrieved.
An LDAP compare cannot be done when the password is properly hashed with a random salt.</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Minimal Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	return new PasswordComparisonAuthenticator(contextSource);
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people"&gt;
	&lt;password-compare /&gt;
&lt;/ldap-authentication-provider&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    return PasswordComparisonAuthenticator(contextSource)
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A more advanced configuration with some customizations can be found below.</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
	PasswordComparisonAuthenticator authenticator =
		new PasswordComparisonAuthenticator(contextSource);
	authenticator.setPasswordAttributeName("pwd"); <i class="conum" data-value="1"></i><b>(1)</b>
	authenticator.setPasswordEncoder(new BCryptPasswordEncoder()); <i class="conum" data-value="2"></i><b>(2)</b>
	return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
	return new LdapAuthenticationProvider(authenticator);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people"&gt;
	&lt;password-compare password-attribute="pwd"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
		&lt;password-encoder ref="passwordEncoder" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
	&lt;/password-compare&gt;
&lt;/ldap-authentication-provider&gt;
&lt;b:bean id="passwordEncoder"
	class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    val authenticator = PasswordComparisonAuthenticator(contextSource)
    authenticator.setPasswordAttributeName("pwd") <i class="conum" data-value="1"></i><b>(1)</b>
    authenticator.setPasswordEncoder(BCryptPasswordEncoder()) <i class="conum" data-value="2"></i><b>(2)</b>
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the password attribute as <code>pwd</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>BCryptPasswordEncoder</code></td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_ldapauthoritiespopulator"><a class="anchor" href="#_ldapauthoritiespopulator"></a>LdapAuthoritiesPopulator</h5>
<div class="paragraph">
<p>Spring Security&#8217;s <code>LdapAuthoritiesPopulator</code> is used to determine what authorites are returned for the user.</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. LdapAuthoritiesPopulator Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
	String groupSearchBase = "";
	DefaultLdapAuthoritiesPopulator authorities =
		new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
	authorities.setGroupSearchFilter("member={0}");
	return authorities;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator, LdapAuthoritiesPopulator authorities) {
	return new LdapAuthenticationProvider(authenticator, authorities);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"
	group-search-filter="member={0}"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    val groupSearchBase = ""
    val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase)
    authorities.setGroupSearchFilter("member={0}")
    return authorities
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator, authorities: LdapAuthoritiesPopulator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator, authorities)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_active_directory"><a class="anchor" href="#_active_directory"></a>Active Directory</h5>
<div class="paragraph">
<p>Active Directory supports its own non-standard authentication options, and the normal usage pattern doesn&#8217;t fit too cleanly with the standard <code>LdapAuthenticationProvider</code>.
Typically authentication is performed using the domain username (in the form <code>user@domain</code>), rather than using an LDAP distinguished name.
To make this easier, Spring Security has an authentication provider which is customized for a typical Active Directory setup.</p>
</div>
<div class="paragraph">
<p>Configuring <code>ActiveDirectoryLdapAuthenticationProvider</code> is quite straightforward.
You just need to supply the domain name and an LDAP URL supplying the address of the server <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.
An example configuration can be seen below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. Example Active Directory Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ActiveDirectoryLdapAuthenticationProvider authenticationProvider() {
	return new ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="authenticationProvider"
        class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&gt;
	&lt;constructor-arg value="example.com" /&gt;
	&lt;constructor-arg value="ldap://company.example.com/" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider {
    return ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="session-mgmt"><a class="anchor" href="#session-mgmt"></a>Session Management</h3>
<div class="paragraph">
<p>HTTP session related functionality is handled by a combination of the <code>SessionManagementFilter</code> and the <code>SessionAuthenticationStrategy</code> interface, which the filter delegates to.
Typical usage includes session-fixation protection attack prevention, detection of session timeouts and restrictions on how many sessions an authenticated user may have open concurrently.</p>
</div>
<div class="sect3">
<h4 id="_detecting_timeouts"><a class="anchor" href="#_detecting_timeouts"></a>Detecting Timeouts</h4>
<div class="paragraph">
<p>You can configure Spring Security to detect the submission of an invalid session ID and redirect the user to an appropriate URL.
This is achieved through the <code>session-management</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management invalid-session-url="/invalidSession.htm" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you use this mechanism to detect session timeouts, it may falsely report an error if the user logs out and then logs back in without closing the browser.
This is because the session cookie is not cleared when you invalidate the session and will be resubmitted even if the user has logged out.
You may be able to explicitly delete the JSESSIONID cookie on logging out, for example by using the following syntax in the logout handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;logout delete-cookies="JSESSIONID" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately this can&#8217;t be guaranteed to work with every servlet container, so you will need to test it in your environment</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are running your application behind a proxy, you may also be able to remove the session cookie by configuring the proxy server.
For example, using Apache HTTPD&#8217;s mod_headers, the following directive would delete the <code>JSESSIONID</code> cookie by expiring it in the response to a logout request (assuming the application is deployed under the path <code>/tutorial</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;LocationMatch "/tutorial/logout"&gt;
Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
&lt;/LocationMatch&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ns-concurrent-sessions"><a class="anchor" href="#ns-concurrent-sessions"></a>Concurrent Session Control</h4>
<div class="paragraph">
<p>If you wish to place constraints on a single user&#8217;s ability to log in to your application, Spring Security supports this out of the box with the following simple additions.
First you need to add the following listener to your <code>web.xml</code> file to keep Spring Security updated about session lifecycle events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the following lines to your application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will prevent a user from logging in multiple times - a second login will cause the first to be invalidated.
Often you would prefer to prevent a second login, in which case you can use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" error-if-maximum-exceeded="true" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second login will then be rejected.
By "rejected", we mean that the user will be sent to the <code>authentication-failure-url</code> if form-based login is being used.
If the second authentication takes place through another non-interactive mechanism, such as "remember-me", an "unauthorized" (401) error will be sent to the client.
If instead you want to use an error page, you can add the attribute <code>session-authentication-error-url</code> to the <code>session-management</code> element.</p>
</div>
<div class="paragraph">
<p>If you are using a customized authentication filter for form-based login, then you have to configure concurrent session control support explicitly.
More details can be found in the <a href="#session-mgmt">Session Management chapter</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-session-fixation"><a class="anchor" href="#ns-session-fixation"></a>Session Fixation Attack Protection</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session fixation</a> attacks are a potential risk where it is possible for a malicious attacker to create a session by accessing a site, then persuade another user to log in with the same session (by sending them a link containing the session identifier as a parameter, for example).
Spring Security protects against this automatically by creating a new session or otherwise changing the session ID when a user logs in.
If you don&#8217;t require this protection, or it conflicts with some other requirement, you can control the behavior using the <code>session-fixation-protection</code> attribute on <code>&lt;session-management&gt;</code>, which has four options</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> - Don&#8217;t do anything.
The original session will be retained.</p>
</li>
<li>
<p><code>newSession</code> - Create a new "clean" session, without copying the existing session data (Spring Security-related attributes will still be copied).</p>
</li>
<li>
<p><code>migrateSession</code> - Create a new session and copy all existing session attributes to the new session.
This is the default in Servlet 3.0 or older containers.</p>
</li>
<li>
<p><code>changeSessionId</code> - Do not create a new session.
Instead, use the session fixation protection provided by the Servlet container (<code>HttpServletRequest#changeSessionId()</code>).
This option is only available in Servlet 3.1 (Java EE 7) and newer containers.
Specifying it in older containers will result in an exception.
This is the default in Servlet 3.1 and newer containers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When session fixation protection occurs, it results in a <code>SessionFixationProtectionEvent</code> being published in the application context.
If you use <code>changeSessionId</code>, this protection will <em>also</em> result in any  <code>javax.servlet.http.HttpSessionIdListener</code> s being notified, so use caution if your code listens for both events.
See the <a href="#session-mgmt">Session Management</a> chapter for additional information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sessionmanagementfilter"><a class="anchor" href="#_sessionmanagementfilter"></a>SessionManagementFilter</h4>
<div class="paragraph">
<p>The <code>SessionManagementFilter</code> checks the contents of the <code>SecurityContextRepository</code> against the current contents of the <code>SecurityContextHolder</code> to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me  <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.
If the repository contains a security context, the filter does nothing.
If it doesn&#8217;t, and the thread-local <code>SecurityContext</code> contains a (non-anonymous) <code>Authentication</code> object, the filter assumes they have been authenticated by a previous filter in the stack.
It will then invoke the configured <code>SessionAuthenticationStrategy</code>.</p>
</div>
<div class="paragraph">
<p>If the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured <code>InvalidSessionStrategy</code>, if one is set.
The most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation <code>SimpleRedirectInvalidSessionStrategy</code>.
The latter is also used when configuring an invalid session URL through the namespace,<a href="#session-mgmt">as described earlier</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sessionauthenticationstrategy"><a class="anchor" href="#_sessionauthenticationstrategy"></a>SessionAuthenticationStrategy</h4>
<div class="paragraph">
<p><code>SessionAuthenticationStrategy</code> is used by both <code>SessionManagementFilter</code> and <code>AbstractAuthenticationProcessingFilter</code>, so if you are using a customized form-login class, for example, you will need to inject it into both of these.
In this case, a typical configuration, combining the namespace and custom beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
	&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
	...
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class=
"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the use of the default, <code>SessionFixationProtectionStrategy</code> may cause issues if you are storing beans in the session which implement <code>HttpSessionBindingListener</code>, including Spring session-scoped beans.
See the Javadoc for this class for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrent-sessions"><a class="anchor" href="#concurrent-sessions"></a>Concurrency Control</h4>
<div class="paragraph">
<p>Spring Security is able to prevent a principal from concurrently authenticating to the same application more than a specified number of times.
Many ISVs take advantage of this to enforce licensing, whilst network administrators like this feature because it helps prevent people from sharing login names.
You can, for example, stop user "Batman" from logging onto the web application from two different sessions.
You can either expire their previous login or you can report an error when they try to log in again, preventing the second login.
Note that if you are using the second approach, a user who has not explicitly logged out (but who has just closed their browser, for example) will not be able to log in again until their original session expires.</p>
</div>
<div class="paragraph">
<p>Concurrency control is supported by the namespace, so please check the earlier namespace chapter for the simplest configuration.
Sometimes you need to customize things though.</p>
</div>
<div class="paragraph">
<p>The implementation uses a specialized version of <code>SessionAuthenticationStrategy</code>, called <code>ConcurrentSessionControlAuthenticationStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Previously the concurrent authentication check was made by the <code>ProviderManager</code>, which could be injected with a <code>ConcurrentSessionController</code>.
The latter would check if the user was attempting to exceed the number of permitted sessions.
However, this approach required that an HTTP session be created in advance, which is undesirable.
In Spring Security 3, the user is first authenticated by the <code>AuthenticationManager</code> and once they are successfully authenticated, a session is created and the check is made whether they are allowed to have another session open.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use concurrent session support, you&#8217;ll need to add the following to <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
	&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
	&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you will need to add the <code>ConcurrentSessionFilter</code> to your <code>FilterChainProxy</code>.
The <code>ConcurrentSessionFilter</code> requires two constructor arguments, <code>sessionRegistry</code>, which generally points to an instance of <code>SessionRegistryImpl</code>, and <code>sessionInformationExpiredStrategy</code>, which defines the strategy to apply when a session has expired.
A configuration using the namespace to create the <code>FilterChainProxy</code> and other default beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="redirectSessionInformationExpiredStrategy"
class="org.springframework.security.web.session.SimpleRedirectSessionInformationExpiredStrategy"&gt;
&lt;beans:constructor-arg name="invalidSessionUrl" value="/session-expired.htm" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="concurrencyFilter"
class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
&lt;beans:constructor-arg name="sessionRegistry" ref="sessionRegistry" /&gt;
&lt;beans:constructor-arg name="sessionInformationExpiredStrategy" ref="redirectSessionInformationExpiredStrategy" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
&lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class="org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"&gt;
&lt;beans:constructor-arg&gt;
	&lt;beans:list&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
		&lt;beans:property name="maximumSessions" value="1" /&gt;
		&lt;beans:property name="exceptionIfMaximumExceeded" value="true" /&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
	&lt;/beans:bean&gt;
	&lt;/beans:list&gt;
&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sessionRegistry"
	class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding the listener to <code>web.xml</code> causes an <code>ApplicationEvent</code> to be published to the Spring <code>ApplicationContext</code> every time a <code>HttpSession</code> commences or ends.
This is critical, as it allows the <code>SessionRegistryImpl</code> to be notified when a session ends.
Without it, a user will never be able to log back in again once they have exceeded their session allowance, even if they log out of another session or it times out.</p>
</div>
<div class="sect4">
<h5 id="list-authenticated-principals"><a class="anchor" href="#list-authenticated-principals"></a>Querying the SessionRegistry for currently authenticated users and their sessions</h5>
<div class="paragraph">
<p>Setting up concurrency-control, either through the namespace or using plain beans has the useful side effect of providing you with a reference to the <code>SessionRegistry</code> which you can use directly within your application, so even if you don&#8217;t want to restrict the number of sessions a user may have, it may be worth setting up the infrastructure anyway.
You can set the <code>maximumSession</code> property to -1 to allow unlimited sessions.
If you&#8217;re using the namespace, you can set an alias for the internally-created <code>SessionRegistry</code> using the <code>session-registry-alias</code> attribute, providing a reference which you can inject into your own beans.</p>
</div>
<div class="paragraph">
<p>The <code>getAllPrincipals()</code> method supplies you with a list of the currently authenticated users.
You can list a user&#8217;s sessions by calling the <code>getAllSessions(Object principal, boolean includeExpiredSessions)</code> method, which returns a list of <code>SessionInformation</code> objects.
You can also expire a user&#8217;s session by calling <code>expireNow()</code> on a <code>SessionInformation</code> instance.
When the user returns to the application, they will be prevented from proceeding.
You may find these methods useful in an administration application, for example.
Have a look at the Javadoc for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-rememberme"><a class="anchor" href="#servlet-rememberme"></a>Remember-Me Authentication</h3>
<div class="sect3">
<h4 id="remember-me-overview"><a class="anchor" href="#remember-me-overview"></a>Overview</h4>
<div class="paragraph">
<p>Remember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions.
This is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place.
Spring Security provides the necessary hooks for these operations to take place, and has two concrete remember-me implementations.
One uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens.</p>
</div>
<div class="paragraph">
<p>Note that both implementations require a <code>UserDetailsService</code>.
If you are using an authentication provider which doesn&#8217;t use a <code>UserDetailsService</code> (for example, the LDAP provider) then it won&#8217;t work unless you also have a <code>UserDetailsService</code> bean in your application context.</p>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-hash-token"><a class="anchor" href="#remember-me-hash-token"></a>Simple Hash-Based Token Approach</h4>
<div class="paragraph">
<p>This approach uses hashing to achieve a useful remember-me strategy.
In essence a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token</code></pre>
</div>
</div>
<div class="paragraph">
<p>As such the remember-me token is valid only for the period specified, and provided that the username, password and key does not change.
Notably, this has a potential security issue in that a captured remember-me token will be usable from any user agent until such time as the token expires.
This is the same issue as with digest authentication.
If a principal is aware a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue.
If more significant security is needed you should use the approach described in the next section.
Alternatively remember-me services should simply not be used at all.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the topics discussed in the chapter on <a href="#ns-config">namespace configuration</a>, you can enable remember-me authentication just by adding the <code>&lt;remember-me&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me key="myAppKey"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UserDetailsService</code> will normally be selected automatically.
If you have more than one in your application context, you need to specify which one should be used with the <code>user-service-ref</code> attribute, where the value is the name of your <code>UserDetailsService</code> bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-persistent-token"><a class="anchor" href="#remember-me-persistent-token"></a>Persistent Token Approach</h4>
<div class="paragraph">
<p>This approach is based on the article <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> with some minor modifications  <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.
To use the this approach with namespace configuration, you would supply a datasource reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me data-source-ref="someDataSource"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The database should contain a <code>persistent_logins</code> table, created using the following SQL (or equivalent):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">create table persistent_logins (username varchar(64) not null,
								series varchar(64) primary key,
								token varchar(64) not null,
								last_used timestamp not null)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-impls"><a class="anchor" href="#remember-me-impls"></a>Remember-Me Interfaces and Implementations</h4>
<div class="paragraph">
<p>Remember-me is used with <code>UsernamePasswordAuthenticationFilter</code>, and is implemented via hooks in the <code>AbstractAuthenticationProcessingFilter</code> superclass.
It is also used within <code>BasicAuthenticationFilter</code>.
The hooks will invoke a concrete <code>RememberMeServices</code> at the appropriate times.
The interface looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response,
	Authentication successfulAuthentication);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the Javadoc for a fuller discussion on what the methods do, although note at this stage that <code>AbstractAuthenticationProcessingFilter</code> only calls the <code>loginFail()</code> and <code>loginSuccess()</code> methods.
The <code>autoLogin()</code> method is called by <code>RememberMeAuthenticationFilter</code> whenever the <code>SecurityContextHolder</code> does not contain an <code>Authentication</code>.
This interface therefore provides the underlying remember-me implementation with sufficient notification of authentication-related events, and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered.
This design allows any number of remember-me implementation strategies.
We&#8217;ve seen above that Spring Security provides two implementations.
We&#8217;ll look at these in turn.</p>
</div>
<div class="sect4">
<h5 id="_tokenbasedremembermeservices"><a class="anchor" href="#_tokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h5>
<div class="paragraph">
<p>This implementation supports the simpler approach described in <a href="#remember-me-hash-token">Simple Hash-Based Token Approach</a>.
<code>TokenBasedRememberMeServices</code> generates a <code>RememberMeAuthenticationToken</code>, which is processed by <code>RememberMeAuthenticationProvider</code>.
A <code>key</code> is shared between this authentication provider and the <code>TokenBasedRememberMeServices</code>.
In addition, <code>TokenBasedRememberMeServices</code> requires A UserDetailsService from which it can retrieve the username and password for signature comparison purposes, and generate the <code>RememberMeAuthenticationToken</code> to contain the correct <code>GrantedAuthority</code> s.
Some sort of logout command should be provided by the application that invalidates the cookie if the user requests this.
<code>TokenBasedRememberMeServices</code> also implements Spring Security&#8217;s <code>LogoutHandler</code> interface so can be used with <code>LogoutFilter</code> to have the cookie cleared automatically.</p>
</div>
<div class="paragraph">
<p>The beans required in an application context to enable remember-me services are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rememberMeFilter" class=
"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"&gt;
&lt;property name="rememberMeServices" ref="rememberMeServices"/&gt;
&lt;property name="authenticationManager" ref="theAuthenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeServices" class=
"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"&gt;
&lt;property name="userDetailsService" ref="myUserDetailsService"/&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeAuthenticationProvider" class=
"org.springframework.security.authentication.RememberMeAuthenticationProvider"&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to add your <code>RememberMeServices</code> implementation to your <code>UsernamePasswordAuthenticationFilter.setRememberMeServices()</code> property, include the <code>RememberMeAuthenticationProvider</code> in your <code>AuthenticationManager.setProviders()</code> list, and add <code>RememberMeAuthenticationFilter</code> into your <code>FilterChainProxy</code> (typically immediately after your <code>UsernamePasswordAuthenticationFilter</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="_persistenttokenbasedremembermeservices"><a class="anchor" href="#_persistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h5>
<div class="paragraph">
<p>This class can be used in the same way as <code>TokenBasedRememberMeServices</code>, but it additionally needs to be configured with a <code>PersistentTokenRepository</code> to store the tokens.
There are two standard implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenRepositoryImpl</code> which is intended for testing only.</p>
</li>
<li>
<p><code>JdbcTokenRepositoryImpl</code> which stores the tokens in a database.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The database schema is described above in <a href="#remember-me-persistent-token">Persistent Token Approach</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-openid"><a class="anchor" href="#servlet-openid"></a>OpenID Support</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The OpenID 1.0 and 2.0 protocols have been deprecated and users are encouraged to migrate to OpenID Connect, which is supported by spring-security-oauth2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The namespace supports <a href="https://openid.net/">OpenID</a> login either instead of, or in addition to normal form-based login, with a simple change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;openid-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should then register yourself with an OpenID provider (such as myopenid.com), and add the user information to your in-memory <code>&lt;user-service&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user name="https://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to login using the <code>myopenid.com</code> site to authenticate.
It is also possible to select a specific <code>UserDetailsService</code> bean for use OpenID by setting the <code>user-service-ref</code> attribute on the <code>openid-login</code> element.
Note that we have omitted the password attribute from the above user configuration, since this set of user data is only being used to load the authorities for the user.
A random password will be generated internally, preventing you from accidentally using this user data as an authentication source elsewhere in your configuration.</p>
</div>
<div class="sect3">
<h4 id="_attribute_exchange"><a class="anchor" href="#_attribute_exchange"></a>Attribute Exchange</h4>
<div class="paragraph">
<p>Support for OpenID <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html">attribute exchange</a>.
As an example, the following configuration would attempt to retrieve the email and full name from the OpenID provider, for use by the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;openid-login&gt;
&lt;attribute-exchange&gt;
	&lt;openid-attribute name="email" type="https://axschema.org/contact/email" required="true"/&gt;
	&lt;openid-attribute name="name" type="https://axschema.org/namePerson"/&gt;
&lt;/attribute-exchange&gt;
&lt;/openid-login&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "type" of each OpenID attribute is a URI, determined by a particular schema, in this case <a href="https://axschema.org/">https://axschema.org/</a>.
If an attribute must be retrieved for successful authentication, the <code>required</code> attribute can be set.
The exact schema and attributes supported will depend on your OpenID provider.
The attribute values are returned as part of the authentication process and can be accessed afterwards using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenIDAuthenticationToken token =
	(OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can obtain the <code>OpenIDAuthenticationToken</code> from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>OpenIDAttribute</code> contains the attribute type and the retrieved value (or values in the case of multi-valued attributes).
You can supply multiple <code>attribute-exchange</code> elements, using an <code>identifier-matcher</code> attribute on each.
This contains a regular expression which will be matched against the OpenID identifier supplied by the user.
See the OpenID sample application in the codebase for an example configuration, providing different attribute lists for the Google, Yahoo and MyOpenID providers.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anonymous"><a class="anchor" href="#anonymous"></a>Anonymous Authentication</h3>
<div class="sect3">
<h4 id="anonymous-overview"><a class="anchor" href="#anonymous-overview"></a>Overview</h4>
<div class="paragraph">
<p>It&#8217;s generally considered good security practice to adopt a "deny-by-default" where you explicitly specify what is allowed and disallow everything else.
Defining what is accessible to unauthenticated users is a similar situation, particularly for web applications.
Many sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages).
In this case it is easiest to define access configuration attributes for these specific URLs rather than have for every secured resource.
Put differently, sometimes it is nice to say <code>ROLE_SOMETHING</code> is required by default and only allow certain exceptions to this rule, such as for login, logout and home pages of an application.
You could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users.</p>
</div>
<div class="paragraph">
<p>This is what we mean by anonymous authentication.
Note that there is no real conceptual difference between a user who is "anonymously authenticated" and an unauthenticated user.
Spring Security&#8217;s anonymous authentication just gives you a more convenient way to configure your access-control attributes.
Calls to servlet API calls such as <code>getCallerPrincipal</code>, for example, will still return null even though there is actually an anonymous authentication object in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>There are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the <code>SecurityContextHolder</code> to identify which principal was responsible for a given operation.
Classes can be authored more robustly if they know the <code>SecurityContextHolder</code> always contains an <code>Authentication</code> object, and never <code>null</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="anonymous-config"><a class="anchor" href="#anonymous-config"></a>Configuration</h4>
<div class="paragraph">
<p>Anonymous authentication support is provided automatically when using the HTTP configuration Spring Security 3.0 and can be customized (or disabled) using the <code>&lt;anonymous&gt;</code> element.
You don&#8217;t need to configure the beans described here unless you are using traditional bean configuration.</p>
</div>
<div class="paragraph">
<p>Three classes that together provide the anonymous authentication feature.
<code>AnonymousAuthenticationToken</code> is an implementation of <code>Authentication</code>, and stores the <code>GrantedAuthority</code> s which apply to the anonymous principal.
There is a corresponding <code>AnonymousAuthenticationProvider</code>, which is chained into the <code>ProviderManager</code> so that <code>AnonymousAuthenticationToken</code> s are accepted.
Finally, there is an <code>AnonymousAuthenticationFilter</code>, which is chained after the normal authentication mechanisms and automatically adds an <code>AnonymousAuthenticationToken</code> to the <code>SecurityContextHolder</code> if there is no existing <code>Authentication</code> held there.
The definition of the filter and authentication provider appears as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="anonymousAuthFilter"
	class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
	class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>key</code> is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>.
The <code>userAttribute</code> is expressed in the form of <code>usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code>.
This is the same syntax as used after the equals sign for the <code>userMap</code> property of <code>InMemoryDaoImpl</code>.</p>
</div>
<div class="paragraph">
<p>As explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
&lt;property name="securityMetadata"&gt;
	&lt;security:filter-security-metadata-source&gt;
	&lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
	&lt;/security:filter-security-metadata-source&gt;" +
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anonymous-auth-trust-resolver"><a class="anchor" href="#anonymous-auth-trust-resolver"></a>AuthenticationTrustResolver</h4>
<div class="paragraph">
<p>Rounding out the anonymous authentication discussion is the <code>AuthenticationTrustResolver</code> interface, with its corresponding <code>AuthenticationTrustResolverImpl</code> implementation.
This interface provides an <code>isAnonymous(Authentication)</code> method, which allows interested classes to take into account this special type of authentication status.
The <code>ExceptionTranslationFilter</code> uses this interface in processing <code>AccessDeniedException</code> s.
If an <code>AccessDeniedException</code> is thrown, and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter will instead commence the <code>AuthenticationEntryPoint</code> so the principal can authenticate properly.
This is a necessary distinction, otherwise principals would always be deemed "authenticated" and never be given an opportunity to login via form, basic, digest or some other normal authentication mechanism.</p>
</div>
<div class="paragraph">
<p>You will often see the <code>ROLE_ANONYMOUS</code> attribute in the above interceptor configuration replaced with <code>IS_AUTHENTICATED_ANONYMOUSLY</code>, which is effectively the same thing when defining access controls.
This is an example of the use of the <code>AuthenticatedVoter</code> which we will see in the <a href="#authz-authenticated-voter">authorization chapter</a>.
It uses an <code>AuthenticationTrustResolver</code> to process this particular configuration attribute and grant access to anonymous users.
The <code>AuthenticatedVoter</code> approach is more powerful, since it allows you to differentiate between anonymous, remember-me and fully-authenticated users.
If you don&#8217;t need this functionality though, then you can stick with <code>ROLE_ANONYMOUS</code>, which will be processed by Spring Security&#8217;s standard <code>RoleVoter</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-preauth"><a class="anchor" href="#servlet-preauth"></a>Pre-Authentication Scenarios</h3>
<div class="paragraph">
<p>There are situations where you want to use Spring Security for authorization, but the user has already been reliably authenticated by some external system prior to accessing the application.
We refer to these situations as "pre-authenticated" scenarios.
Examples include X.509, Siteminder and authentication by the Java EE container in which the application is running.
When using pre-authentication, Spring Security has to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the user making the request.</p>
</li>
<li>
<p>Obtain the authorities for the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The details will depend on the external authentication mechanism.
A user might be identified by their certificate information in the case of X.509, or by an HTTP request header in the case of Siteminder.
If relying on container authentication, the user will be identified by calling the <code>getUserPrincipal()</code> method on the incoming HTTP request.
In some cases, the external mechanism may supply role/authority information for the user but in others the authorities must be obtained from a separate source, such as a <code>UserDetailsService</code>.</p>
</div>
<div class="sect3">
<h4 id="_pre_authentication_framework_classes"><a class="anchor" href="#_pre_authentication_framework_classes"></a>Pre-Authentication Framework Classes</h4>
<div class="paragraph">
<p>Because most pre-authentication mechanisms follow the same pattern, Spring Security has a set of classes which provide an internal framework for implementing pre-authenticated authentication providers.
This removes duplication and allows new implementations to be added in a structured fashion, without having to write everything from scratch.
You don&#8217;t need to know about these classes if you want to use something like <a href="#servlet-x509">X.509 authentication</a>, as it already has a namespace configuration option which is simpler to use and get started with.
If you need to use explicit bean configuration or are planning on writing your own implementation then an understanding of how the provided implementations work will be useful.
You will find classes under the <code>org.springframework.security.web.authentication.preauth</code>.
We just provide an outline here so you should consult the Javadoc and source where appropriate.</p>
</div>
<div class="sect4">
<h5 id="_abstractpreauthenticatedprocessingfilter"><a class="anchor" href="#_abstractpreauthenticatedprocessingfilter"></a>AbstractPreAuthenticatedProcessingFilter</h5>
<div class="paragraph">
<p>This class will check the current contents of the security context and, if empty, it will attempt to extract user information from the HTTP request and submit it to the <code>AuthenticationManager</code>.
Subclasses override the following methods to obtain this information:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. Override AbstractPreAuthenticatedProcessingFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?

protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After calling these, the filter will create a <code>PreAuthenticatedAuthenticationToken</code> containing the returned data and submit it for authentication.
By "authentication" here, we really just mean further processing to perhaps load the user&#8217;s authorities, but the standard Spring Security authentication architecture is followed.</p>
</div>
<div class="paragraph">
<p>Like other Spring Security authentication filters, the pre-authentication filter has an <code>authenticationDetailsSource</code> property which by default will create a <code>WebAuthenticationDetails</code> object to store additional information such as the session-identifier and originating IP address in the <code>details</code> property of the <code>Authentication</code> object.
In cases where user role information can be obtained from the pre-authentication mechanism, the data is also stored in this property, with the details implementing the <code>GrantedAuthoritiesContainer</code> interface.
This enables the authentication provider to read the authorities which were externally allocated to the user.
We&#8217;ll look at a concrete example next.</p>
</div>
<div class="sect5">
<h6 id="j2ee-preauth-details"><a class="anchor" href="#j2ee-preauth-details"></a>J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</h6>
<div class="paragraph">
<p>If the filter is configured with an <code>authenticationDetailsSource</code> which is an instance of this class, the authority information is obtained by calling the <code>isUserInRole(String role)</code> method for each of a pre-determined set of "mappable roles".
The class gets these from a configured <code>MappableAttributesRetriever</code>.
Possible implementations include hard-coding a list in the application context and reading the role information from the <code>&lt;security-role&gt;</code> information in a <code>web.xml</code> file.
The pre-authentication sample application uses the latter approach.</p>
</div>
<div class="paragraph">
<p>There is an additional stage where the roles (or attributes) are mapped to Spring Security <code>GrantedAuthority</code> objects using a configured <code>Attributes2GrantedAuthoritiesMapper</code>.
The default will just add the usual <code>ROLE_</code> prefix to the names, but it gives you full control over the behaviour.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preauthenticatedauthenticationprovider"><a class="anchor" href="#_preauthenticatedauthenticationprovider"></a>PreAuthenticatedAuthenticationProvider</h5>
<div class="paragraph">
<p>The pre-authenticated provider has little more to do than load the <code>UserDetails</code> object for the user.
It does this by delegating to an <code>AuthenticationUserDetailsService</code>.
The latter is similar to the standard <code>UserDetailsService</code> but takes an <code>Authentication</code> object rather than just user name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface AuthenticationUserDetailsService {
	UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface may have also other uses but with pre-authentication it allows access to the authorities which were packaged in the <code>Authentication</code> object, as we saw in the previous section.
The <code>PreAuthenticatedGrantedAuthoritiesUserDetailsService</code> class does this.
Alternatively, it may delegate to a standard <code>UserDetailsService</code> via the <code>UserDetailsByNameServiceWrapper</code> implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_http403forbiddenentrypoint"><a class="anchor" href="#_http403forbiddenentrypoint"></a>Http403ForbiddenEntryPoint</h5>
<div class="paragraph">
<p>The <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is responsible for kick-starting the authentication process for an unauthenticated user (when they try to access a protected resource), but in the pre-authenticated case this doesn&#8217;t apply.
You would only configure the <code>ExceptionTranslationFilter</code> with an instance of this class if you aren&#8217;t using pre-authentication in combination with other authentication mechanisms.
It will be called if the user is rejected by the <code>AbstractPreAuthenticatedProcessingFilter</code> resulting in a null authentication.
It always returns a <code>403</code>-forbidden response code if called.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_concrete_implementations"><a class="anchor" href="#_concrete_implementations"></a>Concrete Implementations</h4>
<div class="paragraph">
<p>X.509 authentication is covered in its <a href="#servlet-x509">own chapter</a>.
Here we&#8217;ll look at some classes which provide support for other pre-authenticated scenarios.</p>
</div>
<div class="sect4">
<h5 id="_request_header_authentication_siteminder"><a class="anchor" href="#_request_header_authentication_siteminder"></a>Request-Header Authentication (Siteminder)</h5>
<div class="paragraph">
<p>An external authentication system may supply information to the application by setting specific headers on the HTTP request.
A well-known example of this is Siteminder, which passes the username in a header called <code>SM_USER</code>.
This mechanism is supported by the class <code>RequestHeaderAuthenticationFilter</code> which simply extracts the username from the header.
It defaults to using the name <code>SM_USER</code> as the header name.
See the Javadoc for more details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that when using a system like this, the framework performs no authentication checks at all and it is <em>extremely</em> important that the external system is configured properly and protects all access to the application.
If an attacker is able to forge the headers in their original request without this being detected then they could potentially choose any username they wished.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_siteminder_example_configuration"><a class="anchor" href="#_siteminder_example_configuration"></a>Siteminder Example Configuration</h6>
<div class="paragraph">
<p>A typical configuration using this filter would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http&gt;
&lt;!-- Additional http configuration omitted --&gt;
&lt;security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter"&gt;
&lt;property name="principalRequestHeader" value="SM_USER"/&gt;
&lt;property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
&lt;property name="preAuthenticatedUserDetailsService"&gt;
	&lt;bean id="userDetailsServiceWrapper"
		class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;property name="userDetailsService" ref="userDetailsService"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
&lt;/security:authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve assumed here that the <a href="#ns-config">security namespace</a> is being used for configuration.
It&#8217;s also assumed that you have added a <code>UserDetailsService</code> (called "userDetailsService") to your configuration to load the user&#8217;s roles.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_java_ee_container_authentication"><a class="anchor" href="#_java_ee_container_authentication"></a>Java EE Container Authentication</h5>
<div class="paragraph">
<p>The class <code>J2eePreAuthenticatedProcessingFilter</code> will extract the username from the <code>userPrincipal</code> property of the <code>HttpServletRequest</code>.
Use of this filter would usually be combined with the use of Java EE roles as described above in <a href="#j2ee-preauth-details">J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</a>.</p>
</div>
<div class="paragraph">
<p>There is a sample application in the codebase which uses this approach, so get hold of the code from github and have a look at the application context file if you are interested.
The code is in the <code>samples/xml/preauth</code> directory.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-jaas"><a class="anchor" href="#servlet-jaas"></a>Java Authentication and Authorization Service (JAAS) Provider</h3>
<div class="sect3">
<h4 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h4>
<div class="paragraph">
<p>Spring Security provides a package able to delegate authentication requests to the Java Authentication and Authorization Service (JAAS).
This package is discussed in detail below.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-abstractjaasauthenticationprovider"><a class="anchor" href="#jaas-abstractjaasauthenticationprovider"></a>AbstractJaasAuthenticationProvider</h4>
<div class="paragraph">
<p>The <code>AbstractJaasAuthenticationProvider</code> is the basis for the provided JAAS <code>AuthenticationProvider</code> implementations.
Subclasses must implement a method that creates the <code>LoginContext</code>.
The <code>AbstractJaasAuthenticationProvider</code> has a number of dependencies that can be injected into it that are discussed below.</p>
</div>
<div class="sect4">
<h5 id="jaas-callbackhandler"><a class="anchor" href="#jaas-callbackhandler"></a>JAAS CallbackHandler</h5>
<div class="paragraph">
<p>Most JAAS <code>LoginModule</code> s require a callback of some sort.
These callbacks are usually used to obtain the username and password from the user.</p>
</div>
<div class="paragraph">
<p>In a Spring Security deployment, Spring Security is responsible for this user interaction (via the authentication mechanism).
Thus, by the time the authentication request is delegated through to JAAS, Spring Security&#8217;s authentication mechanism will already have fully-populated an <code>Authentication</code> object containing all the information required by the JAAS <code>LoginModule</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, the JAAS package for Spring Security provides two default callback handlers, <code>JaasNameCallbackHandler</code> and <code>JaasPasswordCallbackHandler</code>.
Each of these callback handlers implement <code>JaasAuthenticationCallbackHandler</code>.
In most cases these callback handlers can simply be used without understanding the internal mechanics.</p>
</div>
<div class="paragraph">
<p>For those needing full control over the callback behavior, internally <code>AbstractJaasAuthenticationProvider</code> wraps these <code>JaasAuthenticationCallbackHandler</code> s with an <code>InternalCallbackHandler</code>.
The <code>InternalCallbackHandler</code> is the class that actually implements JAAS normal <code>CallbackHandler</code> interface.
Any time that the JAAS <code>LoginModule</code> is used, it is passed a list of application context configured <code>InternalCallbackHandler</code> s.
If the <code>LoginModule</code> requests a callback against the <code>InternalCallbackHandler</code> s, the callback is in-turn passed to the <code>JaasAuthenticationCallbackHandler</code> s being wrapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="jaas-authoritygranter"><a class="anchor" href="#jaas-authoritygranter"></a>JAAS AuthorityGranter</h5>
<div class="paragraph">
<p>JAAS works with principals.
Even "roles" are represented as principals in JAAS.
Spring Security, on the other hand, works with <code>Authentication</code> objects.
Each <code>Authentication</code> object contains a single principal, and multiple <code>GrantedAuthority</code> s.
To facilitate mapping between these different concepts, Spring Security&#8217;s JAAS package includes an <code>AuthorityGranter</code> interface.</p>
</div>
<div class="paragraph">
<p>An <code>AuthorityGranter</code> is responsible for inspecting a JAAS principal and returning a set of <code>String</code> s, representing the authorities assigned to the principal.
For each returned authority string, the <code>AbstractJaasAuthenticationProvider</code> creates a <code>JaasGrantedAuthority</code> (which implements Spring Security&#8217;s <code>GrantedAuthority</code> interface) containing the authority string and the JAAS principal that the <code>AuthorityGranter</code> was passed.
The <code>AbstractJaasAuthenticationProvider</code> obtains the JAAS principals by firstly successfully authenticating the user&#8217;s credentials using the JAAS <code>LoginModule</code>, and then accessing the <code>LoginContext</code> it returns.
A call to <code>LoginContext.getSubject().getPrincipals()</code> is made, with each resulting principal passed to each <code>AuthorityGranter</code> defined against the <code>AbstractJaasAuthenticationProvider.setAuthorityGranters(List)</code> property.</p>
</div>
<div class="paragraph">
<p>Spring Security does not include any production <code>AuthorityGranter</code> s given that every JAAS principal has an implementation-specific meaning.
However, there is a <code>TestAuthorityGranter</code> in the unit tests that demonstrates a simple <code>AuthorityGranter</code> implementation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-defaultjaasauthenticationprovider"><a class="anchor" href="#jaas-defaultjaasauthenticationprovider"></a>DefaultJaasAuthenticationProvider</h4>
<div class="paragraph">
<p>The <code>DefaultJaasAuthenticationProvider</code> allows a JAAS <code>Configuration</code> object to be injected into it as a dependency.
It then creates a <code>LoginContext</code> using the injected JAAS <code>Configuration</code>.
This means that <code>DefaultJaasAuthenticationProvider</code> is not bound any particular implementation of <code>Configuration</code> as <code>JaasAuthenticationProvider</code> is.</p>
</div>
<div class="sect4">
<h5 id="jaas-inmemoryconfiguration"><a class="anchor" href="#jaas-inmemoryconfiguration"></a>InMemoryConfiguration</h5>
<div class="paragraph">
<p>In order to make it easy to inject a <code>Configuration</code> into <code>DefaultJaasAuthenticationProvider</code>, a default in-memory implementation named <code>InMemoryConfiguration</code> is provided.
The implementation constructor accepts a <code>Map</code> where each key represents a login configuration name and the value represents an <code>Array</code> of <code>AppConfigurationEntry</code> s.
<code>InMemoryConfiguration</code> also supports a default <code>Array</code> of <code>AppConfigurationEntry</code> objects that will be used if no mapping is found within the provided <code>Map</code>.
For details, refer to the class level javadoc of <code>InMemoryConfiguration</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jaas-djap-config"><a class="anchor" href="#jaas-djap-config"></a>DefaultJaasAuthenticationProvider Example Configuration</h5>
<div class="paragraph">
<p>While the Spring configuration for <code>InMemoryConfiguration</code> can be more verbose than the standard JAAS configuration files, using it in conjunction with <code>DefaultJaasAuthenticationProvider</code> is more flexible than <code>JaasAuthenticationProvider</code> since it not dependant on the default <code>Configuration</code> implementation.</p>
</div>
<div class="paragraph">
<p>An example configuration of <code>DefaultJaasAuthenticationProvider</code> using <code>InMemoryConfiguration</code> is provided below.
Note that custom implementations of <code>Configuration</code> can easily be injected into <code>DefaultJaasAuthenticationProvider</code> as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthProvider"
class="org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider"&gt;
&lt;property name="configuration"&gt;
&lt;bean class="org.springframework.security.authentication.jaas.memory.InMemoryConfiguration"&gt;
&lt;constructor-arg&gt;
	&lt;map&gt;
	&lt;!--
	SPRINGSECURITY is the default loginContextName
	for AbstractJaasAuthenticationProvider
	--&gt;
	&lt;entry key="SPRINGSECURITY"&gt;
	&lt;array&gt;
	&lt;bean class="javax.security.auth.login.AppConfigurationEntry"&gt;
		&lt;constructor-arg value="sample.SampleLoginModule" /&gt;
		&lt;constructor-arg&gt;
		&lt;util:constant static-field=
			"javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED"/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg&gt;
		&lt;map&gt;&lt;/map&gt;
		&lt;/constructor-arg&gt;
		&lt;/bean&gt;
	&lt;/array&gt;
	&lt;/entry&gt;
	&lt;/map&gt;
	&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
&lt;list&gt;
	&lt;!-- You will need to write your own implementation of AuthorityGranter --&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-jaasauthenticationprovider"><a class="anchor" href="#jaas-jaasauthenticationprovider"></a>JaasAuthenticationProvider</h4>
<div class="paragraph">
<p>The <code>JaasAuthenticationProvider</code> assumes the default <code>Configuration</code> is an instance of <a href="https://download.oracle.com/javase/1.4.2/docs/guide/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html"> ConfigFile</a>.
This assumption is made in order to attempt to update the <code>Configuration</code>.
The <code>JaasAuthenticationProvider</code> then uses the default <code>Configuration</code> to create the <code>LoginContext</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a JAAS login configuration file, <code>/WEB-INF/login.conf</code>, with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">JAASTest {
	sample.SampleLoginModule required;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like all Spring Security beans, the <code>JaasAuthenticationProvider</code> is configured via the application context.
The following definitions would correspond to the above JAAS login configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthenticationProvider"
class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
&lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
&lt;property name="loginContextName" value="JAASTest"/&gt;
&lt;property name="callbackHandlers"&gt;
&lt;list&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
	&lt;list&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
	&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-apiprovision"><a class="anchor" href="#jaas-apiprovision"></a>Running as a Subject</h4>
<div class="paragraph">
<p>If configured, the <code>JaasApiIntegrationFilter</code> will attempt to run as the <code>Subject</code> on the <code>JaasAuthenticationToken</code>.
This means that the <code>Subject</code> can be accessed using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Subject subject = Subject.getSubject(AccessController.getContext());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This integration can easily be configured using the <a href="#nsa-http-jaas-api-provision">jaas-api-provision</a> attribute.
This feature is useful when integrating with legacy or external API&#8217;s that rely on the JAAS Subject being populated.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-cas"><a class="anchor" href="#servlet-cas"></a>CAS Authentication</h3>
<div class="sect3">
<h4 id="cas-overview"><a class="anchor" href="#cas-overview"></a>Overview</h4>
<div class="paragraph">
<p>JA-SIG produces an enterprise-wide single sign on system known as CAS.
Unlike other initiatives, JA-SIG&#8217;s Central Authentication Service is open source, widely used, simple to understand, platform independent, and supports proxy capabilities.
Spring Security fully supports CAS, and provides an easy migration path from single-application deployments of Spring Security through to multiple-application deployments secured by an enterprise-wide CAS server.</p>
</div>
<div class="paragraph">
<p>You can learn more about CAS at <a href="https://www.apereo.org" class="bare">https://www.apereo.org</a>.
You will also need to visit this site to download the CAS Server files.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-how-it-works"><a class="anchor" href="#cas-how-it-works"></a>How CAS Works</h4>
<div class="paragraph">
<p>Whilst the CAS web site contains documents that detail the architecture of CAS, we present the general overview again here within the context of Spring Security.
Spring Security 3.x supports CAS 3.
At the time of writing, the CAS server was at version 3.4.</p>
</div>
<div class="paragraph">
<p>Somewhere in your enterprise you will need to setup a CAS server.
The CAS server is simply a standard WAR file, so there isn&#8217;t anything difficult about setting up your server.
Inside the WAR file you will customise the login and other single sign on pages displayed to users.</p>
</div>
<div class="paragraph">
<p>When deploying a CAS 3.4 server, you will also need to specify an <code>AuthenticationHandler</code> in the <code>deployerConfigContext.xml</code> included with CAS.
The <code>AuthenticationHandler</code> has a simple method that returns a boolean as to whether a given set of Credentials is valid.
Your <code>AuthenticationHandler</code> implementation will need to link into some type of backend authentication repository, such as an LDAP server or database.
CAS itself includes numerous <code>AuthenticationHandler</code> s out of the box to assist with this.
When you download and deploy the server war file, it is set up to successfully authenticate users who enter a password matching their username, which is useful for testing.</p>
</div>
<div class="paragraph">
<p>Apart from the CAS server itself, the other key players are of course the secure web applications deployed throughout your enterprise.
These web applications are known as "services".
There are three types of services.
Those that authenticate service tickets, those that can obtain proxy tickets, and those that authenticate proxy tickets.
Authenticating a proxy ticket differs because the list of proxies must be validated and often times a proxy ticket can be reused.</p>
</div>
<div class="sect4">
<h5 id="cas-sequence"><a class="anchor" href="#cas-sequence"></a>Spring Security and CAS Interaction Sequence</h5>
<div class="paragraph">
<p>The basic interaction between a web browser, CAS server and a Spring Security-secured service is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The web user is browsing the service&#8217;s public pages.
CAS or Spring Security is not involved.</p>
</li>
<li>
<p>The user eventually requests a page that is either secure or one of the beans it uses is secure.
Spring Security&#8217;s <code>ExceptionTranslationFilter</code> will detect the <code>AccessDeniedException</code> or <code>AuthenticationException</code>.</p>
</li>
<li>
<p>Because the user&#8217;s <code>Authentication</code> object (or lack thereof) caused an <code>AuthenticationException</code>, the <code>ExceptionTranslationFilter</code> will call the configured <code>AuthenticationEntryPoint</code>.
If using CAS, this will be the <code>CasAuthenticationEntryPoint</code> class.</p>
</li>
<li>
<p>The <code>CasAuthenticationEntryPoint</code> will redirect the user&#8217;s browser to the CAS server.
It will also indicate a <code>service</code> parameter, which is the callback URL for the Spring Security service (your application).
For example, the URL to which the browser is redirected might be <a href="https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas" class="bare">https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas</a>.</p>
</li>
<li>
<p>After the user&#8217;s browser redirects to CAS, they will be prompted for their username and password.
If the user presents a session cookie which indicates they&#8217;ve previously logged on, they will not be prompted to login again (there is an exception to this procedure, which we&#8217;ll cover later).
CAS will use the <code>PasswordHandler</code> (or <code>AuthenticationHandler</code> if using CAS 3.0) discussed above to decide whether the username and password is valid.</p>
</li>
<li>
<p>Upon successful login, CAS will redirect the user&#8217;s browser back to the original service.
It will also include a <code>ticket</code> parameter, which is an opaque string representing the "service ticket".
Continuing our earlier example, the URL the browser is redirected to might be <a href="https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ" class="bare">https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ</a>.</p>
</li>
<li>
<p>Back in the service web application, the <code>CasAuthenticationFilter</code> is always listening for requests to <code>/login/cas</code> (this is configurable, but we&#8217;ll use the defaults in this introduction).
The processing filter will construct a <code>UsernamePasswordAuthenticationToken</code> representing the service ticket.
The principal will be equal to <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>, whilst the credentials will be the service ticket opaque value.
This authentication request will then be handed to the configured <code>AuthenticationManager</code>.</p>
</li>
<li>
<p>The <code>AuthenticationManager</code> implementation will be the <code>ProviderManager</code>, which is in turn configured with the <code>CasAuthenticationProvider</code>.
The <code>CasAuthenticationProvider</code> only responds to <code>UsernamePasswordAuthenticationToken</code> s containing the CAS-specific principal (such as <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>) and <code>CasAuthenticationToken</code> s (discussed later).</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will validate the service ticket using a <code>TicketValidator</code> implementation.
This will typically be a <code>Cas20ServiceTicketValidator</code> which is one of the classes included in the CAS client library.
In the event the application needs to validate proxy tickets, the <code>Cas20ProxyTicketValidator</code> is used.
The <code>TicketValidator</code> makes an HTTPS request to the CAS server in order to validate the service ticket.
It may also include a proxy callback URL, which is included in this example: <a href="https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor" class="bare">https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor</a>.</p>
</li>
<li>
<p>Back on the CAS server, the validation request will be received.
If the presented service ticket matches the service URL the ticket was issued to, CAS will provide an affirmative response in XML indicating the username.
If any proxy was involved in the authentication (discussed below), the list of proxies is also included in the XML response.</p>
</li>
<li>
<p>[OPTIONAL] If the request to the CAS validation service included the proxy callback URL (in the <code>pgtUrl</code> parameter), CAS will include a <code>pgtIou</code> string in the XML response.
This <code>pgtIou</code> represents a proxy-granting ticket IOU.
The CAS server will then create its own HTTPS connection back to the <code>pgtUrl</code>.
This is to mutually authenticate the CAS server and the claimed service URL.
The HTTPS connection will be used to send a proxy granting ticket to the original web application.
For example, <a href="https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH" class="bare">https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH</a>.</p>
</li>
<li>
<p>The <code>Cas20TicketValidator</code> will parse the XML received from the CAS server.
It will return to the <code>CasAuthenticationProvider</code> a <code>TicketResponse</code>, which includes the username (mandatory), proxy list (if any were involved), and proxy-granting ticket IOU (if the proxy callback was requested).</p>
</li>
<li>
<p>Next <code>CasAuthenticationProvider</code> will call a configured <code>CasProxyDecider</code>.
The <code>CasProxyDecider</code> indicates whether the proxy list in the <code>TicketResponse</code> is acceptable to the service.
Several implementations are provided with Spring Security: <code>RejectProxyTickets</code>, <code>AcceptAnyCasProxy</code> and <code>NamedCasProxyDecider</code>.
These names are largely self-explanatory, except <code>NamedCasProxyDecider</code> which allows a <code>List</code> of trusted proxies to be provided.</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will next request a <code>AuthenticationUserDetailsService</code> to load the <code>GrantedAuthority</code> objects that apply to the user contained in the <code>Assertion</code>.</p>
</li>
<li>
<p>If there were no problems, <code>CasAuthenticationProvider</code> constructs a <code>CasAuthenticationToken</code> including the details contained in the <code>TicketResponse</code> and the <code>GrantedAuthority</code>s.</p>
</li>
<li>
<p>Control then returns to <code>CasAuthenticationFilter</code>, which places the created <code>CasAuthenticationToken</code> in the security context.</p>
</li>
<li>
<p>The user&#8217;s browser is redirected to the original page that caused the <code>AuthenticationException</code> (or a custom destination depending on the configuration).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s good that you&#8217;re still here!
Let&#8217;s now look at how this is configured</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-client"><a class="anchor" href="#cas-client"></a>Configuration of CAS Client</h4>
<div class="paragraph">
<p>The web application side of CAS is made easy due to Spring Security.
It is assumed you already know the basics of using Spring Security, so these are not covered again below.
We&#8217;ll assume a namespace based configuration is being used and add in the CAS beans as required.
Each section builds upon the previous section.
A full CAS sample application can be found in the Spring Security <a href="#samples">Samples</a>.</p>
</div>
<div class="sect4">
<h5 id="cas-st"><a class="anchor" href="#cas-st"></a>Service Ticket Authentication</h5>
<div class="paragraph">
<p>This section describes how to setup Spring Security to authenticate Service Tickets.
Often times this is all a web application requires.
You will need to add a <code>ServiceProperties</code> bean to your application context.
This represents your CAS service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
&lt;property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/&gt;
&lt;property name="sendRenew" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>service</code> must equal a URL that will be monitored by the <code>CasAuthenticationFilter</code>.
The <code>sendRenew</code> defaults to false, but should be set to true if your application is particularly sensitive.
What this parameter does is tell the CAS login service that a single sign on login is unacceptable.
Instead, the user will need to re-enter their username and password in order to gain access to the service.</p>
</div>
<div class="paragraph">
<p>The following beans should be configured to commence the CAS authentication process (assuming you&#8217;re using a namespace configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:custom-filter position="CAS_FILTER" ref="casFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
&lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For CAS to operate, the <code>ExceptionTranslationFilter</code> must have its <code>authenticationEntryPoint</code> property set to the <code>CasAuthenticationEntryPoint</code> bean.
This can easily be done using <a href="#nsa-http-entry-point-ref">entry-point-ref</a> as is done in the example above.
The <code>CasAuthenticationEntryPoint</code> must refer to the <code>ServiceProperties</code> bean (discussed above), which provides the URL to the enterprise&#8217;s CAS login server.
This is where the user&#8217;s browser will be redirected.</p>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationFilter</code> has very similar properties to the <code>UsernamePasswordAuthenticationFilter</code> (used for form-based logins).
You can use these properties to customize things like behavior for authentication success and failure.</p>
</div>
<div class="paragraph">
<p>Next you need to add a <code>CasAuthenticationProvider</code> and its collaborators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
&lt;property name="authenticationUserDetailsService"&gt;
	&lt;bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;constructor-arg ref="userService" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="serviceProperties" ref="serviceProperties" /&gt;
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
	&lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
&lt;/bean&gt;

&lt;security:user-service id="userService"&gt;
&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used.
This is not safe for production, but makes reading
in samples easier.
Normally passwords should be hashed using BCrypt --&gt;
&lt;security:user name="joe" password="{noop}joe" authorities="ROLE_USER" /&gt;
...
&lt;/security:user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> uses a <code>UserDetailsService</code> instance to load the authorities for a user, once they have been authenticated by CAS.
We&#8217;ve shown a simple in-memory setup here.
Note that the <code>CasAuthenticationProvider</code> does not actually use the password for authentication, but it does use the authorities.</p>
</div>
<div class="paragraph">
<p>The beans are all reasonably self-explanatory if you refer back to the <a href="#cas-how-it-works">How CAS Works</a> section.</p>
</div>
<div class="paragraph">
<p>This completes the most basic configuration for CAS.
If you haven&#8217;t made any mistakes, your web application should happily work within the framework of CAS single sign on.
No other parts of Spring Security need to be concerned about the fact CAS handled authentication.
In the following sections we will discuss some (optional) more advanced configurations.</p>
</div>
</div>
<div class="sect4">
<h5 id="cas-singlelogout"><a class="anchor" href="#cas-singlelogout"></a>Single Logout</h5>
<div class="paragraph">
<p>The CAS protocol supports Single Logout and can be easily added to your Spring Security configuration.
Below are updates to the Spring Security configuration that handle Single Logout</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:logout logout-success-url="/cas-logout.jsp"/&gt;
&lt;security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt;
&lt;security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt;
&lt;/security:http&gt;

&lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt;
&lt;bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt;

&lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt;
&lt;bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt;
&lt;constructor-arg value="https://localhost:9443/cas/logout"/&gt;
&lt;constructor-arg&gt;
	&lt;bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt;
&lt;/constructor-arg&gt;
&lt;property name="filterProcessesUrl" value="/logout/cas"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>logout</code> element logs the user out of the local application, but does not end the session with the CAS server or any other applications that have been logged into.
The <code>requestSingleLogoutFilter</code> filter will allow the URL of <code>/spring_security_cas_logout</code> to be requested to redirect the application to the configured CAS Server logout URL.
Then the CAS Server will send a Single Logout request to all the services that were signed into.
The <code>singleLogoutFilter</code> handles the Single Logout request by looking up the <code>HttpSession</code> in a static <code>Map</code> and then invalidating it.</p>
</div>
<div class="paragraph">
<p>It might be confusing why both the <code>logout</code> element and the <code>singleLogoutFilter</code> are needed.
It is considered best practice to logout locally first since the <code>SingleSignOutFilter</code> just stores the <code>HttpSession</code> in a static <code>Map</code> in order to call invalidate on it.
With the configuration above, the flow of logout would be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user requests <code>/logout</code> which would log the user out of the local application and send the user to the logout success page.</p>
</li>
<li>
<p>The logout success page, <code>/cas-logout.jsp</code>, should instruct the user to click a link pointing to <code>/logout/cas</code> in order to logout out of all applications.</p>
</li>
<li>
<p>When the user clicks the link, the user is redirected to the CAS single logout URL (<a href="https://localhost:9443/cas/logout" class="bare">https://localhost:9443/cas/logout</a>).</p>
</li>
<li>
<p>On the CAS Server side, the CAS single logout URL then submits single logout requests to all the CAS Services.
On the CAS Service side, JASIG&#8217;s <code>SingleSignOutFilter</code> processes the logout request by invalidating the original session.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next step is to add the following to your web.xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.CharacterEncodingFilter
&lt;/filter-class&gt;
&lt;init-param&gt;
	&lt;param-name&gt;encoding&lt;/param-name&gt;
	&lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
&lt;listener-class&gt;
	org.jasig.cas.client.session.SingleSignOutHttpSessionListener
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the SingleSignOutFilter you might encounter some encoding issues.
Therefore it is recommended to add the <code>CharacterEncodingFilter</code> to ensure that the character encoding is correct when using the <code>SingleSignOutFilter</code>.
Again, refer to JASIG&#8217;s documentation for details.
The <code>SingleSignOutHttpSessionListener</code> ensures that when an <code>HttpSession</code> expires, the mapping used for single logout is removed.</p>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt-client"><a class="anchor" href="#cas-pt-client"></a>Authenticating to a Stateless Service with CAS</h5>
<div class="paragraph">
<p>This section describes how to authenticate to a service using CAS.
In other words, this section discusses how to setup a client that uses a service that authenticates with CAS.
The next section describes how to setup a stateless service to Authenticate using CAS.</p>
</div>
<div class="sect5">
<h6 id="cas-pt-client-config"><a class="anchor" href="#cas-pt-client-config"></a>Configuring CAS to Obtain Proxy Granting Tickets</h6>
<div class="paragraph">
<p>In order to authenticate to a stateless service, the application needs to obtain a proxy granting ticket (PGT).
This section describes how to configure Spring Security to obtain a PGT building upon thencas-st[Service Ticket Authentication] configuration.</p>
</div>
<div class="paragraph">
<p>The first step is to include a <code>ProxyGrantingTicketStorage</code> in your Spring Security configuration.
This is used to store PGT&#8217;s that are obtained by the <code>CasAuthenticationFilter</code> so that they can be used to obtain proxy tickets.
An example configuration is shown below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!--
NOTE: In a real application you should not use an in memory implementation.
You will also want to ensure to clean up expired tickets by calling
ProxyGrantingTicketStorage.cleanup()
--&gt;
&lt;bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to update the <code>CasAuthenticationProvider</code> to be able to obtain proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
The <code>proxyCallbackUrl</code> should be set to a URL that the application will receive PGT&#8217;s at.
Last, the configuration should also reference the <code>ProxyGrantingTicketStorage</code> so it can use a PGT to obtain proxy tickets.
You can find an example of the configuration changes that should be made below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
		&lt;property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/&gt;
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last step is to update the <code>CasAuthenticationFilter</code> to accept PGT and to store them in the <code>ProxyGrantingTicketStorage</code>.
It is important the <code>proxyReceptorUrl</code> matches the <code>proxyCallbackUrl</code> of the <code>Cas20ProxyTicketValidator</code>.
An example configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
	...
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="cas-pt-client-sample"><a class="anchor" href="#cas-pt-client-sample"></a>Calling a Stateless Service Using a Proxy Ticket</h6>
<div class="paragraph">
<p>Now that Spring Security obtains PGTs, you can use them to create proxy tickets which can be used to authenticate to a stateless service.
The CAS <a href="#samples">sample application</a> contains a working example in the <code>ProxyTicketSampleServlet</code>.
Example code can be found below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt"><a class="anchor" href="#cas-pt"></a>Proxy Ticket Authentication</h5>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> distinguishes between stateful and stateless clients.
A stateful client is considered any that submits to the <code>filterProcessUrl</code> of the <code>CasAuthenticationFilter</code>.
A stateless client is any that presents an authentication request to <code>CasAuthenticationFilter</code> on a URL other than the <code>filterProcessUrl</code>.</p>
</div>
<div class="paragraph">
<p>Because remoting protocols have no way of presenting themselves within the context of an <code>HttpSession</code>, it isn&#8217;t possible to rely on the default practice of storing the security context in the session between requests.
Furthermore, because the CAS server invalidates a ticket after it has been validated by the <code>TicketValidator</code>, presenting the same proxy ticket on subsequent requests will not work.</p>
</div>
<div class="paragraph">
<p>One obvious option is to not use CAS at all for remoting protocol clients.
However, this would eliminate many of the desirable features of CAS.
As a middle-ground, the <code>CasAuthenticationProvider</code> uses a <code>StatelessTicketCache</code>.
This is used solely for stateless clients which use a principal equal to <code>CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER</code>.
What happens is the <code>CasAuthenticationProvider</code> will store the resulting <code>CasAuthenticationToken</code> in the <code>StatelessTicketCache</code>, keyed on the proxy ticket.
Accordingly, remoting protocol clients can present the same proxy ticket and the <code>CasAuthenticationProvider</code> will not need to contact the CAS server for validation (aside from the first request).
Once authenticated, the proxy ticket could be used for URLs other than the original target service.</p>
</div>
<div class="paragraph">
<p>This section builds upon the previous sections to accommodate proxy ticket authentication.
The first step is to specify to authenticate all artifacts as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
...
&lt;property name="authenticateAllArtifacts" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to specify <code>serviceProperties</code> and the <code>authenticationDetailsSource</code> for the <code>CasAuthenticationFilter</code>.
The <code>serviceProperties</code> property instructs the <code>CasAuthenticationFilter</code> to attempt to authenticate all artifacts instead of only ones present on the <code>filterProcessUrl</code>.
The <code>ServiceAuthenticationDetailsSource</code> creates a <code>ServiceAuthenticationDetails</code> that ensures the current URL, based upon the <code>HttpServletRequest</code>, is used as the service URL when validating the ticket.
The method for generating the service URL can be customized by injecting a custom <code>AuthenticationDetailsSource</code> that returns a custom <code>ServiceAuthenticationDetails</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
...
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;property name="authenticationDetailsSource"&gt;
	&lt;bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"&gt;
	&lt;constructor-arg ref="serviceProperties"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also need to update the <code>CasAuthenticationProvider</code> to handle proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
You will need to configure the <code>statelessTicketCache</code> and which proxies you want to accept.
You can find an example of the updates required to accept all proxies below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
	&lt;property name="acceptAnyProxy" value="true"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="statelessTicketCache"&gt;
	&lt;bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache"&gt;
	&lt;property name="cache"&gt;
		&lt;bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose"&gt;
		&lt;constructor-arg value="casTickets"/&gt;
		&lt;constructor-arg value="50"/&gt;
		&lt;constructor-arg value="true"/&gt;
		&lt;constructor-arg value="false"/&gt;
		&lt;constructor-arg value="3600"/&gt;
		&lt;constructor-arg value="900"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-x509"><a class="anchor" href="#servlet-x509"></a>X.509 Authentication</h3>
<div class="sect3">
<h4 id="x509-overview"><a class="anchor" href="#x509-overview"></a>Overview</h4>
<div class="paragraph">
<p>The most common use of X.509 certificate authentication is in verifying the identity of a server when using SSL, most commonly when using HTTPS from a browser.
The browser will automatically check that the certificate presented by a server has been issued (ie digitally signed) by one of a list of trusted certificate authorities which it maintains.</p>
</div>
<div class="paragraph">
<p>You can also use SSL with "mutual authentication"; the server will then request a valid certificate from the client as part of the SSL handshake.
The server will authenticate the client by checking that its certificate is signed by an acceptable authority.
If a valid certificate has been provided, it can be obtained through the servlet API in an application.
Spring Security X.509 module extracts the certificate using a filter.
It maps the certificate to an application user and loads that user&#8217;s set of granted authorities for use with the standard Spring Security infrastructure.</p>
</div>
<div class="paragraph">
<p>You should be familiar with using certificates and setting up client authentication for your servlet container before attempting to use it with Spring Security.
Most of the work is in creating and installing suitable certificates and keys.
For example, if you&#8217;re using Tomcat then read the instructions here <a href="https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html</a>.
It&#8217;s important that you get this working before trying it out with Spring Security</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_x_509_authentication_to_your_web_application"><a class="anchor" href="#_adding_x_509_authentication_to_your_web_application"></a>Adding X.509 Authentication to Your Web Application</h4>
<div class="paragraph">
<p>Enabling X.509 client authentication is very straightforward.
Just add the <code>&lt;x509/&gt;</code> element to your http security namespace configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
	&lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The element has two optional attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject-principal-regex</code>.
The regular expression used to extract a username from the certificate&#8217;s subject name.
The default value is shown above.
This is the username which will be passed to the <code>UserDetailsService</code> to load the authorities for the user.</p>
</li>
<li>
<p><code>user-service-ref</code>.
This is the bean Id of the <code>UserDetailsService</code> to be used with X.509.
It isn&#8217;t needed if there is only one defined in your application context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>subject-principal-regex</code> should contain a single group.
For example the default expression "CN=(.*?)," matches the common name field.
So if the subject name in the certificate is "CN=Jimi Hendrix, OU=&#8230;&#8203;", this will give a user name of "Jimi Hendrix".
The matches are case insensitive.
So "emailAddress=(.*?)," will match "EMAILADDRESS=<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>,CN=&#8230;&#8203;" giving a user name "<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>".
If the client presents a certificate and a valid username is successfully extracted, then there should be a valid <code>Authentication</code> object in the security context.
If no certificate is found, or no corresponding user could be found then the security context will remain empty.
This means that you can easily use X.509 authentication with other options such as a form-based login.</p>
</div>
</div>
<div class="sect3">
<h4 id="x509-ssl-config"><a class="anchor" href="#x509-ssl-config"></a>Setting up SSL in Tomcat</h4>
<div class="paragraph">
<p>There are some pre-generated certificates in the <code>samples/certificate</code> directory in the Spring Security project.
You can use these to enable SSL for testing if you don&#8217;t want to generate your own.
The file <code>server.jks</code> contains the server certificate, private key and the issuing certificate authority certificate.
There are also some client certificate files for the users from the sample applications.
You can install these in your browser to enable SSL client authentication.</p>
</div>
<div class="paragraph">
<p>To run tomcat with SSL support, drop the <code>server.jks</code> file into the tomcat <code>conf</code> directory and add the following connector to the <code>server.xml</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
			clientAuth="true" sslProtocol="TLS"
			keystoreFile="${catalina.home}/conf/server.jks"
			keystoreType="JKS" keystorePass="password"
			truststoreFile="${catalina.home}/conf/server.jks"
			truststoreType="JKS" truststorePass="password"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientAuth</code> can also be set to <code>want</code> if you still want SSL connections to succeed even if the client doesn&#8217;t provide a certificate.
Clients which don&#8217;t present a certificate won&#8217;t be able to access any objects secured by Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="runas"><a class="anchor" href="#runas"></a>Run-As Authentication Replacement</h3>
<div class="sect3">
<h4 id="runas-overview"><a class="anchor" href="#runas-overview"></a>Overview</h4>
<div class="paragraph">
<p>The <code>AbstractSecurityInterceptor</code> is able to temporarily replace the <code>Authentication</code> object in the <code>SecurityContext</code> and <code>SecurityContextHolder</code> during the secure object callback phase.
This only occurs if the original <code>Authentication</code> object was successfully processed by the <code>AuthenticationManager</code> and <code>AccessDecisionManager</code>.
The <code>RunAsManager</code> will indicate the replacement <code>Authentication</code> object, if any, that should be used during the <code>SecurityInterceptorCallback</code>.</p>
</div>
<div class="paragraph">
<p>By temporarily replacing the <code>Authentication</code> object during the secure object callback phase, the secured invocation will be able to call other objects which require different authentication and authorization credentials.
It will also be able to perform any internal security checks for specific <code>GrantedAuthority</code> objects.
Because Spring Security provides a number of helper classes that automatically configure remoting protocols based on the contents of the <code>SecurityContextHolder</code>, these run-as replacements are particularly useful when calling remote web services</p>
</div>
</div>
<div class="sect3">
<h4 id="runas-config"><a class="anchor" href="#runas-config"></a>Configuration</h4>
<div class="paragraph">
<p>A <code>RunAsManager</code> interface is provided by Spring Security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication buildRunAs(Authentication authentication, Object object,
	List&lt;ConfigAttribute&gt; config);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first method returns the <code>Authentication</code> object that should replace the existing <code>Authentication</code> object for the duration of the method invocation.
If the method returns <code>null</code>, it indicates no replacement should be made.
The second method is used by the <code>AbstractSecurityInterceptor</code> as part of its startup validation of configuration attributes.
The <code>supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code>RunAsManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
<div class="paragraph">
<p>One concrete implementation of a <code>RunAsManager</code> is provided with Spring Security.
The <code>RunAsManagerImpl</code> class returns a replacement <code>RunAsUserToken</code> if any <code>ConfigAttribute</code> starts with <code>RUN_AS_</code>.
If any such <code>ConfigAttribute</code> is found, the replacement <code>RunAsUserToken</code> will contain the same principal, credentials and granted authorities as the original <code>Authentication</code> object, along with a new <code>SimpleGrantedAuthority</code> for each <code>RUN_AS_</code> <code>ConfigAttribute</code>.
Each new <code>SimpleGrantedAuthority</code> will be prefixed with <code>ROLE_</code>, followed by the <code>RUN_AS</code> <code>ConfigAttribute</code>.
For example, a <code>RUN_AS_SERVER</code> will result in the replacement <code>RunAsUserToken</code> containing a <code>ROLE_RUN_AS_SERVER</code> granted authority.</p>
</div>
<div class="paragraph">
<p>The replacement <code>RunAsUserToken</code> is just like any other <code>Authentication</code> object.
It needs to be authenticated by the <code>AuthenticationManager</code>, probably via delegation to a suitable <code>AuthenticationProvider</code>.
The <code>RunAsImplAuthenticationProvider</code> performs such authentication.
It simply accepts as valid any <code>RunAsUserToken</code> presented.</p>
</div>
<div class="paragraph">
<p>To ensure malicious code does not create a <code>RunAsUserToken</code> and present it for guaranteed acceptance by the <code>RunAsImplAuthenticationProvider</code>, the hash of a key is stored in all generated tokens.
The <code>RunAsManagerImpl</code> and <code>RunAsImplAuthenticationProvider</code> is created in the bean context with the same key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="runAsManager"
	class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
	class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the same key, each <code>RunAsUserToken</code> can be validated it was created by an approved <code>RunAsManagerImpl</code>.
The <code>RunAsUserToken</code> is immutable after creation for security reasons</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout"><a class="anchor" href="#jc-logout"></a>Handling Logouts</h3>
<div class="sect3">
<h4 id="logout-java-configuration"><a class="anchor" href="#logout-java-configuration"></a>Logout Java/Kotlin Configuration</h4>
<div class="paragraph">
<p>When using the <code>{security-api-url}org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html[WebSecurityConfigurerAdapter]</code>, logout capabilities are automatically applied.
The default is that accessing the URL <code>/logout</code> will log the user out by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invalidating the HTTP Session</p>
</li>
<li>
<p>Cleaning up any RememberMe authentication that was configured</p>
</li>
<li>
<p>Clearing the <code>SecurityContextHolder</code></p>
</li>
<li>
<p>Redirect to <code>/login?logout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar to configuring login capabilities, however, you also have various options to further customize your logout requirements:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Logout Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        .logout(logout -&gt; logout                                                <i class="conum" data-value="1"></i><b>(1)</b>
            .logoutUrl("/my/logout")                                            <i class="conum" data-value="2"></i><b>(2)</b>
            .logoutSuccessUrl("/my/index")                                      <i class="conum" data-value="3"></i><b>(3)</b>
            .logoutSuccessHandler(logoutSuccessHandler)                         <i class="conum" data-value="4"></i><b>(4)</b>
            .invalidateHttpSession(true)                                        <i class="conum" data-value="5"></i><b>(5)</b>
            .addLogoutHandler(logoutHandler)                                    <i class="conum" data-value="6"></i><b>(6)</b>
            .deleteCookies(cookieNamesToClear)                                  <i class="conum" data-value="7"></i><b>(7)</b>
        )
        ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        logout {
            logoutUrl = "/my/logout"                              <i class="conum" data-value="1"></i><b>(1)</b>
            logoutSuccessUrl = "/my/index"                        <i class="conum" data-value="2"></i><b>(2)</b>
            logoutSuccessHandler = customLogoutSuccessHandler     <i class="conum" data-value="3"></i><b>(3)</b>
            invalidateHttpSession = true                          <i class="conum" data-value="4"></i><b>(4)</b>
            addLogoutHandler(logoutHandler)                       <i class="conum" data-value="5"></i><b>(5)</b>
            deleteCookies(cookieNamesToClear)                     <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Provides logout support.
This is automatically applied when using <code>WebSecurityConfigurerAdapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The URL that triggers log out to occur (default is <code>/logout</code>).
If CSRF protection is enabled (default), then the request must also be a POST.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The URL to redirect to after logout has occurred.
The default is <code>/login?logout</code>.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Let&#8217;s you specify a custom <code>LogoutSuccessHandler</code>.
If this is specified, <code>logoutSuccessUrl()</code> is ignored.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specify whether to invalidate the <code>HttpSession</code> at the time of logout.
This is <strong>true</strong> by default.
Configures the <code>SecurityContextLogoutHandler</code> under the covers.
For more information, please consult the {security-api-url}org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-[JavaDoc].</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Adds a <code>LogoutHandler</code>.
<code>SecurityContextLogoutHandler</code> is added as the last <code>LogoutHandler</code> by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Allows specifying the names of cookies to be removed on logout success.
This is a shortcut for adding a <code>CookieClearingLogoutHandler</code> explicitly.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Logouts can of course also be configured using the XML Namespace notation.
Please see the documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section for further details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Generally, in order to customize logout functionality, you can add
<code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]</code>
and/or
<code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[LogoutSuccessHandler]</code>
implementations.
For many common scenarios, these handlers are applied under the
covers when using the fluent API.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-logout"><a class="anchor" href="#ns-logout"></a>Logout XML Configuration</h4>
<div class="paragraph">
<p>The <code>logout</code> element adds support for logging out by navigating to a particular URL.
The default logout URL is <code>/logout</code>, but you can set it to something else using the <code>logout-url</code> attribute.
More information on other available attributes may be found in the namespace appendix.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-handler"><a class="anchor" href="#jc-logout-handler"></a>LogoutHandler</h4>
<div class="paragraph">
<p>Generally, <code>{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]</code>
implementations indicate classes that are able to participate in logout handling.
They are expected to be invoked to perform necessary clean-up.
As such they should
not throw exceptions.
Various implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html[PersistentTokenBasedRememberMeServices]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html[TokenBasedRememberMeServices]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html[CookieClearingLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/csrf/CsrfLogoutHandler.html[CsrfLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[SecurityContextLogoutHandler]</p>
</li>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/HeaderWriterLogoutHandler.html[HeaderWriterLogoutHandler]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please see <a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a> for details.</p>
</div>
<div class="paragraph">
<p>Instead of providing <code>LogoutHandler</code> implementations directly, the fluent API also provides shortcuts that provide the respective <code>LogoutHandler</code> implementations under the covers.
E.g. <code>deleteCookies()</code> allows specifying the names of one or more cookies to be removed on logout success.
This is a shortcut compared to adding a <code>CookieClearingLogoutHandler</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-success-handler"><a class="anchor" href="#jc-logout-success-handler"></a>LogoutSuccessHandler</h4>
<div class="paragraph">
<p>The <code>LogoutSuccessHandler</code> is called after a successful logout by the <code>LogoutFilter</code>, to handle e.g.
redirection or forwarding to the appropriate destination.
Note that the interface is almost the same as the <code>LogoutHandler</code> but may raise an exception.</p>
</div>
<div class="paragraph">
<p>The following implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{security-api-url}org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html[SimpleUrlLogoutSuccessHandler]</p>
</li>
<li>
<p>HttpStatusReturningLogoutSuccessHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned above, you don&#8217;t need to specify the <code>SimpleUrlLogoutSuccessHandler</code> directly.
Instead, the fluent API provides a shortcut by setting the <code>logoutSuccessUrl()</code>.
This will setup the <code>SimpleUrlLogoutSuccessHandler</code> under the covers.
The provided URL will be redirected to after a logout has occurred.
The default is <code>/login?logout</code>.</p>
</div>
<div class="paragraph">
<p>The <code>HttpStatusReturningLogoutSuccessHandler</code> can be interesting in REST API type scenarios.
Instead of redirecting to a URL upon the successful logout, this <code>LogoutSuccessHandler</code> allows you to provide a plain HTTP status code to be returned.
If not configured a status code 200 will be returned by default.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-references"><a class="anchor" href="#jc-logout-references"></a>Further Logout-Related References</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#ns-logout">Logout Handling</a></p>
</li>
<li>
<p><a href="#test-logout">Testing Logout</a></p>
</li>
<li>
<p><a href="#servletapi-logout">HttpServletRequest.logout()</a></p>
</li>
<li>
<p><a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a></p>
</li>
<li>
<p><a href="#servlet-considerations-csrf-logout">Logging Out</a> in section CSRF Caveats</p>
</li>
<li>
<p>Section <a href="#cas-singlelogout">Single Logout</a> (CAS protocol)</p>
</li>
<li>
<p>Documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-events"><a class="anchor" href="#servlet-events"></a>Authentication Events</h3>
<div class="paragraph">
<p>For each authentication that succeeds or fails, a <code>AuthenticationSuccessEvent</code> or <code>AuthenticationFailureEvent</code> is fired, respectively.</p>
</div>
<div class="paragraph">
<p>To listen for these events, you must first publish an <code>AuthenticationEventPublisher</code>.
Spring Security&#8217;s <code>DefaultAuthenticationEventPublisher</code> will probably do fine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    return new DefaultAuthenticationEventPublisher(applicationEventPublisher);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    return DefaultAuthenticationEventPublisher(applicationEventPublisher)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, you can use Spring&#8217;s <code>@EventListener</code> support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class AuthenticationEvents {
	@EventListener
    public void onSuccess(AuthenticationSuccessEvent success) {
		// ...
    }

    @EventListener
    public void onFailure(AuthenticationFailureEvent failures) {
		// ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class AuthenticationEvents {
    @EventListener
    fun onSuccess(success: AuthenticationSuccessEvent?) {
        // ...
    }

    @EventListener
    fun onFailure(failures: AbstractAuthenticationFailureEvent?) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While similar to <code>AuthenticationSuccessHandler</code> and <code>AuthenticationFailureHandler</code>, these are nice in that they can be used independently from the servlet API.</p>
</div>
<div class="sect3">
<h4 id="_adding_exception_mappings"><a class="anchor" href="#_adding_exception_mappings"></a>Adding Exception Mappings</h4>
<div class="paragraph">
<p><code>DefaultAuthenticationEventPublisher</code> by default will publish an <code>AuthenticationFailureEvent</code> for the following events:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadCredentialsException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernameNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AccountExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ProviderNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureProviderNotFoundEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisabledException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureDisabledEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LockedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureLockedEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationServiceException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureServiceExceptionEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CredentialsExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureCredentialsExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidBearerTokenException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The publisher does an exact <code>Exception</code> match, which means that sub-classes of these exceptions won&#8217;t also produce events.</p>
</div>
<div class="paragraph">
<p>To that end, you may want to supply additional mappings to the publisher via the <code>setAdditionalExceptionMappings</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    Map&lt;Class&lt;? extends AuthenticationException&gt;,
        Class&lt;? extends AuthenticationFailureEvent&gt;&gt; mapping =
            Collections.singletonMap(FooException.class, FooEvent.class);
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val mapping: Map&lt;Class&lt;out AuthenticationException&gt;, Class&lt;out AbstractAuthenticationFailureEvent&gt;&gt; =
            mapOf(Pair(FooException::class.java, FooEvent::class.java))
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_default_event"><a class="anchor" href="#_default_event"></a>Default Event</h4>
<div class="paragraph">
<p>And, you can supply a catch-all event to fire in the case of any <code>AuthenticationException</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent
        (GenericAuthenticationFailureEvent.class);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent(GenericAuthenticationFailureEvent::class.java)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authorization"><a class="anchor" href="#servlet-authorization"></a>Authorization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The advanced authorization capabilities within Spring Security represent one of the most compelling reasons for its popularity.
Irrespective of how you choose to authenticate - whether using a Spring Security-provided mechanism and provider, or integrating with a container or other non-Spring Security authentication authority - you will find the authorization services can be used within your application in a consistent and simple way.</p>
</div>
<div class="paragraph">
<p>In this part we&#8217;ll explore the different <code>AbstractSecurityInterceptor</code> implementations, which were introduced in Part I.
We then move on to explore how to fine-tune authorization through use of domain access control lists.</p>
</div>
<div class="sect2">
<h3 id="authz-arch"><a class="anchor" href="#authz-arch"></a>Authorization Architecture</h3>
<div class="sect3">
<h4 id="authz-authorities"><a class="anchor" href="#authz-authorities"></a>Authorities</h4>
<div class="paragraph">
<p><a href="#servlet-authentication-authentication"><code>Authentication</code></a>, discusses how all <code>Authentication</code> implementations store a list of <code>GrantedAuthority</code> objects.
These represent the authorities that have been granted to the principal.
the <code>GrantedAuthority</code> objects are inserted into the <code>Authentication</code> object by the <code>AuthenticationManager</code> and are later read by <code>AccessDecisionManager</code> s when making authorization decisions.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code> is an interface with only one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String getAuthority();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method allows
<code>AccessDecisionManager</code> s to obtain a precise <code>String</code> representation of the <code>GrantedAuthority</code>.
By returning a representation as a <code>String</code>, a <code>GrantedAuthority</code> can be easily "read" by most <code>AccessDecisionManager</code> s.
If a <code>GrantedAuthority</code> cannot be precisely represented as a <code>String</code>, the <code>GrantedAuthority</code> is considered "complex" and <code>getAuthority()</code> must return <code>null</code>.</p>
</div>
<div class="paragraph">
<p>An example of a "complex" <code>GrantedAuthority</code> would be an implementation that stores a list of operations and authority thresholds that apply to different customer account numbers.
Representing this complex <code>GrantedAuthority</code> as a <code>String</code> would be quite difficult, and as a result the <code>getAuthority()</code> method should return <code>null</code>.
This will indicate to any <code>AccessDecisionManager</code> that it will need to specifically support the <code>GrantedAuthority</code> implementation in order to understand its contents.</p>
</div>
<div class="paragraph">
<p>Spring Security includes one concrete <code>GrantedAuthority</code> implementation, <code>SimpleGrantedAuthority</code>.
This allows any user-specified <code>String</code> to be converted into a <code>GrantedAuthority</code>.
All <code>AuthenticationProvider</code> s included with the security architecture use <code>SimpleGrantedAuthority</code> to populate the <code>Authentication</code> object.</p>
</div>
</div>
<div class="sect3">
<h4 id="authz-pre-invocation"><a class="anchor" href="#authz-pre-invocation"></a>Pre-Invocation Handling</h4>
<div class="paragraph">
<p>Spring Security provides interceptors which control access to secure objects such as method invocations or web requests.
A pre-invocation decision on whether the invocation is allowed to proceed is made by the <code>AccessDecisionManager</code>.</p>
</div>
<div class="sect4">
<h5 id="authz-access-decision-manager"><a class="anchor" href="#authz-access-decision-manager"></a>The AccessDecisionManager</h5>
<div class="paragraph">
<p>The <code>AccessDecisionManager</code> is called by the <code>AbstractSecurityInterceptor</code> and is responsible for making final access control decisions.
The <code>AccessDecisionManager</code> interface contains three methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void decide(Authentication authentication, Object secureObject,
	Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AccessDecisionManager</code>'s <code>decide</code> method is passed all the relevant information it needs in order to make an authorization decision.
In particular, passing the secure <code>Object</code> enables those arguments contained in the actual secure object invocation to be inspected.
For example, let&#8217;s assume the secure object was a <code>MethodInvocation</code>.
It would be easy to query the <code>MethodInvocation</code> for any <code>Customer</code> argument, and then implement some sort of security logic in the <code>AccessDecisionManager</code> to ensure the principal is permitted to operate on that customer.
Implementations are expected to throw an <code>AccessDeniedException</code> if access is denied.</p>
</div>
<div class="paragraph">
<p>The <code>supports(ConfigAttribute)</code> method is called by the <code>AbstractSecurityInterceptor</code> at startup time to determine if the <code>AccessDecisionManager</code> can process the passed <code>ConfigAttribute</code>.
The <code>supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code>AccessDecisionManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-voting-based"><a class="anchor" href="#authz-voting-based"></a>Voting-Based AccessDecisionManager Implementations</h5>
<div class="paragraph">
<p>Whilst users can implement their own <code>AccessDecisionManager</code> to control all aspects of authorization, Spring Security includes several <code>AccessDecisionManager</code> implementations that are based on voting.
<a href="#authz-access-voting">Voting Decision Manager</a> illustrates the relevant classes.</p>
</div>
<div id="authz-access-voting" class="imageblock">
<div class="content">
<img src="images/access-decision-voting.png" alt="access decision voting">
</div>
<div class="title">Figure 11. Voting Decision Manager</div>
</div>
<div class="paragraph">
<p>Using this approach, a series of <code>AccessDecisionVoter</code> implementations are polled on an authorization decision.
The <code>AccessDecisionManager</code> then decides whether or not to throw an <code>AccessDeniedException</code> based on its assessment of the votes.</p>
</div>
<div class="paragraph">
<p>The <code>AccessDecisionVoter</code> interface has three methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Concrete implementations return an <code>int</code>, with possible values               being reflected in the <code>AccessDecisionVoter</code> static fields <code>ACCESS_ABSTAIN</code>, <code>ACCESS_DENIED</code> and <code>ACCESS_GRANTED</code>.
A voting implementation will return <code>ACCESS_ABSTAIN</code> if it has no opinion on an authorization decision.
If it does have an opinion, it must return either <code>ACCESS_DENIED</code> or <code>ACCESS_GRANTED</code>.</p>
</div>
<div class="paragraph">
<p>There are three concrete <code>AccessDecisionManager</code> s provided with Spring Security that tally the votes.
The <code>ConsensusBased</code> implementation will grant or deny access based on the consensus of non-abstain votes.
Properties are provided to control behavior in the event of an equality of votes or if all votes are abstain.
The <code>AffirmativeBased</code> implementation will grant access if one or more <code>ACCESS_GRANTED</code> votes were received (i.e. a deny vote will be ignored, provided there was at least one grant vote).
Like the <code>ConsensusBased</code> implementation, there is a parameter that controls the behavior if all voters abstain.
The <code>UnanimousBased</code> provider expects unanimous <code>ACCESS_GRANTED</code> votes in order to grant access, ignoring abstains.
It will deny access if there is any <code>ACCESS_DENIED</code> vote.
Like the other implementations, there is a parameter that controls the behaviour if all voters abstain.</p>
</div>
<div class="paragraph">
<p>It is possible to implement a custom <code>AccessDecisionManager</code> that tallies votes differently.
For example, votes from a particular <code>AccessDecisionVoter</code> might receive additional weighting, whilst a deny vote from a particular voter may have a veto effect.</p>
</div>
<div class="sect5">
<h6 id="authz-role-voter"><a class="anchor" href="#authz-role-voter"></a>RoleVoter</h6>
<div class="paragraph">
<p>The most commonly used <code>AccessDecisionVoter</code> provided with Spring Security is the simple <code>RoleVoter</code>, which treats configuration attributes as simple role names and votes to grant access if the user has been assigned that role.</p>
</div>
<div class="paragraph">
<p>It will vote if any <code>ConfigAttribute</code> begins with the prefix <code>ROLE_</code>.
It will vote to grant access if there is a <code>GrantedAuthority</code> which returns a <code>String</code> representation (via the <code>getAuthority()</code> method) exactly equal to one or more <code>ConfigAttributes</code> starting with the prefix <code>ROLE_</code>.
If there is no exact match of any <code>ConfigAttribute</code> starting with <code>ROLE_</code>, the <code>RoleVoter</code> will vote to deny access.
If no <code>ConfigAttribute</code> begins with <code>ROLE_</code>, the voter will abstain.</p>
</div>
</div>
<div class="sect5">
<h6 id="authz-authenticated-voter"><a class="anchor" href="#authz-authenticated-voter"></a>AuthenticatedVoter</h6>
<div class="paragraph">
<p>Another voter which we&#8217;ve implicitly seen is the <code>AuthenticatedVoter</code>, which can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users.
Many sites allow certain limited access under remember-me authentication, but require a user to confirm their identity by logging in for full access.</p>
</div>
<div class="paragraph">
<p>When we&#8217;ve used the attribute <code>IS_AUTHENTICATED_ANONYMOUSLY</code> to grant anonymous access, this attribute was being processed by the <code>AuthenticatedVoter</code>.
See the Javadoc for this class for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="authz-custom-voter"><a class="anchor" href="#authz-custom-voter"></a>Custom Voters</h6>
<div class="paragraph">
<p>Obviously, you can also implement a custom <code>AccessDecisionVoter</code> and you can put just about any access-control logic you want in it.
It might be specific to your application (business-logic related) or it might implement some security administration logic.
For example, you&#8217;ll find a <a href="https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time">blog article</a> on the Spring web site which describes how to use a voter to deny access in real-time to users whose accounts have been suspended.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="authz-after-invocation-handling"><a class="anchor" href="#authz-after-invocation-handling"></a>After Invocation Handling</h4>
<div class="paragraph">
<p>Whilst the <code>AccessDecisionManager</code> is called by the <code>AbstractSecurityInterceptor</code> before proceeding with the secure object invocation, some applications need a way of modifying the object actually returned by the secure object invocation.
Whilst you could easily implement your own AOP concern to achieve this, Spring Security provides a convenient hook that has several concrete implementations that integrate with its ACL capabilities.</p>
</div>
<div class="paragraph">
<p><a href="#authz-after-invocation">After Invocation Implementation</a> illustrates Spring Security&#8217;s <code>AfterInvocationManager</code> and its concrete implementations.</p>
</div>
<div id="authz-after-invocation" class="imageblock">
<div class="content">
<img src="images/after-invocation.png" alt="after invocation">
</div>
<div class="title">Figure 12. After Invocation Implementation</div>
</div>
<div class="paragraph">
<p>Like many other parts of Spring Security, <code>AfterInvocationManager</code> has a single concrete implementation, <code>AfterInvocationProviderManager</code>, which polls a list of <code>AfterInvocationProvider</code> s.
Each <code>AfterInvocationProvider</code> is allowed to modify the return object or throw an <code>AccessDeniedException</code>.
Indeed multiple providers can modify the object, as the result of the previous provider is passed to the next in the list.</p>
</div>
<div class="paragraph">
<p>Please be aware that if you&#8217;re using <code>AfterInvocationManager</code>, you will still need configuration attributes that allow the <code>MethodSecurityInterceptor</code>'s <code>AccessDecisionManager</code> to allow an operation.
If you&#8217;re using the typical Spring Security included <code>AccessDecisionManager</code> implementations, having no configuration attributes defined for a particular secure method invocation will cause each <code>AccessDecisionVoter</code> to abstain from voting.
In turn, if the <code>AccessDecisionManager</code> property           &#8220;allowIfAllAbstainDecisions&#8221; is <code>false</code>, an <code>AccessDeniedException</code> will be thrown.
You may avoid this potential issue by either (i) setting &#8220;allowIfAllAbstainDecisions&#8221; to <code>true</code> (although this is generally not recommended) or (ii) simply ensure that there is at least one configuration attribute that an <code>AccessDecisionVoter</code> will vote to grant access for.
This latter (recommended) approach is usually achieved through a <code>ROLE_USER</code> or <code>ROLE_AUTHENTICATED</code> configuration attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="authz-hierarchical-roles"><a class="anchor" href="#authz-hierarchical-roles"></a>Hierarchical Roles</h4>
<div class="paragraph">
<p>It is a common requirement that a particular role in an application should automatically "include" other roles.
For example, in an application which has the concept of an "admin" and a "user" role, you may want an admin to be able to do everything a normal user can.
To achieve this, you can either make sure that all admin users are also assigned the "user" role.
Alternatively, you can modify every access constraint which requires the "user" role to also include the "admin" role.
This can get quite complicated if you have a lot of different roles in your application.</p>
</div>
<div class="paragraph">
<p>The use of a role-hierarchy allows you to configure which roles (or authorities) should include others.
An extended version of Spring Security&#8217;s <a href="#authz-role-voter">RoleVoter</a>, <code>RoleHierarchyVoter</code>, is configured with a <code>RoleHierarchy</code>, from which it obtains all the "reachable authorities" which the user is assigned.
A typical configuration might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="roleVoter" class="org.springframework.security.access.vote.RoleHierarchyVoter"&gt;
	&lt;constructor-arg ref="roleHierarchy" /&gt;
&lt;/bean&gt;
&lt;bean id="roleHierarchy"
		class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"&gt;
	&lt;property name="hierarchy"&gt;
		&lt;value&gt;
			ROLE_ADMIN &gt; ROLE_STAFF
			ROLE_STAFF &gt; ROLE_USER
			ROLE_USER &gt; ROLE_GUEST
		&lt;/value&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have four roles in a hierarchy <code>ROLE_ADMIN &#8658; ROLE_STAFF &#8658; ROLE_USER &#8658; ROLE_GUEST</code>.
A user who is authenticated with <code>ROLE_ADMIN</code>, will behave as if they have all four roles when security constraints are evaluated against an <code>AccessDecisionManager</code> configured with the above <code>RoleHierarchyVoter</code>.
The <code>&gt;</code> symbol can be thought of as meaning "includes".</p>
</div>
<div class="paragraph">
<p>Role hierarchies offer a convenient means of simplifying the access-control configuration data for your application and/or reducing the number of authorities which you need to assign to a user.
For more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authorization-filtersecurityinterceptor"><a class="anchor" href="#servlet-authorization-filtersecurityinterceptor"></a>Authorize HttpServletRequest with FilterSecurityInterceptor</h3>
<div class="paragraph">
<p>This section builds on <a href="#servlet-architecture">Servlet Architecture and Implementation</a> by digging deeper into how <a href="#servlet-authorization">authorization</a> works within Servlet based applications.</p>
</div>
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html[<code>FilterSecurityInterceptor</code>] provides <a href="#servlet-authorization">authorization</a> for <code>HttpServletRequest</code>s.
It is inserted into the <a href="#servlet-filterchainproxy">FilterChainProxy</a> as one of the <a href="#servlet-security-filters">Security Filters</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authorization/filtersecurityinterceptor.png" alt="filtersecurityinterceptor">
</div>
<div class="title">Figure 13. Authorize HttpServletRequest</div>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, the <code>FilterSecurityInterceptor</code> obtains an  <a href="#servlet-authentication-authentication">Authentication</a> from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Second, <code>FilterSecurityInterceptor</code> creates a {security-api-url}org/springframework/security/web/FilterInvocation.html[<code>FilterInvocation</code>] from the <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, and <code>FilterChain</code> that are passed into the <code>FilterSecurityInterceptor</code>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Next, it passes the <code>FilterInvocation</code> to <code>SecurityMetadataSource</code> to get the <code>ConfigAttribute</code>s.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> Finally, it passes the <code>Authentication</code>, <code>FilterInvocation</code>, and <code>ConfigAttribute</code>s to the <code>AccessDecisionManager</code>.</p>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> If authorization is denied, an <code>AccessDeniedException</code> is thrown.
In this case the <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> handles the <code>AccessDeniedException</code>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_6.png" alt="number 6"></span> If access is granted, <code>FilterSecurityInterceptor</code> continues with the <a href="#servlet-filters-review">FilterChain</a> which allows the application to process normally.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, Spring Security&#8217;s authorization will require all requests to be authenticated.
The explicit configuration looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Every Request Must be Authenticated</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We can configure Spring Security to have different rules by adding more rules in order of precedence.</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. Authorize Requests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.authorizeRequests(authorize -&gt; authorize                                  <i class="conum" data-value="1"></i><b>(1)</b>
			.mvcMatchers("/resources/**", "/signup", "/about").permitAll()         <i class="conum" data-value="2"></i><b>(2)</b>
			.mvcMatchers("/admin/**").hasRole("ADMIN")                             <i class="conum" data-value="3"></i><b>(3)</b>
			.mvcMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")   <i class="conum" data-value="4"></i><b>(4)</b>
			.anyRequest().denyAll()                                                <i class="conum" data-value="5"></i><b>(5)</b>
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt; <i class="conum" data-value="1"></i><b>(1)</b>
	&lt;!-- ... --&gt;
	<i class="conum" data-value="2"></i><b>(2)</b>
	&lt;intercept-url pattern="/resources/**" access="permitAll"/&gt;
	&lt;intercept-url pattern="/signup" access="permitAll"/&gt;
	&lt;intercept-url pattern="/about" access="permitAll"/&gt;

	&lt;intercept-url pattern="/admin/**" access="hasRole('ADMIN')"/&gt; <i class="conum" data-value="3"></i><b>(3)</b>
	&lt;intercept-url pattern="/db/**" access="hasRole('ADMIN') and hasRole('DBA')"/&gt; <i class="conum" data-value="4"></i><b>(4)</b>
	&lt;intercept-url pattern="/**" access="denyAll"/&gt; <i class="conum" data-value="5"></i><b>(5)</b>
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests { <i class="conum" data-value="1"></i><b>(1)</b>
            authorize("/resources/**", permitAll) <i class="conum" data-value="2"></i><b>(2)</b>
            authorize("/signup", permitAll)
            authorize("/about", permitAll)

            authorize("/admin/**", hasRole("ADMIN")) <i class="conum" data-value="3"></i><b>(3)</b>
            authorize("/db/**", "hasRole('ADMIN') and hasRole('DBA')") <i class="conum" data-value="4"></i><b>(4)</b>
            authorize(anyRequest, denyAll) <i class="conum" data-value="5"></i><b>(5)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There are multiple authorization rules specified.
Each rule is considered in the order they were declared.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We specified multiple URL patterns that any user can access.
Specifically, any user can access a request if the URL starts with "/resources/", equals "/signup", or equals "/about".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any URL that starts with "/admin/" will be restricted to users who have the role "ROLE_ADMIN".
You will notice that since we are invoking the <code>hasRole</code> method we do not need to specify the "ROLE_" prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any URL that starts with "/db/" requires the user to have both "ROLE_ADMIN" and "ROLE_DBA".
You will notice that since we are using the <code>hasRole</code> expression we do not need to specify the "ROLE_" prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any URL that has not already been matched on is denied access.
This is a good strategy if you do not want to accidentally forget to update your authorization rules.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="el-access"><a class="anchor" href="#el-access"></a>Expression-Based Access Control</h3>
<div class="paragraph">
<p>Spring Security 3.0 introduced the ability to use Spring EL expressions as an authorization mechanism in addition to the simple use of configuration attributes and access-decision voters which have seen before.
Expression-based access control is built on the same architecture but allows complicated Boolean logic to be encapsulated in a single expression.</p>
</div>
<div class="sect3">
<h4 id="_overview_2"><a class="anchor" href="#_overview_2"></a>Overview</h4>
<div class="paragraph">
<p>Spring Security uses Spring EL for expression support and you should look at how that works if you are interested in understanding the topic in more depth.
Expressions are evaluated with a "root object" as part of the evaluation context.
Spring Security uses specific classes for web and method security as the root object, in order to provide built-in expressions and access to values such as the current principal.</p>
</div>
<div class="sect4">
<h5 id="el-common-built-in"><a class="anchor" href="#el-common-built-in"></a>Common Built-In Expressions</h5>
<div class="paragraph">
<p>The base class for expression root objects is <code>SecurityExpressionRoot</code>.
This provides some common expressions which are available in both web and method security.</p>
</div>
<table id="common-expressions" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Common built-in expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasRole(String role)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified role.</p>
<p class="tableblock">For example, <code>hasRole('admin')</code></p>
<p class="tableblock">By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code>defaultRolePrefix</code> on <code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyRole(String&#8230;&#8203; roles)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied roles (given as a comma-separated list of strings).</p>
<p class="tableblock">For example, <code>hasAnyRole('admin', 'user')</code></p>
<p class="tableblock">By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code>defaultRolePrefix</code> on <code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAuthority(String authority)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified authority.</p>
<p class="tableblock">For example, <code>hasAuthority('read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyAuthority(String&#8230;&#8203; authorities)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied authorities (given as a comma-separated list of strings)</p>
<p class="tableblock">For example, <code>hasAnyAuthority('read', 'write')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the principal object representing the current user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the current <code>Authentication</code> object obtained from the <code>SecurityContext</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>permitAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>denyAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAnonymous()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is an anonymous user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isRememberMe()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is a remember-me user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not anonymous</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isFullyAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not an anonymous or a remember-me user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object target, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the given permission.
For example, <code>hasPermission(domainObject, 'read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object targetId, String targetType, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the given permission.
For example, <code>hasPermission(1, 'com.example.domain.Message', 'read')</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="el-access-web"><a class="anchor" href="#el-access-web"></a>Web Security Expressions</h4>
<div class="paragraph">
<p>To use expressions to secure individual URLs, you would first need to set the <code>use-expressions</code> attribute in the <code>&lt;http&gt;</code> element to <code>true</code>.
Spring Security will then expect the <code>access</code> attributes of the <code>&lt;intercept-url&gt;</code> elements to contain Spring EL expressions.
The expressions should evaluate to a Boolean, defining whether access should be allowed or not.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/admin*"
		access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have defined that the "admin" area of an application (defined by the URL pattern) should only be available to users who have the granted authority "admin" and whose IP address matches a local subnet.
We&#8217;ve already seen the built-in <code>hasRole</code> expression in the previous section.
The expression <code>hasIpAddress</code> is an additional built-in expression which is specific to web security.
It is defined by the <code>WebSecurityExpressionRoot</code> class, an instance of which is used as the expression root object when evaluating web-access expressions.
This object also directly exposed the <code>HttpServletRequest</code> object under the name <code>request</code> so you can invoke the request directly in an expression.
If expressions are being used, a <code>WebExpressionVoter</code> will be added to the <code>AccessDecisionManager</code> which is used by the namespace.
So if you aren&#8217;t using the namespace and want to use expressions, you will have to add one of these to your configuration.</p>
</div>
<div class="sect4">
<h5 id="el-access-web-beans"><a class="anchor" href="#el-access-web-beans"></a>Referring to Beans in Web Security Expressions</h5>
<div class="paragraph">
<p>If you wish to extend the expressions that are available, you can easily refer to any Spring Bean you expose.
For example, assuming you have a Bean with the name of <code>webSecurity</code> that contains the following method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WebSecurity {
		public boolean check(Authentication authentication, HttpServletRequest request) {
				...
		}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class WebSecurity {
    fun check(authentication: Authentication?, request: HttpServletRequest?): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You could refer to the method using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. Refer to method</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .antMatchers("/user/**").access("@webSecurity.check(authentication,request)")
        ...
    )</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/**"
		access="@webSecurity.check(authentication,request)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/**", "@webSecurity.check(authentication,request)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="el-access-web-path-variables"><a class="anchor" href="#el-access-web-path-variables"></a>Path Variables in Web Security Expressions</h5>
<div class="paragraph">
<p>At times it is nice to be able to refer to path variables within a URL.
For example, consider a RESTful application that looks up a user by id from the URL path in the format <code>/user/{userId}</code>.</p>
</div>
<div class="paragraph">
<p>You can easily refer to the path variable by placing it in the pattern.
For example, if you had a Bean with the name of <code>webSecurity</code> that contains the following method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WebSecurity {
		public boolean checkUserId(Authentication authentication, int id) {
				...
		}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class WebSecurity {
    fun checkUserId(authentication: Authentication?, id: Int): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You could refer to the method using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. Path Variables</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
	.authorizeRequests(authorize -&gt; authorize
		.antMatchers("/user/{userId}/**").access("@webSecurity.checkUserId(authentication,#userId)")
		...
	);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/{userId}/**"
		access="@webSecurity.checkUserId(authentication,#userId)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/{userId}/**", "@webSecurity.checkUserId(authentication,#userId)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration URLs that match would pass in the path variable (and convert it) into checkUserId method.
For example, if the URL were <code>/user/123/resource</code>, then the id passed in would be <code>123</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_method_security_expressions"><a class="anchor" href="#_method_security_expressions"></a>Method Security Expressions</h4>
<div class="paragraph">
<p>Method security is a bit more complicated than a simple allow or deny rule.
Spring Security 3.0 introduced some new annotations in order to allow comprehensive support for the use of expressions.</p>
</div>
<div class="sect4">
<h5 id="el-pre-post-annotations"><a class="anchor" href="#el-pre-post-annotations"></a>@Pre and @Post Annotations</h5>
<div class="paragraph">
<p>There are four annotations which support expression attributes to allow pre and post-invocation authorization checks and also to support filtering of submitted collection arguments or return values.
They are <code>@PreAuthorize</code>, <code>@PreFilter</code>, <code>@PostAuthorize</code> and <code>@PostFilter</code>.
Their use is enabled through the <code>global-method-security</code> namespace element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled"/&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_access_control_using_preauthorize_and_postauthorize"><a class="anchor" href="#_access_control_using_preauthorize_and_postauthorize"></a>Access Control using @PreAuthorize and @PostAuthorize</h6>
<div class="paragraph">
<p>The most obviously useful annotation is <code>@PreAuthorize</code> which decides whether a method can actually be invoked or not.
For example (from the "Contacts" sample application)</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasRole('USER')")
public void create(Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
fun create(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>which means that access will only be allowed for users with the role "ROLE_USER".
Obviously the same thing could easily be achieved using a traditional configuration and a simple configuration attribute for the required role.
But what about:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasPermission(#contact, 'admin')")
public void deletePermission(Contact contact, Sid recipient, Permission permission);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasPermission(#contact, 'admin')")
fun deletePermission(contact: Contact?, recipient: Sid?, permission: Permission?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here we&#8217;re actually using a method argument as part of the expression to decide whether the current user has the "admin"permission for the given contact.
The built-in <code>hasPermission()</code> expression is linked into the Spring Security ACL module through the application context, as we&#8217;ll <a href="#el-permission-evaluator">see below</a>.
You can access any of the method arguments by name as expression variables.</p>
</div>
<div class="paragraph">
<p>There are a number of ways in which Spring Security can resolve the method arguments.
Spring Security uses <code>DefaultSecurityParameterNameDiscoverer</code> to discover the parameter names.
By default, the following options are tried for a method as a whole.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If Spring Security&#8217;s <code>@P</code> annotation is present on a single argument to the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.access.method.P;

...

@PreAuthorize("#c.name == authentication.name")
public void doSomething(@P("c") Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.security.access.method.P

...

@PreAuthorize("#c.name == authentication.name")
fun doSomething(@P("c") contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes this is implemented using <code>AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</div>
</li>
<li>
<p>If Spring Data&#8217;s <code>@Param</code> annotation is present on at least one parameter for the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.data.repository.query.Param;

...

@PreAuthorize("#n == authentication.name")
Contact findContactByName(@Param("n") String name);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.data.repository.query.Param

...

@PreAuthorize("#n == authentication.name")
fun findContactByName(@Param("n") name: String?): Contact?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes this is implemented using <code>AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</div>
</li>
<li>
<p>If JDK 8 was used to compile the source with the -parameters argument and Spring 4+ is being used, then the standard JDK reflection API is used to discover the parameter names.
This works on both classes and interfaces.</p>
</li>
<li>
<p>Last, if the code was compiled with the debug symbols, the parameter names will be discovered using the debug symbols.
This will not work for interfaces since they do not have debug information about the parameter names.
For interfaces, annotations or the JDK 8 approach must be used.</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-spel"></a></div>
<div class="content">
<div class="paragraph">
<p>Any Spring-EL functionality is available within the expression, so you can also access properties on the arguments.
For example, if you wanted a particular method to only allow access to a user whose username matched that of the contact, you could write</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("#contact.name == authentication.name")
public void doSomething(Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("#contact.name == authentication.name")
fun doSomething(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here we are accessing another built-in expression, <code>authentication</code>, which is the <code>Authentication</code> stored in the security context.
You can also access its "principal" property directly, using the expression <code>principal</code>.
The value will often be a <code>UserDetails</code> instance, so you might use an expression like <code>principal.username</code> or <code>principal.enabled</code>.</p>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-post"></a></div>
<div class="content">
<div class="paragraph">
<p>Less commonly, you may wish to perform an access-control check after the method has been invoked.
This can be achieved using the <code>@PostAuthorize</code> annotation.
To access the return value from a method, use the built-in name <code>returnObject</code> in the expression.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_filtering_using_prefilter_and_postfilter"><a class="anchor" href="#_filtering_using_prefilter_and_postfilter"></a>Filtering using @PreFilter and @PostFilter</h6>
<div class="paragraph">
<p>Spring Security supports filtering of collections, arrays, maps and streams using expressions.
This is most commonly performed on the return value of a method.
For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
public List&lt;Contact&gt; getAll();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
fun getAll(): List&lt;Contact?&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using the <code>@PostFilter</code> annotation, Spring Security iterates through the returned collection or map and removes any elements for which the supplied expression is false.
For an array, a new array instance will be returned containing filtered elements.
The name <code>filterObject</code> refers to the current object in the collection.
In case when a map is used it will refer to the current <code>Map.Entry</code> object which allows one to use <code>filterObject.key</code> or <code>filterObject.value</code> in the expresion.
You can also filter before the method call, using <code>@PreFilter</code>, though this is a less common requirement.
The syntax is just the same, but if there is more than one argument which is a collection type then you have to select one by name using the <code>filterTarget</code> property of this annotation.</p>
</div>
<div class="paragraph">
<p>Note that filtering is obviously not a substitute for tuning your data retrieval queries.
If you are filtering large collections and removing many of the entries then this is likely to be inefficient.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="el-method-built-in"><a class="anchor" href="#el-method-built-in"></a>Built-In Expressions</h5>
<div class="paragraph">
<p>There are some built-in expressions which are specific to method security, which we have already seen in use above.
The <code>filterTarget</code> and <code>returnValue</code> values are simple enough, but the use of the <code>hasPermission()</code> expression warrants a closer look.</p>
</div>
<div class="sect5">
<h6 id="el-permission-evaluator"><a class="anchor" href="#el-permission-evaluator"></a>The PermissionEvaluator interface</h6>
<div class="paragraph">
<p><code>hasPermission()</code> expressions are delegated to an instance of <code>PermissionEvaluator</code>.
It is intended to bridge between the expression system and Spring Security&#8217;s ACL system, allowing you to specify authorization constraints on domain objects, based on abstract permissions.
It has no explicit dependencies on the ACL module, so you could swap that out for an alternative implementation if required.
The interface has two methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean hasPermission(Authentication authentication, Object targetDomainObject,
							Object permission);

boolean hasPermission(Authentication authentication, Serializable targetId,
							String targetType, Object permission);</code></pre>
</div>
</div>
<div class="paragraph">
<p>which map directly to the available versions of the expression, with the exception that the first argument (the <code>Authentication</code> object) is not supplied.
The first is used in situations where the domain object, to which access is being controlled, is already loaded.
Then expression will return true if the current user has the given permission for that object.
The second version is used in cases where the object is not loaded, but its identifier is known.
An abstract "type" specifier for the domain object is also required, allowing the correct ACL permissions to be loaded.
This has traditionally been the Java class of the object, but does not have to be as long as it is consistent with how the permissions are loaded.</p>
</div>
<div class="paragraph">
<p>To use <code>hasPermission()</code> expressions, you have to explicitly configure a <code>PermissionEvaluator</code> in your application context.
This would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:global-method-security pre-post-annotations="enabled"&gt;
&lt;security:expression-handler ref="expressionHandler"/&gt;
&lt;/security:global-method-security&gt;

&lt;bean id="expressionHandler" class=
"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"&gt;
	&lt;property name="permissionEvaluator" ref="myPermissionEvaluator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>myPermissionEvaluator</code> is the bean which implements <code>PermissionEvaluator</code>.
Usually this will be the implementation from the ACL module which is called <code>AclPermissionEvaluator</code>.
See the "Contacts" sample application configuration for more details.</p>
</div>
</div>
<div class="sect5">
<h6 id="_method_security_meta_annotations"><a class="anchor" href="#_method_security_meta_annotations"></a>Method Security Meta Annotations</h6>
<div class="paragraph">
<p>You can make use of meta annotations for method security to make your code more readable.
This is especially convenient if you find that you are repeating the same complex expression throughout your code base.
For example, consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("#contact.name == authentication.name")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of repeating this everywhere, we can create a meta annotation that can be used instead.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
public @interface ContactPermission {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
annotation class ContactPermission</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Meta annotations can be used for any of the Spring Security method security annotations.
In order to remain compliant with the specification JSR-250 annotations do not support meta annotations.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="secure-object-impls"><a class="anchor" href="#secure-object-impls"></a>Secure Object Implementations</h3>
<div class="sect3">
<h4 id="aop-alliance"><a class="anchor" href="#aop-alliance"></a>AOP Alliance (MethodInvocation) Security Interceptor</h4>
<div class="paragraph">
<p>Prior to Spring Security 2.0, securing <code>MethodInvocation</code> s needed quite a lot of boiler plate configuration.
Now the recommended approach for method security is to use <a href="#ns-method-security">namespace configuration</a>.
This way the method security infrastructure beans are configured automatically for you so you don&#8217;t really need to know about the implementation classes.
We&#8217;ll just provide a quick overview of the classes that are involved here.</p>
</div>
<div class="paragraph">
<p>Method security is enforced using a <code>MethodSecurityInterceptor</code>, which secures <code>MethodInvocation</code> s.
Depending on the configuration approach, an interceptor may be specific to a single bean or shared between multiple beans.
The interceptor uses a <code>MethodSecurityMetadataSource</code> instance to obtain the configuration attributes that apply to a particular method invocation.
<code>MapBasedMethodSecurityMetadataSource</code> is used to store configuration attributes keyed by method names (which can be wildcarded) and will be used internally when the attributes are defined in the application context using the <code>&lt;intercept-methods&gt;</code> or <code>&lt;protect-point&gt;</code> elements.
Other implementations will be used to handle annotation-based configuration.</p>
</div>
<div class="sect4">
<h5 id="_explicit_methodsecurityinterceptor_configuration"><a class="anchor" href="#_explicit_methodsecurityinterceptor_configuration"></a>Explicit MethodSecurityInterceptor Configuration</h5>
<div class="paragraph">
<p>You can of course configure a <code>MethodSecurityInterceptor</code> directly in your application context for use with one of Spring AOP&#8217;s proxying mechanisms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aspectj"><a class="anchor" href="#aspectj"></a>AspectJ (JoinPoint) Security Interceptor</h4>
<div class="paragraph">
<p>The AspectJ security interceptor is very similar to the AOP Alliance security interceptor discussed in the previous section.
Indeed we will only discuss the differences in this section.</p>
</div>
<div class="paragraph">
<p>The AspectJ interceptor is named <code>AspectJSecurityInterceptor</code>.
Unlike the AOP Alliance security interceptor, which relies on the Spring application context to weave in the security interceptor via proxying, the <code>AspectJSecurityInterceptor</code> is weaved in via the AspectJ compiler.
It would not be uncommon to use both types of security interceptors in the same application, with <code>AspectJSecurityInterceptor</code> being used for domain object instance security and the AOP Alliance <code>MethodSecurityInterceptor</code> being used for services layer security.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first consider how the <code>AspectJSecurityInterceptor</code> is configured in the Spring application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, aside from the class name, the <code>AspectJSecurityInterceptor</code> is exactly the same as the AOP Alliance security interceptor.
Indeed the two interceptors can share the same <code>securityMetadataSource</code>, as the <code>SecurityMetadataSource</code> works with <code>java.lang.reflect.Method</code> s rather than an AOP library-specific class.
Of course, your access decisions have access to the relevant AOP library-specific invocation (ie <code>MethodInvocation</code> or <code>JoinPoint</code>) and as such can consider a range of addition criteria when making access decisions (such as method arguments).</p>
</div>
<div class="paragraph">
<p>Next you&#8217;ll need to define an AspectJ <code>aspect</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.security.samples.aspectj;

import org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
import org.springframework.security.access.intercept.aspectj.AspectJCallback;
import org.springframework.beans.factory.InitializingBean;

public aspect DomainObjectInstanceSecurityAspect implements InitializingBean {

	private AspectJSecurityInterceptor securityInterceptor;

	pointcut domainObjectInstanceExecution(): target(PersistableEntity)
		&amp;&amp; execution(public * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

	Object around(): domainObjectInstanceExecution() {
		if (this.securityInterceptor == null) {
			return proceed();
		}

		AspectJCallback callback = new AspectJCallback() {
			public Object proceedWithObject() {
				return proceed();
			}
		};

		return this.securityInterceptor.invoke(thisJoinPoint, callback);
	}

	public AspectJSecurityInterceptor getSecurityInterceptor() {
		return securityInterceptor;
	}

	public void setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
		this.securityInterceptor = securityInterceptor;
	}

	public void afterPropertiesSet() throws Exception {
		if (this.securityInterceptor == null)
			throw new IllegalArgumentException("securityInterceptor required");
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the security interceptor will be applied to every instance of <code>PersistableEntity</code>, which is an abstract class not shown (you can use any other class or <code>pointcut</code> expression you like).
For those curious, <code>AspectJCallback</code> is needed because the <code>proceed();</code> statement has special meaning only within an <code>around()</code> body.
The <code>AspectJSecurityInterceptor</code> calls this anonymous <code>AspectJCallback</code> class when it wants the target object to continue.</p>
</div>
<div class="paragraph">
<p>You will need to configure Spring to load the aspect and wire it with the <code>AspectJSecurityInterceptor</code>.
A bean declaration which achieves this is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="domainObjectInstanceSecurityAspect"
	class="security.samples.aspectj.DomainObjectInstanceSecurityAspect"
	factory-method="aspectOf"&gt;
&lt;property name="securityInterceptor" ref="bankManagerSecurity"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it!
Now you can create your beans from anywhere within your application, using whatever means you think fit (e.g. <code>new Person();</code>) and they will have the security interceptor applied.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-method"><a class="anchor" href="#jc-method"></a>Method Security</h3>
<div class="paragraph">
<p>From version 2.0 onwards Spring Security has improved support substantially for adding security to your service layer methods.
It provides support for JSR-250 annotation security as well as the framework&#8217;s original <code>@Secured</code> annotation.
From 3.0 you can also make use of new <a href="#el-access">expression-based annotations</a>.
You can apply security to a single bean, using the <code>intercept-methods</code> element to decorate the bean declaration, or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.</p>
</div>
<div class="sect3">
<h4 id="_enablemethodsecurity"><a class="anchor" href="#_enablemethodsecurity"></a>EnableMethodSecurity</h4>
<div class="paragraph">
<p>In Spring Security 5.6, we can enable annotation-based security using the <code>@EnableMethodSecurity</code> annotation on any <code>@Configuration</code> instance.</p>
</div>
<div class="paragraph">
<p>This improves upon <code>@EnableGlobalMethodSecurity</code> in a number of ways. <code>@EnableMethodSecurity</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Uses the simplified <code>AuthorizationManager</code> API instead of metadata sources, config attributes, decision managers, and voters.
This simplifies reuse and customization.</p>
</li>
<li>
<p>Favors direct bean-based configuration, instead of requiring extending <code>GlobalMethodSecurityConfiguration</code> to customize beans</p>
</li>
<li>
<p>Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize</p>
</li>
<li>
<p>Checks for conflicting annotations to ensure an unambiguous security configuration</p>
</li>
<li>
<p>Complies with JSR-250</p>
</li>
<li>
<p>Enables <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, and <code>@PostFilter</code> by default</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For earlier versions, please read about similar support with <a href="#jc-enable-global-method-security">@EnableGlobalMethodSecurity</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the following would enable Spring Security&#8217;s <code>@PreAuthorize</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. Method Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the <code>DefaultAuthorizationMethodInterceptorChain</code> for it to make the actual decision:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. Method Security Annotation Usage</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {
	@PreAuthorize("hasRole('USER')")
	Account readAccount(Long id);

	@PreAuthorize("hasRole('USER')")
	List&lt;Account&gt; findAccounts();

	@PreAuthorize("hasRole('TELLER')")
	Account post(Account account, Double amount);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface BankService {
	@PreAuthorize("hasRole('USER')")
	fun readAccount(id : Long) : Account

	@PreAuthorize("hasRole('USER')")
	fun findAccounts() : List&lt;Account&gt;

	@PreAuthorize("hasRole('TELLER')")
	fun post(account : Account, amount : Double) : Account
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable support for Spring Security&#8217;s <code>@Secured</code> annotation using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. @Secured Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(securedEnabled = true)
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security secured-enabled="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>or JSR-250 using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. JSR-250 Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(jsr250Enabled = true)
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security jsr250-enabled="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_customizing_authorization"><a class="anchor" href="#_customizing_authorization"></a>Customizing Authorization</h5>
<div class="paragraph">
<p>Spring Security&#8217;s <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, and <code>@PostFilter</code> ship with rich expression-based support.</p>
</div>
<div id="jc-method-security-custom-expression-handler" class="paragraph">
<p>If you need to customize the way that expressions are handled, you can expose a custom <code>MethodSecurityExpressionHandler</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Custom MethodSecurityExpressionHandler</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler() {
	DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
	handler.setTrustResolver(myCustomTrustResolver);
	return handler;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">companion object {
	@Bean
	fun methodSecurityExpressionHandler() : MethodSecurityExpressionHandler {
		val handler = DefaultMethodSecurityExpressionHandler();
		handler.setTrustResolver(myCustomTrustResolver);
		return handler;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security&gt;
	&lt;sec:expression-handler ref="myExpressionHandler"/&gt;
&lt;/sec:method-security&gt;

&lt;bean id="myExpressionHandler"
		class="org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler"&gt;
	&lt;property name="trustResolver" ref="myCustomTrustResolver"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We expose <code>MethodSecurityExpressionHandler</code> using a <code>static</code> method to ensure that Spring publishes it before it initializes Spring Security&#8217;s method security <code>@Configuration</code> classes</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, for role-based authorization, Spring Security adds a default <code>ROLE_</code> prefix, which is uses when evaluating expressions like <code>hasRole</code>.</p>
</div>
<div id="jc-method-security-custom-granted-authority-defaults" class="paragraph">
<p>You can configure the authorization rules to use a different prefix by exposing a <code>GrantedAuthorityDefaults</code> bean, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. Custom MethodSecurityExpressionHandler</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
static GrantedAuthorityDefaults grantedAuthorityDefaults() {
	return new GrantedAuthorityDefaults("MYPREFIX_");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">companion object {
	@Bean
	fun grantedAuthorityDefaults() : GrantedAuthorityDefaults {
		return GrantedAuthorityDefaults("MYPREFIX_");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;bean id="grantedAuthorityDefaults" class="org.springframework.security.config.core.GrantedAuthorityDefaults"&gt;
	&lt;constructor-arg value="MYPREFIX_"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We expose <code>GrantedAuthorityDefaults</code> using a <code>static</code> method to ensure that Spring publishes it before it initializes Spring Security&#8217;s method security <code>@Configuration</code> classes</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jc-method-security-custom-authorization-manager"><a class="anchor" href="#jc-method-security-custom-authorization-manager"></a>Custom Authorization Managers</h5>
<div class="paragraph">
<p>Method authorization is a combination of before- and after-method authorization.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Before-method authorization is performed before the method is invoked.
If that authorization denies access, the method is not invoked, and an <code>AccessDeniedException</code> is thrown
After-method authorization is performed after the method is invoked, but before the method returns to the caller.
If that authorization denies access, the value is not returned, and an <code>AccessDeniedException</code> is thrown</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To recreate what adding <code>@EnableMethodSecurity</code> does by default, you would publish the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Full Pre-post Method Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preFilterAuthorizationMethodInterceptor() {
		return new PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postFilterAuthorizationMethodInterceptor() {
		return new PostFilterAuthorizationMethodInterceptor();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preFilterAuthorizationMethodInterceptor() : Advisor {
		return PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postFilterAuthorizationMethodInterceptor() : Advisor {
		return PostFilterAuthorizationMethodInterceptor();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security pre-post-enabled="false"/&gt;

&lt;aop:config/&gt;

&lt;bean id="preFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor"/&gt;
&lt;bean id="preAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
		factory-method="preAuthorize"/&gt;
&lt;bean id="postAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"
		factory-method="postAuthorize"/&gt;
&lt;bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that Spring Security&#8217;s method security is built using Spring AOP.
So, interceptors are invoked based on the order specified.
This can be customized by calling <code>setOrder</code> on the interceptor instances like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Publish Custom Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
Advisor postFilterAuthorizationMethodInterceptor() {
	PostFilterAuthorizationMethodInterceptor interceptor = new PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
fun postFilterAuthorizationMethodInterceptor() : Advisor {
	val interceptor = PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor"&gt;
	&lt;property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).POST_AUTHORIZE.getOrder() -1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may want to only support <code>@PreAuthorize</code> in your application, in which case you can do the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Only @PreAuthorize Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorize() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorize() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize()
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security pre-post-enabled="false"/&gt;

&lt;aop:config/&gt;

&lt;bean id="preAuthorizeAuthorizationMethodInterceptor"
	class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
	factory-method="preAuthorize"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you may have a custom before-method <code>AuthorizationManager</code> that you want to add to the list.</p>
</div>
<div class="paragraph">
<p>In this case, you will need to tell Spring Security both the <code>AuthorizationManager</code> and to which methods and classes your authorization manager applies.</p>
</div>
<div class="paragraph">
<p>Thus, you can configure Spring Security to invoke your <code>AuthorizationManager</code> in between <code>@PreAuthorize</code> and <code>@PostAuthorize</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. Custom Before Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize() {
		JdkRegexpMethodPointcut pattern = new JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		AuthorizationManager&lt;MethodInvocation&gt; rule = AuthorityAuthorizationManager.isAuthenticated();
		AuthorizationManagerBeforeMethodInterceptor interceptor = new AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize() : Advisor {
		val pattern = JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		val rule = AuthorityAuthorizationManager.isAuthenticated();
		val interceptor = AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;aop:config/&gt;

&lt;bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
			&lt;property name="pattern" value="org.mycompany.myapp.service.*"/&gt;
		&lt;/bean&gt;
	&lt;/constructor-arg&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/&gt;
	&lt;/constructor-arg&gt;
	&lt;property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can place your interceptor in between Spring Security method interceptors using the order constants specified in <code>AuthorizationInterceptorsOrder</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same can be done for after-method authorization.
After-method authorization is generally concerned with analysing the return value to verify access.</p>
</div>
<div class="paragraph">
<p>For example, you might have a method that confirms that the account requested actually belongs to the logged-in user like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. @PostAuthorize example</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	Account readAccount(Long id);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	fun readAccount(id : Long) : Account
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can supply your own <code>AuthorizationMethodInterceptor</code> to customize how access to the return value is evaluated.</p>
</div>
<div class="paragraph">
<p>For example, if you have your own custom annotation, you can configure it like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. Custom After Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize(AuthorizationManager&lt;MethodInvocationResult&gt; rules) {
		AnnotationMethodMatcher pattern = new AnnotationMethodMatcher(MySecurityAnnotation.class);
		AuthorizationManagerAfterMethodInterceptor interceptor = new AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize(rules : AuthorizationManager&lt;MethodInvocationResult&gt;) : Advisor {
		val pattern = AnnotationMethodMatcher(MySecurityAnnotation::class.java);
		val interceptor = AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;aop:config/&gt;

&lt;bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.aop.support.annotation.AnnotationMethodMatcher"&gt;
			&lt;constructor-arg value="#{T(org.mycompany.MySecurityAnnotation)}"/&gt;
		&lt;/bean&gt;
	&lt;/constructor-arg&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/&gt;
	&lt;/constructor-arg&gt;
	&lt;property name="order"
		value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and it will be invoked after the <code>@PostAuthorize</code> interceptor.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jc-enable-global-method-security"><a class="anchor" href="#jc-enable-global-method-security"></a>EnableGlobalMethodSecurity</h4>
<div class="paragraph">
<p>We can enable annotation-based security using the <code>@EnableGlobalMethodSecurity</code> annotation on any <code>@Configuration</code> instance.
For example, the following would enable Spring Security&#8217;s <code>@Secured</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the AccessDecisionManager for it to make the actual decision:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for JSR-250 annotations can be enabled using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security&#8217;s native annotations.
To use the new expression-based syntax, you would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the equivalent Java code would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_globalmethodsecurityconfiguration"><a class="anchor" href="#_globalmethodsecurityconfiguration"></a>GlobalMethodSecurityConfiguration</h4>
<div class="paragraph">
<p>Sometimes you may need to perform operations that are more complicated than are possible with the <code>@EnableGlobalMethodSecurity</code> annotation allow.
For these instances, you can extend the <code>GlobalMethodSecurityConfiguration</code> ensuring that the <code>@EnableGlobalMethodSecurity</code> annotation is present on your subclass.
For example, if you wanted to provide a custom <code>MethodSecurityExpressionHandler</code>, you could use the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For additional information about methods that can be overridden, refer to the <code>GlobalMethodSecurityConfiguration</code> Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-global-method"><a class="anchor" href="#ns-global-method"></a>The &lt;global-method-security&gt; Element</h4>
<div class="paragraph">
<p>This element is used to enable annotation-based security in your application (by setting the appropriate attributes on the element), and also to group together security pointcut declarations which will be applied across your entire application context.
You should only declare one <code>&lt;global-method-security&gt;</code> element.
The following declaration would enable support for Spring Security&#8217;s <code>@Secured</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security secured-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on an class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the <code>AccessDecisionManager</code> for it to make the actual decision:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for JSR-250 annotations can be enabled using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security jsr250-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security&#8217;s native annotations.
To use the new expression-based syntax, you would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the equivalent Java code would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expression-based annotations are a good choice if you need to define simple rules that go beyond checking the role names against the user&#8217;s list of authorities.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The annotated methods will only be secured for instances which are defined as Spring beans (in the same application context in which method-security is enabled).
If you want to secure instances which are not created by Spring (using the <code>new</code> operator, for example) then you need to use AspectJ.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can enable more than one type of annotation in the same application, but only one type should be used for any interface or class as the behaviour will not be well-defined otherwise.
If two annotations are found which apply to a particular method, then only one of them will be applied.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ns-protect-pointcut"><a class="anchor" href="#ns-protect-pointcut"></a>Adding Security Pointcuts using protect-pointcut</h4>
<div class="paragraph">
<p>The use of <code>protect-pointcut</code> is particularly powerful, as it allows you to apply security to many beans with only a simple declaration.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security&gt;
&lt;protect-pointcut expression="execution(* com.mycompany.*Service.*(..))"
	access="ROLE_USER"/&gt;
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will protect all methods on beans declared in the application context whose classes are in the <code>com.mycompany</code> package and whose class names end in "Service".
Only users with the <code>ROLE_USER</code> role will be able to invoke these methods.
As with URL matching, the most specific matches must come first in the list of pointcuts, as the first matching expression will be used.
Security annotations take precedence over pointcuts.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls"><a class="anchor" href="#domain-acls"></a>Domain Object Security (ACLs)</h3>
<div class="sect3">
<h4 id="domain-acls-overview"><a class="anchor" href="#domain-acls-overview"></a>Overview</h4>
<div class="paragraph">
<p>Complex applications often will find the need to define access permissions not simply at a web request or method invocation level.
Instead, security decisions need to comprise both who (<code>Authentication</code>), where (<code>MethodInvocation</code>) and what (<code>SomeDomainObject</code>).
In other words, authorization decisions also need to consider the actual domain object instance subject of a method invocation.</p>
</div>
<div class="paragraph">
<p>Imagine you&#8217;re designing an application for a pet clinic.
There will be two main groups of users of your Spring-based application: staff of the pet clinic, as well as the pet clinic&#8217;s customers.
The staff will have access to all of the data, whilst your customers will only be able to see their own customer records.
To make it a little more interesting, your customers can allow other users to see their customer records, such as their "puppy preschool" mentor or president of their local "Pony Club".
Using Spring Security as the foundation, you have several approaches that can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write your business methods to enforce the security.
You could consult a collection within the <code>Customer</code> domain object instance to determine which users have access.
By using the <code>SecurityContextHolder.getContext().getAuthentication()</code>, you&#8217;ll be able to access the <code>Authentication</code> object.</p>
</li>
<li>
<p>Write an <code>AccessDecisionVoter</code> to enforce the security from the <code>GrantedAuthority[]</code> s stored in the <code>Authentication</code> object.
This would mean your <code>AuthenticationManager</code> would need to populate the <code>Authentication</code> with custom <code>GrantedAuthority[]</code>s representing each of the <code>Customer</code> domain object instances the principal has access to.</p>
</li>
<li>
<p>Write an <code>AccessDecisionVoter</code> to enforce the security and open the target <code>Customer</code> domain object directly.
This would mean your voter needs access to a DAO that allows it to retrieve the <code>Customer</code> object.
It would then access the <code>Customer</code> object&#8217;s collection of approved users and make the appropriate decision.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each one of these approaches is perfectly legitimate.
However, the first couples your authorization checking to your business code.
The main problems with this include the enhanced difficulty of unit testing and the fact it would be more difficult to reuse the <code>Customer</code> authorization logic elsewhere.
Obtaining the <code>GrantedAuthority[]</code> s from the <code>Authentication</code> object is also fine, but will not scale to large numbers of <code>Customer</code> s.
If a user might be able to access 5,000 <code>Customer</code> s (unlikely in this case, but imagine if it were a popular vet for a large Pony Club!) the amount of memory consumed and time required to construct the <code>Authentication</code> object would be undesirable.
The final method, opening the <code>Customer</code> directly from external code, is probably the best of the three.
It achieves separation of concerns, and doesn&#8217;t misuse memory or CPU cycles, but it is still inefficient in that both the <code>AccessDecisionVoter</code> and the eventual business method itself will perform a call to the DAO responsible for retrieving the <code>Customer</code> object.
Two accesses per method invocation is clearly undesirable.
In addition, with every approach listed you&#8217;ll need to write your own access control list (ACL) persistence and business logic from scratch.</p>
</div>
<div class="paragraph">
<p>Fortunately, there is another alternative, which we&#8217;ll talk about below.</p>
</div>
</div>
<div class="sect3">
<h4 id="domain-acls-key-concepts"><a class="anchor" href="#domain-acls-key-concepts"></a>Key Concepts</h4>
<div class="paragraph">
<p>Spring Security&#8217;s ACL services are shipped in the <code>spring-security-acl-xxx.jar</code>.
You will need to add this JAR to your classpath to use Spring Security&#8217;s domain object instance security capabilities.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s domain object instance security capabilities centre on the concept of an access control list (ACL).
Every domain object instance in your system has its own ACL, and the ACL records details of who can and can&#8217;t work with that domain object.
With this in mind, Spring Security delivers three main ACL-related capabilities to your application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A way of efficiently retrieving ACL entries for all of your domain objects (and modifying those ACLs)</p>
</li>
<li>
<p>A way of ensuring a given principal is permitted to work with your objects, before methods are called</p>
</li>
<li>
<p>A way of ensuring a given principal is permitted to work with your objects (or something they return), after methods are called</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As indicated by the first bullet point, one of the main capabilities of the Spring Security ACL module is providing a high-performance way of retrieving ACLs.
This ACL repository capability is extremely important, because every domain object instance in your system might have several access control entries, and each ACL might inherit from other ACLs in a tree-like structure (this is supported out-of-the-box by Spring Security, and is very commonly used).
Spring Security&#8217;s ACL capability has been carefully designed to provide high performance retrieval of ACLs, together with pluggable caching, deadlock-minimizing database updates, independence from ORM frameworks (we use JDBC directly), proper encapsulation, and transparent database updating.</p>
</div>
<div class="paragraph">
<p>Given databases are central to the operation of the ACL module, let&#8217;s explore the four main tables used by default in the implementation.
The tables are presented below in order of size in a typical Spring Security ACL deployment, with the table with the most rows listed last:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ACL_SID allows us to uniquely identify any principal or authority in the system ("SID" stands for "security identity").
The only columns are the ID, a textual representation of the SID, and a flag to indicate whether the textual                   representation refers to a principal name or a <code>GrantedAuthority</code>.
Thus, there is a single row for each unique principal or <code>GrantedAuthority</code>.
When used in the context of receiving a permission, a SID is generally called a "recipient".</p>
</li>
<li>
<p>ACL_CLASS allows us to uniquely identify any domain object class in the system.
The only columns are the ID and the Java class name.
Thus, there is a single row for each unique Class we wish to store ACL permissions for.</p>
</li>
<li>
<p>ACL_OBJECT_IDENTITY stores information for each unique domain object instance in the system.
Columns include the ID, a foreign key to the ACL_CLASS table, a unique identifier so we know which ACL_CLASS instance we&#8217;re providing information for, the parent, a foreign key to the ACL_SID table to represent the owner of the domain object instance, and whether we allow ACL entries to inherit from any parent ACL.
We have a single row for every domain object instance we&#8217;re storing ACL permissions for.</p>
</li>
<li>
<p>Finally, ACL_ENTRY stores the individual permissions assigned to each recipient.
Columns include a foreign key to the ACL_OBJECT_IDENTITY, the recipient (i.e. a foreign key to ACL_SID), whether we&#8217;ll be auditing or not, and the integer bit mask that represents the actual permission being granted or denied.
We have a single row for every recipient that receives a permission to work with a domain object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned in the last paragraph, the ACL system uses integer bit masking.
Don&#8217;t worry, you need not be aware of the finer points of bit shifting to use the ACL system, but suffice to say that we have 32 bits we can switch on or off.
Each of these bits represents a permission, and by default the permissions are read (bit 0), write (bit 1), create (bit 2), delete (bit 3) and administer (bit 4).
It&#8217;s easy to implement your own <code>Permission</code> instance if you wish to use other permissions, and the remainder of the ACL framework will operate without knowledge of your extensions.</p>
</div>
<div class="paragraph">
<p>It is important to understand that the number of domain objects in your system has absolutely no bearing on the fact we&#8217;ve chosen to use integer bit masking.
Whilst you have 32 bits available for permissions, you could have billions of domain object instances (which will mean billions of rows in ACL_OBJECT_IDENTITY and quite probably ACL_ENTRY).
We make this point because we&#8217;ve found sometimes people mistakenly believe they need a bit for each potential domain object, which is not the case.</p>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve provided a basic overview of what the ACL system does, and what it looks like at a table structure, let&#8217;s explore the key interfaces.
The key interfaces are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Acl</code>: Every domain object has one and only one <code>Acl</code> object, which internally holds the <code>AccessControlEntry</code> s as well as knows the owner of the <code>Acl</code>.
An Acl does not refer directly to the domain object, but instead to an <code>ObjectIdentity</code>.
The <code>Acl</code> is stored in the ACL_OBJECT_IDENTITY table.</p>
</li>
<li>
<p><code>AccessControlEntry</code>: An <code>Acl</code> holds multiple <code>AccessControlEntry</code> s, which are often abbreviated as ACEs in the framework.
Each ACE refers to a specific tuple of <code>Permission</code>, <code>Sid</code> and <code>Acl</code>.
An ACE can also be granting or non-granting and contain audit settings.
The ACE is stored in the ACL_ENTRY table.</p>
</li>
<li>
<p><code>Permission</code>: A permission represents a particular immutable bit mask, and offers convenience functions for bit masking and outputting information.
The basic permissions presented above (bits 0 through 4) are contained in the <code>BasePermission</code> class.</p>
</li>
<li>
<p><code>Sid</code>: The ACL module needs to refer to principals and <code>GrantedAuthority[]</code> s.
A level of indirection is provided by the <code>Sid</code> interface, which is an abbreviation of "security identity".
Common classes include <code>PrincipalSid</code> (to represent the principal inside an <code>Authentication</code> object) and <code>GrantedAuthoritySid</code>.
The security identity information is stored in the ACL_SID table.</p>
</li>
<li>
<p><code>ObjectIdentity</code>: Each domain object is represented internally within the ACL module by an <code>ObjectIdentity</code>.
The default implementation is called <code>ObjectIdentityImpl</code>.</p>
</li>
<li>
<p><code>AclService</code>: Retrieves the <code>Acl</code> applicable for a given <code>ObjectIdentity</code>.
In the included implementation (<code>JdbcAclService</code>), retrieval operations are delegated to a <code>LookupStrategy</code>.
The <code>LookupStrategy</code> provides a highly optimized strategy for retrieving ACL information, using batched retrievals (<code>BasicLookupStrategy</code>) and supporting custom implementations that leverage materialized views, hierarchical queries and similar performance-centric, non-ANSI SQL capabilities.</p>
</li>
<li>
<p><code>MutableAclService</code>: Allows a modified <code>Acl</code> to be presented for persistence.
It is not essential to use this interface if you do not wish.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please note that our out-of-the-box AclService and related database classes all use ANSI SQL.
This should therefore work with all major databases.
At the time of writing, the system had been successfully tested using Hypersonic SQL, PostgreSQL, Microsoft SQL Server and Oracle.</p>
</div>
<div class="paragraph">
<p>Two samples ship with Spring Security that demonstrate the ACL module.
The first is the Contacts Sample, and the other is the Document Management System (DMS) Sample.
We suggest taking a look over these for examples.</p>
</div>
</div>
<div class="sect3">
<h4 id="domain-acls-getting-started"><a class="anchor" href="#domain-acls-getting-started"></a>Getting Started</h4>
<div class="paragraph">
<p>To get starting using Spring Security&#8217;s ACL capability, you will need to store your ACL information somewhere.
This necessitates the instantiation of a <code>DataSource</code> using Spring.
The <code>DataSource</code> is then injected into a <code>JdbcMutableAclService</code> and <code>BasicLookupStrategy</code> instance.
The latter provides high-performance ACL retrieval capabilities, and the former provides mutator capabilities.
Refer to one of the samples that ship with Spring Security for an example configuration.
You&#8217;ll also need to populate the database with the four ACL-specific tables listed in the last section (refer to the ACL samples for the appropriate SQL statements).</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve created the required schema and instantiated <code>JdbcMutableAclService</code>, you&#8217;ll next need to ensure your domain model supports interoperability with the Spring Security ACL package.
Hopefully <code>ObjectIdentityImpl</code> will prove sufficient, as it provides a large number of ways in which it can be used.
Most people will have domain objects that contain a <code>public Serializable getId()</code> method.
If the return type is long, or compatible with long (e.g. an int), you will find you need not give further consideration to <code>ObjectIdentity</code> issues.
Many parts of the ACL module rely on long identifiers.
If you&#8217;re not using long (or an int, byte etc), there is a very good chance you&#8217;ll need to reimplement a number of classes.
We do not intend to support non-long identifiers in Spring Security&#8217;s ACL module, as longs are already compatible with all database sequences, the most common identifier data type, and are of sufficient length to accommodate all common usage scenarios.</p>
</div>
<div class="paragraph">
<p>The following fragment of code shows how to create an <code>Acl</code>, or modify an existing <code>Acl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Prepare the information we'd like in our access control entry (ACE)
ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));
Sid sid = new PrincipalSid("Samantha");
Permission p = BasePermission.ADMINISTRATION;

// Create or update the relevant ACL
MutableAcl acl = null;
try {
acl = (MutableAcl) aclService.readAclById(oi);
} catch (NotFoundException nfe) {
acl = aclService.createAcl(oi);
}

// Now grant some permissions via an access control entry (ACE)
acl.insertAce(acl.getEntries().length, p, sid, true);
aclService.updateAcl(acl);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we&#8217;re retrieving the ACL associated with the "Foo" domain object with identifier number 44.
We&#8217;re then adding an ACE so that a principal named "Samantha" can "administer" the object.
The code fragment is relatively self-explanatory, except the insertAce method.
The first argument to the insertAce method is determining at what position in the Acl the new entry will be inserted.
In the example above, we&#8217;re just putting the new ACE at the end of the existing ACEs.
The final argument is a Boolean indicating whether the ACE is granting or denying.
Most of the time it will be granting (true), but if it is denying (false), the permissions are effectively being blocked.</p>
</div>
<div class="paragraph">
<p>Spring Security does not provide any special integration to automatically create, update or delete ACLs as part of your DAO or repository operations.
Instead, you will need to write code like shown above for your individual domain objects.
It&#8217;s worth considering using AOP on your services layer to automatically integrate the ACL information with your services layer operations.
We&#8217;ve found this quite an effective approach in the past.</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve used the above techniques to store some ACL information in the database, the next step is to actually use the ACL information as part of authorization decision logic.
You have a number of choices here.
You could write your own <code>AccessDecisionVoter</code> or <code>AfterInvocationProvider</code> that respectively fires before or after a method invocation.
Such classes would use <code>AclService</code> to retrieve the relevant ACL and then call <code>Acl.isGranted(Permission[] permission, Sid[] sids, boolean administrativeMode)</code> to decide whether permission is granted or denied.
Alternately, you could use our <code>AclEntryVoter</code>, <code>AclEntryAfterInvocationProvider</code> or <code>AclEntryAfterInvocationCollectionFilteringProvider</code> classes.
All of these classes provide a declarative-based approach to evaluating ACL information at runtime, freeing you from needing to write any code.
Please refer to the sample applications to learn how to use these classes.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oauth2"><a class="anchor" href="#_oauth2"></a>OAuth2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="oauth2login"><a class="anchor" href="#oauth2login"></a>OAuth 2.0 Login</h3>
<div class="paragraph">
<p>The OAuth 2.0 Login feature provides an application with the capability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (e.g. GitHub) or OpenID Connect 1.0 Provider (such as Google).
OAuth 2.0 Login implements the use cases: "Login with Google" or "Login with GitHub".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OAuth 2.0 Login is implemented by using the <strong>Authorization Code Grant</strong>, as specified in the <a href="https://tools.ietf.org/html/rfc6749#section-4.1">OAuth 2.0 Authorization Framework</a> and <a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OpenID Connect Core 1.0</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="oauth2login-sample-boot"><a class="anchor" href="#oauth2login-sample-boot"></a>Spring Boot 2.x Sample</h4>
<div class="paragraph">
<p>Spring Boot 2.x brings full auto-configuration capabilities for OAuth 2.0 Login.</p>
</div>
<div class="paragraph">
<p>This section shows how to configure the {gh-samples-url}/boot/oauth2login[<strong>OAuth 2.0 Login sample</strong>] using <em>Google</em> as the <em>Authentication Provider</em> and covers the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-sample-initial-setup">Initial setup</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-redirect-uri">Setting the redirect URI</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-application-config">Configure application.yml</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-boot-application">Boot up the application</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-initial-setup"><a class="anchor" href="#oauth2login-sample-initial-setup"></a>Initial setup</h5>
<div class="paragraph">
<p>To use Google&#8217;s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OAuth 2.0 implementation</a> for authentication conforms to the  <a href="https://openid.net/connect/">OpenID Connect 1.0</a> specification and is <a href="https://openid.net/certification/">OpenID Certified</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Follow the instructions on the <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a> page, starting in the section, "Setting up OAuth 2.0".</p>
</div>
<div class="paragraph">
<p>After completing the "Obtain OAuth 2.0 credentials" instructions, you should have a new OAuth Client with credentials consisting of a Client ID and a Client Secret.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-redirect-uri"><a class="anchor" href="#oauth2login-sample-redirect-uri"></a>Setting the redirect URI</h5>
<div class="paragraph">
<p>The redirect URI is the path in the application that the end-user&#8217;s user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client <em>(<a href="#oauth2login-sample-initial-setup">created in the previous step</a>)</em> on the Consent page.</p>
</div>
<div class="paragraph">
<p>In the "Set a redirect URI" sub-section, ensure that the <strong>Authorized redirect URIs</strong> field is set to <code><a href="http://localhost:8080/login/oauth2/code/google" class="bare">http://localhost:8080/login/oauth2/code/google</a></code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The default redirect URI template is <code>{baseUrl}/login/oauth2/code/{registrationId}</code>.
The <strong><em>registrationId</em></strong> is a unique identifier for the <a href="#oauth2Client-client-registration">ClientRegistration</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the OAuth Client is running behind a proxy server, it is recommended to check <a href="#http-proxy-server">Proxy Server Configuration</a> to ensure the application is correctly configured.
Also, see the supported <a href="#oauth2Client-auth-code-redirect-uri"><code>URI</code> template variables</a> for <code>redirect-uri</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-application-config"><a class="anchor" href="#oauth2login-sample-application-config"></a>Configure application.yml</h5>
<div class="paragraph">
<p>Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the <em>authentication flow</em>.
To do so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to <code>application.yml</code> and set the following configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:	<i class="conum" data-value="1"></i><b>(1)</b>
          google:	<i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 51. OAuth Client properties</div>
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring.security.oauth2.client.registration</code> is the base property prefix for OAuth Client properties.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Following the base property prefix is the ID for the <a href="#oauth2Client-client-registration">ClientRegistration</a>, such as google.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>Replace the values in the <code>client-id</code> and <code>client-secret</code> property with the OAuth 2.0 credentials you created earlier.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-boot-application"><a class="anchor" href="#oauth2login-sample-boot-application"></a>Boot up the application</h5>
<div class="paragraph">
<p>Launch the Spring Boot 2.x sample and go to <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.
You are then redirected to the default <em>auto-generated</em> login page, which displays a link for Google.</p>
</div>
<div class="paragraph">
<p>Click on the Google link, and you are then redirected to Google for authentication.</p>
</div>
<div class="paragraph">
<p>After authenticating with your Google account credentials, the next page presented to you is the Consent screen.
The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier.
Click <strong>Allow</strong> to authorize the OAuth Client to access your email address and basic profile information.</p>
</div>
<div class="paragraph">
<p>At this point, the OAuth Client retrieves your email address and basic profile information from the <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> and establishes an authenticated session.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-boot-property-mappings"><a class="anchor" href="#oauth2login-boot-property-mappings"></a>Spring Boot 2.x Property Mappings</h4>
<div class="paragraph">
<p>The following table outlines the mapping of the Spring Boot 2.x OAuth Client properties to the <a href="#oauth2Client-client-registration">ClientRegistration</a> properties.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Boot 2.x</th>
<th class="tableblock halign-left valign-top">ClientRegistration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>registrationId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-secret</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientSecret</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientAuthenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.authorization-grant-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authorizationGrantType</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.redirect-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>redirectUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.scope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scopes</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.authorization-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.authorizationUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.token-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.tokenUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.jwk-set-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.jwkSetUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.issuerUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.uri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.authenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-name-attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.userNameAttributeName</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>ClientRegistration</code> can be initially configured using discovery of an OpenID Connect Provider&#8217;s <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> or an Authorization Server&#8217;s <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>, by specifying the <code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code> property.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-common-oauth2-provider"><a class="anchor" href="#oauth2login-common-oauth2-provider"></a>CommonOAuth2Provider</h4>
<div class="paragraph">
<p><code>CommonOAuth2Provider</code> pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta.</p>
</div>
<div class="paragraph">
<p>For example, the <code>authorization-uri</code>, <code>token-uri</code>, and <code>user-info-uri</code> do not change often for a Provider.
Therefore, it makes sense to provide default values in order to reduce the required configuration.</p>
</div>
<div class="paragraph">
<p>As demonstrated previously, when we <a href="#oauth2login-sample-application-config">configured a Google client</a>, only the <code>client-id</code> and <code>client-secret</code> properties are required.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The auto-defaulting of client properties works seamlessly here because the <code>registrationId</code> (<code>google</code>) matches the <code>GOOGLE</code> <code>enum</code> (case-insensitive) in <code>CommonOAuth2Provider</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For cases where you may want to specify a different <code>registrationId</code>, such as <code>google-login</code>, you can still leverage auto-defaulting of client properties by configuring the <code>provider</code> property.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google-login:	<i class="conum" data-value="1"></i><b>(1)</b>
            provider: google	<i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>registrationId</code> is set to <code>google-login</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>provider</code> property is set to <code>google</code>, which will leverage the auto-defaulting of client properties set in <code>CommonOAuth2Provider.GOOGLE.getBuilder()</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-custom-provider-properties"><a class="anchor" href="#oauth2login-custom-provider-properties"></a>Configuring Custom Provider Properties</h4>
<div class="paragraph">
<p>There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain).</p>
</div>
<div class="paragraph">
<p>For example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints.</p>
</div>
<div class="paragraph">
<p>For these cases, Spring Boot 2.x provides the following base property for configuring custom provider properties: <code>spring.security.oauth2.client.provider.<em>[providerId]</em></code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta:	<i class="conum" data-value="1"></i><b>(1)</b>
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The base property (<code>spring.security.oauth2.client.provider.okta</code>) allows for custom configuration of protocol endpoint locations.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-override-boot-autoconfig"><a class="anchor" href="#oauth2login-override-boot-autoconfig"></a>Overriding Spring Boot 2.x Auto-configuration</h4>
<div class="paragraph">
<p>The Spring Boot 2.x auto-configuration class for OAuth Client support is <code>OAuth2ClientAutoConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>It performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Registers a <code>ClientRegistrationRepository</code> <code>@Bean</code> composed of <code>ClientRegistration</code>(s) from the configured OAuth Client properties.</p>
</li>
<li>
<p>Provides a <code>WebSecurityConfigurerAdapter</code> <code>@Configuration</code> and enables OAuth 2.0 Login through <code>httpSecurity.oauth2Login()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you need to override the auto-configuration based on your specific requirements, you may do so in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-register-clientregistrationrepository-bean">Register a ClientRegistrationRepository @Bean</a></p>
</li>
<li>
<p><a href="#oauth2login-provide-websecurityconfigureradapter">Provide a WebSecurityConfigurerAdapter</a></p>
</li>
<li>
<p><a href="#oauth2login-completely-override-autoconfiguration">Completely Override the Auto-configuration</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-register-clientregistrationrepository-bean"><a class="anchor" href="#oauth2login-register-clientregistrationrepository-bean"></a>Register a ClientRegistrationRepository @Bean</h5>
<div class="paragraph">
<p>The following example shows how to register a <code>ClientRegistrationRepository</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {
    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-provide-websecurityconfigureradapter"><a class="anchor" href="#oauth2login-provide-websecurityconfigureradapter"></a>Provide a WebSecurityConfigurerAdapter</h5>
<div class="paragraph">
<p>The following example shows how to provide a <code>WebSecurityConfigurerAdapter</code> with <code>@EnableWebSecurity</code> and enable OAuth 2.0 login through <code>httpSecurity.oauth2Login()</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(withDefaults());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-completely-override-autoconfiguration"><a class="anchor" href="#oauth2login-completely-override-autoconfiguration"></a>Completely Override the Auto-configuration</h5>
<div class="paragraph">
<p>The following example shows how to completely override the auto-configuration by registering a <code>ClientRegistrationRepository</code> <code>@Bean</code> and providing a <code>WebSecurityConfigurerAdapter</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. Overriding the auto-configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.oauth2Login(withDefaults());
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {

    @EnableWebSecurity
    class OAuth2LoginSecurityConfig: WebSecurityConfigurerAdapter() {

        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                oauth2Login { }
            }
        }
    }

    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-javaconfig-wo-boot"><a class="anchor" href="#oauth2login-javaconfig-wo-boot"></a>Java Configuration without Spring Boot 2.x</h4>
<div class="paragraph">
<p>If you are not able to use Spring Boot 2.x and would like to configure one of the pre-defined providers in <code>CommonOAuth2Provider</code> (for example, Google), apply the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.oauth2Login(withDefaults());
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	@Bean
	public OAuth2AuthorizedClientService authorizedClientService(
			ClientRegistrationRepository clientRegistrationRepository) {
		return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
	}

	@Bean
	public OAuth2AuthorizedClientRepository authorizedClientRepository(
			OAuth2AuthorizedClientService authorizedClientService) {
		return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
	}

	private ClientRegistration googleClientRegistration() {
		return CommonOAuth2Provider.GOOGLE.getBuilder("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http auto-config="true"&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;oauth2-login authorized-client-repository-ref="authorizedClientRepository"/&gt;
&lt;/http&gt;

&lt;client-registrations&gt;
	&lt;client-registration registration-id="google"
						 client-id="google-client-id"
						 client-secret="google-client-secret"
						 provider-id="google"/&gt;
&lt;/client-registrations&gt;

&lt;b:bean id="authorizedClientService"
		class="org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService"
		autowire="constructor"/&gt;

&lt;b:bean id="authorizedClientRepository"
		class="org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository"&gt;
	&lt;b:constructor-arg ref="authorizedClientService"/&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-advanced"><a class="anchor" href="#oauth2login-advanced"></a>Advanced Configuration</h4>
<div class="paragraph">
<p><code>HttpSecurity.oauth2Login()</code> provides a number of configuration options for customizing OAuth 2.0 Login.
The main configuration options are grouped into their protocol endpoint counterparts.</p>
</div>
<div class="paragraph">
<p>For example, <code>oauth2Login().authorizationEndpoint()</code> allows configuring the <em>Authorization Endpoint</em>, whereas <code>oauth2Login().tokenEndpoint()</code> allows configuring the <em>Token Endpoint</em>.</p>
</div>
<div class="paragraph">
<p>The following code shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. Advanced OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .authorizationEndpoint(authorization -&gt; authorization
			            ...
			    )
			    .redirectionEndpoint(redirection -&gt; redirection
			            ...
			    )
			    .tokenEndpoint(token -&gt; token
			            ...
			    )
			    .userInfoEndpoint(userInfo -&gt; userInfo
			            ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                authorizationEndpoint {
                    ...
                }
                redirectionEndpoint {
                    ...
                }
                tokenEndpoint {
                    ...
                }
                userInfoEndpoint {
                    ...
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The main goal of the <code>oauth2Login()</code> DSL was to closely align with the naming, as defined in the specifications.</p>
</div>
<div class="paragraph">
<p>The OAuth 2.0 Authorization Framework defines the <a href="https://tools.ietf.org/html/rfc6749#section-3">Protocol Endpoints</a> as follows:</p>
</div>
<div class="paragraph">
<p>The authorization process utilizes two authorization server endpoints (HTTP resources):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorization Endpoint: Used by the client to obtain authorization from the resource owner via user-agent redirection.</p>
</li>
<li>
<p>Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As well as one client endpoint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redirection Endpoint: Used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The OpenID Connect Core 1.0 specification defines the <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> as follows:</p>
</div>
<div class="paragraph">
<p>The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user.
To obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication.
These claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available for the <code>oauth2Login()</code> DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. OAuth2 Login Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .clientRegistrationRepository(this.clientRegistrationRepository())
			    .authorizedClientRepository(this.authorizedClientRepository())
			    .authorizedClientService(this.authorizedClientService())
			    .loginPage("/login")
			    .authorizationEndpoint(authorization -&gt; authorization
			        .baseUri(this.authorizationRequestBaseUri())
			        .authorizationRequestRepository(this.authorizationRequestRepository())
			        .authorizationRequestResolver(this.authorizationRequestResolver())
			    )
			    .redirectionEndpoint(redirection -&gt; redirection
			        .baseUri(this.authorizationResponseBaseUri())
			    )
			    .tokenEndpoint(token -&gt; token
			        .accessTokenResponseClient(this.accessTokenResponseClient())
			    )
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userAuthoritiesMapper(this.userAuthoritiesMapper())
			        .userService(this.oauth2UserService())
			        .oidcUserService(this.oidcUserService())
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                loginPage = "/login"
                authorizationEndpoint {
                    baseUri = authorizationRequestBaseUri()
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                }
                redirectionEndpoint {
                    baseUri = authorizationResponseBaseUri()
                }
                tokenEndpoint {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                    userService = oauth2UserService()
                    oidcUserService = oidcUserService()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition to the <code>oauth2Login()</code> DSL, XML configuration is also supported.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available in the <a href="#nsa-oauth2-login">security namespace</a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. OAuth2 Login XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login client-registration-repository-ref="clientRegistrationRepository"
				  authorized-client-repository-ref="authorizedClientRepository"
				  authorized-client-service-ref="authorizedClientService"
				  authorization-request-repository-ref="authorizationRequestRepository"
				  authorization-request-resolver-ref="authorizationRequestResolver"
				  access-token-response-client-ref="accessTokenResponseClient"
				  user-authorities-mapper-ref="userAuthoritiesMapper"
				  user-service-ref="oauth2UserService"
				  oidc-user-service-ref="oidcUserService"
				  login-processing-url="/login/oauth2/code/*"
				  login-page="/login"
				  authentication-success-handler-ref="authenticationSuccessHandler"
				  authentication-failure-handler-ref="authenticationFailureHandler"
				  jwt-decoder-factory-ref="jwtDecoderFactory"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sections go into more detail on each of the configuration options available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-login-page">OAuth 2.0 Login Page</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-redirection-endpoint">Redirection Endpoint</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-userinfo-endpoint">UserInfo Endpoint</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-login-page"><a class="anchor" href="#oauth2login-advanced-login-page"></a>OAuth 2.0 Login Page</h5>
<div class="paragraph">
<p>By default, the OAuth 2.0 Login Page is auto-generated by the <code>DefaultLoginPageGeneratingFilter</code>.
The default login page shows each configured OAuth Client with its <code>ClientRegistration.clientName</code> as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In order for <code>DefaultLoginPageGeneratingFilter</code> to show links for configured OAuth Clients, the registered <code>ClientRegistrationRepository</code> needs to also implement <code>Iterable&lt;ClientRegistration&gt;</code>.
See <code>InMemoryClientRegistrationRepository</code> for reference.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The link&#8217;s destination for each OAuth Client defaults to the following:</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + "/{registrationId}"</code></p>
</div>
<div class="paragraph">
<p>The following line shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;a href="/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To override the default login page, configure <code>oauth2Login().loginPage()</code> and (optionally) <code>oauth2Login().authorizationEndpoint().baseUri()</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. OAuth2 Login Page Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .loginPage("/login/oauth2")
			    ...
			    .authorizationEndpoint(authorization -&gt; authorization
			        .baseUri("/login/oauth2/authorization")
			        ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                loginPage = "/login/oauth2"
                authorizationEndpoint {
                    baseUri = "/login/oauth2/authorization"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login login-page="/login/oauth2"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You need to provide a <code>@Controller</code> with a <code>@RequestMapping("/login/oauth2")</code> that is capable of rendering the custom login page.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As noted earlier, configuring <code>oauth2Login().authorizationEndpoint().baseUri()</code> is optional.
However, if you choose to customize it, ensure the link to each OAuth Client matches the <code>authorizationEndpoint().baseUri()</code>.</p>
</div>
<div class="paragraph">
<p>The following line shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;a href="/login/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-redirection-endpoint"><a class="anchor" href="#oauth2login-advanced-redirection-endpoint"></a>Redirection Endpoint</h5>
<div class="paragraph">
<p>The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client via the Resource Owner user-agent.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
OAuth 2.0 Login leverages the Authorization Code Grant.
Therefore, the authorization credential is the authorization code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default Authorization Response <code>baseUri</code> (redirection endpoint) is <code><strong>/login/oauth2/code/</strong>*</code>, which is defined in <code>OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI</code>.</p>
</div>
<div class="paragraph">
<p>If you would like to customize the Authorization Response <code>baseUri</code>, configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. Redirection Endpoint Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .redirectionEndpoint(redirection -&gt; redirection
			        .baseUri("/login/oauth2/callback/*")
			        ...
			    )
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                redirectionEndpoint {
                    baseUri = "/login/oauth2/callback/*"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login login-processing-url="/login/oauth2/callback/*"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You also need to ensure the <code>ClientRegistration.redirectUri</code> matches the custom Authorization Response <code>baseUri</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
	.clientId("google-client-id")
	.clientSecret("google-client-secret")
	.redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
	.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
    .clientId("google-client-id")
    .clientSecret("google-client-secret")
    .redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
    .build()</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-userinfo-endpoint"><a class="anchor" href="#oauth2login-advanced-userinfo-endpoint"></a>UserInfo Endpoint</h5>
<div class="paragraph">
<p>The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities">Mapping User Authorities</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oauth2-user-service">OAuth 2.0 UserService</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oidc-user-service">OpenID Connect 1.0 UserService</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-map-authorities"><a class="anchor" href="#oauth2login-advanced-map-authorities"></a>Mapping User Authorities</h6>
<div class="paragraph">
<p>After the user successfully authenticates with the OAuth 2.0 Provider, the <code>OAuth2User.getAuthorities()</code> (or <code>OidcUser.getAuthorities()</code>) may be mapped to a new set of <code>GrantedAuthority</code> instances, which will be supplied to <code>OAuth2AuthenticationToken</code> when completing the authentication.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthenticationToken.getAuthorities()</code> is used for authorizing requests, such as in <code>hasRole('USER')</code> or <code>hasRole('ADMIN')</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are a couple of options to choose from when mapping user authorities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper">Using a GrantedAuthoritiesMapper</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-map-authorities-oauth2userservice">Delegation-based strategy with OAuth2UserService</a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-grantedauthoritiesmapper"><a class="anchor" href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper"></a>Using a GrantedAuthoritiesMapper</h7>
<div class="paragraph">
<p>Provide an implementation of <code>GrantedAuthoritiesMapper</code> and configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. Granted Authorities Mapper Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userAuthoritiesMapper(this.userAuthoritiesMapper())
			        ...
			    )
			);
	}

	private GrantedAuthoritiesMapper userAuthoritiesMapper() {
		return (authorities) -&gt; {
			Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

			authorities.forEach(authority -&gt; {
				if (OidcUserAuthority.class.isInstance(authority)) {
					OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;

					OidcIdToken idToken = oidcUserAuthority.getIdToken();
					OidcUserInfo userInfo = oidcUserAuthority.getUserInfo();

					// Map the claims found in idToken and/or userInfo
					// to one or more GrantedAuthority's and add it to mappedAuthorities

				} else if (OAuth2UserAuthority.class.isInstance(authority)) {
					OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;

					Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes();

					// Map the attributes found in userAttributes
					// to one or more GrantedAuthority's and add it to mappedAuthorities

				}
			});

			return mappedAuthorities;
		};
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                }
            }
        }
    }

    private fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection&lt;GrantedAuthority&gt; -&gt;
        val mappedAuthorities = emptySet&lt;GrantedAuthority&gt;()

        authorities.forEach { authority -&gt;
            if (authority is OidcUserAuthority) {
                val idToken = authority.idToken
                val userInfo = authority.userInfo
                // Map the claims found in idToken and/or userInfo
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            } else if (authority is OAuth2UserAuthority) {
                val userAttributes = authority.attributes
                // Map the attributes found in userAttributes
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            }
        }

        mappedAuthorities
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login user-authorities-mapper-ref="userAuthoritiesMapper"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you may register a <code>GrantedAuthoritiesMapper</code> <code>@Bean</code> to have it automatically applied to the configuration, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. Granted Authorities Mapper Bean Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
		    .oauth2Login(withDefaults());
	}

	@Bean
	public GrantedAuthoritiesMapper userAuthoritiesMapper() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login { }
        }
    }

    @Bean
    fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-oauth2userservice"><a class="anchor" href="#oauth2login-advanced-map-authorities-oauth2userservice"></a>Delegation-based strategy with OAuth2UserService</h7>
<div class="paragraph">
<p>This strategy is advanced compared to using a <code>GrantedAuthoritiesMapper</code>, however, it&#8217;s also more flexible as it gives you access to the <code>OAuth2UserRequest</code> and <code>OAuth2User</code> (when using an OAuth 2.0 UserService) or <code>OidcUserRequest</code> and <code>OidcUser</code> (when using an OpenID Connect 1.0 UserService).</p>
</div>
<div class="paragraph">
<p>The <code>OAuth2UserRequest</code> (and <code>OidcUserRequest</code>) provides you access to the associated <code>OAuth2AccessToken</code>, which is very useful in the cases where the <em>delegator</em> needs to fetch authority information from a protected resource before it can map the custom authorities for the user.</p>
</div>
<div class="paragraph">
<p>The following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. OAuth2UserService Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .oidcUserService(this.oidcUserService())
			        ...
			    )
			);
	}

	private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
		final OidcUserService delegate = new OidcUserService();

		return (userRequest) -&gt; {
			// Delegate to the default implementation for loading a user
			OidcUser oidcUser = delegate.loadUser(userRequest);

			OAuth2AccessToken accessToken = userRequest.getAccessToken();
			Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

			// TODO
			// 1) Fetch the authority information from the protected resource using accessToken
			// 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities

			// 3) Create a copy of oidcUser but use the mappedAuthorities instead
			oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo());

			return oidcUser;
		};
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                }
            }
        }
    }

    @Bean
    fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        val delegate = OidcUserService()

        return OAuth2UserService { userRequest -&gt;
            // Delegate to the default implementation for loading a user
            var oidcUser = delegate.loadUser(userRequest)

            val accessToken = userRequest.accessToken
            val mappedAuthorities = HashSet&lt;GrantedAuthority&gt;()

            // TODO
            // 1) Fetch the authority information from the protected resource using accessToken
            // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities
            // 3) Create a copy of oidcUser but use the mappedAuthorities instead
            oidcUser = DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo)

            oidcUser
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-login oidc-user-service-ref="oidcUserService"
				  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oauth2-user-service"><a class="anchor" href="#oauth2login-advanced-oauth2-user-service"></a>OAuth 2.0 UserService</h6>
<div class="paragraph">
<p><code>DefaultOAuth2UserService</code> is an implementation of an <code>OAuth2UserService</code> that supports standard OAuth 2.0 Provider&#8217;s.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2UserService</code> obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an <code>AuthenticatedPrincipal</code> in the form of an <code>OAuth2User</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>DefaultOAuth2UserService</code> uses a <code>RestOperations</code> when requesting the user attributes at the UserInfo Endpoint.</p>
</div>
<div class="paragraph">
<p>If you need to customize the pre-processing of the UserInfo Request, you can provide <code>DefaultOAuth2UserService.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2UserRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a UserInfo Request that sets the <code>OAuth2AccessToken</code> in the <code>Authorization</code> header by default.</p>
</div>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the UserInfo Response, you will need to provide <code>DefaultOAuth2UserService.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error (400 Bad Request).
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultOAuth2UserService</code> or provide your own implementation of <code>OAuth2UserService</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
			    .userInfoEndpoint(userInfo -&gt; userInfo
			        .userService(this.oauth2UserService())
			        ...
			    )
			);
	}

	private OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oauth2UserService() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userService = oauth2UserService()
                    // ...
                }
            }
        }
    }

    private fun oauth2UserService(): OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oidc-user-service"><a class="anchor" href="#oauth2login-advanced-oidc-user-service"></a>OpenID Connect 1.0 UserService</h6>
<div class="paragraph">
<p><code>OidcUserService</code> is an implementation of an <code>OAuth2UserService</code> that supports OpenID Connect 1.0 Provider&#8217;s.</p>
</div>
<div class="paragraph">
<p>The <code>OidcUserService</code> leverages the <code>DefaultOAuth2UserService</code> when requesting the user attributes at the UserInfo Endpoint.</p>
</div>
<div class="paragraph">
<p>If you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide <code>OidcUserService.setOauth2UserService()</code> with a custom configured <code>DefaultOAuth2UserService</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>OidcUserService</code> or provide your own implementation of <code>OAuth2UserService</code> for OpenID Connect 1.0 Provider&#8217;s, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Login(oauth2 -&gt; oauth2
				.userInfoEndpoint(userInfo -&gt; userInfo
				    .oidcUserService(this.oidcUserService())
				    ...
			    )
			);
	}

	private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                    // ...
                }
            }
        }
    }

    private fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-idtoken-verify"><a class="anchor" href="#oauth2login-advanced-idtoken-verify"></a>ID Token Signature Verification</h5>
<div class="paragraph">
<p>OpenID Connect 1.0 Authentication introduces the <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID Token</a>, which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client.</p>
</div>
<div class="paragraph">
<p>The ID Token is represented as a <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a> (JWT) and MUST be signed using <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a> (JWS).</p>
</div>
<div class="paragraph">
<p>The <code>OidcIdTokenDecoderFactory</code> provides a <code>JwtDecoder</code> used for <code>OidcIdToken</code> signature verification. The default algorithm is <code>RS256</code> but may be different when assigned during client registration.
For these cases, a resolver may be configured to return the expected JWS algorithm assigned for a specific client.</p>
</div>
<div class="paragraph">
<p>The JWS algorithm resolver is a <code>Function</code> that accepts a <code>ClientRegistration</code> and returns the expected <code>JwsAlgorithm</code> for the client, eg. <code>SignatureAlgorithm.RS256</code> or <code>MacAlgorithm.HS256</code></p>
</div>
<div class="paragraph">
<p>The following code shows how to configure the <code>OidcIdTokenDecoderFactory</code> <code>@Bean</code> to default to <code>MacAlgorithm.HS256</code> for all <code>ClientRegistration</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoderFactory&lt;ClientRegistration&gt; idTokenDecoderFactory() {
	OidcIdTokenDecoderFactory idTokenDecoderFactory = new OidcIdTokenDecoderFactory();
	idTokenDecoderFactory.setJwsAlgorithmResolver(clientRegistration -&gt; MacAlgorithm.HS256);
	return idTokenDecoderFactory;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun idTokenDecoderFactory(): JwtDecoderFactory&lt;ClientRegistration?&gt; {
    val idTokenDecoderFactory = OidcIdTokenDecoderFactory()
    idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 }
    return idTokenDecoderFactory
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For MAC based algorithms such as <code>HS256</code>, <code>HS384</code> or <code>HS512</code>, the <code>client-secret</code> corresponding to the <code>client-id</code> is used as the symmetric key for signature verification.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If more than one <code>ClientRegistration</code> is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided <code>ClientRegistration</code> to determine which algorithm to return.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-oidc-logout"><a class="anchor" href="#oauth2login-advanced-oidc-logout"></a>OpenID Connect 1.0 Logout</h5>
<div class="paragraph">
<p>OpenID Connect Session Management 1.0 allows the ability to log out the End-User at the Provider using the Client.
One of the strategies available is <a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-Initiated Logout</a>.</p>
</div>
<div class="paragraph">
<p>If the OpenID Provider supports both Session Management and <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">Discovery</a>, the client may obtain the <code>end_session_endpoint</code> <code>URL</code> from the OpenID Provider&#8217;s <a href="https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata">Discovery Metadata</a>.
This can be achieved by configuring the <code>ClientRegistration</code> with the <code>issuer-uri</code>, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            ...
        provider:
          okta:
            issuer-uri: https://dev-1234.oktapreview.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OidcClientInitiatedLogoutSuccessHandler</code>, which implements RP-Initiated Logout, may be configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(withDefaults())
			.logout(logout -&gt; logout
				.logoutSuccessHandler(oidcLogoutSuccessHandler())
			);
	}

	private LogoutSuccessHandler oidcLogoutSuccessHandler() {
		OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler =
				new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository);

		// Sets the location that the End-User's User Agent will be redirected to
		// after the logout has been performed at the Provider
		oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}");

		return oidcLogoutSuccessHandler;
	}
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` supports the `{baseUrl}` placeholder.
If used, the application's base URL, like `https://app.example.org`, will replace it at request time.</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {
    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
            logout {
                logoutSuccessHandler = oidcLogoutSuccessHandler()
            }
        }
    }

    private fun oidcLogoutSuccessHandler(): LogoutSuccessHandler {
        val oidcLogoutSuccessHandler = OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository)

        // Sets the location that the End-User's User Agent will be redirected to
        // after the logout has been performed at the Provider
        oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}")
        return oidcLogoutSuccessHandler
    }
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` supports the `{baseUrl}` placeholder.
If used, the application's base URL, like `https://app.example.org`, will replace it at request time.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2client"><a class="anchor" href="#oauth2client"></a>OAuth 2.0 Client</h3>
<div class="paragraph">
<p>The OAuth 2.0 Client features provide support for the Client role as defined in the <a href="https://tools.ietf.org/html/rfc6749#section-1.1">OAuth 2.0 Authorization Framework</a>.</p>
</div>
<div class="paragraph">
<p>At a high-level, the core features available are:</p>
</div>
<div class="ulist">
<div class="title">Authorization Grant support</div>
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">Authorization Code</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-6">Refresh Token</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">Client Credentials</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">Resource Owner Password Credentials</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">JWT Bearer</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Client Authentication support</div>
<ul>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.2">JWT Bearer</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">HTTP Client support</div>
<ul>
<li>
<p><a href="#oauth2Client-webclient-servlet"><code>WebClient</code> integration for Servlet Environments</a> (for requesting protected resources)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>HttpSecurity.oauth2Client()</code> DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client.
In addition, <code>HttpSecurity.oauth2Client().authorizationCodeGrant()</code> enables the customization of the Authorization Code grant.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options provided by the <code>HttpSecurity.oauth2Client()</code> DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. OAuth2 Client Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.clientRegistrationRepository(this.clientRegistrationRepository())
				.authorizedClientRepository(this.authorizedClientRepository())
				.authorizedClientService(this.authorizedClientService())
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					.authorizationRequestResolver(this.authorizationRequestResolver())
					.accessTokenResponseClient(this.accessTokenResponseClient())
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition to the <code>HttpSecurity.oauth2Client()</code> DSL, XML configuration is also supported.</p>
</div>
<div class="paragraph">
<p>The following code shows the complete configuration options available in the <a href="#nsa-oauth2-client">security namespace</a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. OAuth2 Client XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client client-registration-repository-ref="clientRegistrationRepository"
				   authorized-client-repository-ref="authorizedClientRepository"
				   authorized-client-service-ref="authorizedClientService"&gt;
		&lt;authorization-code-grant
				authorization-request-repository-ref="authorizationRequestRepository"
				authorization-request-resolver-ref="authorizationRequestResolver"
				access-token-response-client-ref="accessTokenResponseClient"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClientManager</code> is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more <code>OAuth2AuthorizedClientProvider</code>(s).</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to register an <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code> and associate it with an <code>OAuth2AuthorizedClientProvider</code> composite that provides support for the <code>authorization_code</code>, <code>refresh_token</code>, <code>client_credentials</code> and <code>password</code> authorization grant types:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider: OAuth2AuthorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sections will go into more detail on the core components used by OAuth 2.0 Client and the configuration options available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-core-interface-class">Core Interfaces / Classes</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-client-registration">ClientRegistration</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-registration-repo">ClientRegistrationRepository</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-client">OAuth2AuthorizedClient</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-auth-grant-support">Authorization Grant Support</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-auth-code-grant">Authorization Code</a></p>
</li>
<li>
<p><a href="#oauth2Client-refresh-token-grant">Refresh Token</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-creds-grant">Client Credentials</a></p>
</li>
<li>
<p><a href="#oauth2Client-password-grant">Resource Owner Password Credentials</a></p>
</li>
<li>
<p><a href="#oauth2Client-jwt-bearer-grant">JWT Bearer</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-client-auth-support">Client Authentication Support</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-jwt-bearer-auth">JWT Bearer</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-additional-features">Additional Features</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-registered-authorized-client">Resolving an Authorized Client</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-webclient-servlet">WebClient integration for Servlet Environments</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2Client-core-interface-class"><a class="anchor" href="#oauth2Client-core-interface-class"></a>Core Interfaces / Classes</h4>
<div class="sect4">
<h5 id="oauth2Client-client-registration"><a class="anchor" href="#oauth2Client-client-registration"></a>ClientRegistration</h5>
<div class="paragraph">
<p><code>ClientRegistration</code> is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.</p>
</div>
<div class="paragraph">
<p>A client registration holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistration</code> and its properties are defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class ClientRegistration {
	private String registrationId;	<i class="conum" data-value="1"></i><b>(1)</b>
	private String clientId;	<i class="conum" data-value="2"></i><b>(2)</b>
	private String clientSecret;	<i class="conum" data-value="3"></i><b>(3)</b>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<i class="conum" data-value="4"></i><b>(4)</b>
	private AuthorizationGrantType authorizationGrantType;	<i class="conum" data-value="5"></i><b>(5)</b>
	private String redirectUri;	<i class="conum" data-value="6"></i><b>(6)</b>
	private Set&lt;String&gt; scopes;	<i class="conum" data-value="7"></i><b>(7)</b>
	private ProviderDetails providerDetails;
	private String clientName;	<i class="conum" data-value="8"></i><b>(8)</b>

	public class ProviderDetails {
		private String authorizationUri;	<i class="conum" data-value="9"></i><b>(9)</b>
		private String tokenUri;	<i class="conum" data-value="10"></i><b>(10)</b>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<i class="conum" data-value="11"></i><b>(11)</b>
		private String issuerUri;	<i class="conum" data-value="12"></i><b>(12)</b>
        private Map&lt;String, Object&gt; configurationMetadata;  <i class="conum" data-value="13"></i><b>(13)</b>

		public class UserInfoEndpoint {
			private String uri;	<i class="conum" data-value="14"></i><b>(14)</b>
            private AuthenticationMethod authenticationMethod;  <i class="conum" data-value="15"></i><b>(15)</b>
			private String userNameAttributeName;	<i class="conum" data-value="16"></i><b>(16)</b>

		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>registrationId</code>: The ID that uniquely identifies the <code>ClientRegistration</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>clientId</code>: The client identifier.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>clientSecret</code>: The client secret.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>clientAuthenticationMethod</code>: The method used to authenticate the Client with the Provider.
The supported values are <strong>client_secret_basic</strong>, <strong>client_secret_post</strong>, <strong>private_key_jwt</strong>, <strong>client_secret_jwt</strong> and <strong>none</strong> <a href="https://tools.ietf.org/html/rfc6749#section-2.1">(public clients)</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>authorizationGrantType</code>: The OAuth 2.0 Authorization Framework defines four <a href="https://tools.ietf.org/html/rfc6749#section-1.3">Authorization Grant</a> types.
The supported values are <code>authorization_code</code>, <code>client_credentials</code>, <code>password</code>, as well as, extension grant type <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>redirectUri</code>: The client&#8217;s registered redirect URI that the <em>Authorization Server</em> redirects the end-user&#8217;s user-agent
to after the end-user has authenticated and authorized access to the client.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>scopes</code>: The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>clientName</code>: A descriptive name used for the client.
The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>authorizationUri</code>: The Authorization Endpoint URI for the Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td><code>tokenUri</code>: The Token Endpoint URI for the Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td><code>jwkSetUri</code>: The URI used to retrieve the <a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a> Set from the Authorization Server,
which contains the cryptographic key(s) used to verify the <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a> of the ID Token and optionally the UserInfo Response.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td><code>issuerUri</code>: Returns the issuer identifier uri for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td><code>configurationMetadata</code>: The <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">OpenID Provider Configuration Information</a>.
This information will only be available if the Spring Boot 2.x property <code>spring.security.oauth2.client.provider.[providerId].issuerUri</code> is configured.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td><code>(userInfoEndpoint)uri</code>: The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td><code>(userInfoEndpoint)authenticationMethod</code>: The authentication method used when sending the access token to the UserInfo Endpoint.
The supported values are <strong>header</strong>, <strong>form</strong> and <strong>query</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td><code>userNameAttributeName</code>: The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>ClientRegistration</code> can be initially configured using discovery of an OpenID Connect Provider&#8217;s <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> or an Authorization Server&#8217;s <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistrations</code> provides convenience methods for configuring a <code>ClientRegistration</code> in this way, as can be seen in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientRegistration clientRegistration =
    ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val clientRegistration = ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above code will query in series <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">https://idp.example.com/issuer/.well-known/openid-configuration</a></code>, and then <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">https://idp.example.com/.well-known/openid-configuration/issuer</a></code>, and finally <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/issuer</a></code>, stopping at the first to return a 200 response.</p>
</div>
<div class="paragraph">
<p>As an alternative, you can use <code>ClientRegistrations.fromOidcIssuerLocation()</code> to only query the OpenID Connect Provider&#8217;s Configuration endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-registration-repo"><a class="anchor" href="#oauth2Client-client-registration-repo"></a>ClientRegistrationRepository</h5>
<div class="paragraph">
<p>The <code>ClientRegistrationRepository</code> serves as a repository for OAuth 2.0 / OpenID Connect 1.0 <code>ClientRegistration</code>(s).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Client registration information is ultimately stored and owned by the associated Authorization Server.
This repository provides the ability to retrieve a sub-set of the primary client registration information, which is stored with the Authorization Server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot 2.x auto-configuration binds each of the properties under <code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code> to an instance of <code>ClientRegistration</code> and then composes each of the <code>ClientRegistration</code> instance(s) within a <code>ClientRegistrationRepository</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default implementation of <code>ClientRegistrationRepository</code> is <code>InMemoryClientRegistrationRepository</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The auto-configuration also registers the <code>ClientRegistrationRepository</code> as a <code>@Bean</code> in the <code>ApplicationContext</code> so that it is available for dependency-injection, if needed by the application.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@GetMapping("/")
	public String index() {
		ClientRegistration oktaRegistration =
			this.clientRegistrationRepository.findByRegistrationId("okta");

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    @GetMapping("/")
    fun index(): String {
        val oktaRegistration =
                this.clientRegistrationRepository.findByRegistrationId("okta")

        //...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-client"><a class="anchor" href="#oauth2Client-authorized-client"></a>OAuth2AuthorizedClient</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> is a representation of an Authorized Client.
A client is considered to be authorized when the end-user (Resource Owner) has granted authorization to the client to access its protected resources.</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> serves the purpose of associating an <code>OAuth2AccessToken</code> (and optional <code>OAuth2RefreshToken</code>) to a <code>ClientRegistration</code> (client) and resource owner, who is the <code>Principal</code> end-user that granted the authorization.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-repo-service"><a class="anchor" href="#oauth2Client-authorized-repo-service"></a>OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientRepository</code> is responsible for persisting <code>OAuth2AuthorizedClient</code>(s) between web requests.
Whereas, the primary role of <code>OAuth2AuthorizedClientService</code> is to manage <code>OAuth2AuthorizedClient</code>(s) at the application-level.</p>
</div>
<div class="paragraph">
<p>From a developer perspective, the <code>OAuth2AuthorizedClientRepository</code> or <code>OAuth2AuthorizedClientService</code> provides the capability to lookup an <code>OAuth2AccessToken</code> associated with a client so that it may be used to initiate a protected resource request.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @GetMapping("/")
    public String index(Authentication authentication) {
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientService: OAuth2AuthorizedClientService

    @GetMapping("/")
    fun index(authentication: Authentication): String {
        val authorizedClient: OAuth2AuthorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());
        val accessToken = authorizedClient.accessToken

        ...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot 2.x auto-configuration registers an <code>OAuth2AuthorizedClientRepository</code> and/or <code>OAuth2AuthorizedClientService</code> <code>@Bean</code> in the <code>ApplicationContext</code>.
However, the application may choose to override and register a custom <code>OAuth2AuthorizedClientRepository</code> or <code>OAuth2AuthorizedClientService</code> <code>@Bean</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AuthorizedClientService</code> is <code>InMemoryOAuth2AuthorizedClientService</code>, which stores <code>OAuth2AuthorizedClient</code>(s) in-memory.</p>
</div>
<div class="paragraph">
<p>Alternatively, the JDBC implementation <code>JdbcOAuth2AuthorizedClientService</code> may be configured for persisting <code>OAuth2AuthorizedClient</code>(s) in a database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>JdbcOAuth2AuthorizedClientService</code> depends on the table definition described in <a href="#dbschema-oauth2-client">OAuth 2.0 Client Schema</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-manager-provider"><a class="anchor" href="#oauth2Client-authorized-manager-provider"></a>OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</h5>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClientManager</code> is responsible for the overall management of <code>OAuth2AuthorizedClient</code>(s).</p>
</div>
<div class="paragraph">
<p>The primary responsibilities include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorizing (or re-authorizing) an OAuth 2.0 Client, using an <code>OAuth2AuthorizedClientProvider</code>.</p>
</li>
<li>
<p>Delegating the persistence of an <code>OAuth2AuthorizedClient</code>, typically using an <code>OAuth2AuthorizedClientService</code> or <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
<li>
<p>Delegating to an <code>OAuth2AuthorizationSuccessHandler</code> when an OAuth 2.0 Client has been successfully authorized (or re-authorized).</p>
</li>
<li>
<p>Delegating to an <code>OAuth2AuthorizationFailureHandler</code> when an OAuth 2.0 Client fails to authorize (or re-authorize).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>OAuth2AuthorizedClientProvider</code> implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client.
Implementations will typically implement an authorization grant type, eg. <code>authorization_code</code>, <code>client_credentials</code>, etc.</p>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AuthorizedClientManager</code> is <code>DefaultOAuth2AuthorizedClientManager</code>, which is associated with an <code>OAuth2AuthorizedClientProvider</code> that may support multiple authorization grant types using a delegation-based composite.
The <code>OAuth2AuthorizedClientProviderBuilder</code> may be used to configure and build the delegation-based composite.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure and build an <code>OAuth2AuthorizedClientProvider</code> composite that provides support for the <code>authorization_code</code>, <code>refresh_token</code>, <code>client_credentials</code> and <code>password</code> authorization grant types:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When an authorization attempt succeeds, the <code>DefaultOAuth2AuthorizedClientManager</code> will delegate to the <code>OAuth2AuthorizationSuccessHandler</code>, which (by default) will save the <code>OAuth2AuthorizedClient</code> via the <code>OAuth2AuthorizedClientRepository</code>.
In the case of a re-authorization failure, eg. a refresh token is no longer valid, the previously saved <code>OAuth2AuthorizedClient</code> will be removed from the <code>OAuth2AuthorizedClientRepository</code> via the <code>RemoveAuthorizedClientOAuth2AuthorizationFailureHandler</code>.
The default behaviour may be customized via <code>setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler)</code> and <code>setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultOAuth2AuthorizedClientManager</code> is also associated with a <code>contextAttributesMapper</code> of type <code>Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt;</code>, which is responsible for mapping attribute(s) from the <code>OAuth2AuthorizeRequest</code> to a <code>Map</code> of attributes to be associated to the <code>OAuth2AuthorizationContext</code>.
This can be useful when you need to supply an <code>OAuth2AuthorizedClientProvider</code> with required (supported) attribute(s), eg. the <code>PasswordOAuth2AuthorizedClientProvider</code> requires the resource owner&#8217;s <code>username</code> and <code>password</code> to be available in <code>OAuth2AuthorizationContext.getAttributes()</code>.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of the <code>contextAttributesMapper</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
	return authorizeRequest -&gt; {
		Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
			contextAttributes = new HashMap&lt;&gt;();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username: String = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password: String = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultOAuth2AuthorizedClientManager</code> is designed to be used <strong><em>within</em></strong> the context of a <code>HttpServletRequest</code>.
When operating <strong><em>outside</em></strong> of a <code>HttpServletRequest</code> context, use <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> instead.</p>
</div>
<div class="paragraph">
<p>A <em>service application</em> is a common use case for when to use an <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code>.
Service applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account.
An OAuth 2.0 Client configured with the <code>client_credentials</code> grant type can be considered a type of service application.</p>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure an <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> that provides support for the <code>client_credentials</code> grant type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientService authorizedClientService) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager =
			new AuthorizedClientServiceOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientService);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientService)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-auth-grant-support"><a class="anchor" href="#oauth2Client-auth-grant-support"></a>Authorization Grant Support</h4>
<div class="sect4">
<h5 id="oauth2Client-auth-code-grant"><a class="anchor" href="#oauth2Client-auth-code-grant"></a>Authorization Code</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">Authorization Code</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_obtaining_authorization"><a class="anchor" href="#_obtaining_authorization"></a>Obtaining Authorization</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">Authorization Request/Response</a> protocol flow for the Authorization Code grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_initiating_the_authorization_request"><a class="anchor" href="#_initiating_the_authorization_request"></a>Initiating the Authorization Request</h6>
<div class="paragraph">
<p>The <code>OAuth2AuthorizationRequestRedirectFilter</code> uses an <code>OAuth2AuthorizationRequestResolver</code> to resolve an <code>OAuth2AuthorizationRequest</code> and initiate the Authorization Code grant flow by redirecting the end-user&#8217;s user-agent to the Authorization Server&#8217;s Authorization Endpoint.</p>
</div>
<div class="paragraph">
<p>The primary role of the <code>OAuth2AuthorizationRequestResolver</code> is to resolve an <code>OAuth2AuthorizationRequest</code> from the provided web request.
The default implementation <code>DefaultOAuth2AuthorizationRequestResolver</code> matches on the (default) path <code>/oauth2/authorization/{registrationId}</code> extracting the <code>registrationId</code> and using it to build the <code>OAuth2AuthorizationRequest</code> for the associated <code>ClientRegistration</code>.</p>
</div>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            scope: read, write
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>A request with the base path <code>/oauth2/authorization/okta</code> will initiate the Authorization Request redirect by the <code>OAuth2AuthorizationRequestRedirectFilter</code> and ultimately start the Authorization Code grant flow.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>AuthorizationCodeOAuth2AuthorizedClientProvider</code> is an implementation of <code>OAuth2AuthorizedClientProvider</code> for the Authorization Code grant,
which also initiates the Authorization Request redirect by the <code>OAuth2AuthorizationRequestRedirectFilter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the OAuth 2.0 Client is a <a href="https://tools.ietf.org/html/rfc6749#section-2.1">Public Client</a>, then configure the OAuth 2.0 Client registration as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Public Clients are supported using <a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> (PKCE).
If the client is running in an untrusted environment (eg. native application or web browser-based application) and therefore incapable of maintaining the confidentiality of it&#8217;s credentials, PKCE will automatically be used when the following conditions are true:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>client-secret</code> is omitted (or empty)</p>
</li>
<li>
<p><code>client-authentication-method</code> is set to "none" (<code>ClientAuthenticationMethod.NONE</code>)</p>
</li>
</ol>
</div>
<div id="oauth2Client-auth-code-redirect-uri" class="paragraph">
<p>The <code>DefaultOAuth2AuthorizationRequestResolver</code> also supports <code>URI</code> template variables for the <code>redirect-uri</code> using <code>UriComponentsBuilder</code>.</p>
</div>
<div class="paragraph">
<p>The following configuration uses all the supported <code>URI</code> template variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            ...
            redirect-uri: "{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"
            ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>{baseUrl}</code> resolves to <code>{baseScheme}://{baseHost}{basePort}{basePath}</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuring the <code>redirect-uri</code> with <code>URI</code> template variables is especially useful when the OAuth 2.0 Client is running behind a <a href="#http-proxy-server">Proxy Server</a>.
This ensures that the <code>X-Forwarded-*</code> headers are used when expanding the <code>redirect-uri</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_authorization_request"><a class="anchor" href="#_customizing_the_authorization_request"></a>Customizing the Authorization Request</h6>
<div class="paragraph">
<p>One of the primary use cases an <code>OAuth2AuthorizationRequestResolver</code> can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework.</p>
</div>
<div class="paragraph">
<p>For example, OpenID Connect defines additional OAuth 2.0 request parameters for the <a href="https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest">Authorization Code Flow</a> extending from the standard parameters defined in the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">OAuth 2.0 Authorization Framework</a>.
One of those extended parameters is the <code>prompt</code> parameter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OPTIONAL. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are: none, login, consent, select_account
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to configure the <code>DefaultOAuth2AuthorizationRequestResolver</code> with a <code>Consumer&lt;OAuth2AuthorizationRequest.Builder&gt;</code> that customizes the Authorization Request for <code>oauth2Login()</code>, by including the request parameter <code>prompt=consent</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -&gt; authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(oauth2 -&gt; oauth2
				.authorizationEndpoint(authorization -&gt; authorization
					.authorizationRequestResolver(
						authorizationRequestResolver(this.clientRegistrationRepository)
					)
				)
			);
	}

	private OAuth2AuthorizationRequestResolver authorizationRequestResolver(
			ClientRegistrationRepository clientRegistrationRepository) {

		DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver =
				new DefaultOAuth2AuthorizationRequestResolver(
						clientRegistrationRepository, "/oauth2/authorization");
		authorizationRequestResolver.setAuthorizationRequestCustomizer(
				authorizationRequestCustomizer());

		return  authorizationRequestResolver;
	}

	private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
		return customizer -&gt; customizer
					.additionalParameters(params -&gt; params.put("prompt", "consent"));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    @Autowired
    private lateinit var customClientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login {
                authorizationEndpoint {
                    authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)
                }
            }
        }
    }

    private fun authorizationRequestResolver(
            clientRegistrationRepository: ClientRegistrationRepository?): OAuth2AuthorizationRequestResolver? {
        val authorizationRequestResolver = DefaultOAuth2AuthorizationRequestResolver(
                clientRegistrationRepository, "/oauth2/authorization")
        authorizationRequestResolver.setAuthorizationRequestCustomizer(
                authorizationRequestCustomizer())
        return authorizationRequestResolver
    }

    private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
        return Consumer { customizer -&gt;
            customizer
                    .additionalParameters { params -&gt; params["prompt"] = "consent" }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the simple use case, where the additional request parameter is always the same for a specific provider, it may be added directly in the <code>authorization-uri</code> property.</p>
</div>
<div class="paragraph">
<p>For example, if the value for the request parameter <code>prompt</code> is always <code>consent</code> for the provider <code>okta</code>, than simply configure as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows the common use case of adding a custom parameter on top of the standard parameters.
Alternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by simply overriding the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> property.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthorizationRequest.Builder.build()</code> constructs the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code>, which represents the Authorization Request URI including all query parameters using the <code>application/x-www-form-urlencoded</code> format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a variation of <code>authorizationRequestCustomizer()</code> from the preceding example, and instead overrides the <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> property.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
	return customizer -&gt; customizer
				.authorizationRequestUri(uriBuilder -&gt; uriBuilder
					.queryParam("prompt", "consent").build());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
    return Consumer { customizer: OAuth2AuthorizationRequest.Builder -&gt;
        customizer
                .authorizationRequestUri { uriBuilder: UriBuilder -&gt;
                    uriBuilder
                            .queryParam("prompt", "consent").build()
                }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_storing_the_authorization_request"><a class="anchor" href="#_storing_the_authorization_request"></a>Storing the Authorization Request</h6>
<div class="paragraph">
<p>The <code>AuthorizationRequestRepository</code> is responsible for the persistence of the <code>OAuth2AuthorizationRequest</code> from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>OAuth2AuthorizationRequest</code> is used to correlate and validate the Authorization Response.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>AuthorizationRequestRepository</code> is <code>HttpSessionOAuth2AuthorizationRequestRepository</code>, which stores the <code>OAuth2AuthorizationRequest</code> in the <code>HttpSession</code>.</p>
</div>
<div class="paragraph">
<p>If you have a custom implementation of <code>AuthorizationRequestRepository</code>, you may configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. AuthorizationRequestRepository Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					...
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client&gt;
		&lt;authorization-code-grant authorization-request-repository-ref="authorizationRequestRepository"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token"><a class="anchor" href="#_requesting_an_access_token"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">Access Token Request/Response</a> protocol flow for the Authorization Code grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Authorization Code grant is <code>DefaultAuthorizationCodeTokenResponseClient</code>, which uses a <code>RestOperations</code> for exchanging an authorization code for an access token at the Authorization Server’s Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultAuthorizationCodeTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request"><a class="anchor" href="#_customizing_the_access_token_request"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2AuthorizationCodeGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2AuthorizationCodeGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response"><a class="anchor" href="#_customizing_the_access_token_response"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultAuthorizationCodeTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultAuthorizationCodeTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. Access Token Response Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -&gt; oauth2
				.authorizationCodeGrant(codeGrant -&gt; codeGrant
					.accessTokenResponseClient(this.accessTokenResponseClient())
					...
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;oauth2-client&gt;
		&lt;authorization-code-grant access-token-response-client-ref="accessTokenResponseClient"/&gt;
	&lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-refresh-token-grant"><a class="anchor" href="#oauth2Client-refresh-token-grant"></a>Refresh Token</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.5">Refresh Token</a>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_refreshing_an_access_token"><a class="anchor" href="#_refreshing_an_access_token"></a>Refreshing an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-6">Access Token Request/Response</a> protocol flow for the Refresh Token grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Refresh Token grant is <code>DefaultRefreshTokenTokenResponseClient</code>, which uses a <code>RestOperations</code> when refreshing an access token at the Authorization Server’s Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultRefreshTokenTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_2"><a class="anchor" href="#_customizing_the_access_token_request_2"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultRefreshTokenTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2RefreshTokenGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2RefreshTokenGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-6">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_2"><a class="anchor" href="#_customizing_the_access_token_response_2"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultRefreshTokenTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultRefreshTokenTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; refreshTokenTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken(configurer -&gt; configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val refreshTokenTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .authorizationCode()
        .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().refreshToken()</code> configures a <code>RefreshTokenOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Refresh Token grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>OAuth2RefreshToken</code> may optionally be returned in the Access Token Response for the <code>authorization_code</code> and <code>password</code> grant types.
If the <code>OAuth2AuthorizedClient.getRefreshToken()</code> is available and the <code>OAuth2AuthorizedClient.getAccessToken()</code> is expired, it will automatically be refreshed by the <code>RefreshTokenOAuth2AuthorizedClientProvider</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-creds-grant"><a class="anchor" href="#oauth2Client-client-creds-grant"></a>Client Credentials</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">Client Credentials</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_2"><a class="anchor" href="#_requesting_an_access_token_2"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">Access Token Request/Response</a> protocol flow for the Client Credentials grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Client Credentials grant is <code>DefaultClientCredentialsTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Server’s Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultClientCredentialsTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_3"><a class="anchor" href="#_customizing_the_access_token_request_3"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultClientCredentialsTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2ClientCredentialsGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2ClientCredentialsGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_3"><a class="anchor" href="#_customizing_the_access_token_response_3"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultClientCredentialsTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultClientCredentialsTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; clientCredentialsTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.clientCredentials(configurer -&gt; configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val clientCredentialsTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()</code> configures a <code>ClientCredentialsOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Client Credentials grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token"><a class="anchor" href="#_using_the_access_token"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -&gt; {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer { attrs: MutableMap&lt;String, Any&gt; -&gt;
                    attrs[HttpServletRequest::class.java.name] = servletRequest
                    attrs[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> and <code>HttpServletResponse</code> are both OPTIONAL attributes.
If not provided, it will default to <code>ServletRequestAttributes</code> using <code>RequestContextHolder.getRequestAttributes()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-password-grant"><a class="anchor" href="#oauth2Client-password-grant"></a>Resource Owner Password Credentials</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the OAuth 2.0 Authorization Framework for further details on the <a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">Resource Owner Password Credentials</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_3"><a class="anchor" href="#_requesting_an_access_token_3"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">Access Token Request/Response</a> protocol flow for the Resource Owner Password Credentials grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the Resource Owner Password Credentials grant is <code>DefaultPasswordTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Server’s Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultPasswordTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_4"><a class="anchor" href="#_customizing_the_access_token_request_4"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultPasswordTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;OAuth2PasswordGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>OAuth2PasswordGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a standard <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the standard Token Request and add custom parameter(s).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The custom <code>Converter</code> must return a valid <code>RequestEntity</code> representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_4"><a class="anchor" href="#_customizing_the_access_token_response_4"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultPasswordTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultPasswordTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; passwordTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.password(configurer -&gt; configurer.accessTokenResponseClient(passwordTokenResponseClient))
				.refreshToken()
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val passwordTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .password { it.accessTokenResponseClient(passwordTokenResponseClient) }
        .refreshToken()
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().password()</code> configures a <code>PasswordOAuth2AuthorizedClientProvider</code>,
which is an implementation of an <code>OAuth2AuthorizedClientProvider</code> for the Resource Owner Password Credentials grant.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token_2"><a class="anchor" href="#_using_the_access_token_2"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: password
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
	return authorizeRequest -&gt; {
		Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
			contextAttributes = new HashMap&lt;&gt;();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -&gt; {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer {
                    it[HttpServletRequest::class.java.name] = servletRequest
                    it[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> and <code>HttpServletResponse</code> are both OPTIONAL attributes.
If not provided, it will default to <code>ServletRequestAttributes</code> using <code>RequestContextHolder.getRequestAttributes()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-jwt-bearer-grant"><a class="anchor" href="#oauth2Client-jwt-bearer-grant"></a>JWT Bearer</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the <a href="https://datatracker.ietf.org/doc/html/rfc7523">JWT Bearer</a> grant.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_requesting_an_access_token_4"><a class="anchor" href="#_requesting_an_access_token_4"></a>Requesting an Access Token</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">Access Token Request/Response</a> protocol flow for the JWT Bearer grant.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation of <code>OAuth2AccessTokenResponseClient</code> for the JWT Bearer grant is <code>DefaultJwtBearerTokenResponseClient</code>, which uses a <code>RestOperations</code> when requesting an access token at the Authorization Server’s Token Endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultJwtBearerTokenResponseClient</code> is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_request_5"><a class="anchor" href="#_customizing_the_access_token_request_5"></a>Customizing the Access Token Request</h6>
<div class="paragraph">
<p>If you need to customize the pre-processing of the Token Request, you can provide <code>DefaultJwtBearerTokenResponseClient.setRequestEntityConverter()</code> with a custom <code>Converter&lt;JwtBearerGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
The default implementation <code>JwtBearerGrantRequestEntityConverter</code> builds a <code>RequestEntity</code> representation of a <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">OAuth 2.0 Access Token Request</a>.
However, providing a custom <code>Converter</code>, would allow you to extend the Token Request and add custom parameter(s).</p>
</div>
</div>
<div class="sect5">
<h6 id="_customizing_the_access_token_response_5"><a class="anchor" href="#_customizing_the_access_token_response_5"></a>Customizing the Access Token Response</h6>
<div class="paragraph">
<p>On the other end, if you need to customize the post-handling of the Token Response, you will need to provide <code>DefaultJwtBearerTokenResponseClient.setRestOperations()</code> with a custom configured <code>RestOperations</code>.
The default <code>RestOperations</code> is configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC <code>FormHttpMessageConverter</code> is required as it&#8217;s used when sending the OAuth 2.0 Access Token Request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> is a <code>HttpMessageConverter</code> for an OAuth 2.0 Access Token Response.
You can provide <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> with a custom <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> that is used for converting the OAuth 2.0 Access Token Response parameters to an <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> is a <code>ResponseErrorHandler</code> that can handle an OAuth 2.0 Error, eg. 400 Bad Request.
It uses an <code>OAuth2ErrorHttpMessageConverter</code> for converting the OAuth 2.0 Error parameters to an <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>Whether you customize <code>DefaultJwtBearerTokenResponseClient</code> or provide your own implementation of <code>OAuth2AccessTokenResponseClient</code>, you&#8217;ll need to configure it as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;JwtBearerGrantRequest&gt; jwtBearerTokenResponseClient = ...

JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider();
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.provider(jwtBearerAuthorizedClientProvider)
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Customize
val jwtBearerTokenResponseClient: OAuth2AccessTokenResponseClient&lt;JwtBearerGrantRequest&gt; = ...

val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()
jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .provider(jwtBearerAuthorizedClientProvider)
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_using_the_access_token_3"><a class="anchor" href="#_using_the_access_token_3"></a>Using the Access Token</h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer
            scope: read
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =
			new JwtBearerOAuth2AuthorizedClientProvider();

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.provider(jwtBearerAuthorizedClientProvider)
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .provider(jwtBearerAuthorizedClientProvider)
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may obtain the <code>OAuth2AccessToken</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class OAuth2ResourceServerController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/resource")
	public String resource(JwtAuthenticationToken jwtAuthentication) {
		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(jwtAuthentication)
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);
		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class OAuth2ResourceServerController {

    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/resource")
    fun resource(jwtAuthentication: JwtAuthenticationToken?): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(jwtAuthentication)
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-client-auth-support"><a class="anchor" href="#oauth2Client-client-auth-support"></a>Client Authentication Support</h4>
<div class="sect4">
<h5 id="oauth2Client-jwt-bearer-auth"><a class="anchor" href="#oauth2Client-jwt-bearer-auth"></a>JWT Bearer</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.2">JWT Bearer</a> Client Authentication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default implementation for JWT Bearer Client Authentication is <code>NimbusJwtClientAuthenticationParametersConverter</code>,
which is a <code>Converter</code> that customizes the Token Request parameters by adding
a signed JSON Web Token (JWS) in the <code>client_assertion</code> parameter.</p>
</div>
<div class="paragraph">
<p>The <code>java.security.PrivateKey</code> or <code>javax.crypto.SecretKey</code> used for signing the JWS
is supplied by the <code>com.nimbusds.jose.jwk.JWK</code> resolver associated with <code>NimbusJwtClientAuthenticationParametersConverter</code>.</p>
</div>
<div class="sect5">
<h6 id="_authenticate_using_private_key_jwt"><a class="anchor" href="#_authenticate_using_private_key_jwt"></a>Authenticate using <code>private_key_jwt</code></h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: private_key_jwt
            authorization-grant-type: authorization_code
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure <code>DefaultAuthorizationCodeTokenResponseClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;ClientRegistration, JWK&gt; jwkResolver = (clientRegistration) -&gt; {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
		// Assuming RSA key type
		RSAPublicKey publicKey = ...
		RSAPrivateKey privateKey = ...
		return new RSAKey.Builder(publicKey)
				.privateKey(privateKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter =
		new OAuth2AuthorizationCodeGrantRequestEntityConverter();
requestEntityConverter.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter&lt;&gt;(jwkResolver));

DefaultAuthorizationCodeTokenResponseClient tokenResponseClient =
		new DefaultAuthorizationCodeTokenResponseClient();
tokenResponseClient.setRequestEntityConverter(requestEntityConverter);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwkResolver: Function&lt;ClientRegistration, JWK&gt; =
    Function&lt;ClientRegistration, JWK&gt; { clientRegistration -&gt;
        if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {
            // Assuming RSA key type
            var publicKey: RSAPublicKey
            var privateKey: RSAPrivateKey
            RSAKey.Builder(publicKey) = //...
                .privateKey(privateKey) = //...
                .keyID(UUID.randomUUID().toString())
                .build()
        }
        null
    }

val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter()
requestEntityConverter.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)

val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient()
tokenResponseClient.setRequestEntityConverter(requestEntityConverter)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_authenticate_using_client_secret_jwt"><a class="anchor" href="#_authenticate_using_client_secret_jwt"></a>Authenticate using <code>client_secret_jwt</code></h6>
<div class="paragraph">
<p>Given the following Spring Boot 2.x properties for an OAuth 2.0 Client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            client-authentication-method: client_secret_jwt
            authorization-grant-type: client_credentials
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure <code>DefaultClientCredentialsTokenResponseClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;ClientRegistration, JWK&gt; jwkResolver = (clientRegistration) -&gt; {
	if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) {
		SecretKeySpec secretKey = new SecretKeySpec(
				clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8),
				"HmacSHA256");
		return new OctetSequenceKey.Builder(secretKey)
				.keyID(UUID.randomUUID().toString())
				.build();
	}
	return null;
};

OAuth2ClientCredentialsGrantRequestEntityConverter requestEntityConverter =
		new OAuth2ClientCredentialsGrantRequestEntityConverter();
requestEntityConverter.addParametersConverter(
		new NimbusJwtClientAuthenticationParametersConverter&lt;&gt;(jwkResolver));

DefaultClientCredentialsTokenResponseClient tokenResponseClient =
		new DefaultClientCredentialsTokenResponseClient();
tokenResponseClient.setRequestEntityConverter(requestEntityConverter);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwkResolver = Function&lt;ClientRegistration, JWK?&gt; { clientRegistration: ClientRegistration -&gt;
    if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) {
        val secretKey = SecretKeySpec(
            clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8),
            "HmacSHA256"
        )
        OctetSequenceKey.Builder(secretKey)
            .keyID(UUID.randomUUID().toString())
            .build()
    }
    null
}

val requestEntityConverter = OAuth2ClientCredentialsGrantRequestEntityConverter()
requestEntityConverter.addParametersConverter(
    NimbusJwtClientAuthenticationParametersConverter(jwkResolver)
)

val tokenResponseClient = DefaultClientCredentialsTokenResponseClient()
tokenResponseClient.setRequestEntityConverter(requestEntityConverter)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-additional-features"><a class="anchor" href="#oauth2Client-additional-features"></a>Additional Features</h4>
<div class="sect4">
<h5 id="oauth2Client-registered-authorized-client"><a class="anchor" href="#oauth2Client-registered-authorized-client"></a>Resolving an Authorized Client</h5>
<div class="paragraph">
<p>The <code>@RegisteredOAuth2AuthorizedClient</code> annotation provides the capability of resolving a method parameter to an argument value of type <code>OAuth2AuthorizedClient</code>.
This is a convenient alternative compared to accessing the <code>OAuth2AuthorizedClient</code> using the <code>OAuth2AuthorizedClientManager</code> or <code>OAuth2AuthorizedClientService</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OAuth2ClientController {

	@GetMapping("/")
	public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @GetMapping("/")
    fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
        val accessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@RegisteredOAuth2AuthorizedClient</code> annotation is handled by <code>OAuth2AuthorizedClientArgumentResolver</code>, which directly uses an <a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a> and therefore inherits it&#8217;s capabilities.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-webclient-servlet"><a class="anchor" href="#oauth2Client-webclient-servlet"></a>WebClient integration for Servlet Environments</h4>
<div class="paragraph">
<p>The OAuth 2.0 Client support integrates with <code>WebClient</code> using an <code>ExchangeFilterFunction</code>.</p>
</div>
<div class="paragraph">
<p>The <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> provides a simple mechanism for requesting protected resources by using an <code>OAuth2AuthorizedClient</code> and including the associated <code>OAuth2AccessToken</code> as a Bearer Token.
It directly uses an <a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a> and therefore inherits the following capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>OAuth2AccessToken</code> will be requested if the client has not yet been authorized.</p>
<div class="ulist">
<ul>
<li>
<p><code>authorization_code</code> - triggers the Authorization Request redirect to initiate the flow</p>
</li>
<li>
<p><code>client_credentials</code> - the access token is obtained directly from the Token Endpoint</p>
</li>
<li>
<p><code>password</code> - the access token is obtained directly from the Token Endpoint</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the <code>OAuth2AccessToken</code> is expired, it will be refreshed (or renewed) if an <code>OAuth2AuthorizedClientProvider</code> is available to perform the authorization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code shows an example of how to configure <code>WebClient</code> with OAuth 2.0 Client support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_providing_the_authorized_client"><a class="anchor" href="#_providing_the_authorized_client"></a>Providing the Authorized Client</h5>
<div class="paragraph">
<p>The <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> determines the client to use (for a request) by resolving the <code>OAuth2AuthorizedClient</code> from the <code>ClientRequest.attributes()</code> (request attributes).</p>
</div>
<div class="paragraph">
<p>The following code shows how to set an <code>OAuth2AuthorizedClient</code> as a request attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(oauth2AuthorizedClient(authorizedClient))   <i class="conum" data-value="1"></i><b>(1)</b>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
    val resourceUri: String = ...
    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(oauth2AuthorizedClient(authorizedClient)) <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>oauth2AuthorizedClient()</code> is a <code>static</code> method in <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following code shows how to set the <code>ClientRegistration.getRegistrationId()</code> as a request attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String index() {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(clientRegistrationId("okta"))   <i class="conum" data-value="1"></i><b>(1)</b>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun index(): String {
    val resourceUri: String = ...

    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(clientRegistrationId("okta"))  <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>clientRegistrationId()</code> is a <code>static</code> method in <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_defaulting_the_authorized_client"><a class="anchor" href="#_defaulting_the_authorized_client"></a>Defaulting the Authorized Client</h5>
<div class="paragraph">
<p>If neither <code>OAuth2AuthorizedClient</code> or <code>ClientRegistration.getRegistrationId()</code> is provided as a request attribute, the <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> can determine the <em>default</em> client to use depending on it&#8217;s configuration.</p>
</div>
<div class="paragraph">
<p>If <code>setDefaultOAuth2AuthorizedClient(true)</code> is configured and the user has authenticated using <code>HttpSecurity.oauth2Login()</code>, the <code>OAuth2AccessToken</code> associated with the current <code>OAuth2AuthenticationToken</code> is used.</p>
</div>
<div class="paragraph">
<p>The following code shows the specific configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultOAuth2AuthorizedClient(true);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultOAuth2AuthorizedClient(true)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is recommended to be cautious with this feature since all HTTP requests will receive the access token.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, if <code>setDefaultClientRegistrationId("okta")</code> is configured with a valid <code>ClientRegistration</code>, the <code>OAuth2AccessToken</code> associated with the <code>OAuth2AuthorizedClient</code> is used.</p>
</div>
<div class="paragraph">
<p>The following code shows the specific configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultClientRegistrationId("okta");
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultClientRegistrationId("okta")
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is recommended to be cautious with this feature since all HTTP requests will receive the access token.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2resourceserver"><a class="anchor" href="#oauth2resourceserver"></a>OAuth 2.0 Resource Server</h3>
<div class="paragraph">
<p>Spring Security supports protecting endpoints using two forms of OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JWT</a></p>
</li>
<li>
<p>Opaque Tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is handy in circumstances where an application has delegated its authority management to an <a href="https://tools.ietf.org/html/rfc6749">authorization server</a> (for example, Okta or Ping Identity).
This authorization server can be consulted by resource servers to authorize requests.</p>
</div>
<div class="paragraph">
<p>This section provides details on how Spring Security provides support for OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Working samples for both {gh-samples-url}/boot/oauth2resourceserver[JWTs] and {gh-samples-url}/boot/oauth2resourceserver-opaque[Opaque Tokens] are available in the {gh-samples-url}[Spring Security repository].</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how Bearer Token Authentication works within Spring Security.
First, we see that, like <a href="#servlet-authentication-basic">Basic Authentication</a>, the <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a> header is sent back to an unauthenticated client.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/bearerauthenticationentrypoint.png" alt="bearerauthenticationentrypoint">
</div>
<div class="title">Figure 14. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>The figure above builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user is not authenticated, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/oauth2/server/resource/authentication/BearerTokenAuthenticationEntryPoint.html[<code>BearerTokenAuthenticationEntryPoint</code>] which sends a WWW-Authenticate header.
The <code>RequestCache</code> is typically a <code>NullRequestCache</code> that does not save the request since the client is capable of replaying the requests it originally requested.</p>
</div>
<div class="paragraph">
<p>When a client receives the <code>WWW-Authenticate: Bearer</code> header, it knows it should retry with a bearer token.
Below is the flow for the bearer token being processed.</p>
</div>
<div id="oauth2resourceserver-authentication-bearertokenauthenticationfilter" class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/bearertokenauthenticationfilter.png" alt="bearertokenauthenticationfilter">
</div>
<div class="title">Figure 15. Authenticating Bearer Token</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the user submits their bearer token, the <code>BearerTokenAuthenticationFilter</code> creates a <code>BearerTokenAuthenticationToken</code> which is a type of <a href="#servlet-authentication-authentication"><code>Authentication</code></a> by extracting the token from the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the <code>HttpServletRequest</code> is passed to the <code>AuthenticationManagerResolver</code>, which selects the <code>AuthenticationManager</code>. The <code>BearerTokenAuthenticationToken</code> is passed into the <code>AuthenticationManager</code> to be authenticated.
The details of what <code>AuthenticationManager</code> looks like depends on whether you&#8217;re configured for <a href="#oauth2resourceserver-jwt-minimalconfiguration">JWT</a> or <a href="#oauth2resourceserver-opaque-minimalconfiguration">opaque token</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p>The <code>AuthenticationEntryPoint</code> is invoked to trigger the WWW-Authenticate header to be sent again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p>The <code>BearerTokenAuthenticationFilter</code> invokes <code>FilterChain.doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-minimaldependencies"><a class="anchor" href="#oauth2resourceserver-jwt-minimaldependencies"></a>Minimal Dependencies for JWT</h4>
<div class="paragraph">
<p>Most Resource Server support is collected into <code>spring-security-oauth2-resource-server</code>.
However, the support for decoding and verifying JWTs is in <code>spring-security-oauth2-jose</code>, meaning that both are necessary in order to have a working resource server that supports JWT-encoded Bearer Tokens.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-jwt-minimalconfiguration"></a>Minimal Configuration for JWTs</h4>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server consists of two basic steps.
First, include the needed dependencies and second, indicate the location of the authorization server.</p>
</div>
<div class="sect4">
<h5 id="_specifying_the_authorization_server"><a class="anchor" href="#_specifying_the_authorization_server"></a>Specifying the Authorization Server</h5>
<div class="paragraph">
<p>In a Spring Boot application, to specify which authorization server to use, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/issuer" class="bare">https://idp.example.com/issuer</a></code> is the value contained in the <code>iss</code> claim for JWT tokens that the authorization server will issue.
Resource Server will use this property to further self-configure, discover the authorization server&#8217;s public keys, and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use the <code>issuer-uri</code> property, it must also be true that one of <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">https://idp.example.com/issuer/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">https://idp.example.com/.well-known/openid-configuration/issuer</a></code>, or <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> is a supported endpoint for the authorization server.
This endpoint is referred to as a <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Provider Configuration</a> endpoint or a <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a> endpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect4">
<h5 id="_startup_expectations"><a class="anchor" href="#_startup_expectations"></a>Startup Expectations</h5>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate JWT-encoded Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>It achieves this through a deterministic startup process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Query the Provider Configuration or Authorization Server Metadata endpoint for the <code>jwks_url</code> property</p>
</li>
<li>
<p>Query the <code>jwks_url</code> endpoint for supported algorithms</p>
</li>
<li>
<p>Configure the validation strategy to query <code>jwks_url</code> for valid public keys of the algorithms found</p>
</li>
<li>
<p>Configure the validation strategy to validate each JWTs <code>iss</code> claim against <code><a href="https://idp.example.com" class="bare">https://idp.example.com</a></code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A consequence of this process is that the authorization server must be up and receiving requests in order for Resource Server to successfully start up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup will fail.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations"><a class="anchor" href="#_runtime_expectations"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given a well-formed JWT, Resource Server will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate its signature against a public key obtained from the <code>jwks_url</code> endpoint during startup and matched against the JWT</p>
</li>
<li>
<p>Validate the JWT&#8217;s <code>exp</code> and <code>nbf</code> timestamps and the JWT&#8217;s <code>iss</code> claim, and</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the authorization server makes available new keys, Spring Security will automatically rotate the keys used to validate JWTs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code>Jwt</code> object, and <code>Authentication#getName</code> maps to the JWT&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, consider jumping to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-jwt-architecture">How JWT Authentication Works</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-jwkseturi">How to Configure without tying Resource Server startup to an authorization server&#8217;s availability</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-sansboot">How to Configure without Spring Boot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-architecture"><a class="anchor" href="#oauth2resourceserver-jwt-architecture"></a>How JWT Authentication Works</h4>
<div class="paragraph">
<p>Next, let&#8217;s see the architectural components that Spring Security uses to support <a href="https://tools.ietf.org/html/rfc7519">JWT</a> Authentication in servlet-based applications, like the one we just saw.</p>
</div>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/oauth2/server/resource/authentication/JwtAuthenticationProvider.html[<code>JwtAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a> and <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> to authenticate a JWT.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>JwtAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/jwtauthenticationprovider.png" alt="jwtauthenticationprovider">
</div>
<div class="title">Figure 16. <code>JwtAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> passes a <code>BearerTokenAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> of type <code>JwtAuthenticationProvider</code>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtdecoder" class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>JwtAuthenticationProvider</code> decodes, verifies, and validates the <code>Jwt</code> using a <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtauthenticationconverter" class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> <code>JwtAuthenticationProvider</code> then uses the <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> to convert the <code>Jwt</code> into a <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>JwtAuthenticationToken</code> and has a principal that is the <code>Jwt</code> returned by the configured <code>JwtDecoder</code>.
Ultimately, the returned <code>JwtAuthenticationToken</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-jwkseturi"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi"></a>Specifying the Authorization Server JWK Set Uri Directly</h4>
<div class="paragraph">
<p>If the authorization server doesn&#8217;t support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, then the <code>jwk-set-uri</code> can be supplied as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The JWK Set uri is not standardized, but can typically be found in the authorization server&#8217;s documentation
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consequently, Resource Server will not ping the authorization server at startup.
We still specify the <code>issuer-uri</code> so that Resource Server still validates the <code>iss</code> claim on incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property can also be supplied directly on the <a href="#oauth2resourceserver-jwt-jwkseturi-dsl">DSL</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-sansboot"><a class="anchor" href="#oauth2resourceserver-jwt-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a resource server. When including <code>spring-security-oauth2-jose</code>, this <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. Custom JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(myConverter())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = myConverter()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div id="oauth2resourceserver-jwt-decoder" class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is a <code>JwtDecoder</code>, which <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder">decodes <code>String</code> tokens into validated instances of <code>Jwt</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromIssuerLocation(issuerUri);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return JwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Calling <code>{security-api-url}org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-[JwtDecoders#fromIssuerLocation]</code> is what invokes the Provider Configuration or Authorization Server Metadata endpoint in order to derive the JWK Set Uri.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>JwtDecoder</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>jwkSetUri()</code> or replaced using <code>decoder()</code>.</p>
</div>
<div class="paragraph">
<p>Or, if you&#8217;re not using Spring Boot at all, then both of these components - the filter chain and a <code>JwtDecoder</code> can be specified in XML.</p>
</div>
<div class="paragraph">
<p>The filter chain is specified like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="jwtDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And the <code>JwtDecoder</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jwtDecoder"
        class="org.springframework.security.oauth2.jwt.JwtDecoders"
        factory-method="fromIssuerLocation"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-jwkseturi-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi-dsl"></a>Using <code>jwkSetUri()</code></h5>
<div class="paragraph">
<p>An authorization server&#8217;s JWK Set Uri can be configured <a href="#oauth2resourceserver-jwt-jwkseturi">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. JWK Set Uri Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.com/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>jwkSetUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-dsl"></a>Using <code>decoder()</code></h5>
<div class="paragraph">
<p>More powerful than <code>jwkSetUri()</code> is <code>decoder()</code>, which will completely replace any Boot auto configuration of <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. JWT Decoder Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwtDecoder extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .decoder(myCustomDecoder())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwtDecoder : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtDecoder = myCustomDecoder()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="myCustomDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#oauth2resourceserver-jwt-validation">validation</a>, <a href="#oauth2resourceserver-jwt-claimsetmapping">mapping</a>, or <a href="#oauth2resourceserver-jwt-timeouts">request timeouts</a>, is necessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-bean"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-bean"></a>Exposing a <code>JwtDecoder</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>Or, exposing a <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> <code>@Bean</code> has the same effect as <code>decoder()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-algorithm"></a>Configuring Trusted Algorithms</h4>
<div class="paragraph">
<p>By default, <code>NimbusJwtDecoder</code>, and hence Resource Server, will only trust and verify tokens using <code>RS256</code>.</p>
</div>
<div class="paragraph">
<p>You can customize this via <a href="#oauth2resourceserver-jwt-boot-algorithm">Spring Boot</a>, <a href="#oauth2resourceserver-jwt-decoder-builder">the NimbusJwtDecoder builder</a>, or from the <a href="#oauth2resourceserver-jwt-decoder-jwk-response">JWK Set response</a>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-boot-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-boot-algorithm"></a>Via Spring Boot</h5>
<div class="paragraph">
<p>The simplest way to set the algorithm is as a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-builder"></a>Using a Builder</h5>
<div class="paragraph">
<p>For greater power, though, we can use a builder that ships with <code>NimbusJwtDecoder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Calling <code>jwsAlgorithm</code> more than once will configure <code>NimbusJwtDecoder</code> to trust more than one algorithm, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you can call <code>jwsAlgorithms</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -&gt; {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }.build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-jwk-response"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-jwk-response"></a>From JWK Set response</h5>
<div class="paragraph">
<p>Since Spring Security&#8217;s JWT support is based off of Nimbus, you can use all it&#8217;s great features as well.</p>
</div>
<div class="paragraph">
<p>For example, Nimbus has a <code>JWSKeySelector</code> implementation that will select the set of algorithms based on the JWK Set URI response.
You can use it to generate a <code>NimbusJwtDecoder</code> like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    // makes a request to the JWK Set endpoint
    JWSKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);

    DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor&lt;&gt;();
    jwtProcessor.setJWSKeySelector(jwsKeySelector);

    return new NimbusJwtDecoder(jwtProcessor);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    // makes a request to the JWK Set endpoint
    val jwsKeySelector: JWSKeySelector&lt;SecurityContext&gt; = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL&lt;SecurityContext&gt;(this.jwkSetUrl)
    val jwtProcessor: DefaultJWTProcessor&lt;SecurityContext&gt; = DefaultJWTProcessor()
    jwtProcessor.jwsKeySelector = jwsKeySelector
    return NimbusJwtDecoder(jwtProcessor)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-public-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key"></a>Trusting a Single Asymmetric Key</h4>
<div class="paragraph">
<p>Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key.
The public key can be provided via <a href="#oauth2resourceserver-jwt-decoder-public-key-boot">Spring Boot</a> or by <a href="#oauth2resourceserver-jwt-decoder-public-key-builder">Using a Builder</a>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-boot"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-boot"></a>Via Spring Boot</h5>
<div class="paragraph">
<p>Specifying a key via Spring Boot is quite simple.
The key&#8217;s location can be specified like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to allow for a more sophisticated lookup, you can post-process the <code>RsaKeyConversionServicePostProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory -&gt;
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory -&gt;
        beanFactory.getBean&lt;RsaKeyConversionServicePostProcessor&gt;()
                .setResourceLoader(CustomResourceLoader())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Specify your key&#8217;s location:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">key.location: hfds://my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then autowire the value:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${key.location}")
RSAPublicKey key;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Value("\${key.location}")
val key: RSAPublicKey? = null</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-builder"></a>Using a Builder</h5>
<div class="paragraph">
<p>To wire an <code>RSAPublicKey</code> directly, you can simply use the appropriate <code>NimbusJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withPublicKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withPublicKey(this.key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-secret-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-secret-key"></a>Trusting a Single Symmetric Key</h4>
<div class="paragraph">
<p>Using a single symmetric key is also simple.
You can simply load in your <code>SecretKey</code> and use the appropriate <code>NimbusJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withSecretKey(key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-authorization"><a class="anchor" href="#oauth2resourceserver-jwt-authorization"></a>Configuring Authorization</h4>
<div class="paragraph">
<p>A JWT that is issued from an OAuth 2.0 Authorization Server will typically either have a <code>scope</code> or <code>scp</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. Authorization Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-jwt-authorization-extraction"></a>Extracting Authorities Manually</h5>
<div class="paragraph">
<p>However, there are a number of circumstances where this default is insufficient.
For example, some authorization servers don&#8217;t use the <code>scope</code> attribute, but instead have their own custom attribute.
Or, at other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities.</p>
</div>
<div class="paragraph">
<p>To this end, Spring Security ships with <code>JwtAuthenticationConverter</code>, which is responsible for <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter">converting a <code>Jwt</code> into an <code>Authentication</code></a>.
By default, Spring Security will wire the <code>JwtAuthenticationProvider</code> with a default instance of <code>JwtAuthenticationConverter</code>.</p>
</div>
<div class="paragraph">
<p>As part of configuring a <code>JwtAuthenticationConverter</code>, you can supply a subsidiary converter to go from <code>Jwt</code> to a <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that that your authorization server communicates authorities in a custom claim called <code>authorities</code>.
In that case, you can configure the claim that <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter"><code>JwtAuthenticationConverter</code></a> should inspect, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. Authorities Claim Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authoritiesClaimName" value="authorities"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure the authority prefix to be different as well.
Instead of prefixing each authority with <code>SCOPE_</code>, you can change it to <code>ROLE_</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. Authorities Prefix Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authorityPrefix" value="ROLE_"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you can remove the prefix altogether by calling <code>JwtGrantedAuthoritiesConverter#setAuthorityPrefix("")</code>.</p>
</div>
<div class="paragraph">
<p>For more flexibility, the DSL supports entirely replacing the converter with any class that implements <code>Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class CustomAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}

// ...

@EnableWebSecurity
public class CustomAuthenticationConverterConfig extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(new CustomAuthenticationConverter())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class CustomAuthenticationConverter : Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    override fun convert(jwt: Jwt): AbstractAuthenticationToken {
        return CustomAuthenticationToken(jwt)
    }
}

// ...

@EnableWebSecurity
class CustomAuthenticationConverterConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               jwt {
                   jwtAuthenticationConverter = CustomAuthenticationConverter()
               }
           }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-validation"><a class="anchor" href="#oauth2resourceserver-jwt-validation"></a>Configuring Validation</h4>
<div class="paragraph">
<p>Using <a href="#oauth2resourceserver-jwt-minimalconfiguration">minimal Spring Boot configuration</a>, indicating the authorization server&#8217;s issuer uri, Resource Server will default to verifying the <code>iss</code> claim as well as the <code>exp</code> and <code>nbf</code> timestamp claims.</p>
</div>
<div class="paragraph">
<p>In circumstances where validation needs to be customized, Resource Server ships with two standard validators and also accepts custom <code>OAuth2TokenValidator</code> instances.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-clockskew"><a class="anchor" href="#oauth2resourceserver-jwt-validation-clockskew"></a>Customizing Timestamp Validation</h5>
<div class="paragraph">
<p>JWT&#8217;s typically have a window of validity, with the start of the window indicated in the <code>nbf</code> claim and the end indicated in the <code>exp</code> claim.</p>
</div>
<div class="paragraph">
<p>However, every server can experience clock drift, which can cause tokens to appear expired to one server, but not to another.
This can cause some implementation heartburn as the number of collaborating servers increases in a distributed system.</p>
</div>
<div class="paragraph">
<p>Resource Server uses <code>JwtTimestampValidator</code> to verify a token&#8217;s validity window, and it can be configured with a <code>clockSkew</code> to alleviate the above problem:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator&lt;Jwt&gt; withClockSkew = new DelegatingOAuth2TokenValidator&lt;&gt;(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new JwtIssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val withClockSkew: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))

    jwtDecoder.setJwtValidator(withClockSkew)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, Resource Server configures a clock skew of 60 seconds.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-custom"><a class="anchor" href="#oauth2resourceserver-jwt-validation-custom"></a>Configuring a Custom Validator</h5>
<div class="paragraph">
<p>Adding a check for the <code>aud</code> claim is simple with the <code>OAuth2TokenValidator</code> API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD, aud -&gt; aud.contains("messaging"));
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun audienceValidator(): OAuth2TokenValidator&lt;Jwt?&gt; {
    return JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD) { aud -&gt; aud.contains("messaging") }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, for more control you can implement your own <code>OAuth2TokenValidator</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("custom_code", "Custom error message", null);

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}

// ...

OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new AudienceValidator();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class AudienceValidator : OAuth2TokenValidator&lt;Jwt&gt; {
    var error: OAuth2Error = OAuth2Error("custom_code", "Custom error message", null)

    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}

// ...

fun audienceValidator(): OAuth2TokenValidator&lt;Jwt&gt; {
    return AudienceValidator()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, to add into a resource server, it&#8217;s a matter of specifying the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = audienceValidator();
    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val audienceValidator = audienceValidator()
    val withIssuer: OAuth2TokenValidator&lt;Jwt&gt; = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)

    jwtDecoder.setJwtValidator(withAudience)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-claimsetmapping"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping"></a>Configuring Claim Set Mapping</h4>
<div class="paragraph">
<p>Spring Security uses the <a href="https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home">Nimbus</a> library for parsing JWTs and validating their signatures.
Consequently, Spring Security is subject to Nimbus&#8217;s interpretation of each field value and how to coerce each into a Java type.</p>
</div>
<div class="paragraph">
<p>For example, because Nimbus remains Java 7 compatible, it doesn&#8217;t use <code>Instant</code> to represent timestamp fields.</p>
</div>
<div class="paragraph">
<p>And it&#8217;s entirely possible to use a different library or for JWT processing, which may make its own coercion decisions that need adjustment.</p>
</div>
<div class="paragraph">
<p>Or, quite simply, a resource server may want to add or remove claims from a JWT for domain-specific reasons.</p>
</div>
<div class="paragraph">
<p>For these purposes, Resource Server supports mapping the JWT claim set with <code>MappedJwtClaimSetConverter</code>.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-singleclaim"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-singleclaim"></a>Customizing the Conversion of a Single Claim</h5>
<div class="paragraph">
<p>By default, <code>MappedJwtClaimSetConverter</code> will attempt to coerce claims into the following types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Claim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java Type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aud</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;String&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iss</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jti</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nbf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sub</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An individual claim&#8217;s conversion strategy can be configured using <code>MappedJwtClaimSetConverter.withDefaults</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()

    val converter = MappedJwtClaimSetConverter
            .withDefaults(mapOf("sub" to this::lookupUserIdBySub))
    jwtDecoder.setClaimSetConverter(converter)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This will keep all the defaults, except it will override the default claim converter for <code>sub</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-add"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-add"></a>Adding a Claim</h5>
<div class="paragraph">
<p><code>MappedJwtClaimSetConverter</code> can also be used to add a custom claim, for example, to adapt to an existing system:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -&gt; "value"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("custom" to Converter&lt;Any, String&gt; { "value" }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-remove"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-remove"></a>Removing a Claim</h5>
<div class="paragraph">
<p>And removing a claim is also simple, using the same API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -&gt; null));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("legacyclaim" to Converter&lt;Any, Any&gt; { null }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-rename"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-rename"></a>Renaming a Claim</h5>
<div class="paragraph">
<p>In more sophisticated scenarios, like consulting multiple claims at once or renaming a claim, Resource Server accepts any class that implements <code>Converter&lt;Map&lt;String, Object&gt;, Map&lt;String,Object&gt;&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UsernameSubClaimAdapter implements Converter&lt;Map&lt;String, Object&gt;, Map&lt;String, Object&gt;&gt; {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map&lt;String, Object&gt; convert(Map&lt;String, Object&gt; claims) {
        Map&lt;String, Object&gt; convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UsernameSubClaimAdapter : Converter&lt;Map&lt;String, Any?&gt;, Map&lt;String, Any?&gt;&gt; {
    private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap())
    override fun convert(claims: Map&lt;String, Any?&gt;): Map&lt;String, Any?&gt; {
        val convertedClaims = delegate.convert(claims)
        val username = convertedClaims["user_name"] as String
        convertedClaims["sub"] = username
        return convertedClaims
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And then, the instance can be supplied like normal:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
    jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter())
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-timeouts"><a class="anchor" href="#oauth2resourceserver-jwt-timeouts"></a>Configuring Timeouts</h4>
<div class="paragraph">
<p>By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.</p>
</div>
<div class="paragraph">
<p>This may be too short in some scenarios.
Further, it doesn&#8217;t take into account more sophisticated patterns like back-off and discovery.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server connects to the authorization server, <code>NimbusJwtDecoder</code> accepts an instance of <code>RestOperations</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build();
    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder {
    val rest: RestOperations = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also by default, Resource Server caches in-memory the authorization server&#8217;s JWK set for 5 minutes, which you may want to adjust.
Further, it doesn&#8217;t take into account more sophisticated caching patterns like eviction or using a shared cache.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server caches the JWK set, <code>NimbusJwtDecoder</code> accepts an instance of <code>Cache</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JwtDecoder jwtDecoder(CacheManager cacheManager) {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(cacheManager: CacheManager): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When given a <code>Cache</code>, Resource Server will use the JWK Set Uri as the key and the JWK Set JSON as the value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring isn&#8217;t a cache provider, so you&#8217;ll need to make sure to include the appropriate dependencies, like <code>spring-boot-starter-cache</code> and your favorite caching provider.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Whether it&#8217;s socket or cache timeouts, you may instead want to work with Nimbus directly.
To do so, remember that <code>NimbusJwtDecoder</code> ships with a constructor that takes Nimbus&#8217;s <code>JWTProcessor</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimaldependencies"><a class="anchor" href="#oauth2resourceserver-opaque-minimaldependencies"></a>Minimal Dependencies for Introspection</h4>
<div class="paragraph">
<p>As described in <a href="#oauth2resourceserver-jwt-minimaldependencies">Minimal Dependencies for JWT</a> most of Resource Server support is collected in <code>spring-security-oauth2-resource-server</code>.
However unless a custom <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> is provided, the Resource Server will fallback to NimbusOpaqueTokenIntrospector.
Meaning that both <code>spring-security-oauth2-resource-server</code> and <code>oauth2-oidc-sdk</code> are necessary in order to have a working minimal Resource Server that supports opaque Bearer Tokens.
Please refer to <code>spring-security-oauth2-resource-server</code> in order to determin the correct version for <code>oauth2-oidc-sdk</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-opaque-minimalconfiguration"></a>Minimal Configuration for Introspection</h4>
<div class="paragraph">
<p>Typically, an opaque token can be verified via an <a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Introspection Endpoint</a>, hosted by the authorization server.
This can be handy when revocation is a requirement.</p>
</div>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server that uses introspection consists of two basic steps.
First, include the needed dependencies and second, indicate the introspection endpoint details.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri"></a>Specifying the Authorization Server</h5>
<div class="paragraph">
<p>To specify where the introspection endpoint is, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/introspect" class="bare">https://idp.example.com/introspect</a></code> is the introspection endpoint hosted by your authorization server and <code>client-id</code> and <code>client-secret</code> are the credentials needed to hit that endpoint.</p>
</div>
<div class="paragraph">
<p>Resource Server will use these properties to further self-configure and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using introspection, the authorization server&#8217;s word is the law.
If the authorization server responses that the token is valid, then it is.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect4">
<h5 id="_startup_expectations_2"><a class="anchor" href="#_startup_expectations_2"></a>Startup Expectations</h5>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate Opaque Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>This startup process is quite a bit simpler than for JWTs since no endpoints need to be discovered and no additional validation rules get added.</p>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations_2"><a class="anchor" href="#_runtime_expectations_2"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given an Opaque Token, Resource Server will</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Query the provided introspection endpoint using the provided credentials and the token</p>
</li>
<li>
<p>Inspect the response for an <code>{ 'active' : true }</code> attribute</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code>{security-api-url}org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html[OAuth2AuthenticatedPrincipal]</code> object, and <code>Authentication#getName</code> maps to the token&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, you may want to jump to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-opaque-architecture">How Opaque Token Authentication Works</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-attributes">Looking Up Attributes Post-Authentication</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-authorization-extraction">Extracting Authorities Manually</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-jwt-introspector">Using Introspection with JWTs</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-architecture"><a class="anchor" href="#oauth2resourceserver-opaque-architecture"></a>How Opaque Token Authentication Works</h4>
<div class="paragraph">
<p>Next, let&#8217;s see the architectural components that Spring Security uses to support <a href="https://tools.ietf.org/html/rfc7662">opaque token</a> Authentication in servlet-based applications, like the one we just saw.</p>
</div>
<div class="paragraph">
<p>{security-api-url}org/springframework/security/oauth2/server/resource/authentication/OpaqueTokenAuthenticationProvider.html[<code>OpaqueTokenAuthenticationProvider</code>] is an <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> implementation that leverages a <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> to authenticate an opaque token.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how <code>OpaqueTokenAuthenticationProvider</code> works within Spring Security.
The figure explains details of how the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> in figures from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> works.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/oauth2/opaquetokenauthenticationprovider.png" alt="opaquetokenauthenticationprovider">
</div>
<div class="title">Figure 17. <code>OpaqueTokenAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The authentication <code>Filter</code> from <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> passes a <code>BearerTokenAuthenticationToken</code> to the <code>AuthenticationManager</code> which is implemented by <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <code>ProviderManager</code> is configured to use an <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> of type <code>OpaqueTokenAuthenticationProvider</code>.</p>
</div>
<div id="oauth2resourceserver-opaque-architecture-introspector" class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> <code>OpaqueTokenAuthenticationProvider</code> introspects the opaque token and adds granted authorities using an <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a>.
When authentication is successful, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is of type <code>BearerTokenAuthentication</code> and has a principal that is the <code>OAuth2AuthenticatedPrincipal</code> returned by the configured <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a>.
Ultimately, the returned <code>BearerTokenAuthentication</code> will be set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> by the authentication <code>Filter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-attributes"><a class="anchor" href="#oauth2resourceserver-opaque-attributes"></a>Looking Up Attributes Post-Authentication</h4>
<div class="paragraph">
<p>Once a token is authenticated, an instance of <code>BearerTokenAuthentication</code> is set in the <code>SecurityContext</code>.</p>
</div>
<div class="paragraph">
<p>This means that it&#8217;s available in <code>@Controller</code> methods when using <code>@EnableWebMvc</code> in your configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public String foo(BearerTokenAuthentication authentication) {
    return authentication.getTokenAttributes().get("sub") + " is the subject";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): String {
    return authentication.tokenAttributes["sub"].toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since <code>BearerTokenAuthentication</code> holds an <code>OAuth2AuthenticatedPrincipal</code>, that also means that it&#8217;s available to controller methods, too:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return principal.getAttribute("sub") + " is the subject";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String {
    return principal.getAttribute&lt;Any&gt;("sub").toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_looking_up_attributes_via_spel"><a class="anchor" href="#_looking_up_attributes_via_spel"></a>Looking Up Attributes Via SpEL</h5>
<div class="paragraph">
<p>Of course, this also means that attributes can be accessed via SpEL.</p>
</div>
<div class="paragraph">
<p>For example, if using <code>@EnableGlobalMethodSecurity</code> so that you can use <code>@PreAuthorize</code> annotations, you can do:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public String forFoosEyesOnly() {
    return "foo";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): String {
    return "foo"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-sansboot"><a class="anchor" href="#oauth2resourceserver-opaque-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a resource server.
When use Opaque Token, this <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. Custom Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myIntrospector())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div id="oauth2resourceserver-opaque-introspector" class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is an <code>OpaqueTokenIntrospector</code>, <a href="#oauth2resourceserver-opaque-architecture-introspector">which decodes <code>String</code> tokens into validated instances of <code>OAuth2AuthenticatedPrincipal</code></a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>introspectionUri()</code> and <code>introspectionClientCredentials()</code> or replaced using <code>introspector()</code>.</p>
</div>
<div class="paragraph">
<p>Or, if you&#8217;re not using Spring Boot at all, then both of these components - the filter chain and a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> can be specified in XML.</p>
</div>
<div class="paragraph">
<p>The filter chain is specified like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And the <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. Opaque Token Introspector</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_id}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_secret}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri-dsl"></a>Using <code>introspectionUri()</code></h5>
<div class="paragraph">
<p>An authorization server&#8217;s Introspection Uri can be configured <a href="#oauth2resourceserver-opaque-introspectionuri">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. Introspection URI Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospectionUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospectionUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspectionUri = "https://idp.example.com/introspect"
                    introspectionClientCredentials("client", "secret")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="https://idp.example.com/introspect"/&gt;
    &lt;constructor-arg value="client"/&gt;
    &lt;constructor-arg value="secret"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>introspectionUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-dsl"></a>Using <code>introspector()</code></h5>
<div class="paragraph">
<p>More powerful than <code>introspectionUri()</code> is <code>introspector()</code>, which will completely replace any Boot auto configuration of <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. Introspector Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospector extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospector : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myCustomIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="myCustomIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#oauth2resourceserver-opaque-authorization-extraction">authority mapping</a>, <a href="#oauth2resourceserver-opaque-jwt-introspector">JWT revocation</a>, or <a href="#oauth2resourceserver-opaque-timeouts">request timeouts</a>, is necessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-bean"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-bean"></a>Exposing a <code>OpaqueTokenIntrospector</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>Or, exposing a <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> <code>@Bean</code> has the same effect as <code>introspector()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-authorization"><a class="anchor" href="#oauth2resourceserver-opaque-authorization"></a>Configuring Authorization</h4>
<div class="paragraph">
<p>An OAuth 2.0 Introspection endpoint will typically return a <code>scope</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. Authorization Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MappedAuthorities extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorizeRequests -&gt; authorizeRequests
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MappedAuthorities : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               opaqueToken { }
           }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): List&lt;Message?&gt; {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-opaque-authorization-extraction"></a>Extracting Authorities Manually</h5>
<div class="paragraph">
<p>By default, Opaque Token support will extract the scope claim from an introspection response and parse it into individual <code>GrantedAuthority</code> instances.</p>
</div>
<div class="paragraph">
<p>For example, if the introspection response were:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "active" : true,
    "scope" : "message:read message:write"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then Resource Server would generate an <code>Authentication</code> with two authorities, one for <code>message:read</code> and the other for <code>message:write</code>.</p>
</div>
<div class="paragraph">
<p>This can, of course, be customized using a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> that takes a look at the attribute set and converts in its own way:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        return new DefaultOAuth2AuthenticatedPrincipal(
                principal.getName(), principal.getAttributes(), extractAuthorities(principal));
    }

    private Collection&lt;GrantedAuthority&gt; extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List&lt;String&gt; scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token)
        return DefaultOAuth2AuthenticatedPrincipal(
                principal.name, principal.attributes, extractAuthorities(principal))
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection&lt;GrantedAuthority&gt; {
        val scopes: List&lt;String&gt; = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-timeouts"><a class="anchor" href="#oauth2resourceserver-opaque-timeouts"></a>Configuring Timeouts</h4>
<div class="paragraph">
<p>By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.</p>
</div>
<div class="paragraph">
<p>This may be too short in some scenarios.
Further, it doesn&#8217;t take into account more sophisticated patterns like back-off and discovery.</p>
</div>
<div class="paragraph">
<p>To adjust the way in which Resource Server connects to the authorization server, <code>NimbusOpaqueTokenIntrospector</code> accepts an instance of <code>RestOperations</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) {
    RestOperations rest = builder
            .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret())
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    return new NimbusOpaqueTokenIntrospector(introspectionUri, rest);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? {
    val rest: RestOperations = builder
            .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret)
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusOpaqueTokenIntrospector(introspectionUri, rest)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-jwt-introspector"><a class="anchor" href="#oauth2resourceserver-opaque-jwt-introspector"></a>Using Introspection with JWTs</h4>
<div class="paragraph">
<p>A common question is whether or not introspection is compatible with JWTs.
Spring Security&#8217;s Opaque Token support has been designed to not care about the format of the token&#8201;&#8212;&#8201;it will gladly pass any token to the introspection endpoint provided.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s say that you&#8217;ve got a requirement that requires you to check with the authorization server on each request, in case the JWT has been revoked.</p>
</div>
<div class="paragraph">
<p>Even though you are using the JWT format for the token, your validation method is introspection, meaning you&#8217;d want to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the resulting <code>Authentication</code> would be <code>BearerTokenAuthentication</code>.
Any attributes in the corresponding <code>OAuth2AuthenticatedPrincipal</code> would be whatever was returned by the introspection endpoint.</p>
</div>
<div class="paragraph">
<p>But, let&#8217;s say that, oddly enough, the introspection endpoint only returns whether or not the token is active.
Now what?</p>
</div>
<div class="paragraph">
<p>In this case, you can create a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> that still hits the endpoint, but then updates the returned principal to have the JWTs claims as the attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        try {
            Jwt jwt = this.jwtDecoder.decode(token);
            return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);
        } catch (JwtException ex) {
            throw new OAuth2IntrospectionException(ex);
        }
    }

    private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor&lt;SecurityContext&gt; {
    	JWTClaimsSet process(SignedJWT jwt, SecurityContext context)
                throws JOSEException {
            return jwt.getJWTClaimsSet();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal = delegate.introspect(token)
        return try {
            val jwt: Jwt = jwtDecoder.decode(token)
            DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES)
        } catch (ex: JwtException) {
            throw OAuth2IntrospectionException(ex.message)
        }
    }

    private class ParseOnlyJWTProcessor : DefaultJWTProcessor&lt;SecurityContext&gt;() {
        override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet {
            return jwt.jwtClaimsSet
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-userinfo"><a class="anchor" href="#oauth2resourceserver-opaque-userinfo"></a>Calling a <code>/userinfo</code> Endpoint</h4>
<div class="paragraph">
<p>Generally speaking, a Resource Server doesn&#8217;t care about the underlying user, but instead about the authorities that have been granted.</p>
</div>
<div class="paragraph">
<p>That said, at times it can be valuable to tie the authorization statement back to a user.</p>
</div>
<div class="paragraph">
<p>If an application is also using <code>spring-security-oauth2-client</code>, having set up the appropriate <code>ClientRegistrationRepository</code>, then this is quite simple with a custom <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>.
This implementation below does three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Delegates to the introspection endpoint, to affirm the token&#8217;s validity</p>
</li>
<li>
<p>Looks up the appropriate client registration associated with the <code>/userinfo</code> endpoint</p>
</li>
<li>
<p>Invokes and returns the response from the <code>/userinfo</code> endpoint</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();

    private final ClientRegistrationRepository repository;

    // ... constructor

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        Instant issuedAt = authorized.getAttribute(ISSUED_AT);
        Instant expiresAt = authorized.getAttribute(EXPIRES_AT);
        ClientRegistration clientRegistration = this.repository.findByRegistrationId("registration-id");
        OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
        OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);
        return this.oauth2UserService.loadUser(oauth2UserRequest);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService = DefaultOAuth2UserService()
    private val repository: ClientRegistrationRepository? = null

    // ... constructor

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
        val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT)
        val clientRegistration: ClientRegistration = repository!!.findByRegistrationId("registration-id")
        val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
        val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken)
        return oauth2UserService.loadUser(oauth2UserRequest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you aren&#8217;t using <code>spring-security-oauth2-client</code>, it&#8217;s still quite simple.
You will simply need to invoke the <code>/userinfo</code> with your own instance of <code>WebClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        return makeUserInfoRequest(authorized);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        return makeUserInfoRequest(authorized)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Either way, having created your <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>, you should publish it as a <code>@Bean</code> to override the defaults:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
OpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector(...);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector(...)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2reourceserver-opaqueandjwt"><a class="anchor" href="#oauth2reourceserver-opaqueandjwt"></a>Supporting both JWT and Opaque Token</h4>
<div class="paragraph">
<p>In some cases, you may have a need to access both kinds of tokens.
For example, you may support more than one tenant where one tenant issues JWTs and the other issues opaque tokens.</p>
</div>
<div class="paragraph">
<p>If this decision must be made at request-time, then you can use an <code>AuthenticationManagerResolver</code> to achieve it, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
AuthenticationManagerResolver&lt;HttpServletRequest&gt; tokenAuthenticationManagerResolver() {
    BearerTokenResolver bearerToken = new DefaultBearerTokenResolver();
    JwtAuthenticationProvider jwt = jwt();
    OpaqueTokenAuthenticationProvider opaqueToken = opaqueToken();

    return request -&gt; {
        if (useJwt(request)) {
            return jwt::authenticate;
        } else {
            return opaqueToken::authenticate;
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun tokenAuthenticationManagerResolver(): AuthenticationManagerResolver&lt;HttpServletRequest&gt; {
    val bearerToken: BearerTokenResolver = DefaultBearerTokenResolver()
    val jwt: JwtAuthenticationProvider = jwt()
    val opaqueToken: OpaqueTokenAuthenticationProvider = opaqueToken()

    return AuthenticationManagerResolver { request -&gt;
        if (useJwt(request)) {
            AuthenticationManager { jwt.authenticate(it) }
        } else {
            AuthenticationManager { opaqueToken.authenticate(it) }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The implementation of <code>useJwt(HttpServletRequest)</code> will likely depend on custom request material like the path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And then specify this <code>AuthenticationManagerResolver</code> in the DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. Authentication Manager Resolver</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = tokenAuthenticationManagerResolver()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="tokenAuthenticationManagerResolver"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-multitenancy"><a class="anchor" href="#oauth2resourceserver-multitenancy"></a>Multi-tenancy</h4>
<div class="paragraph">
<p>A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.</p>
</div>
<div class="paragraph">
<p>For example, your resource server may accept bearer tokens from two different authorization servers.
Or, your authorization server may represent a multiplicity of issuers.</p>
</div>
<div class="paragraph">
<p>In each case, there are two things that need to be done and trade-offs associated with how you choose to do them:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Resolve the tenant</p>
</li>
<li>
<p>Propagate the tenant</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_resolving_the_tenant_by_claim"><a class="anchor" href="#_resolving_the_tenant_by_claim"></a>Resolving the Tenant By Claim</h5>
<div class="paragraph">
<p>One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the <code>JwtIssuerAuthenticationManagerResolver</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 85. Multitenancy Tenant by JWT Claim</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="authenticationManagerResolver"/&gt;
&lt;/http&gt;

&lt;bean id="authenticationManagerResolver"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;value&gt;https://idp.example.org/issuerOne&lt;/value&gt;
            &lt;value&gt;https://idp.example.org/issuerTwo&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is nice because the issuer endpoints are loaded lazily.
In fact, the corresponding <code>JwtAuthenticationProvider</code> is instantiated only when the first request with the corresponding issuer is sent.
This allows for an application startup that is independent from those authorization servers being up and available.</p>
</div>
<div class="sect5">
<h6 id="_dynamic_tenants"><a class="anchor" href="#_dynamic_tenants"></a>Dynamic Tenants</h6>
<div class="paragraph">
<p>Of course, you may not want to restart the application each time a new tenant is added.
In this case, you can configure the <code>JwtIssuerAuthenticationManagerResolver</code> with a repository of <code>AuthenticationManager</code> instances, which you can edit at runtime, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private void addManager(Map&lt;String, AuthenticationManager&gt; authenticationManagers, String issuer) {
	JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider
	        (JwtDecoders.fromIssuerLocation(issuer));
	authenticationManagers.put(issuer, authenticationProvider::authenticate);
}

// ...

JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">private fun addManager(authenticationManagers: MutableMap&lt;String, AuthenticationManager&gt;, issuer: String) {
    val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer))
    authenticationManagers[issuer] = AuthenticationManager {
        authentication: Authentication? -&gt; authenticationProvider.authenticate(authentication)
    }
}

// ...

val customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver =
    JwtIssuerAuthenticationManagerResolver(authenticationManagers::get)
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, you construct <code>JwtIssuerAuthenticationManagerResolver</code> with a strategy for obtaining the <code>AuthenticationManager</code> given the issuer.
This approach allows us to add and remove elements from the repository (shown as a <code>Map</code> in the snippet) at runtime.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It would be unsafe to simply take any issuer and construct an <code>AuthenticationManager</code> from it.
The issuer should be one that the code can verify from a trusted source like a list of allowed issuers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_parsing_the_claim_only_once"><a class="anchor" href="#_parsing_the_claim_only_once"></a>Parsing the Claim Only Once</h6>
<div class="paragraph">
<p>You may have observed that this strategy, while simple, comes with the trade-off that the JWT is parsed once by the <code>AuthenticationManagerResolver</code> and then again by the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> later on in the request.</p>
</div>
<div class="paragraph">
<p>This extra parsing can be alleviated by configuring the <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> directly with a <code>JWTClaimSetAwareJWSKeySelector</code> from Nimbus:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class TenantJWSKeySelector
    implements JWTClaimSetAwareJWSKeySelector&lt;SecurityContext&gt; {

	private final TenantRepository tenants; <i class="conum" data-value="1"></i><b>(1)</b>
	private final Map&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; selectors = new ConcurrentHashMap&lt;&gt;(); <i class="conum" data-value="2"></i><b>(2)</b>

	public TenantJWSKeySelector(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public List&lt;? extends Key&gt; selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)
			throws KeySourceException {
		return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)
				.selectJWSKeys(jwsHeader, securityContext);
	}

	private String toTenant(JWTClaimsSet claimSet) {
		return (String) claimSet.getClaim("iss");
	}

	private JWSKeySelector&lt;SecurityContext&gt; fromTenant(String tenant) {
		return Optional.ofNullable(this.tenantRepository.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
		        .map(t -&gt; t.getAttrbute("jwks_uri"))
				.map(this::fromUri)
				.orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
	}

	private JWSKeySelector&lt;SecurityContext&gt; fromUri(String uri) {
		try {
			return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <i class="conum" data-value="4"></i><b>(4)</b>
		} catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimSetAwareJWSKeySelector&lt;SecurityContext&gt; {
    private val tenants: TenantRepository <i class="conum" data-value="1"></i><b>(1)</b>
    private val selectors: MutableMap&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; = ConcurrentHashMap() <i class="conum" data-value="2"></i><b>(2)</b>

    init {
        this.tenants = tenants
    }

    fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List&lt;Key?&gt; {
        return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -&gt; fromTenant(tenant) }
                .selectJWSKeys(jwsHeader, securityContext)
    }

    private fun toTenant(claimSet: JWTClaimsSet): String {
        return claimSet.getClaim("iss") as String
    }

    private fun fromTenant(tenant: String): JWSKeySelector&lt;SecurityContext&gt; {
        return Optional.ofNullable(this.tenants.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
                .map { t -&gt; t.getAttrbute("jwks_uri") }
                .map { uri: String -&gt; fromUri(uri) }
                .orElseThrow { IllegalArgumentException("unknown tenant") }
    }

    private fun fromUri(uri: String): JWSKeySelector&lt;SecurityContext?&gt; {
        return try {
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) <i class="conum" data-value="4"></i><b>(4)</b>
        } catch (ex: Exception) {
            throw IllegalArgumentException(ex)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A hypothetical source for tenant information</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A cache for `JWKKeySelector`s, keyed by tenant identifier</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Looking up the tenant is more secure than simply calculating the JWK Set endpoint on the fly - the lookup acts as a list of allowed tenants</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create a <code>JWSKeySelector</code> via the types of keys that come back from the JWK Set endpoint - the lazy lookup here means that you don&#8217;t need to configure all tenants at startup</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The above key selector is a composition of many key selectors.
It chooses which key selector to use based on the <code>iss</code> claim in the JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use this approach, make sure that the authorization server is configured to include the claim set as part of the token&#8217;s signature.
Without this, you have no guarantee that the issuer hasn&#8217;t been altered by a bad actor.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we can construct a <code>JWTProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JWTProcessor jwtProcessor(JWTClaimSetJWSKeySelector keySelector) {
	ConfigurableJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor();
	jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);
	return jwtProcessor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector&lt;SecurityContext&gt;): JWTProcessor&lt;SecurityContext&gt; {
    val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
    jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector
    return jwtProcessor
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you are already seeing, the trade-off for moving tenant-awareness down to this level is more configuration.
We have just a bit more.</p>
</div>
<div class="paragraph">
<p>Next, we still want to make sure you are validating the issuer.
But, since the issuer may be different per JWT, then you&#8217;ll need a tenant-aware validator, too:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class TenantJwtIssuerValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
	private final TenantRepository tenants;
	private final Map&lt;String, JwtIssuerValidator&gt; validators = new ConcurrentHashMap&lt;&gt;();

	public TenantJwtIssuerValidator(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public OAuth2TokenValidatorResult validate(Jwt token) {
		return this.validators.computeIfAbsent(toTenant(token), this::fromTenant)
				.validate(token);
	}

	private String toTenant(Jwt jwt) {
		return jwt.getIssuer();
	}

	private JwtIssuerValidator fromTenant(String tenant) {
		return Optional.ofNullable(this.tenants.findById(tenant))
		        .map(t -&gt; t.getAttribute("issuer"))
				.map(JwtIssuerValidator::new)
				.orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class TenantJwtIssuerValidator(tenants: TenantRepository) : OAuth2TokenValidator&lt;Jwt&gt; {
    private val tenants: TenantRepository
    private val validators: MutableMap&lt;String, JwtIssuerValidator&gt; = ConcurrentHashMap()
    override fun validate(token: Jwt): OAuth2TokenValidatorResult {
        return validators.computeIfAbsent(toTenant(token)) { tenant: String -&gt; fromTenant(tenant) }
                .validate(token)
    }

    private fun toTenant(jwt: Jwt): String {
        return jwt.issuer.toString()
    }

    private fun fromTenant(tenant: String): JwtIssuerValidator {
        return Optional.ofNullable(tenants.findById(tenant))
                .map({ t -&gt; t.getAttribute("issuer") })
                .map({ JwtIssuerValidator() })
                .orElseThrow({ IllegalArgumentException("unknown tenant") })
    }

    init {
        this.tenants = tenants
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have a tenant-aware processor and a tenant-aware validator, we can proceed with creating our <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator&lt;Jwt&gt; jwtValidator) {
	NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor);
	OAuth2TokenValidator&lt;Jwt&gt; validator = new DelegatingOAuth2TokenValidator&lt;&gt;
			(JwtValidators.createDefault(), this.jwtValidator);
	decoder.setJwtValidator(validator);
	return decoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(jwtProcessor: JWTProcessor&lt;SecurityContext&gt;?, jwtValidator: OAuth2TokenValidator&lt;Jwt&gt;?): JwtDecoder {
    val decoder = NimbusJwtDecoder(jwtProcessor)
    val validator: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator)
    decoder.setJwtValidator(validator)
    return decoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve finished talking about resolving the tenant.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve chosen to resolve the tenant by something other than a JWT claim, then you&#8217;ll need to make sure you address your downstream resource servers in the same way.
For example, if you are resolving it by subdomain, you may need to address the downstream resource server using the same subdomain.</p>
</div>
<div class="paragraph">
<p>However, if you resolve it by a claim in the bearer token, read on to learn about <a href="#oauth2resourceserver-bearertoken-resolver">Spring Security&#8217;s support for bearer token propagation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-resolver"><a class="anchor" href="#oauth2resourceserver-bearertoken-resolver"></a>Bearer Token Resolution</h4>
<div class="paragraph">
<p>By default, Resource Server looks for a bearer token in the <code>Authorization</code> header.
This, however, can be customized in a handful of ways.</p>
</div>
<div class="sect4">
<h5 id="_reading_the_bearer_token_from_a_custom_header"><a class="anchor" href="#_reading_the_bearer_token_from_a_custom_header"></a>Reading the Bearer Token from a Custom Header</h5>
<div class="paragraph">
<p>For example, you may have a need to read the bearer token from a custom header.
To achieve this, you can expose a <code>DefaultBearerTokenResolver</code> as a bean, or wire an instance into the DSL, as you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. Custom Bearer Token Header</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BearerTokenResolver bearerTokenResolver() {
    DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
    return bearerTokenResolver;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun bearerTokenResolver(): BearerTokenResolver {
    val bearerTokenResolver = DefaultBearerTokenResolver()
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
    return bearerTokenResolver
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver"&gt;
    &lt;property name="bearerTokenHeaderName" value="Proxy-Authorization"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, in circumstances where a provider is using both a custom header and value, you can use <code>HeaderBearerTokenResolver</code> instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reading_the_bearer_token_from_a_form_parameter"><a class="anchor" href="#_reading_the_bearer_token_from_a_form_parameter"></a>Reading the Bearer Token from a Form Parameter</h5>
<div class="paragraph">
<p>Or, you may wish to read the token from a form parameter, which you can do by configuring the <code>DefaultBearerTokenResolver</code>, as you can see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. Form Parameter Bearer Token</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();
resolver.setAllowFormEncodedBodyParameter(true);
http
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .bearerTokenResolver(resolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val resolver = DefaultBearerTokenResolver()
resolver.setAllowFormEncodedBodyParameter(true)
http {
    oauth2ResourceServer {
        bearerTokenResolver = resolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver"&gt;
    &lt;property name="allowFormEncodedBodyParameter" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bearer_token_propagation"><a class="anchor" href="#_bearer_token_propagation"></a>Bearer Token Propagation</h4>
<div class="paragraph">
<p>Now that you&#8217;re resource server has validated the token, it might be handy to pass it to downstream services.
This is quite simple with <code>{security-api-url}org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html[ServletBearerExchangeFilterFunction]</code>, which you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServletBearerExchangeFilterFunction())
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServletBearerExchangeFilterFunction())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the above <code>WebClient</code> is used to perform requests, Spring Security will look up the current <code>Authentication</code> and extract any <code>{security-api-url}org/springframework/security/oauth2/core/AbstractOAuth2Token.html[AbstractOAuth2Token]</code> credential.
Then, it will propagate that token in the <code>Authorization</code> header.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
        .block()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Will invoke the <code><a href="https://other-service.example.com/endpoint" class="bare">https://other-service.example.com/endpoint</a></code>, adding the bearer token <code>Authorization</code> header for you.</p>
</div>
<div class="paragraph">
<p>In places where you need to override this behavior, it&#8217;s a simple matter of supplying the header yourself, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -&gt; headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
        .block()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers{  headers -&gt; headers.setBearerAuth(overridingToken)}
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the filter will fall back and simply forward the request onto the rest of the web filter chain.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the {security-api-url}org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html[OAuth 2.0 Client filter function], this filter function makes no attempt to renew the token, should it be expired.
To obtain this level of support, please use the OAuth 2.0 Client filter.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_resttemplate_support"><a class="anchor" href="#_resttemplate_support"></a><code>RestTemplate</code> support</h5>
<div class="paragraph">
<p>There is no <code>RestTemplate</code> equivalent for <code>ServletBearerExchangeFilterFunction</code> at the moment, but you can propagate the request&#8217;s bearer token quite simply with your own interceptor:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
RestTemplate rest() {
	RestTemplate rest = new RestTemplate();
	rest.getInterceptors().add((request, body, execution) -&gt; {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return execution.execute(request, body);
		}

		if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {
			return execution.execute(request, body);
		}

		AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();
	    request.getHeaders().setBearerAuth(token.getTokenValue());
	    return execution.execute(request, body);
	});
	return rest;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rest(): RestTemplate {
    val rest = RestTemplate()
    rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution -&gt;
        val authentication: Authentication? = SecurityContextHolder.getContext().authentication
        if (authentication != null) {
            execution.execute(request, body)
        }

        if (authentication!!.credentials !is AbstractOAuth2Token) {
            execution.execute(request, body)
        }

        val token: AbstractOAuth2Token = authentication.credentials as AbstractOAuth2Token
        request.headers.setBearerAuth(token.tokenValue)
        execution.execute(request, body)
    })
    return rest
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the {security-api-url}org/springframework/security/oauth2/client/OAuth2AuthorizedClientManager.html[OAuth 2.0 Authorized Client Manager], this filter interceptor makes no attempt to renew the token, should it be expired.
To obtain this level of support, please create an interceptor using the <a href="#oauth2client">OAuth 2.0 Authorized Client Manager</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-failure"><a class="anchor" href="#oauth2resourceserver-bearertoken-failure"></a>Bearer Token Failure</h4>
<div class="paragraph">
<p>A bearer token may be invalid for a number of reasons. For example, the token may no longer be active.</p>
</div>
<div class="paragraph">
<p>In these circumstances, Resource Server throws an <code>InvalidBearerTokenException</code>.
Like other exceptions, this results in an OAuth 2.0 Bearer Token error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http request hljs" data-lang="http request">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error_code="invalid_token", error_description="Unsupported algorithm of none", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, it is published as an <code>AuthenticationFailureBadCredentialsEvent</code>, which you can <a href="#servlet-events">listen for in your application</a> like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class FailureEvents {
	@EventListener
    public void onFailure(AuthenticationFailureEvent failure) {
		if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {
		    // ... handle
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class FailureEvents {
    @EventListener
    fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) {
        if (badCredentials.authentication is BearerTokenAuthenticationToken) {
            // ... handle
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-saml2"><a class="anchor" href="#servlet-saml2"></a>SAML2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servlet-saml2login"><a class="anchor" href="#servlet-saml2login"></a>SAML 2.0 Login</h3>
<div class="paragraph">
<p>The SAML 2.0 Login feature provides an application with the capability to act as a SAML 2.0 Relying Party, having users <a href="https://wiki.shibboleth.net/confluence/display/CONCEPT/FlowsAndConfig">log in</a> to the application by using their existing account at a SAML 2.0 Asserting Party (Okta, ADFS, etc).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SAML 2.0 Login is implemented by using the <strong>Web Browser SSO Profile</strong>, as specified in
<a href="https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15">SAML 2 Profiles</a>.
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-spring-security-history" class="paragraph">
<p>Since 2009, support for relying parties has existed as an <a href="https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml">extension project</a>.
In 2019, the process began to port that into <a href="https://github.com/spring-projects/spring-security">Spring Security</a> proper.
This process is similar to the one started in 2017 for <a href="#oauth2">Spring Security&#8217;s OAuth 2.0 support</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A working sample for {gh-samples-url}/boot/saml2login[SAML 2.0 Login] is available in the {gh-samples-url}[Spring Security repository].</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how SAML 2.0 Relying Party Authentication works within Spring Security.
First, we see that, like <a href="#oauth2login">OAuth 2.0 Login</a>, Spring Security takes the user to a third-party for performing authentication.
It does this through a series of redirects.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/saml2/saml2webssoauthenticationrequestfilter.png" alt="saml2webssoauthenticationrequestfilter">
</div>
<div class="title">Figure 18. Redirecting to Asserting Party Authentication</div>
</div>
<div class="paragraph">
<p>The figure above builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> and <a href="#servlet-authentication-abstractprocessingfilter"><code>AbstractAuthenticationProcessingFilter</code></a> diagrams:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, a user makes an unauthenticated request to the resource <code>/private</code> for which it is not authorized.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Spring Security&#8217;s <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> indicates that the unauthenticated request is <em>Denied</em> by throwing an <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Since the user lacks authorization, the <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> initiates <em>Start Authentication</em>.
The configured <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is an instance of {security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[<code>LoginUrlAuthenticationEntryPoint</code>] which redirects to <a href="#servlet-saml2login-sp-initiated-factory">the <code>&lt;saml2:AuthnRequest&gt;</code> generating endpoint</a>, <code>Saml2WebSsoAuthenticationRequestFilter</code>.
Or, if you&#8217;ve <a href="#servlet-saml2login-relyingpartyregistrationrepository">configured more than one asserting party</a>, it will first redirect to a picker page.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> Next, the <code>Saml2WebSsoAuthenticationRequestFilter</code> creates, signs, serializes, and encodes a <code>&lt;saml2:AuthnRequest&gt;</code> using its configured <a href="#servlet-saml2login-sp-initiated-factory"><code>Saml2AuthenticationRequestFactory</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> Then, the browser takes this <code>&lt;saml2:AuthnRequest&gt;</code> and presents it to the asserting party.
The asserting party attempts to authentication the user.
If successful, it will return a <code>&lt;saml2:Response&gt;</code> back to the browser.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_6.png" alt="number 6"></span> The browser then POSTs the <code>&lt;saml2:Response&gt;</code> to the assertion consumer service endpoint.</p>
</div>
<div id="servlet-saml2login-authentication-saml2webssoauthenticationfilter" class="imageblock">
<div class="content">
<img src="images/servlet/saml2/saml2webssoauthenticationfilter.png" alt="saml2webssoauthenticationfilter">
</div>
<div class="title">Figure 19. Authenticating a <code>&lt;saml2:Response&gt;</code></div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> When the browser submits a <code>&lt;saml2:Response&gt;</code> to the application, it <a href="#servlet-saml2login-authenticate-responses">delegates to <code>Saml2WebSsoAuthenticationFilter</code></a>.
This filter calls its configured <code>AuthenticationConverter</code> to create a <code>Saml2AuthenticationToken</code> by extracting the response from the <code>HttpServletRequest</code>.
This converter additionally resolves the <a href="#servlet-saml2login-relyingpartyregistration"><code>RelyingPartyRegistration</code></a> and supplies it to <code>Saml2AuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Next, the filter passes the token to its configured <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.
By default, it will use the <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> is cleared out.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is invoked to restart the authentication process.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-authentication"><code>Authentication</code></a> is set on the <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a>.</p>
</li>
<li>
<p>The <code>Saml2WebSsoAuthenticationFilter</code> invokes <code>FilterChain#doFilter(request,response)</code> to continue with the rest of the application logic.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimaldependencies"><a class="anchor" href="#servlet-saml2login-minimaldependencies"></a>Minimal Dependencies</h4>
<div class="paragraph">
<p>SAML 2.0 service provider support resides in <code>spring-security-saml2-service-provider</code>.
It builds off of the OpenSAML library.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimalconfiguration"><a class="anchor" href="#servlet-saml2login-minimalconfiguration"></a>Minimal Configuration</h4>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a service provider consists of two basic steps.
First, include the needed dependencies and second, indicate the necessary asserting party metadata.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Also, this presupposes that you&#8217;ve already <a href="#servlet-saml2login-metadata">registered the relying party with your asserting party</a>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_specifying_identity_provider_metadata"><a class="anchor" href="#_specifying_identity_provider_metadata"></a>Specifying Identity Provider Metadata</h5>
<div class="paragraph">
<p>In a Spring Boot application, to specify an identity provider&#8217;s metadata, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    saml2:
      relyingparty:
        registration:
          adfs:
            identityprovider:
              entity-id: https://idp.example.com/issuer
              verification.credentials:
                - certificate-location: "classpath:idp.crt"
              singlesignon.url: https://idp.example.com/issuer/sso
              singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://idp.example.com/issuer" class="bare">https://idp.example.com/issuer</a></code> is the value contained in the <code>Issuer</code> attribute of the SAML responses that the identity provider will issue</p>
</li>
<li>
<p><code>classpath:idp.crt</code> is the location on the classpath for the identity provider&#8217;s certificate for verifying SAML responses, and</p>
</li>
<li>
<p><code><a href="https://idp.example.com/issuer/sso" class="bare">https://idp.example.com/issuer/sso</a></code> is the endpoint where the identity provider is expecting <code>AuthnRequest</code> s.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Identity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party.
These are frequently abbreviated as AP and RP, respectively.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations_3"><a class="anchor" href="#_runtime_expectations_3"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>As configured above, the application processes any <code>POST /login/saml2/sso/{registrationId}</code> request containing a <code>SAMLResponse</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">POST /login/saml2/sso/adfs HTTP/1.1

SAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two ways to see induce your asserting party to generate a <code>SAMLResponse</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, you can navigate to your asserting party.
It likely has some kind of link or button for each registered relying party that you can click to send the <code>SAMLResponse</code>.</p>
</li>
<li>
<p>Second, you can navigate to a protected page in your app, for example, <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.
Your app then redirects to the configured asserting party which then sends the <code>SAMLResponse</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From here, consider jumping to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-saml2login-architecture">How SAML 2.0 Login Integrates with OpenSAML</a></p>
</li>
<li>
<p><a href="#servlet-saml2login-authenticatedprincipal">How to Use the <code>Saml2AuthenticatedPrincipal</code></a></p>
</li>
<li>
<p><a href="#servlet-saml2login-sansboot">How to Override or Replace Spring Boot&#8217;s Auto Configuration</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-architecture"><a class="anchor" href="#servlet-saml2login-architecture"></a>How SAML 2.0 Login Integrates with OpenSAML</h4>
<div class="paragraph">
<p>Spring Security&#8217;s SAML 2.0 support has a couple of design goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, rely on a library for SAML 2.0 operations and domain objects.
To achieve this, Spring Security uses OpenSAML.</p>
</li>
<li>
<p>Second, ensure this library is not required when using Spring Security&#8217;s SAML support.
To achieve this, any interfaces or classes where Spring Security uses OpenSAML in the contract remain encapsulated.
This makes it possible for you to switch out OpenSAML for some other library or even an unsupported version of OpenSAML.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a natural outcome of the above two goals, Spring Security&#8217;s SAML API is quite small relative to other modules.
Instead, classes like <code>OpenSamlAuthenticationRequestFactory</code> and <code>OpenSamlAuthenticationProvider</code> expose <code>Converter</code> s that customize various steps in the authentication process.</p>
</div>
<div class="paragraph">
<p>For example, once your application receives a <code>SAMLResponse</code> and delegates to <code>Saml2WebSsoAuthenticationFilter</code>, the filter will delegate to <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<div class="title">Authenticating an OpenSAML <code>Response</code></div>
<p><span class="image"><img src="images/servlet/saml2/opensamlauthenticationprovider.png" alt="opensamlauthenticationprovider"></span></p>
</div>
<div class="paragraph">
<p>This figure builds off of the <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code> diagram</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> The <code>Saml2WebSsoAuthenticationFilter</code> formulates the <code>Saml2AuthenticationToken</code> and invokes the <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> The <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a> invokes the <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> The authentication provider deserializes the response into an OpenSAML <code>Response</code> and checks its signature.
If the signature is invalid, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> Then, the provider <a href="#servlet-saml2login-opensamlauthenticationprovider-decryption">decrypts any <code>EncryptedAssertion</code> elements</a>.
If any decryptions fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> Next, the provider validates the response&#8217;s <code>Issuer</code> and <code>Destination</code> values.
If they don&#8217;t match what&#8217;s in the <code>RelyingPartyRegistration</code>, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_6.png" alt="number 6"></span> After that, the provider verifies the signature of each <code>Assertion</code>.
If any signature is invalid, authentication fails.
Also, if neither the response nor the assertions have signatures, authentication fails.
Either the response or all the assertions must have signatures.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_7.png" alt="number 7"></span> Then, the provider <a href="#servlet-saml2login-opensamlauthenticationprovider-decryption">decrypts any <code>EncryptedID</code> or <code>EncryptedAttribute</code> elements</a>.
If any decryptions fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_8.png" alt="number 8"></span> Next, the provider validates each assertion&#8217;s <code>ExpiresAt</code> and <code>NotBefore</code> timestamps, the <code>&lt;Subject&gt;</code> and any <code>&lt;AudienceRestriction&gt;</code> conditions.
If any validations fail, authentication fails.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_9.png" alt="number 9"></span> Following that, the provider takes the first assertion&#8217;s <code>AttributeStatement</code> and maps it to a <code>Map&lt;String, List&lt;Object&gt;&gt;</code>.
It also grants the <code>ROLE_USER</code> granted authority.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/icons/number_10.png" alt="number 10"></span> And finally, it takes the <code>NameID</code> from the first assertion, the <code>Map</code> of attributes, and the <code>GrantedAuthority</code> and constructs a <code>Saml2AuthenticatedPrincipal</code>.
Then, it places that principal and the authorities into a <code>Saml2Authentication</code>.</p>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code> is a Spring Security <code>Saml2AuthenticatedPrincipal</code> object, and <code>Authentication#getName</code> maps to the first assertion&#8217;s <code>NameID</code> element.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensaml-customization"><a class="anchor" href="#servlet-saml2login-opensaml-customization"></a>Customizing OpenSAML Configuration</h5>
<div class="paragraph">
<p>Any class that uses both Spring Security and OpenSAML should statically initialize <code>OpenSamlInitializationService</code> at the beginning of the class, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
	OpenSamlInitializationService.initialize();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This replaces OpenSAML&#8217;s <code>InitializationService#initialize</code>.</p>
</div>
<div class="paragraph">
<p>Occasionally, it can be valuable to customize how OpenSAML builds, marshalls, and unmarshalls SAML objects.
In these circumstances, you may instead want to call <code>OpenSamlInitializationService#requireInitialize(Consumer)</code> that gives you access to OpenSAML&#8217;s <code>XMLObjectProviderFactory</code>.</p>
</div>
<div class="paragraph">
<p>For example, when sending an unsigned AuthNRequest, you may want to force reauthentication.
In that case, you can register your own <code>AuthnRequestMarshaller</code>, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
	OpenSamlInitializationService.requireInitialize(factory -&gt; {
		AuthnRequestMarshaller marshaller = new AuthnRequestMarshaller() {
			@Override
            public Element marshall(XMLObject object, Element element) throws MarshallingException {
				configureAuthnRequest((AuthnRequest) object);
				return super.marshall(object, element);
            }

            public Element marshall(XMLObject object, Document document) throws MarshallingException {
				configureAuthnRequest((AuthnRequest) object);
				return super.marshall(object, document);
            }

            private void configureAuthnRequest(AuthnRequest authnRequest) {
				authnRequest.setForceAuthN(true);
            }
		}

	    factory.getMarshallerFactory().registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller);
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>requireInitialize</code> method may only be called once per application instance.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sansboot"><a class="anchor" href="#servlet-saml2login-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h4>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates for a relying party.</p>
</div>
<div class="paragraph">
<p>The first is a <code>WebSecurityConfigurerAdapter</code> that configures the app as a relying party.
When including <code>spring-security-saml2-service-provider</code>, the <code>WebSecurityConfigurerAdapter</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 88. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .saml2Login(withDefaults());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        saml2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>WebSecurityConfigurerAdapter</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>You can replace this by exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. Custom SAML 2.0 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(withDefaults());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the role of <code>USER</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository" class="paragraph">
<p>The second <code>@Bean</code> Spring Boot creates is a {security-api-url}org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistrationRepository.html[<code>RelyingPartyRegistrationRepository</code>], which represents the asserting party and relying party metadata.
This includes things like the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party.</p>
</div>
<div class="paragraph">
<p>You can override the default by publishing your own <code>RelyingPartyRegistrationRepository</code> bean.
For example, you can look up the asserting party&#8217;s configuration by hitting its metadata endpoint like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. Relying Party Registration Repository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${metadata.location}")
String assertingPartyMetadataLocation;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
	RelyingPartyRegistration registration = RelyingPartyRegistrations
            .fromMetadataLocation(assertingPartyMetadataLocation)
            .registrationId("example")
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or you can provide each detail manually, as you can see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. Relying Party Registration Repository Manual Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${verification.key}")
File verificationKey;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() throws Exception {
    X509Certificate certificate = X509Support.decodeCertificate(this.verificationKey);
    Saml2X509Credential credential = Saml2X509Credential.verification(certificate);
    RelyingPartyRegistration registration = RelyingPartyRegistration
            .withRegistrationId("example")
            .assertingPartyDetails(party -&gt; party
                .entityId("https://idp.example.com/issuer")
                .singleSignOnServiceLocation("https://idp.example.com/SSO.saml2")
                .wantAuthnRequestsSigned(false)
                .verificationX509Credentials(c -&gt; c.add(credential))
            )
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that <code>X509Support</code> is an OpenSAML class, used here in the snippet for brevity
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository-dsl" class="paragraph">
<p>Alternatively, you can directly wire up the repository using the DSL, which will also override the auto-configured <code>WebSecurityConfigurerAdapter</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. Custom Relying Party Registration DSL</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .relyingPartyRegistrationRepository(relyingPartyRegistrations())
            );
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
                relyingPartyRegistrationRepository = relyingPartyRegistrations()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A relying party can be multi-tenant by registering more than one relying party in the <code>RelyingPartyRegistrationRepository</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-relyingpartyregistration"><a class="anchor" href="#servlet-saml2login-relyingpartyregistration"></a>RelyingPartyRegistration</h4>
<div class="paragraph">
<p>A {security-api-url}org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.html[<code>RelyingPartyRegistration</code>]
instance represents a link between an relying party and assering party&#8217;s metadata.</p>
</div>
<div class="paragraph">
<p>In a <code>RelyingPartyRegistration</code>, you can provide relying party metadata like its <code>Issuer</code> value, where it expects SAML Responses to be sent to, and any credentials that it owns for the purposes of signing or decrypting payloads.</p>
</div>
<div class="paragraph">
<p>Also, you can provide asserting party metadata like its <code>Issuer</code> value, where it expects AuthnRequests to be sent to, and any public credentials that it owns for the purposes of the relying party verifying or encrypting payloads.</p>
</div>
<div class="paragraph">
<p>The following <code>RelyingPartyRegistration</code> is the minimum required for most setups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations
        .fromMetadataLocation("https://ap.example.org/metadata")
        .registrationId("my-id")
        .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Though a more sophisticated setup is also possible, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("my-id")
        .entityId("{baseUrl}/{registrationId}")
        .decryptionX509Credentials(c -&gt; c.add(relyingPartyDecryptingCredential()))
        .assertionConsumerServiceLocation("/my-login-endpoint/{registrationId}")
        .assertingParty(party -&gt; party
                .entityId("https://ap.example.org")
                .verificationX509Credentials(c -&gt; c.add(assertingPartyVerifyingCredential()))
                .singleSignOnServiceLocation("https://ap.example.org/SSO.saml2")
        );</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The top-level metadata methods are details about the relying party.
The methods inside <code>assertingPartyDetails</code> are details about the asserting party.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The location where a relying party is expecting SAML Responses is the Assertion Consumer Service Location.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default for the relying party&#8217;s <code>entityId</code> is <code>{baseUrl}/saml2/service-provider-metadata/{registrationId}</code>.
This is this value needed when configuring the asserting party to know about your relying party.</p>
</div>
<div class="paragraph">
<p>The default for the <code>assertionConsumerServiceLocation</code> is <code>/login/saml2/sso/{registrationId}</code>.
It&#8217;s mapped by default to <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code></a> in the filter chain.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-uripatterns"><a class="anchor" href="#servlet-saml2login-rpr-uripatterns"></a>URI Patterns</h5>
<div class="paragraph">
<p>You probably noticed in the above examples the <code>{baseUrl}</code> and <code>{registrationId}</code> placeholders.</p>
</div>
<div class="paragraph">
<p>These are useful for generating URIs. As such, the relying party&#8217;s <code>entityId</code> and <code>assertionConsumerServiceLocation</code> support the following placeholders:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>baseUrl</code> - the scheme, host, and port of a deployed application</p>
</li>
<li>
<p><code>registrationId</code> - the registration id for this relying party</p>
</li>
<li>
<p><code>baseScheme</code> - the scheme of a deployed application</p>
</li>
<li>
<p><code>baseHost</code> - the host of a deployed application</p>
</li>
<li>
<p><code>basePort</code> - the port of a deployed application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the <code>assertionConsumerServiceLocation</code> defined above was:</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>which in a deployed application would translate to</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/adfs</code></p>
</div>
<div class="paragraph">
<p>The <code>entityId</code> above was defined as:</p>
</div>
<div class="paragraph">
<p><code>{baseUrl}/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>which in a deployed application would translate to</p>
</div>
<div class="paragraph">
<p><code>https://rp.example.com/adfs</code></p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-credentials"><a class="anchor" href="#servlet-saml2login-rpr-credentials"></a>Credentials</h5>
<div class="paragraph">
<p>You also likely noticed the credential that was used.</p>
</div>
<div class="paragraph">
<p>Oftentimes, a relying party will use the same key to sign payloads as well as decrypt them.
Or it will use the same key to verify payloads as well as encrypt them.</p>
</div>
<div class="paragraph">
<p>Because of this, Spring Security ships with <code>Saml2X509Credential</code>, a SAML-specific credential that simplifies configuring the same key for different use cases.</p>
</div>
<div class="paragraph">
<p>At a minimum, it&#8217;s necessary to have a certificate from the asserting party so that the asserting party&#8217;s signed responses can be verified.</p>
</div>
<div class="paragraph">
<p>To construct a <code>Saml2X509Credential</code> that you&#8217;ll use to verify assertions from the asserting party, you can load the file and use
the <code>CertificateFactory</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Resource resource = new ClassPathResource("ap.crt");
try (InputStream is = resource.getInputStream()) {
	X509Certificate certificate = (X509Certificate)
            CertificateFactory.getInstance("X.509").generateCertificate(is);
	return Saml2X509Credential.verification(certificate);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say that the asserting party is going to also encrypt the assertion.
In that case, the relying party will need a private key to be able to decrypt the encrypted value.</p>
</div>
<div class="paragraph">
<p>In that case, you&#8217;ll need an <code>RSAPrivateKey</code> as well as its corresponding <code>X509Certificate</code>.
You can load the first using Spring Security&#8217;s <code>RsaKeyConverters</code> utility class and the second as you did before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">X509Certificate certificate = relyingPartyDecryptionCertificate();
Resource resource = new ClassPathResource("rp.crt");
try (InputStream is = resource.getInputStream()) {
	RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is);
	return Saml2X509Credential.decryption(rsa, certificate);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When you specify the locations of these files as the appropriate Spring Boot properties, then Spring Boot will perform these conversions for you.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-relyingpartyregistrationresolver"><a class="anchor" href="#servlet-saml2login-rpr-relyingpartyregistrationresolver"></a>Resolving the Relying Party from the Request</h5>
<div class="paragraph">
<p>As seen so far, Spring Security resolves the <code>RelyingPartyRegistration</code> by looking for the registration id in the URI path.</p>
</div>
<div class="paragraph">
<p>There are a number of reasons you may want to customize. Among them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You may know that you will never be a multi-tenant application and so want to have a simpler URL scheme</p>
</li>
<li>
<p>You may identify tenants in a way other than by the URI path</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To customize the way that a <code>RelyingPartyRegistration</code> is resolved, you can configure a custom <code>Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt;</code>.
The default looks up the registration id from the URI&#8217;s last path element and looks it up in your <code>RelyingPartyRegistrationRepository</code>.</p>
</div>
<div class="paragraph">
<p>You can provide a simpler resolver that, for example, always returns the same relying party:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SingleRelyingPartyRegistrationResolver
        implements Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; {

	@Override
    public RelyingPartyRegistration convert(HttpServletRequest request) {
		return this.relyingParty;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can provide this resolver to the appropriate filters that <a href="#servlet-saml2login-sp-initiated-factory">produce <code>&lt;saml2:AuthnRequest&gt;</code> s</a>, <a href="#servlet-saml2login-authenticate-responses">authenticate <code>&lt;saml2:Response&gt;</code> s</a>, and <a href="#servlet-saml2login-metadata">produce <code>&lt;saml2:SPSSODescriptor&gt;</code> metadata</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that if you have any placeholders in your <code>RelyingPartyRegistration</code>, your resolver implementation should resolve them.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-duplicated"><a class="anchor" href="#servlet-saml2login-rpr-duplicated"></a>Duplicated Relying Party Configurations</h5>
<div class="paragraph">
<p>When an application uses multiple asserting parties, some configuration is duplicated between <code>RelyingPartyRegistration</code> instances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The relying party&#8217;s <code>entityId</code></p>
</li>
<li>
<p>Its <code>assertionConsumerServiceLocation</code>, and</p>
</li>
<li>
<p>Its credentials, for example its signing or decryption credentials</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What&#8217;s nice about this setup is credentials may be more easily rotated for some identity providers vs others.</p>
</div>
<div class="paragraph">
<p>The duplication can be alleviated in a few different ways.</p>
</div>
<div class="paragraph">
<p>First, in YAML this can be alleviated with references, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          signing.credentials: &amp;relying-party-credentials
            - private-key-location: classpath:rp.key
            - certificate-location: classpath:rp.crt
          identityprovider:
            entity-id: ...
        azure:
          signing.credentials: *relying-party-credentials
          identityprovider:
            entity-id: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, in a database, it&#8217;s not necessary to replicate <code>RelyingPartyRegistration</code> 's model.</p>
</div>
<div class="paragraph">
<p>Third, in Java, you can create a custom configuration method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private RelyingPartyRegistration.Builder
        addRelyingPartyDetails(RelyingPartyRegistration.Builder builder) {

	Saml2X509Credential signingCredential = ...
	builder.signingX509Credentials(c -&gt; c.addAll(signingCredential));
	// ... other relying party configurations
}

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
    RelyingPartyRegistration okta = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("okta")).build();

    RelyingPartyRegistration azure = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("azure")).build();

    return new InMemoryRelyingPartyRegistrationRepository(okta, azure);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sp-initiated-factory"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory"></a>Producing <code>&lt;saml2:AuthnRequest&gt;</code> s</h4>
<div class="paragraph">
<p>As stated earlier, Spring Security&#8217;s SAML 2.0 support produces a <code>&lt;saml2:AuthnRequest&gt;</code> to commence authentication with the asserting party.</p>
</div>
<div class="paragraph">
<p>Spring Security achieves this in part by registering the <code>Saml2WebSsoAuthenticationRequestFilter</code> in the filter chain.
This filter by default responds to endpoint <code>/saml2/authenticate/{registrationId}</code>.</p>
</div>
<div class="paragraph">
<p>For example, if you were deployed to <code><a href="https://rp.example.com" class="bare">https://rp.example.com</a></code> and you gave your registration an ID of <code>okta</code>, you could navigate to:</p>
</div>
<div class="paragraph">
<p><code><a href="https://rp.example.org/saml2/authenticate/ping" class="bare">https://rp.example.org/saml2/authenticate/ping</a></code></p>
</div>
<div class="paragraph">
<p>and the result would be a redirect that included a <code>SAMLRequest</code> parameter containing the signed, deflated, and encoded <code>&lt;saml2:AuthnRequest&gt;</code>.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-signing"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-signing"></a>Changing How the <code>&lt;saml2:AuthnRequest&gt;</code> Gets Sent</h5>
<div class="paragraph">
<p>By default, Spring Security signs each <code>&lt;saml2:AuthnRequest&gt;</code> and send it as a GET to the asserting party.</p>
</div>
<div class="paragraph">
<p>Many asserting parties don&#8217;t require a signed <code>&lt;saml2:AuthnRequest&gt;</code>.
This can be configured automatically via <code>RelyingPartyRegistrations</code>, or you can supply it manually, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. Not Requiring Signed AuthnRequests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Boot</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          identityprovider:
            entity-id: ...
            singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .wantAuthnRequestsSigned(false)
        );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Otherwise, you will need to specify a private key to <code>RelyingPartyRegistration#signingX509Credentials</code> so that Spring Security can sign the <code>&lt;saml2:AuthnRequest&gt;</code> before sending.</p>
</div>
<div id="servlet-saml2login-sp-initiated-factory-algorithm" class="paragraph">
<p>By default, Spring Security will sign the <code>&lt;saml2:AuthnRequest&gt;</code> using <code>rsa-sha256</code>, though some asserting parties will require a different algorithm, as indicated in their metadata.</p>
</div>
<div class="paragraph">
<p>You can configure the algorithm based on the asserting party&#8217;s <a href="#servlet-saml2login-relyingpartyregistrationrepository">metadata using <code>RelyingPartyRegistrations</code></a>.</p>
</div>
<div class="paragraph">
<p>Or, you can provide it manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String metadataLocation = "classpath:asserting-party-metadata.xml";
RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations.fromMetadataLocation(metadataLocation)
        // ...
        .assertingPartyDetails((party) -&gt; party
            // ...
            .signingAlgorithms((sign) -&gt; sign.add(SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512))
        );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The snippet above uses the OpenSAML <code>SignatureConstants</code> class to supply the algorithm name.
But, that&#8217;s just for convenience.
Since the datatype is <code>String</code>, you can supply the name of the algorithm directly.
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-sp-initiated-factory-binding" class="paragraph">
<p>Some asserting parties require that the <code>&lt;saml2:AuthnRequest&gt;</code> be POSTed.
This can be configured automatically via <code>RelyingPartyRegistrations</code>, or you can supply it manually, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .singleSignOnServiceBinding(Saml2MessageType.POST)
        );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-custom-authnrequest"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest"></a>Customizing OpenSAML&#8217;s <code>AuthnRequest</code> Instance</h5>
<div class="paragraph">
<p>There are a number of reasons that you may want to adjust an <code>AuthnRequest</code>.
For example, you may want <code>ForceAuthN</code> to be set to <code>true</code>, which Spring Security sets to <code>false</code> by default.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t need information from the <code>HttpServletRequest</code> to make your decision, then the easiest way is to <a href="#servlet-saml2login-opensaml-customization">register a custom <code>AuthnRequestMarshaller</code> with OpenSAML</a>.
This will give you access to post-process the <code>AuthnRequest</code> instance before it&#8217;s serialized.</p>
</div>
<div class="paragraph">
<p>But, if you do need something from the request, then you can use create a custom <code>Saml2AuthenticationRequestContext</code> implementation and then a <code>Converter&lt;Saml2AuthenticationRequestContext, AuthnRequest&gt;</code> to build an <code>AuthnRequest</code> yourself, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class AuthnRequestConverter implements
        Converter&lt;MySaml2AuthenticationRequestContext, AuthnRequest&gt; {

	private final AuthnRequestBuilder authnRequestBuilder;
	private final IssuerBuilder issuerBuilder;

	// ... constructor

	public AuthnRequest convert(Saml2AuthenticationRequestContext context) {
		MySaml2AuthenticationRequestContext myContext = (MySaml2AuthenticationRequestContext) context;
		Issuer issuer = issuerBuilder.buildObject();
		issuer.setValue(myContext.getIssuer());

		AuthnRequest authnRequest = authnRequestBuilder.buildObject();
		authnRequest.setIssuer(iss);
        authnRequest.setDestination(myContext.getDestination());
		authnRequest.setAssertionConsumerServiceURL(myContext.getAssertionConsumerServiceUrl());

		// ... additional settings

		authRequest.setForceAuthn(myContext.getForceAuthn());
		return authnRequest;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can construct your own <code>Saml2AuthenticationRequestContextResolver</code> and <code>Saml2AuthenticationRequestFactory</code> and publish them as <code>@Bean</code> s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
Saml2AuthenticationRequestContextResolver authenticationRequestContextResolver() {
	Saml2AuthenticationRequestContextResolver resolver =
            new DefaultSaml2AuthenticationRequestContextResolver();
	return request -&gt; {
        Saml2AuthenticationRequestContext context = resolver.resolve(request);
        return new MySaml2AuthenticationRequestContext(context, request.getParameter("force") != null);
	};
}

@Bean
Saml2AuthenticationRequestFactory authenticationRequestFactory(
		AuthnRequestConverter authnRequestConverter) {

	OpenSamlAuthenticationRequestFactory authenticationRequestFactory =
            new OpenSamlAuthenticationRequestFactory();
	authenticationRequestFactory.setAuthenticationRequestContextConverter(authnRequestConverter);
	return authenticationRequestFactory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticate-responses"><a class="anchor" href="#servlet-saml2login-authenticate-responses"></a>Authenticating <code>&lt;saml2:Response&gt;</code> s</h4>
<div class="paragraph">
<p>To verify SAML 2.0 Responses, Spring Security uses <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a> by default.</p>
</div>
<div class="paragraph">
<p>You can configure this in a number of ways including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Setting a clock skew to timestamp validation</p>
</li>
<li>
<p>Mapping the response to a list of <code>GrantedAuthority</code> instances</p>
</li>
<li>
<p>Customizing the strategy for validating assertions</p>
</li>
<li>
<p>Customizing the strategy for decrypting response and assertion elements</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To configure these, you&#8217;ll use the <code>saml2Login#authenticationManager</code> method in the DSL.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-clockskew"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-clockskew"></a>Setting a Clock Skew</h5>
<div class="paragraph">
<p>It&#8217;s not uncommon for the asserting and relying parties to have system clocks that aren&#8217;t perfectly synchronized.
For that reason, you can configure <code>OpenSamlAuthenticationProvider</code> 's default assertion validator with some tolerance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setAssertionValidator(OpenSamlAuthenticationProvider
                .createDefaultAssertionValidator(assertionToken -&gt; {
        			Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
        			params.put(CLOCK_SKEW, Duration.ofMinutes(10).toMillis());
        			// ... other validation parameters
        			return new ValidationContext(params);
        		})
        );

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"></a>Coordinating with a <code>UserDetailsService</code></h5>
<div class="paragraph">
<p>Or, perhaps you would like to include user details from a legacy <code>UserDetailsService</code>.
In that case, the response authentication converter can come in handy, as can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    UserDetailsService userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setResponseAuthenticationConverter(responseToken -&gt; {
        	Saml2Authentication authentication = OpenSamlAuthenticationProvider
                    .createDefaultResponseAuthenticationConverter() <i class="conum" data-value="1"></i><b>(1)</b>
                    .convert(responseToken);
        	Assertion assertion = responseToken.getResponse().getAssertions().get(0);
            String username = assertion.getSubject().getNameID().getValue();
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username); <i class="conum" data-value="2"></i><b>(2)</b>
            return MySaml2Authentication(userDetails, authentication); <i class="conum" data-value="3"></i><b>(3)</b>
        });

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, call the default converter, which extracts attributes and authorities from the response</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Second, call the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> using the relevant information</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Third, return a custom authentication that includes the user details</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It&#8217;s not required to call <code>OpenSamlAuthenticationProvider</code> 's default authentication converter.
It returns a <code>Saml2AuthenticatedPrincipal</code> containing the attributes it extracted from <code>AttributeStatement</code> s as well as the single <code>ROLE_USER</code> authority.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"></a>Performing Additional Validation</h5>
<div class="paragraph">
<p><code>OpenSamlAuthenticationProvider</code> performs minimal validation on SAML 2.0 Assertions.
After verifying the signature, it will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate <code>&lt;AudienceRestriction&gt;</code> and <code>&lt;DelegationRestriction&gt;</code> conditions</p>
</li>
<li>
<p>Validate <code>&lt;SubjectConfirmation&gt;</code> s, expect for any IP address information</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To perform additional validation, you can configure your own assertion validator that delegates to <code>OpenSamlAuthenticationProvider</code> 's default and then performs its own.</p>
</div>
<div id="servlet-saml2login-opensamlauthenticationprovider-onetimeuse" class="paragraph">
<p>For example, you can use OpenSAML&#8217;s <code>OneTimeUseConditionValidator</code> to also validate a <code>&lt;OneTimeUse&gt;</code> condition, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenSamlAuthenticationProvider provider = new OpenSamlAuthenticationProvider();
OneTimeUseConditionValidator validator = ...;
provider.setAssertionValidator(assertionToken -&gt; {
    Saml2ResponseValidatorResult result = OpenSamlAuthenticationProvider
            .createDefaultAssertionValidator()
            .convert(assertionToken);
    Assertion assertion = assertionToken.getAssertion();
    OneTimeUse oneTimeUse = assertion.getConditions().getOneTimeUse();
    ValidationContext context = new ValidationContext();
    try {
    	if (validator.validate(oneTimeUse, assertion, context) == ValidationResult.VALID) {
    		return result;
    	}
    } catch (Exception e) {
    	return result.concat(new Saml2Error(INVALID_ASSERTION, e.getMessage()));
    }
    return result.contact(new Saml2Error(INVALID_ASSERTION, context.getValidationFailureMessage()));
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While recommended, it&#8217;s not necessary to call <code>OpenSamlAuthenticationProvider</code> 's default assertion validator.
A circumstance where you would skip it would be if you don&#8217;t need it to check the <code>&lt;AudienceRestriction&gt;</code> or the <code>&lt;SubjectConfirmation&gt;</code> since you are doing those yourself.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-decryption"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-decryption"></a>Customizing Decryption</h5>
<div class="paragraph">
<p>Spring Security decrypts <code>&lt;saml2:EncryptedAssertion&gt;</code>, <code>&lt;saml2:EncryptedAttribute&gt;</code>, and <code>&lt;saml2:EncryptedID&gt;</code> elements automatically by using the decryption <a href="#servlet-saml2login-rpr-credentials"><code>Saml2X509Credential</code> instances</a> registered in the <a href="#servlet-saml2login-relyingpartyregistration"><code>RelyingPartyRegistration</code></a>.</p>
</div>
<div class="paragraph">
<p><code>OpenSamlAuthenticationProvider</code> exposes <a href="#servlet-saml2login-architecture">two decryption strategies</a>.
The response decrypter is for decrypting encrypted elements of the <code>&lt;saml2:Response&gt;</code>, like <code>&lt;saml2:EncryptedAssertion&gt;</code>.
The assertion decrypter is for decrypting encrypted elements of the <code>&lt;saml2:Assertion&gt;</code>, like <code>&lt;saml2:EncryptedAttribute&gt;</code> and <code>&lt;saml2:EncryptedID&gt;</code>.</p>
</div>
<div class="paragraph">
<p>You can replace <code>OpenSamlAuthenticationProvider&#8217;s default decryption strategy with your own.
For example, if you have a separate service that decrypts the assertions in a `&lt;saml2:Response&gt;</code>, you can use it instead like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MyDecryptionService decryptionService = ...;
OpenSamlAuthenticationProvider provider = new OpenSamlAuthenticationProvider();
provider.setResponseElementsDecrypter((responseToken) -&gt; decryptionService.decrypt(responseToken.getResponse()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are also decrypting individual elements in a <code>&lt;saml2:Assertion&gt;</code>, you can customize the assertion decrypter, too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">provider.setAssertionElementsDecrypter((assertionToken) -&gt; decryptionService.decrypt(assertionToken.getAssertion()));</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two separate decrypters since assertions can be signed separately from responses.
Trying to decrypt a signed assertion&#8217;s elements before signature verification may invalidate the signature.
If your asserting party signs the response only, then it&#8217;s safe to decrypt all elements using only the response decrypter.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-authenticationmanager-custom"><a class="anchor" href="#servlet-saml2login-authenticationmanager-custom"></a>Using a Custom Authentication Manager</h5>
<div id="servlet-saml2login-opensamlauthenticationprovider-authenticationmanager" class="paragraph">
<p>Of course, the <code>authenticationManager</code> DSL method can be also used to perform a completely custom SAML 2.0 authentication.
This authentication manager should expect a <code>Saml2AuthenticationToken</code> object containing the SAML 2.0 Response XML data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(authenticationManager)
            )
        ;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticatedprincipal"><a class="anchor" href="#servlet-saml2login-authenticatedprincipal"></a>Using <code>Saml2AuthenticatedPrincipal</code></h4>
<div class="paragraph">
<p>With the relying party correctly configured for a given asserting party, it&#8217;s ready to accept assertions.
Once the relying party validates an assertion, the result is a <code>Saml2Authentication</code> with a <code>Saml2AuthenticatedPrincipal</code>.</p>
</div>
<div class="paragraph">
<p>This means that you can access the principal in your controller like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MainController {
	@GetMapping("/")
	public String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) {
		String email = principal.getFirstAttribute("email");
		model.setAttribute("email", email);
		return "index";
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Because the SAML 2.0 specification allows for each attribute to have multiple values, you can either call <code>getAttribute</code> to get the list of attributes or <code>getFirstAttribute</code> to get the first in the list.
<code>getFirstAttribute</code> is quite handy when you know that there is only one value.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-metadata"><a class="anchor" href="#servlet-saml2login-metadata"></a>Producing <code>&lt;saml2:SPSSODescriptor&gt;</code> Metadata</h4>
<div class="paragraph">
<p>You can publish a metadata endpoint by adding the <code>Saml2MetadataFilter</code> to the filter chain, as you&#8217;ll see below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; relyingPartyRegistrationResolver =
        new DefaultRelyingPartyRegistrationResolver(this.relyingPartyRegistrationRepository);
Saml2MetadataFilter filter = new Saml2MetadataFilter(
		relyingPartyRegistrationResolver,
        new OpenSamlMetadataResolver());

http
    // ...
    .saml2Login(withDefaults())
    .addFilterBefore(new Saml2MetadataFilter(r), Saml2WebSsoAuthenticationFilter.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use this metadata endpoint to register your relying party with your asserting party.
This is often as simple as finding the correct form field to supply the metadata endpoint.</p>
</div>
<div class="paragraph">
<p>By default, the metadata endpoint is <code>/saml2/service-provider-metadata/{registrationId}</code>.
You can change this by calling the <code>setRequestMatcher</code> method on the filter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata/{registrationId}", "GET"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>ensuring that the <code>registrationId</code> hint is at the end of the path.</p>
</div>
<div class="paragraph">
<p>Or, if you have registered a custom relying party registration resolver in the constructor, then you can specify a path without a <code>registrationId</code> hint, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata", "GET"));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-logout"><a class="anchor" href="#servlet-saml2login-logout"></a>Performing Single Logout</h4>
<div class="paragraph">
<p>Spring Security does not yet support single logout.</p>
</div>
<div class="paragraph">
<p>Generally speaking, though, you can achieve this by creating and registering a custom <code>LogoutSuccessHandler</code> and <code>RequestMatcher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    // ...
    .logout(logout -&gt; logout
        .logoutSuccessHandler(myCustomSuccessHandler())
        .logoutRequestMatcher(myRequestMatcher())
    )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The success handler will send logout requests to the asserting party.</p>
</div>
<div class="paragraph">
<p>The request matcher will detect logout requests from the asserting party.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-exploits"><a class="anchor" href="#servlet-exploits"></a>Protection Against Exploits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servlet-csrf"><a class="anchor" href="#servlet-csrf"></a>Cross Site Request Forgery (CSRF) for Servlet Environments</h3>
<div class="paragraph">
<p>This section discusses Spring Security&#8217;s <a href="#csrf">Cross Site Request Forgery (CSRF)</a> support for servlet environments.</p>
</div>
<div class="sect3">
<h4 id="servlet-csrf-using"><a class="anchor" href="#servlet-csrf-using"></a>Using Spring Security CSRF Protection</h4>
<div class="paragraph">
<p>The steps to using Spring Security&#8217;s CSRF protection are outlined below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-csrf-idempotent">Use proper HTTP verbs</a></p>
</li>
<li>
<p><a href="#servlet-csrf-configure">Configure CSRF Protection</a></p>
</li>
<li>
<p><a href="#servlet-csrf-include">Include the CSRF Token</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="servlet-csrf-idempotent"><a class="anchor" href="#servlet-csrf-idempotent"></a>Use proper HTTP verbs</h5>
<div class="paragraph">
<p>The first step to protecting against CSRF attacks is to ensure your website uses proper HTTP verbs.
This is covered in detail in <a href="#csrf-protection-idempotent">Safe Methods Must be Idempotent</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-configure"><a class="anchor" href="#servlet-csrf-configure"></a>Configure CSRF Protection</h5>
<div class="paragraph">
<p>The next step is to configure Spring Security&#8217;s CSRF protection within your application.
Spring Security&#8217;s CSRF protection is enabled by default, but you may need to customize the configuration.
Below are a few common customizations.</p>
</div>
<div class="sect5">
<h6 id="servlet-csrf-configure-custom-repository"><a class="anchor" href="#servlet-csrf-configure-custom-repository"></a>Custom CsrfTokenRepository</h6>
<div class="paragraph">
<p>By default Spring Security stores the expected CSRF token in the <code>HttpSession</code> using <code>HttpSessionCsrfTokenRepository</code>.
There can be cases where users will want to configure a custom <code>CsrfTokenRepository</code>.
For example, it might be desirable to persist the <code>CsrfToken</code> in a cookie to <a href="#servlet-csrf-include-ajax-auto">support a JavaScript based application</a>.</p>
</div>
<div class="paragraph">
<p>By default the <code>CookieCsrfTokenRepository</code> will write to a cookie named <code>XSRF-TOKEN</code> and read it from a header named <code>X-XSRF-TOKEN</code> or the HTTP parameter <code>_csrf</code>.
These defaults come from <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a></p>
</div>
<div class="paragraph">
<p>You can configure <code>CookieCsrfTokenRepository</code> in XML using the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. Store CSRF Token in a Cookie with XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;csrf token-repository-ref="tokenRepository"/&gt;
&lt;/http&gt;
&lt;b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The sample explicitly sets <code>cookieHttpOnly=false</code>.
This is necessary to allow JavaScript (i.e. AngularJS) to read it.
If you do not need the ability to read the cookie with JavaScript directly, it is recommended to omit <code>cookieHttpOnly=false</code> to improve security.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can configure <code>CookieCsrfTokenRepository</code> in Java Configuration using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 95. Store CSRF Token in a Cookie</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -&gt; csrf
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The sample explicitly sets <code>cookieHttpOnly=false</code>.
This is necessary to allow JavaScript (i.e. AngularJS) to read it.
If you do not need the ability to read the cookie with JavaScript directly, it is recommended to omit <code>cookieHttpOnly=false</code> (by using <code>new CookieCsrfTokenRepository()</code> instead) to improve security.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-configure-disable"><a class="anchor" href="#servlet-csrf-configure-disable"></a>Disable CSRF Protection</h6>
<div class="paragraph">
<p>CSRF protection is enabled by default.
However, it is simple to disable CSRF protection if it <a href="#csrf-when">makes sense for your application</a>.</p>
</div>
<div class="paragraph">
<p>The XML configuration below will disable CSRF protection.</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. Disable CSRF XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;csrf disabled="true"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The Java configuration below will disable CSRF protection.</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. Disable CSRF</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -&gt; csrf.disable());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-include"><a class="anchor" href="#servlet-csrf-include"></a>Include the CSRF Token</h5>
<div class="paragraph">
<p>In order for the <a href="#csrf-protection-stp">synchronizer token pattern</a> to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request.
This must be included in a part of the request (i.e. form parameter, HTTP header, etc) that is not automatically included in the HTTP request by the browser.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfFilter.html">CsrfFilter</a> exposes a <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html">CsrfToken</a> as an <code>HttpServletRequest</code> attribute named <code>_csrf</code>.
This means that any view technology can access the <code>CsrfToken</code> to expose the expected token as either a <a href="#servlet-csrf-include-form-attr">form</a> or <a href="#servlet-csrf-include-ajax-meta-attr">meta tag</a>.
Fortunately, there are integrations listed below that make including the token in <a href="#servlet-csrf-include-form">form</a> and <a href="#servlet-csrf-include-ajax">ajax</a> requests even easier.</p>
</div>
<div class="sect5">
<h6 id="servlet-csrf-include-form"><a class="anchor" href="#servlet-csrf-include-form"></a>Form URL Encoded</h6>
<div class="paragraph">
<p>In order to post an HTML form the CSRF token must be included in the form as a hidden input.
For example, the rendered HTML might look like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. CSRF Token HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Next we will discuss various ways of including the CSRF token in a form as a hidden input.</p>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-auto"><a class="anchor" href="#servlet-csrf-include-form-auto"></a>Automatic CSRF Token Inclusion</h7>
<div class="paragraph">
<p>Spring Security&#8217;s CSRF support provides integration with Spring&#8217;s <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/RequestDataValueProcessor.html">RequestDataValueProcessor</a> via its <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html">CsrfRequestDataValueProcessor</a>.
This means that if you leverage <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib">Spring’s form tag library</a>, <a href="https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor">Thymeleaf</a>, or any other view technology that integrates with <code>RequestDataValueProcessor</code>, then forms that have an unsafe HTTP method (i.e. post) will automatically include the actual CSRF token.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-tag"><a class="anchor" href="#servlet-csrf-include-form-tag"></a>csrfInput Tag</h7>
<div class="paragraph">
<p>If you are using JSPs, then you can use <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib">Spring’s form tag library</a>.
However, if that is not an option, you can also easily include the token with the <a href="#taglibs-csrfinput">csrfInput</a> tag.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-attr"><a class="anchor" href="#servlet-csrf-include-form-attr"></a>CsrfToken Request Attribute</h7>
<div class="paragraph">
<p>If the <a href="#servlet-csrf-include">other options</a> for including the actual CSRF token in the request do not work, you can take advantage of the fact that the <code>CsrfToken</code> <a href="#servlet-csrf-include">is exposed</a> as an <code>HttpServletRequest</code> attribute named <code>_csrf</code>.</p>
</div>
<div class="paragraph">
<p>An example of doing this with a JSP is shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. CSRF Token in Form with Request Attribute</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;c:url var="logoutUrl" value="/logout"/&gt;
&lt;form action="${logoutUrl}"
	method="post"&gt;
&lt;input type="submit"
	value="Log out" /&gt;
&lt;input type="hidden"
	name="${_csrf.parameterName}"
	value="${_csrf.token}"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-include-ajax"><a class="anchor" href="#servlet-csrf-include-ajax"></a>Ajax and JSON Requests</h6>
<div class="paragraph">
<p>If you are using JSON, then it is not possible to submit the CSRF token within an HTTP parameter.
Instead you can submit the token within a HTTP header.</p>
</div>
<div class="paragraph">
<p>In the following sections we will discuss various ways of including the CSRF token as an HTTP request header in JavaScript based applications.</p>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-ajax-auto"><a class="anchor" href="#servlet-csrf-include-ajax-auto"></a>Automatic Inclusion</h7>
<div class="paragraph">
<p>Spring Security can easily be <a href="#servlet-csrf-configure-custom-repository">configured</a> to store the expected CSRF token in a cookie.
By storing the expected CSRF in a cookie, JavaScript frameworks like <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a> will automatically include the actual CSRF token in the HTTP request headers.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-ajax-meta"><a class="anchor" href="#servlet-csrf-include-ajax-meta"></a>Meta tags</h7>
<div class="paragraph">
<p>An alternative pattern to <a href="#servlet-csrf-include-form-auto">exposing the CSRF in a cookie</a> is to include the CSRF token within your <code>meta</code> tags.
The HTML might look something like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. CSRF meta tag HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
	&lt;meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;
	&lt;meta name="_csrf_header" content="X-CSRF-TOKEN"/&gt;
	&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once the meta tags contained the CSRF token, the JavaScript code would read the meta tags and include the CSRF token as a header.
If you were using jQuery, this could be done with the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. AJAX send CSRF Token</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect7">
<h8 id="servlet-csrf-include-ajax-meta-tag"><a class="anchor" href="#servlet-csrf-include-ajax-meta-tag"></a>csrfMeta tag</h8>
<div class="paragraph">
<p>If you are using JSPs a simple way to write the CSRF token to the <code>meta</code> tags is by leveraging the <a href="#taglibs-csrfmeta">csrfMeta</a> tag.</p>
</div>
</div>
<div class="sect7">
<h8 id="servlet-csrf-include-ajax-meta-attr"><a class="anchor" href="#servlet-csrf-include-ajax-meta-attr"></a>CsrfToken Request Attribute</h8>
<div class="paragraph">
<p>If the <a href="#servlet-csrf-include">other options</a> for including the actual CSRF token in the request do not work, you can take advantage of the fact that the <code>CsrfToken</code> <a href="#servlet-csrf-include">is exposed</a> as an <code>HttpServletRequest</code> attribute named <code>_csrf</code>.
An example of doing this with a JSP is shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. CSRF meta tag JSP</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
	&lt;meta name="_csrf" content="${_csrf.token}"/&gt;
	&lt;!-- default header name is X-CSRF-TOKEN --&gt;
	&lt;meta name="_csrf_header" content="${_csrf.headerName}"/&gt;
	&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-csrf-considerations"><a class="anchor" href="#servlet-csrf-considerations"></a>CSRF Considerations</h4>
<div class="paragraph">
<p>There are a few special considerations to consider when implementing protection against CSRF attacks.
This section discusses those considerations as it pertains to servlet environments.
Refer to <a href="#csrf-considerations">[csrf-considerations]</a> for a more general discussion.</p>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-login"><a class="anchor" href="#servlet-considerations-csrf-login"></a>Logging In</h5>
<div class="paragraph">
<p>It is important to <a href="#csrf-considerations-login">require CSRF for log in</a> requests to protect against forging log in attempts.
Spring Security&#8217;s servlet support does this out of the box.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-logout"><a class="anchor" href="#servlet-considerations-csrf-logout"></a>Logging Out</h5>
<div class="paragraph">
<p>It is important to <a href="#csrf-considerations-logout">require CSRF for log out</a> requests to protect against forging log out attempts.
If CSRF protection is enabled (default), Spring Security&#8217;s <code>LogoutFilter</code> to only process HTTP POST.
This ensures that log out requires a CSRF token and that a malicious user cannot forcibly log out your users.</p>
</div>
<div class="paragraph">
<p>The easiest approach is to use a form to log out.
If you really want a link, you can use JavaScript to have the link perform a POST (i.e. maybe on a hidden form).
For browsers with JavaScript that is disabled, you can optionally have the link take the user to a log out confirmation page that will perform the POST.</p>
</div>
<div class="paragraph">
<p>If you really want to use HTTP GET with logout you can do so, but remember this is generally not recommended.
For example, the following Java Configuration will perform logout with the URL <code>/logout</code> is requested with any HTTP method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. Log out with HTTP GET</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.logout(logout -&gt; logout
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            logout {
                logoutRequestMatcher = AntPathRequestMatcher("/logout")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-timeouts"><a class="anchor" href="#servlet-considerations-csrf-timeouts"></a>CSRF and Session Timeouts</h5>
<div class="paragraph">
<p>By default Spring Security stores the CSRF token in the <code>HttpSession</code>.
This can lead to a situation where the session expires which means there is not an expected CSRF token to validate against.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve already discussed <a href="#csrf-considerations-login">general solutions</a> to session timeouts.
This section discusses the specifics of CSRF timeouts as it pertains to the servlet support.</p>
</div>
<div class="paragraph">
<p>It is simple to change storage of the expected CSRF token to be in a cookie.
For details, refer to the <a href="#servlet-csrf-configure-custom-repository">Custom CsrfTokenRepository</a> section.</p>
</div>
<div class="paragraph">
<p>If a token does expire, you might want to customize how it is handled by specifying a custom <code>AccessDeniedHandler</code>.
The custom <code>AccessDeniedHandler</code> can process the <code>InvalidCsrfTokenException</code> any way you like.
For an example of how to customize the <code>AccessDeniedHandler</code> refer to the provided links for both <a href="#nsa-access-denied-handler">xml</a> and <a href="https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/java/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.java#L64">Java configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-considerations-multipart"><a class="anchor" href="#servlet-csrf-considerations-multipart"></a>Multipart (file upload)</h5>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart">already discussed</a> how protecting multipart requests (file uploads) from CSRF attacks causes a <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">chicken and the egg</a> problem.
This section discusses how to implement placing the CSRF token in the <a href="#servlet-csrf-considerations-multipart-body">body</a> and <a href="#servlet-csrf-considerations-multipart-url">url</a> within a servlet application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>More information about using multipart forms with Spring can be found within the <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart">1.1.11. Multipart Resolver</a> section of the Spring reference and the <a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html">MultipartFilter javadoc</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="servlet-csrf-considerations-multipart-body"><a class="anchor" href="#servlet-csrf-considerations-multipart-body"></a>Place CSRF Token in the Body</h6>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart-body">already discussed</a> the tradeoffs of placing the CSRF token in the body.
In this section we will discuss how to configure Spring Security to read the CSRF from the body.</p>
</div>
<div class="paragraph">
<p>In order to read the CSRF token from the body, the <code>MultipartFilter</code> is specified before the Spring Security filter.
Specifying the <code>MultipartFilter</code> before the Spring Security filter means that there is no authorization for invoking the <code>MultipartFilter</code> which means anyone can place temporary files on your server.
However, only authorized users will be able to submit a File that is processed by your application.
In general, this is the recommended approach because the temporary file upload should have a negligible impact on most servers.</p>
</div>
<div class="paragraph">
<p>To ensure <code>MultipartFilter</code> is specified before the Spring Security filter with java configuration, users can override beforeSpringSecurityFilterChain as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. Initializer MultipartFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() {
    override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) {
        insertFilters(servletContext, MultipartFilter())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To ensure <code>MultipartFilter</code> is specified before the Spring Security filter with XML configuration, users can ensure the &lt;filter-mapping&gt; element of the <code>MultipartFilter</code> is placed before the springSecurityFilterChain within the web.xml as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 105. web.xml - MultipartFilter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
	&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.multipart.support.MultipartFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-considerations-multipart-url"><a class="anchor" href="#servlet-csrf-considerations-multipart-url"></a>Include CSRF Token in URL</h6>
<div class="paragraph">
<p>If allowing unauthorized users to upload temporary files is not acceptable, an alternative is to place the <code>MultipartFilter</code> after the Spring Security filter and include the CSRF as a query parameter in the action attribute of the form.
Since the <code>CsrfToken</code> is exposed as an <code>HttpServletRequest</code> <a href="#servlet-csrf-include">request attribute</a>, we can use that to create an <code>action</code> with the CSRF token in it.
An example with a jsp is shown below</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. CSRF Token in Action</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;form method="post"
	action="./upload?${_csrf.parameterName}=${_csrf.token}"
	enctype="multipart/form-data"&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-considerations-override-method"><a class="anchor" href="#servlet-csrf-considerations-override-method"></a>HiddenHttpMethodFilter</h5>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart-body">already discussed</a> the trade-offs of placing the CSRF token in the body.</p>
</div>
<div class="paragraph">
<p>In Spring&#8217;s Servlet support, overriding the HTTP method is done using <a href="https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html">HiddenHttpMethodFilter</a>.
More information can be found in <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-rest-method-conversion">HTTP Method Conversion</a> section of the reference documentation.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-headers"><a class="anchor" href="#servlet-headers"></a>Security HTTP Response Headers</h3>
<div class="paragraph">
<p><a href="#headers">Security HTTP Response Headers</a> can be used to increase the security of web applications.
This section is dedicated to servlet based support for Security HTTP Response Headers.</p>
</div>
<div class="sect3">
<h4 id="servlet-headers-default"><a class="anchor" href="#servlet-headers-default"></a>Default Security Headers</h4>
<div class="paragraph">
<p>Spring Security provides a <a href="#headers-default">default set of Security HTTP Response Headers</a> to provide secure defaults.
While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.</p>
</div>
<div class="paragraph">
<p>You can customize specific headers.
For example, assume that you want the defaults except you wish to specify <code>SAMEORIGIN</code> for <a href="#servlet-headers-frame-options">X-Frame-Options</a>.</p>
</div>
<div class="paragraph">
<p>You can easily do this with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 107. Customize Default Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers -&gt; headers
				.frameOptions(frameOptions -&gt; frameOptions
					.sameOrigin()
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options policy="SAMEORIGIN" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.
An example is provided below:</p>
</div>
<div class="paragraph">
<p>If you are using Spring Security&#8217;s Configuration the following will only add <a href="#headers-cache-control">Cache Control</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 108. Customize Cache Control Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				// do not use any default headers unless explicitly listed
				.defaultsDisabled()
				.cacheControl(withDefaults())
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers defaults-disabled="true"&gt;
		&lt;cache-control/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                // do not use any default headers unless explicitly listed
                defaultsDisabled = true
                cacheControl {
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If necessary, you can disable all of the HTTP Security response headers with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 109. Disable All HTTP Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers.disable());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers disabled="true" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-cache-control"><a class="anchor" href="#servlet-headers-cache-control"></a>Cache Control</h4>
<div class="paragraph">
<p>Spring Security includes <a href="#headers-cache-control">Cache Control</a> headers by default.</p>
</div>
<div class="paragraph">
<p>However, if you actually want to cache specific responses, your application can selectively invoke <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)">HttpServletResponse.setHeader(String,String)</a> to override the header set by Spring Security.
This is useful to ensure things like CSS, JavaScript, and images are properly cached.</p>
</div>
<div class="paragraph">
<p>When using Spring Web MVC, this is typically done within your configuration.
Details on how to do this can be found in the <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">Static Resources</a> portion of the Spring Reference documentation</p>
</div>
<div class="paragraph">
<p>If necessary, you can also disable Spring Security&#8217;s cache control HTTP response headers.</p>
</div>
<div class="exampleblock">
<div class="title">Example 110. Cache Control Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers -&gt; headers
				.cacheControl(cache -&gt; cache.disable())
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;cache-control disabled="true"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            headers {
                cacheControl {
                    disable()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-content-type-options"><a class="anchor" href="#servlet-headers-content-type-options"></a>Content Type Options</h4>
<div class="paragraph">
<p>Spring Security includes <a href="#headers-content-type-options">Content-Type</a> headers by default.
However, you can disable it with:</p>
</div>
<div class="exampleblock">
<div class="title">Example 111. Content Type Options Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers -&gt; headers
				.contentTypeOptions(contentTypeOptions -&gt; contentTypeOptions.disable())
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;content-type-options disabled="true"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            headers {
                contentTypeOptions {
                    disable()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-hsts"><a class="anchor" href="#servlet-headers-hsts"></a>HTTP Strict Transport Security (HSTS)</h4>
<div class="paragraph">
<p>Spring Security provides the <a href="#headers-hsts">Strict Transport Security</a> header by default.
However, you can customize the results explicitly.
For example, the following is an example of explicitly providing HSTS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 112. Strict Transport Security</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.httpStrictTransportSecurity(hsts -&gt; hsts
					.includeSubDomains(true)
					.preload(true)
					.maxAgeInSeconds(31536000)
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;hsts
			include-subdomains="true"
			max-age-seconds="31536000"
			preload="true" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                httpStrictTransportSecurity {
                    includeSubDomains = true
                    preload = true
                    maxAgeInSeconds = 31536000
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-hpkp"><a class="anchor" href="#servlet-headers-hpkp"></a>HTTP Public Key Pinning (HPKP)</h4>
<div class="paragraph">
<p>For passivity reasons, Spring Security provides servlet support for <a href="#headers-hpkp">HTTP Public Key Pinning</a> but it is <a href="#headers-hpkp-deprecated">no longer recommended</a>.</p>
</div>
<div class="paragraph">
<p>You can enable HPKP headers with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 113. HTTP Public Key Pinning</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.httpPublicKeyPinning(hpkp -&gt; hpkp
					.includeSubDomains(true)
					.reportUri("https://example.net/pkp-report")
					.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;hpkp
			include-subdomains="true"
			report-uri="https://example.net/pkp-report"&gt;
			&lt;pins&gt;
				&lt;pin algorithm="sha256"&gt;d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=&lt;/pin&gt;
				&lt;pin algorithm="sha256"&gt;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&lt;/pin&gt;
			&lt;/pins&gt;
		&lt;/hpkp&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                httpPublicKeyPinning {
                    includeSubDomains = true
                    reportUri = "https://example.net/pkp-report"
                    pins = mapOf("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" to "sha256",
                            "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" to "sha256")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-frame-options"><a class="anchor" href="#servlet-headers-frame-options"></a>X-Frame-Options</h4>
<div class="paragraph">
<p>By default, Spring Security disables rendering within an iframe using <a href="#headers-frame-options">X-Frame-Options</a>.</p>
</div>
<div class="paragraph">
<p>You can customize frame options to use the same origin within a Configuration using the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 114. X-Frame-Options: SAMEORIGIN</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.frameOptions(frameOptions -&gt; frameOptions
					.sameOrigin()
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options
		policy="SAMEORIGIN" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-xss-protection"><a class="anchor" href="#servlet-headers-xss-protection"></a>X-XSS-Protection</h4>
<div class="paragraph">
<p>By default, Spring Security instructs browsers to block reflected XSS attacks using the &lt;&lt;headers-xss-protection,X-XSS-Protection header&gt;.
However, you can change this default.
For example, the following Configuration specifies that Spring Security should no longer instruct browsers to block the content:</p>
</div>
<div class="exampleblock">
<div class="title">Example 115. X-XSS-Protection Customization</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.xssProtection(xss -&gt; xss
					.block(false)
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;xss-protection block="false"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        // ...
        http {
            headers {
                xssProtection {
                    block = false
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-csp"><a class="anchor" href="#servlet-headers-csp"></a>Content Security Policy (CSP)</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-csp">Content Security Policy</a> by default, because a reasonable default is impossible to know without context of the application.
The web application author must declare the security policy(s) to enforce and/or monitor for the protected resources.</p>
</div>
<div class="paragraph">
<p>For example, given the following security policy:</p>
</div>
<div class="exampleblock">
<div class="title">Example 116. Content Security Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable the CSP header as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 117. Content Security Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers -&gt; headers
				.contentSecurityPolicy(csp -&gt; csp
					.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To enable the CSP <code>report-only</code> header, provide the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 118. Content Security Policy Report Only</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.contentSecurityPolicy(csp -&gt; csp
					.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
					.reportOnly()
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                    reportOnly = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-referrer"><a class="anchor" href="#servlet-headers-referrer"></a>Referrer Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-referrer">Referrer Policy</a> headers by default.
You can enable the Referrer Policy header using the configuration as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 119. Referrer Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers -&gt; headers
				.referrerPolicy(referrer -&gt; referrer
					.policy(ReferrerPolicy.SAME_ORIGIN)
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;referrer-policy policy="same-origin" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                referrerPolicy {
                    policy = ReferrerPolicy.SAME_ORIGIN
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-feature"><a class="anchor" href="#servlet-headers-feature"></a>Feature Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-feature">Feature Policy</a> headers by default.
The following <code>Feature-Policy</code> header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 120. Feature-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Feature-Policy: geolocation 'self'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>can enable the Feature Policy header using the configuration shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 121. Feature-Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.featurePolicy("geolocation 'self'")
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;feature-policy policy-directives="geolocation 'self'" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                featurePolicy("geolocation 'self'")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-permissions"><a class="anchor" href="#servlet-headers-permissions"></a>Permissions Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-permissions">Permissions Policy</a> headers by default.
The following <code>Permissions-Policy</code> header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 122. Permissions-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Permissions-Policy: geolocation=(self)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>can enable the Permissions Policy header using the configuration shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 123. Permissions-Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.permissionsPolicy(permissions -&gt; permissions
					.policy("geolocation=(self)")
				)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;permissions-policy policy="geolocation=(self)" /&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                permissionPolicy {
                    policy = "geolocation=(self)"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-clear-site-data"><a class="anchor" href="#servlet-headers-clear-site-data"></a>Clear Site Data</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-clear-site-data">Clear-Site-Data</a> headers by default.
The following Clear-Site-Data header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 124. Clear-Site-Data Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Clear-Site-Data: "cache", "cookies"</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>can be sent on log out with the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 125. Clear-Site-Data</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.logout()
				.addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            logout {
                addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(CACHE, COOKIES)))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-custom"><a class="anchor" href="#servlet-headers-custom"></a>Custom Headers</h4>
<div class="paragraph">
<p>Spring Security has mechanisms to make it convenient to add the more common security headers to your application.
However, it also provides hooks to enable adding custom headers.</p>
</div>
<div class="sect4">
<h5 id="servlet-headers-static"><a class="anchor" href="#servlet-headers-static"></a>Static Headers</h5>
<div class="paragraph">
<p>There may be times you wish to inject custom security headers into your application that are not supported out of the box.
For example, given the following custom security header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">X-Custom-Security-Header: header-value</code></pre>
</div>
</div>
<div class="paragraph">
<p>The headers could be added to the response using the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 126. StaticHeadersWriter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"))
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;header name="X-Custom-Security-Header" value="header-value"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                addHeaderWriter(StaticHeadersWriter("X-Custom-Security-Header","header-value"))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-headers-writer"><a class="anchor" href="#servlet-headers-writer"></a>Headers Writer</h5>
<div class="paragraph">
<p>When the namespace or Java configuration does not support the headers you want, you can create a custom <code>HeadersWriter</code> instance or even provide a custom implementation of the <code>HeadersWriter</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at an example of using an custom instance of <code>XFrameOptionsHeaderWriter</code>.
If you wanted to explicitly configure <a href="#servlet-headers-frame-options">X-Frame-Options</a> it could be done with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 127. Headers Writer</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -&gt; headers
				.addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;header ref="frameOptionsWriter"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;
&lt;!-- Requires the c-namespace.
See https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
--&gt;
&lt;beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                addHeaderWriter(XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-delegatingrequestmatcherheaderwriter"><a class="anchor" href="#headers-delegatingrequestmatcherheaderwriter"></a>DelegatingRequestMatcherHeaderWriter</h5>
<div class="paragraph">
<p>At times you may want to only write a header for certain requests.
For example, perhaps you want to only protect your log in page from being framed.
You could use the <code>DelegatingRequestMatcherHeaderWriter</code> to do so.</p>
</div>
<div class="paragraph">
<p>An example of using <code>DelegatingRequestMatcherHeaderWriter</code> in Java Configuration can be seen below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 128. DelegatingRequestMatcherHeaderWriter Java Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		RequestMatcher matcher = new AntPathRequestMatcher("/login");
		DelegatingRequestMatcherHeaderWriter headerWriter =
			new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
		http
			// ...
			.headers(headers -&gt; headers
				.frameOptions(frameOptions -&gt; frameOptions.disable())
				.addHeaderWriter(headerWriter)
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;

	&lt;headers&gt;
		&lt;frame-options disabled="true"/&gt;
		&lt;header ref="headerWriter"/&gt;
	&lt;/headers&gt;
&lt;/http&gt;

&lt;beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter"&gt;
	&lt;beans:constructor-arg&gt;
		&lt;bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/&gt;
	&lt;/beans:constructor-arg&gt;
	&lt;beans:constructor-arg&gt;
		&lt;beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/&gt;
	&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        val matcher: RequestMatcher = AntPathRequestMatcher("/login")
        val headerWriter = DelegatingRequestMatcherHeaderWriter(matcher, XFrameOptionsHeaderWriter())
       http {
            headers {
                frameOptions {
                    disable()
                }
                addHeaderWriter(headerWriter)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-http"><a class="anchor" href="#servlet-http"></a>HTTP</h3>
<div class="paragraph">
<p>All HTTP based communication should be protected <a href="#http">using TLS</a>.</p>
</div>
<div class="paragraph">
<p>Below you can find details around Servlet specific features that assist with HTTPS usage.</p>
</div>
<div class="sect3">
<h4 id="servlet-http-redirect"><a class="anchor" href="#servlet-http-redirect"></a>Redirect to HTTPS</h4>
<div class="paragraph">
<p>If a client makes a request using HTTP rather than HTTPS, Spring Security can be configured to redirect to HTTPS.</p>
</div>
<div class="paragraph">
<p>For example, the following Java configuration will redirect any HTTP requests to HTTPS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 129. Redirect to HTTPS</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.requiresChannel(channel -&gt; channel
				.anyRequest().requiresSecure()
			);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            requiresChannel {
                secure(AnyRequestMatcher.INSTANCE, "REQUIRES_SECURE_CHANNEL")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following XML configuration will redirect all HTTP requests to HTTPS</p>
</div>
<div class="exampleblock">
<div class="title">Example 130. Redirect to HTTPS with XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="ROLE_USER" requires-channel="https"/&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-hsts"><a class="anchor" href="#servlet-hsts"></a>Strict Transport Security</h4>
<div class="paragraph">
<p>Spring Security provides support for <a href="#servlet-headers-hsts">Strict Transport Security</a> and enables it by default.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-http-proxy-server"><a class="anchor" href="#servlet-http-proxy-server"></a>Proxy Server Configuration</h4>
<div class="paragraph">
<p>Spring Security <a href="#http-proxy-server">integrates with proxy servers</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-httpfirewall"><a class="anchor" href="#servlet-httpfirewall"></a>HttpFirewall</h3>
<div class="paragraph">
<p>Spring Security has several areas where patterns you have defined are tested against incoming requests in order to decide how the request should be handled.
This occurs when the <code>FilterChainProxy</code> decides which filter chain a request should be passed through and also when the <code>FilterSecurityInterceptor</code> decides which security constraints apply to a request.
It&#8217;s important to understand what the mechanism is and what URL value is used when testing against the patterns that you define.</p>
</div>
<div class="paragraph">
<p>The Servlet Specification defines several properties for the <code>HttpServletRequest</code> which are accessible via getter methods, and which we might want to match against.
These are the <code>contextPath</code>, <code>servletPath</code>, <code>pathInfo</code> and <code>queryString</code>.
Spring Security is only interested in securing paths within the application, so the <code>contextPath</code> is ignored.
Unfortunately, the servlet spec does not define exactly what the values of <code>servletPath</code> and <code>pathInfo</code> will contain for a particular request URI.
For example, each path segment of a URL may contain parameters, as defined in <a href="https://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>
<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.
The Specification does not clearly state whether these should be included in the <code>servletPath</code> and <code>pathInfo</code> values and the behaviour varies between different servlet containers.
There is a danger that when an application is deployed in a container which does not strip path parameters from these values, an attacker could add them to the requested URL in order to cause a pattern match to succeed or fail unexpectedly.
<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>.
Other variations in the incoming URL are also possible.
For example, it could contain path-traversal sequences (like <code>/../</code>) or multiple forward slashes (<code>//</code>) which could also cause pattern-matches to fail.
Some containers normalize these out before performing the servlet mapping, but others don&#8217;t.
To protect against issues like these, <code>FilterChainProxy</code> uses an <code>HttpFirewall</code> strategy to check and wrap the request.
Un-normalized requests are automatically rejected by default, and path parameters and duplicate slashes are removed for matching purposes.
<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>.
It is therefore essential that a <code>FilterChainProxy</code> is used to manage the security filter chain.
Note that the <code>servletPath</code> and <code>pathInfo</code> values are decoded by the container, so your application should not have any valid paths which contain semi-colons, as these parts will be removed for matching purposes.</p>
</div>
<div class="paragraph">
<p>As mentioned above, the default strategy is to use Ant-style paths for matching and this is likely to be the best choice for most users.
The strategy is implemented in the class <code>AntPathRequestMatcher</code> which uses Spring&#8217;s <code>AntPathMatcher</code> to perform a case-insensitive match of the pattern against the concatenated <code>servletPath</code> and <code>pathInfo</code>, ignoring the <code>queryString</code>.</p>
</div>
<div class="paragraph">
<p>If for some reason, you need a more powerful matching strategy, you can use regular expressions.
The strategy implementation is then <code>RegexRequestMatcher</code>.
See the Javadoc for this class for more information.</p>
</div>
<div class="paragraph">
<p>In practice we recommend that you use method security at your service layer, to control access to your application, and do not rely entirely on the use of security constraints defined at the web-application level.
URLs change and it is difficult to take account of all the possible URLs that an application might support and how requests might be manipulated.
You should try and restrict yourself to using a few simple ant paths which are simple to understand.
Always try to use a "deny-by-default" approach where you have a catch-all wildcard ( /<strong> or </strong>) defined last and denying access.</p>
</div>
<div class="paragraph">
<p>Security defined at the service layer is much more robust and harder to bypass, so you should always take advantage of Spring Security&#8217;s method security options.</p>
</div>
<div class="paragraph">
<p>The <code>HttpFirewall</code> also prevents <a href="https://www.owasp.org/index.php/HTTP_Response_Splitting">HTTP Response Splitting</a> by rejecting new line characters in the HTTP Response headers.</p>
</div>
<div class="paragraph">
<p>By default the <code>StrictHttpFirewall</code> is used.
This implementation rejects requests that appear to be malicious.
If it is too strict for your needs, then you can customize what types of requests are rejected.
However, it is important that you do so knowing that this can open your application up to attacks.
For example, if you wish to leverage Spring MVC&#8217;s Matrix Variables, the following configuration could be used:</p>
</div>
<div class="exampleblock">
<div class="title">Example 131. Allow Matrix Variables</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean id="httpFirewall"
    class="org.springframework.security.web.firewall.StrictHttpFirewall"
    p:allowSemicolon="true"/&gt;

&lt;http-firewall ref="httpFirewall"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>StrictHttpFirewall</code> provides an allowed list of valid HTTP methods that are allowed to protect against <a href="https://www.owasp.org/index.php/Cross_Site_Tracing">Cross Site Tracing (XST)</a> and <a href="https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)">HTTP Verb Tampering</a>.
The default valid methods are "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", and "PUT".
If your application needs to modify the valid methods, you can configure a custom <code>StrictHttpFirewall</code> bean.
For example, the following will only allow HTTP "GET" and "POST" methods:</p>
</div>
<div class="exampleblock">
<div class="title">Example 132. Allow Only GET &amp; POST</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;b:bean id="httpFirewall"
      class="org.springframework.security.web.firewall.StrictHttpFirewall"
      p:allowedHttpMethods="GET,HEAD"/&gt;

&lt;http-firewall ref="httpFirewall"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are using <code>new MockHttpServletRequest()</code> it currently creates an HTTP method as an empty String "".
This is an invalid HTTP method and will be rejected by Spring Security.
You can resolve this by replacing it with <code>new MockHttpServletRequest("GET", "")</code>.
See <a href="https://jira.spring.io/browse/SPR-16851">SPR_16851</a> for an issue requesting to improve this.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you must allow any HTTP method (not recommended), you can use <code>StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)</code>.
This will disable validation of the HTTP method entirely.</p>
</div>
<div id="servlet-httpfirewall-headers-parameters" class="paragraph">
<p><code>StrictHttpFirewall</code> also checks header names and values and parameter names.
It requires that each character have a defined code point and not be a control character.</p>
</div>
<div class="paragraph">
<p>This requirement can be relaxed or adjusted as necessary using the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StrictHttpFirewall#setAllowedHeaderNames(Predicate)</code></p>
</li>
<li>
<p><code>StrictHttpFirewall#setAllowedHeaderValues(Predicate)</code></p>
</li>
<li>
<p><code>StrictHttpFirewall#setAllowedParameterNames(Predicate)</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Also, parameter values can be controlled with <code>setAllowedParameterValues(Predicate)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, to switch off this check, you can wire your <code>StrictHttpFirewall</code> with <code>Predicate</code> s that always return <code>true</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 133. Allow Any Header Name, Header Value, and Parameter Name</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHeaderNames((header) -&gt; true);
    firewall.setAllowedHeaderValues((header) -&gt; true);
    firewall.setAllowedParameterNames((parameter) -&gt; true);
    return firewall;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHeaderNames { true }
    firewall.setAllowedHeaderValues { true }
    firewall.setAllowedParameterNames { true }
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, there might be a specific value that you need to allow.</p>
</div>
<div class="paragraph">
<p>For example, iPhone Xʀ uses a <code>User-Agent</code> that includes a character not in the ISO-8859-1 charset.
Due to this fact, some application servers will parse this value into two separate characters, the latter being an undefined character.</p>
</div>
<div class="paragraph">
<p>You can address this with the <code>setAllowedHeaderValues</code> method, as you can see below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 134. Allow Certain User Agents</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    Pattern allowed = Pattern.compile("[\\p{IsAssigned}&amp;&amp;[^\\p{IsControl}]]*");
    Pattern userAgent = ...;
    firewall.setAllowedHeaderValues((header) -&gt; allowed.matcher(header).matches() || userAgent.matcher(header).matches());
    return firewall;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    val allowed = Pattern.compile("[\\p{IsAssigned}&amp;&amp;[^\\p{IsControl}]]*")
    val userAgent = Pattern.compile(...)
    firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the case of header values, you may instead consider parsing them as UTF-8 at verification time like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 135. Parse Headers As UTF-8</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">firewall.setAllowedHeaderValues((header) -&gt; {
    String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);
    return allowed.matcher(parsed).matches();
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">firewall.setAllowedHeaderValues {
    val parsed = String(header.getBytes(ISO_8859_1), UTF_8)
    return allowed.matcher(parsed).matches()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrations"><a class="anchor" href="#_integrations"></a>Integrations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servletapi"><a class="anchor" href="#servletapi"></a>Servlet API integration</h3>
<div class="paragraph">
<p>This section describes how Spring Security is integrated with the Servlet API.</p>
</div>
<div class="sect3">
<h4 id="servletapi-25"><a class="anchor" href="#servletapi-25"></a>Servlet 2.5+ Integration</h4>
<div class="sect4">
<h5 id="servletapi-remote-user"><a class="anchor" href="#servletapi-remote-user"></a>HttpServletRequest.getRemoteUser()</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest.getRemoteUser()</a> will return the result of <code>SecurityContextHolder.getContext().getAuthentication().getName()</code> which is typically the current username.
This can be useful if you want to display the current username in your application.
Additionally, checking if this is null can be used to indicate if a user has authenticated or is anonymous.
Knowing if the user is authenticated or not can be useful for determining if certain UI elements should be shown or not (i.e. a log out link should only be displayed if the user is authenticated).</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-user-principal"><a class="anchor" href="#servletapi-user-principal"></a>HttpServletRequest.getUserPrincipal()</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest.getUserPrincipal()</a> will return the result of <code>SecurityContextHolder.getContext().getAuthentication()</code>.
This means it is an <code>Authentication</code> which is typically an instance of <code>UsernamePasswordAuthenticationToken</code> when using username and password based authentication.
This can be useful if you need additional information about your user.
For example, you might have created a custom <code>UserDetailsService</code> that returns a custom <code>UserDetails</code> containing a first and last name for your user.
You could obtain this information with the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication auth = httpServletRequest.getUserPrincipal();
// assume integrated custom UserDetails called MyCustomUserDetails
// by default, typically instance of UserDetails
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It should be noted that it is typically bad practice to perform so much logic throughout your application.
Instead, one should centralize it to reduce any coupling of Spring Security and the Servlet API&#8217;s.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-user-in-role"><a class="anchor" href="#servletapi-user-in-role"></a>HttpServletRequest.isUserInRole(String)</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest.isUserInRole(String)</a> will determine if <code>SecurityContextHolder.getContext().getAuthentication().getAuthorities()</code> contains a <code>GrantedAuthority</code> with the role passed into <code>isUserInRole(String)</code>.
Typically users should not pass in the "ROLE_" prefix into this method since it is added automatically.
For example, if you want to determine if the current user has the authority "ROLE_ADMIN", you could use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean isAdmin = httpServletRequest.isUserInRole("ADMIN");</code></pre>
</div>
</div>
<div class="paragraph">
<p>This might be useful to determine if certain UI components should be displayed.
For example, you might display admin links only if the current user is an admin.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-3"><a class="anchor" href="#servletapi-3"></a>Servlet 3+ Integration</h4>
<div class="paragraph">
<p>The following section describes the Servlet 3 methods that Spring Security integrates with.</p>
</div>
<div class="sect4">
<h5 id="servletapi-authenticate"><a class="anchor" href="#servletapi-authenticate"></a>HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a> method can be used to ensure that a user is authenticated.
If they are not authenticated, the configured AuthenticationEntryPoint will be used to request the user to authenticate (i.e. redirect to the login page).</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-login"><a class="anchor" href="#servletapi-login"></a>HttpServletRequest.login(String,String)</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29">HttpServletRequest.login(String,String)</a> method can be used to authenticate the user with the current <code>AuthenticationManager</code>.
For example, the following would attempt to authenticate with the username "user" and password "password":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
httpServletRequest.login("user","password");
} catch(ServletException ex) {
// fail to authenticate
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is not necessary to catch the ServletException if you want Spring Security to process the failed authentication attempt.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-logout"><a class="anchor" href="#servletapi-logout"></a>HttpServletRequest.logout()</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29">HttpServletRequest.logout()</a> method can be used to log the current user out.</p>
</div>
<div class="paragraph">
<p>Typically this means that the SecurityContextHolder will be cleared out, the HttpSession will be invalidated, any "Remember Me" authentication will be cleaned up, etc.
However, the configured LogoutHandler implementations will vary depending on your Spring Security configuration.
It is important to note that after HttpServletRequest.logout() has been invoked, you are still in charge of writing a response out.
Typically this would involve a redirect to the welcome page.</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-start-runnable"><a class="anchor" href="#servletapi-start-runnable"></a>AsyncContext.start(Runnable)</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29">AsyncContext.start(Runnable)</a> method that ensures your credentials will be propagated to the new Thread.
Using Spring Security&#8217;s concurrency support, Spring Security overrides the AsyncContext.start(Runnable) to ensure that the current SecurityContext is used when processing the Runnable.
For example, the following would output the current user&#8217;s Authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final AsyncContext async = httpServletRequest.startAsync();
async.start(new Runnable() {
	public void run() {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		try {
			final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
			asyncResponse.setStatus(HttpServletResponse.SC_OK);
			asyncResponse.getWriter().write(String.valueOf(authentication));
			async.complete();
		} catch(Exception ex) {
			throw new RuntimeException(ex);
		}
	}
});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-async"><a class="anchor" href="#servletapi-async"></a>Async Servlet Support</h5>
<div class="paragraph">
<p>If you are using Java Based configuration, you are ready to go.
If you are using XML configuration, there are a few updates that are necessary.
The first step is to ensure you have updated your web.xml to use at least the 3.0 schema as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
version="3.0"&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next you need to ensure that your springSecurityFilterChain is setup for processing asynchronous requests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.DelegatingFilterProxy
&lt;/filter-class&gt;
&lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it!
Now Spring Security will ensure that your SecurityContext is propagated on asynchronous requests too.</p>
</div>
<div class="paragraph">
<p>So how does it work? If you are not really interested, feel free to skip the remainder of this section, otherwise read on.
Most of this is built into the Servlet specification, but there is a little bit of tweaking that Spring Security does to ensure things work with asynchronous requests properly.
Prior to Spring Security 3.2, the SecurityContext from the SecurityContextHolder was automatically saved as soon as the HttpServletResponse was committed.
This can cause issues in an Async environment.
For example, consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">httpServletRequest.startAsync();
new Thread("AsyncThread") {
	@Override
	public void run() {
		try {
			// Do work
			TimeUnit.SECONDS.sleep(1);

			// Write to and commit the httpServletResponse
			httpServletResponse.getOutputStream().flush();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
}.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The issue is that this Thread is not known to Spring Security, so the SecurityContext is not propagated to it.
This means when we commit the HttpServletResponse there is no SecurityContext.
When Spring Security automatically saved the SecurityContext on committing the HttpServletResponse it would lose our logged in user.</p>
</div>
<div class="paragraph">
<p>Since version 3.2, Spring Security is smart enough to no longer automatically save the SecurityContext on committing the HttpServletResponse as soon as HttpServletRequest.startAsync() is invoked.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-31"><a class="anchor" href="#servletapi-31"></a>Servlet 3.1+ Integration</h4>
<div class="paragraph">
<p>The following section describes the Servlet 3.1 methods that Spring Security integrates with.</p>
</div>
<div class="sect4">
<h5 id="servletapi-change-session-id"><a class="anchor" href="#servletapi-change-session-id"></a>HttpServletRequest#changeSessionId()</h5>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()">HttpServletRequest.changeSessionId()</a> is the default method for protecting against <a href="#ns-session-fixation">Session Fixation</a> attacks in Servlet 3.1 and higher.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data"><a class="anchor" href="#data"></a>Spring Data Integration</h3>
<div class="paragraph">
<p>Spring Security provides Spring Data integration that allows referring to the current user within your queries.
It is not only useful but necessary to include the user in the queries to support paged results since filtering the results afterwards would not scale.</p>
</div>
<div class="sect3">
<h4 id="data-configuration"><a class="anchor" href="#data-configuration"></a>Spring Data &amp; Spring Security Configuration</h4>
<div class="paragraph">
<p>To use this support, add <code>org.springframework.security:spring-security-data</code> dependency and provide a bean of type <code>SecurityEvaluationContextExtension</code>.
In Java Configuration, this would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityEvaluationContextExtension securityEvaluationContextExtension() {
	return new SecurityEvaluationContextExtension();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In XML Configuration, this would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.security.data.repository.query.SecurityEvaluationContextExtension"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="data-query"><a class="anchor" href="#data-query"></a>Security Expressions within @Query</h4>
<div class="paragraph">
<p>Now Spring Security can be used within your queries.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Repository
public interface MessageRepository extends PagingAndSortingRepository&lt;Message,Long&gt; {
	@Query("select m from Message m where m.to.id = ?#{ principal?.id }")
	Page&lt;Message&gt; findInbox(Pageable pageable);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This checks to see if the <code>Authentication.getPrincipal().getId()</code> is equal to the recipient of the <code>Message</code>.
Note that this example assumes you have customized the principal to be an Object that has an id property.
By exposing the <code>SecurityEvaluationContextExtension</code> bean, all of the <a href="#common-expressions">Common Security Expressions</a> are available within the Query.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency"><a class="anchor" href="#concurrency"></a>Concurrency Support</h3>
<div class="paragraph">
<p>In most environments, Security is stored on a per <code>Thread</code> basis.
This means that when work is done on a new <code>Thread</code>, the <code>SecurityContext</code> is lost.
Spring Security provides some infrastructure to help make this much easier for users.
Spring Security provides low level abstractions for working with Spring Security in multi-threaded environments.
In fact, this is what Spring Security builds on to integration with <a href="#servletapi-start-runnable">AsyncContext.start(Runnable)</a> and <a href="#mvc-async">Spring MVC Async Integration</a>.</p>
</div>
<div class="sect3">
<h4 id="_delegatingsecuritycontextrunnable"><a class="anchor" href="#_delegatingsecuritycontextrunnable"></a>DelegatingSecurityContextRunnable</h4>
<div class="paragraph">
<p>One of the most fundamental building blocks within Spring Security&#8217;s concurrency support is the <code>DelegatingSecurityContextRunnable</code>.
It wraps a delegate <code>Runnable</code> in order to initialize the <code>SecurityContextHolder</code> with a specified <code>SecurityContext</code> for the delegate.
It then invokes the delegate Runnable ensuring to clear the <code>SecurityContextHolder</code> afterwards.
The <code>DelegatingSecurityContextRunnable</code> looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void run() {
try {
	SecurityContextHolder.setContext(securityContext);
	delegate.run();
} finally {
	SecurityContextHolder.clearContext();
}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While very simple, it makes it seamless to transfer the SecurityContext from one Thread to another.
This is important since, in most cases, the SecurityContextHolder acts on a per Thread basis.
For example, you might have used Spring Security&#8217;s <a href="#nsa-global-method-security">&lt;global-method-security&gt;</a> support to secure one of your services.
You can now easily transfer the <code>SecurityContext</code> of the current <code>Thread</code> to the <code>Thread</code> that invokes the secured service.
An example of how you might do this can be found below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

SecurityContext context = SecurityContextHolder.getContext();
DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable, context);

new Thread(wrappedRunnable).start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creates a <code>Runnable</code> that will be invoking our secured service.
Notice that it is not aware of Spring Security</p>
</li>
<li>
<p>Obtains the <code>SecurityContext</code> that we wish to use from the <code>SecurityContextHolder</code> and initializes the <code>DelegatingSecurityContextRunnable</code></p>
</li>
<li>
<p>Use the <code>DelegatingSecurityContextRunnable</code> to create a Thread</p>
</li>
<li>
<p>Start the Thread we created</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since it is quite common to create a <code>DelegatingSecurityContextRunnable</code> with the <code>SecurityContext</code> from the <code>SecurityContextHolder</code> there is a shortcut constructor for it.
The following code is the same as the code above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable);

new Thread(wrappedRunnable).start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code we have is simple to use, but it still requires knowledge that we are using Spring Security.
In the next section we will take a look at how we can utilize <code>DelegatingSecurityContextExecutor</code> to hide the fact that we are using Spring Security.</p>
</div>
</div>
<div class="sect3">
<h4 id="_delegatingsecuritycontextexecutor"><a class="anchor" href="#_delegatingsecuritycontextexecutor"></a>DelegatingSecurityContextExecutor</h4>
<div class="paragraph">
<p>In the previous section we found that it was easy to use the <code>DelegatingSecurityContextRunnable</code>, but it was not ideal since we had to be aware of Spring Security in order to use it.
Let&#8217;s take a look at how <code>DelegatingSecurityContextExecutor</code> can shield our code from any knowledge that we are using Spring Security.</p>
</div>
<div class="paragraph">
<p>The design of <code>DelegatingSecurityContextExecutor</code> is very similar to that of <code>DelegatingSecurityContextRunnable</code> except it accepts a delegate <code>Executor</code> instead of a delegate <code>Runnable</code>.
You can see an example of how it might be used below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication =
	new UsernamePasswordAuthenticationToken("user","doesnotmatter", AuthorityUtils.createAuthorityList("ROLE_USER"));
context.setAuthentication(authentication);

SimpleAsyncTaskExecutor delegateExecutor =
	new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor, context);

Runnable originalRunnable = new Runnable() {
public void run() {
	// invoke secured service
}
};

executor.execute(originalRunnable);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creates the <code>SecurityContext</code> to be used for our <code>DelegatingSecurityContextExecutor</code>.
Note that in this example we simply create the <code>SecurityContext</code> by hand.
However, it does not matter where or how we get the <code>SecurityContext</code> (i.e. we could obtain it from the <code>SecurityContextHolder</code> if we wanted).</p>
</li>
<li>
<p>Creates a delegateExecutor that is in charge of executing submitted <code>Runnable</code>s</p>
</li>
<li>
<p>Finally we create a <code>DelegatingSecurityContextExecutor</code> which is in charge of wrapping any Runnable that is passed into the execute method with a <code>DelegatingSecurityContextRunnable</code>.
It then passes the wrapped Runnable to the delegateExecutor.
In this instance, the same <code>SecurityContext</code> will be used for every Runnable submitted to our <code>DelegatingSecurityContextExecutor</code>.
This is nice if we are running background tasks that need to be run by a user with elevated privileges.</p>
</li>
<li>
<p>At this point you may be asking yourself "How does this shield my code of any knowledge of Spring Security?" Instead of creating the <code>SecurityContext</code> and the <code>DelegatingSecurityContextExecutor</code> in our own code, we can inject an already initialized instance of <code>DelegatingSecurityContextExecutor</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor

public void submitRunnable() {
Runnable originalRunnable = new Runnable() {
	public void run() {
	// invoke secured service
	}
};
executor.execute(originalRunnable);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now our code is unaware that the <code>SecurityContext</code> is being propagated to the <code>Thread</code>, then the <code>originalRunnable</code> is run, and then the <code>SecurityContextHolder</code> is cleared out.
In this example, the same user is being used to run each thread.
What if we wanted to use the user from <code>SecurityContextHolder</code> at the time we invoked <code>executor.execute(Runnable)</code> (i.e. the currently logged in user) to process <code>originalRunnable</code>?
This can be done by removing the <code>SecurityContext</code> argument from our <code>DelegatingSecurityContextExecutor</code> constructor.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now anytime <code>executor.execute(Runnable)</code> is executed the <code>SecurityContext</code> is first obtained by the <code>SecurityContextHolder</code> and then that <code>SecurityContext</code> is used to create our <code>DelegatingSecurityContextRunnable</code>.
This means that we are running our <code>Runnable</code> with the same user that was used to invoke the <code>executor.execute(Runnable)</code> code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring_security_concurrency_classes"><a class="anchor" href="#_spring_security_concurrency_classes"></a>Spring Security Concurrency Classes</h4>
<div class="paragraph">
<p>Refer to the Javadoc for additional integrations with both the Java concurrent APIs and the Spring Task abstractions.
They are quite self-explanatory once you understand the previous code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSecurityContextCallable</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextExecutorService</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextRunnable</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextScheduledExecutorService</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextSchedulingTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextAsyncTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextTaskScheduler</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jackson"><a class="anchor" href="#jackson"></a>Jackson Support</h3>
<div class="paragraph">
<p>Spring Security provides Jackson support for persisting Spring Security related classes.
This can improve the performance of serializing Spring Security related classes when working with distributed sessions (i.e. session replication, Spring Session, etc).</p>
</div>
<div class="paragraph">
<p>To use it, register the <code>SecurityJackson2Modules.getModules(ClassLoader)</code> with <code>ObjectMapper</code> (<a href="https://github.com/FasterXML/jackson-databind">jackson-databind</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ObjectMapper mapper = new ObjectMapper();
ClassLoader loader = getClass().getClassLoader();
List&lt;Module&gt; modules = SecurityJackson2Modules.getModules(loader);
mapper.registerModules(modules);

// ... use ObjectMapper as normally ...
SecurityContext context = new SecurityContextImpl();
// ...
String json = mapper.writeValueAsString(context);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following Spring Security modules provide Jackson support:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>spring-security-core (<code>CoreJackson2Module</code>)</p>
</li>
<li>
<p>spring-security-web (<code>WebJackson2Module</code>, <code>WebServletJackson2Module</code>, <code>WebServerJackson2Module</code>)</p>
</li>
<li>
<p><a href="#oauth2client">spring-security-oauth2-client</a> (<code>OAuth2ClientJackson2Module</code>)</p>
</li>
<li>
<p>spring-security-cas (<code>CasJackson2Module</code>)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="localization"><a class="anchor" href="#localization"></a>Localization</h3>
<div class="paragraph">
<p>Spring Security supports localization of exception messages that end users are likely to see.
If your application is designed for English-speaking users, you don&#8217;t need to do anything as by default all Security messages are in English.
If you need to support other locales, everything you need to know is contained in this section.</p>
</div>
<div class="paragraph">
<p>All exception messages can be localized, including messages related to authentication failures and access being denied (authorization failures).
Exceptions and logging messages that are focused on developers or system deplopers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security&#8217;s code.</p>
</div>
<div class="paragraph">
<p>Shipping in the <code>spring-security-core-xx.jar</code> you will find an <code>org.springframework.security</code> package that in turn contains a <code>messages.properties</code> file, as well as localized versions for some common languages.
This should be referred to by your <code>ApplicationContext</code>, as Spring Security classes implement Spring&#8217;s <code>MessageSourceAware</code> interface and expect the message resolver to be dependency injected at application context startup time.
Usually all you need to do is register a bean inside your application context to refer to the messages.
An example is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="messageSource"
	class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
&lt;property name="basename" value="classpath:org/springframework/security/messages"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>messages.properties</code> is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages.
This default file is in English.</p>
</div>
<div class="paragraph">
<p>If you wish to customize the <code>messages.properties</code> file, or support other languages, you should copy the file, rename it accordingly, and register it inside the above bean definition.
There are not a large number of message keys inside this file, so localization should not be considered a major initiative.
If you do perform localization of this file, please consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of <code>messages.properties</code>.</p>
</div>
<div class="paragraph">
<p>Spring Security relies on Spring&#8217;s localization support in order to actually lookup the appropriate message.
In order for this to work, you have to make sure that the locale from the incoming request is stored in Spring&#8217;s <code>org.springframework.context.i18n.LocaleContextHolder</code>.
Spring MVC&#8217;s <code>DispatcherServlet</code> does this for your application automatically, but since Spring Security&#8217;s filters are invoked before this, the <code>LocaleContextHolder</code> needs to be set up to contain the correct <code>Locale</code> before the filters are called.
You can either do this in a filter yourself (which must come before the Spring Security filters in <code>web.xml</code>) or you can use Spring&#8217;s <code>RequestContextFilter</code>.
Please refer to the Spring Framework documentation for further details on using localization with Spring.</p>
</div>
<div class="paragraph">
<p>The "contacts" sample application is set up to use localized messages.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc"><a class="anchor" href="#mvc"></a>Spring MVC Integration</h3>
<div class="paragraph">
<p>Spring Security provides a number of optional integrations with Spring MVC.
This section covers the integration in further detail.</p>
</div>
<div class="sect3">
<h4 id="mvc-enablewebmvcsecurity"><a class="anchor" href="#mvc-enablewebmvcsecurity"></a>@EnableWebMvcSecurity</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring Security 4.0, <code>@EnableWebMvcSecurity</code> is deprecated.
The replacement is <code>@EnableWebSecurity</code> which will determine adding the Spring MVC features based upon the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable Spring Security integration with Spring MVC add the <code>@EnableWebSecurity</code> annotation to your configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides the configuration using Spring MVC&#8217;s <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-customize">WebMvcConfigurer</a>.
This means that if you are using more advanced options, like integrating with <code>WebMvcConfigurationSupport</code> directly, then you will need to manually provide the Spring Security configuration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-requestmatcher"><a class="anchor" href="#mvc-requestmatcher"></a>MvcRequestMatcher</h4>
<div class="paragraph">
<p>Spring Security provides deep integration with how Spring MVC matches on URLs with <code>MvcRequestMatcher</code>.
This is helpful to ensure your Security rules match the logic used to handle your requests.</p>
</div>
<div class="paragraph">
<p>In order to use <code>MvcRequestMatcher</code> you must place the Spring Security Configuration in the same <code>ApplicationContext</code> as your <code>DispatcherServlet</code>.
This is necessary because Spring Security&#8217;s <code>MvcRequestMatcher</code> expects a <code>HandlerMappingIntrospector</code> bean with the name of <code>mvcHandlerMappingIntrospector</code> to be registered by your Spring MVC configuration that is used to perform the matching.</p>
</div>
<div class="paragraph">
<p>For a <code>web.xml</code> this means that you should place your configuration in the <code>DispatcherServlet.xml</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- All Spring Configuration (both MVC and Security) are in /WEB-INF/spring/ --&gt;
&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/spring/*.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;!-- Load from the ContextLoaderListener --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below <code>WebSecurityConfiguration</code> in placed in the <code>DispatcherServlet</code>s <code>ApplicationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SecurityInitializer extends
    AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return null;
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class[] { RootConfiguration.class,
        WebMvcConfiguration.class };
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is always recommended to provide authorization rules by matching on the <code>HttpServletRequest</code> and method security.</p>
</div>
<div class="paragraph">
<p>Providing authorization rules by matching on <code>HttpServletRequest</code> is good because it happens very early in the code path and helps reduce the <a href="https://en.wikipedia.org/wiki/Attack_surface">attack surface</a>.
Method security ensures that if someone has bypassed the web authorization rules, that your application is still secured.
This is what is known as <a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">Defence in Depth</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider a controller that is mapped as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping("/admin")
public String admin() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to restrict access to this controller method to admin users, a developer can provide authorization rules by matching on the <code>HttpServletRequest</code> with the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.antMatchers("/admin").hasRole("ADMIN")
		);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With either configuration, the URL <code>/admin</code> will require the authenticated user to be an admin user.
However, depending on our Spring MVC configuration, the URL <code>/admin.html</code> will also map to our <code>admin()</code> method.
Additionally, depending on our Spring MVC configuration, the URL <code>/admin/</code> will also map to our <code>admin()</code> method.</p>
</div>
<div class="paragraph">
<p>The problem is that our security rule is only protecting <code>/admin</code>.
We could add additional rules for all the permutations of Spring MVC, but this would be quite verbose and tedious.</p>
</div>
<div class="paragraph">
<p>Instead, we can leverage Spring Security&#8217;s <code>MvcRequestMatcher</code>.
The following configuration will protect the same URLs that Spring MVC will match on by using Spring MVC to match on the URL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.mvcMatchers("/admin").hasRole("ADMIN")
		);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http request-matcher="mvc"&gt;
	&lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-authentication-principal"><a class="anchor" href="#mvc-authentication-principal"></a>@AuthenticationPrincipal</h4>
<div class="paragraph">
<p>Spring Security provides <code>AuthenticationPrincipalArgumentResolver</code> which can automatically resolve the current <code>Authentication.getPrincipal()</code> for Spring MVC arguments.
By using <code>@EnableWebSecurity</code> you will automatically have this added to your Spring MVC configuration.
If you use XML based configuration, you must add this yourself.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven&gt;
		&lt;mvc:argument-resolvers&gt;
				&lt;bean class="org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver" /&gt;
		&lt;/mvc:argument-resolvers&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once <code>AuthenticationPrincipalArgumentResolver</code> is properly configured, you can be entirely decoupled from Spring Security in your Spring MVC layer.</p>
</div>
<div class="paragraph">
<p>Consider a situation where a custom <code>UserDetailsService</code> that returns an <code>Object</code> that implements <code>UserDetails</code> and your own <code>CustomUser</code> <code>Object</code>. The <code>CustomUser</code> of the currently authenticated user could be accessed using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser() {
	Authentication authentication =
	SecurityContextHolder.getContext().getAuthentication();
	CustomUser custom = (CustomUser) authentication == null ? null : authentication.getPrincipal();

	// .. find messages for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As of Spring Security 3.2 we can resolve the argument more directly by adding an annotation. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.core.annotation.AuthenticationPrincipal;

// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) {

	// .. find messages for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it may be necessary to transform the principal in some way.
For example, if <code>CustomUser</code> needed to be final it could not be extended.
In this situation the <code>UserDetailsService</code> might returns an <code>Object</code> that implements <code>UserDetails</code> and provides a method named <code>getCustomUser</code> to access <code>CustomUser</code>.
For example, it might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomUserUserDetails extends User {
		// ...
		public CustomUser getCustomUser() {
				return customUser;
		}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could then access the <code>CustomUser</code> using a <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">SpEL expression</a> that uses <code>Authentication.getPrincipal()</code> as the root object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.core.annotation.AuthenticationPrincipal;

// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal(expression = "customUser") CustomUser customUser) {

	// .. find messages for this user and return them ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also refer to Beans in our SpEL expressions.
For example, the following could be used if we were using JPA to manage our Users and we wanted to modify and save a property on the current user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.core.annotation.AuthenticationPrincipal;

// ...

@PutMapping("/users/self")
public ModelAndView updateName(@AuthenticationPrincipal(expression = "@jpaEntityManager.merge(#this)") CustomUser attachedCustomUser,
		@RequestParam String firstName) {

	// change the firstName on an attached instance which will be persisted to the database
	attachedCustomUser.setFirstName(firstName);

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can further remove our dependency on Spring Security by making <code>@AuthenticationPrincipal</code> a meta annotation on our own annotation.
Below we demonstrate how we could do this on an annotation named <code>@CurrentUser</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to realize that in order to remove the dependency on Spring Security, it is the consuming application that would create <code>@CurrentUser</code>.
This step is not strictly required, but assists in isolating your dependency to Spring Security to a more central location.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@AuthenticationPrincipal
public @interface CurrentUser {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that <code>@CurrentUser</code> has been specified, we can use it to signal to resolve our <code>CustomUser</code> of the currently authenticated user.
We have also isolated our dependency on Spring Security to a single file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@CurrentUser CustomUser customUser) {

	// .. find messages for this user and return them ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-async"><a class="anchor" href="#mvc-async"></a>Spring MVC Async Integration</h4>
<div class="paragraph">
<p>Spring Web MVC 3.2+ has excellent support for <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-async">Asynchronous Request Processing</a>.
With no additional configuration, Spring Security will automatically setup the <code>SecurityContext</code> to the <code>Thread</code> that invokes a <code>Callable</code> returned by your controllers.
For example, the following method will automatically have its <code>Callable</code> invoked with the <code>SecurityContext</code> that was available when the <code>Callable</code> was created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping(method=RequestMethod.POST)
public Callable&lt;String&gt; processUpload(final MultipartFile file) {

return new Callable&lt;String&gt;() {
	public Object call() throws Exception {
	// ...
	return "someView";
	}
};
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Associating SecurityContext to Callable&#8217;s</div>
<div class="paragraph">
<p>More technically speaking, Spring Security integrates with <code>WebAsyncManager</code>.
The <code>SecurityContext</code> that is used to process the <code>Callable</code> is the <code>SecurityContext</code> that exists on the <code>SecurityContextHolder</code> at the time <code>startCallableProcessing</code> is invoked.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There is no automatic integration with a <code>DeferredResult</code> that is returned by controllers.
This is because <code>DeferredResult</code> is processed by the users and thus there is no way of automatically integrating with it.
However, you can still use <a href="#concurrency">Concurrency Support</a> to provide transparent integration with Spring Security.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-csrf"><a class="anchor" href="#mvc-csrf"></a>Spring MVC and CSRF Integration</h4>
<div class="sect4">
<h5 id="_automatic_token_inclusion"><a class="anchor" href="#_automatic_token_inclusion"></a>Automatic Token Inclusion</h5>
<div class="paragraph">
<p>Spring Security will automatically <a href="#servlet-csrf-include">include the CSRF Token</a> within forms that use the <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/view.html#view-jsp-formtaglib-formtag">Spring MVC form tag</a>.
For example, the following JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"
	xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:form="http://www.springframework.org/tags/form" version="2.0"&gt;
	&lt;jsp:directive.page language="java" contentType="text/html" /&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;
	&lt;!-- ... --&gt;

	&lt;c:url var="logoutUrl" value="/logout"/&gt;
	&lt;form:form action="${logoutUrl}"
		method="post"&gt;
	&lt;input type="submit"
		value="Log out" /&gt;
	&lt;input type="hidden"
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/&gt;
	&lt;/form:form&gt;

	&lt;!-- ... --&gt;
&lt;/html&gt;
&lt;/jsp:root&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will output HTML that is similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- ... --&gt;

&lt;form action="/context/logout" method="post"&gt;
&lt;input type="submit" value="Log out"/&gt;
&lt;input type="hidden" name="_csrf" value="f81d4fae-7dec-11d0-a765-00a0c91e6bf6"/&gt;
&lt;/form&gt;

&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-csrf-resolver"><a class="anchor" href="#mvc-csrf-resolver"></a>Resolving the CsrfToken</h5>
<div class="paragraph">
<p>Spring Security provides <code>CsrfTokenArgumentResolver</code> which can automatically resolve the current <code>CsrfToken</code> for Spring MVC arguments.
By using <a href="#jc-hello-wsca">@EnableWebSecurity</a> you will automatically have this added to your Spring MVC configuration.
If you use XML based configuration, you must add this yourself.</p>
</div>
<div class="paragraph">
<p>Once <code>CsrfTokenArgumentResolver</code> is properly configured, you can expose the <code>CsrfToken</code> to your static HTML based application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class CsrfController {

	@RequestMapping("/csrf")
	public CsrfToken csrf(CsrfToken token) {
		return token;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to keep the <code>CsrfToken</code> a secret from other domains.
This means if you are using <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">Cross Origin Sharing (CORS)</a>, you should <strong>NOT</strong> expose the <code>CsrfToken</code> to any external domains.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket"><a class="anchor" href="#websocket"></a>WebSocket Security</h3>
<div class="paragraph">
<p>Spring Security 4 added support for securing <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">Spring&#8217;s WebSocket support</a>.
This section describes how to use Spring Security&#8217;s WebSocket support.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Direct JSR-356 Support</div>
<div class="paragraph">
<p>Spring Security does not provide direct JSR-356 support because doing so would provide little value.
This is because the format is unknown, so there is <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol">little Spring can do to secure an unknown format</a>.
Additionally, JSR-356 does not provide a way to intercept messages, so security would be rather invasive.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-configuration"><a class="anchor" href="#websocket-configuration"></a>WebSocket Configuration</h4>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig
      extends AbstractSecurityWebSocketMessageBrokerConfigurer { <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers("/user/**").authenticated() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;websocket-message-broker&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
    <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authentication"><a class="anchor" href="#websocket-authentication"></a>WebSocket Authentication</h4>
<div class="paragraph">
<p>WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made.
This means that the <code>Principal</code> on the <code>HttpServletRequest</code> will be handed off to WebSockets.
If you are using Spring Security, the <code>Principal</code> on the <code>HttpServletRequest</code> is overridden automatically.</p>
</div>
<div class="paragraph">
<p>More concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authorization"><a class="anchor" href="#websocket-authorization"></a>WebSocket Authorization</h4>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() <i class="conum" data-value="1"></i><b>(1)</b>
                .simpSubscribeDestMatchers("/user/queue/errors").permitAll() <i class="conum" data-value="2"></i><b>(2)</b>
                .simpDestMatchers("/app/**").hasRole("USER") <i class="conum" data-value="3"></i><b>(3)</b>
                .simpSubscribeDestMatchers("/user/**", "/topic/friends/*").hasRole("USER") <i class="conum" data-value="4"></i><b>(4)</b>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() <i class="conum" data-value="5"></i><b>(5)</b>
                .anyMessage().denyAll(); <i class="conum" data-value="6"></i><b>(6)</b>

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message without a destination (i.e. anything other than Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other Message is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;websocket-message-broker&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;intercept-message type="CONNECT" access="permitAll" /&gt;
    &lt;intercept-message type="UNSUBSCRIBE" access="permitAll" /&gt;
    &lt;intercept-message type="DISCONNECT" access="permitAll" /&gt;

    &lt;intercept-message pattern="/user/queue/errors" type="SUBSCRIBE" access="permitAll" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;intercept-message pattern="/app/**" access="hasRole('USER')" /&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

    <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
    &lt;intercept-message pattern="/topic/friends/*" access="hasRole('USER')" /&gt;

    <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;intercept-message type="MESSAGE" access="denyAll" /&gt;
    &lt;intercept-message type="SUBSCRIBE" access="denyAll" /&gt;

    &lt;intercept-message pattern="/**" access="denyAll" /&gt; <i class="conum" data-value="6"></i><b>(6)</b>
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message of type CONNECT, UNSUBSCRIBE, or DISCONNECT will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other message with a destination is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes"><a class="anchor" href="#websocket-authorization-notes"></a>WebSocket Authorization Notes</h5>
<div class="paragraph">
<p>In order to properly secure your application it is important to understand Spring&#8217;s WebSocket support.</p>
</div>
<div class="sect5">
<h6 id="websocket-authorization-notes-messagetypes"><a class="anchor" href="#websocket-authorization-notes-messagetypes"></a>WebSocket Authorization on Message Types</h6>
<div class="paragraph">
<p>It is important to understand the distinction between SUBSCRIBE and MESSAGE types of messages and how it works within Spring.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The system can send notifications MESSAGE to all users through a destination of "/topic/system/notifications"</p>
</li>
<li>
<p>Clients can receive notifications by SUBSCRIBE to the "/topic/system/notifications".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While we want clients to be able to SUBSCRIBE to "/topic/system/notifications", we do not want to enable them to send a MESSAGE to that destination.
If we allowed sending a MESSAGE to "/topic/system/notifications", then clients could send a message directly to that endpoint and impersonate the system.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any MESSAGE sent to a destination that starts with the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").</p>
</div>
</div>
<div class="sect5">
<h6 id="websocket-authorization-notes-destinations"><a class="anchor" href="#websocket-authorization-notes-destinations"></a>WebSocket Authorization on Destinations</h6>
<div class="paragraph">
<p>It is also is important to understand how destinations are transformed.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Users can send messages to a specific user by sending a message to the destination of "/app/chat".</p>
</li>
<li>
<p>The application sees the message, ensures that the "from" attribute is specified as the current user (we cannot trust the client).</p>
</li>
<li>
<p>The application then sends the message to the recipient using <code>SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)</code>.</p>
</li>
<li>
<p>The message gets turned into the destination of "/queue/user/messages-&lt;sessionid&gt;"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the application above, we want to allow our client to listen to "/user/queue" which is transformed into "/queue/user/messages-&lt;sessionid&gt;".
However, we do not want the client to be able to listen to "/queue/*" because that would allow the client to see messages for every user.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any SUBSCRIBE sent to a message that starts with the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").
Of course we may provide exceptions to account for things like</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-outbound"><a class="anchor" href="#websocket-authorization-notes-outbound"></a>Outbound Messages</h5>
<div class="paragraph">
<p>Spring contains a section titled <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow">Flow of Messages</a> that describes how messages flow through the system.
It is important to note that Spring Security only secures the <code>clientInboundChannel</code>.
Spring Security does not attempt to secure the <code>clientOutboundChannel</code>.</p>
</div>
<div class="paragraph">
<p>The most important reason for this is performance.
For every message that goes in, there are typically many more that go out.
Instead of securing the outbound messages, we encourage securing the subscription to the endpoints.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin"><a class="anchor" href="#websocket-sameorigin"></a>Enforcing Same Origin Policy</h4>
<div class="paragraph">
<p>It is important to emphasize that the browser does not enforce the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same Origin Policy</a> for WebSocket connections.
This is an extremely important consideration.</p>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-why"><a class="anchor" href="#websocket-sameorigin-why"></a>Why Same Origin?</h5>
<div class="paragraph">
<p>Consider the following scenario.
A user visits bank.com and authenticates to their account.
The same user opens another tab in their browser and visits evil.com.
The Same Origin Policy ensures that evil.com cannot read or write data to bank.com.</p>
</div>
<div class="paragraph">
<p>With WebSockets the Same Origin Policy does not apply.
In fact, unless bank.com explicitly forbids it, evil.com can read and write data on behalf of the user.
This means that anything the user can do over the webSocket (i.e. transfer money), evil.com can do on that users behalf.</p>
</div>
<div class="paragraph">
<p>Since SockJS tries to emulate WebSockets it also bypasses the Same Origin Policy.
This means developers need to explicitly protect their applications from external domains when using SockJS.</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-spring"><a class="anchor" href="#websocket-sameorigin-spring"></a>Spring WebSocket Allowed Origin</h5>
<div class="paragraph">
<p>Fortunately, since Spring 4.1.5 Spring&#8217;s WebSocket and SockJS support restricts access to the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins">current domain</a>.
Spring Security adds an additional layer of protection to provide <a href="https://en.wikipedia.org/wiki/Defense_in_depth_%2528computing%2529">defence in depth</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-csrf"><a class="anchor" href="#websocket-sameorigin-csrf"></a>Adding CSRF to Stomp Headers</h5>
<div class="paragraph">
<p>By default Spring Security requires the <a href="#csrf">CSRF token</a> in any CONNECT message type.
This ensures that only a site that has access to the CSRF token can connect.
Since only the <strong>Same Origin</strong> can access the CSRF token, external domains are not allowed to make a connection.</p>
</div>
<div class="paragraph">
<p>Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers</p>
</div>
<div class="paragraph">
<p>Applications can <a href="#servlet-csrf-include">obtain a CSRF token</a> by accessing the request attribute named _csrf.
For example, the following will allow accessing the <code>CsrfToken</code> in a JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var headerName = "${_csrf.headerName}";
var token = "${_csrf.token}";</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using static HTML, you can expose the <code>CsrfToken</code> on a REST endpoint.
For example, the following would expose the <code>CsrfToken</code> on the URL /csrf</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JavaScript can make a REST call to the endpoint and use the response to populate the headerName and the token.</p>
</div>
<div class="paragraph">
<p>We can now include the token in our Stomp client.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">...
var headers = {};
headers[headerName] = token;
stompClient.connect(headers, function(frame) {
  ...

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-disable"><a class="anchor" href="#websocket-sameorigin-disable"></a>Disable CSRF within WebSockets</h5>
<div class="paragraph">
<p>If you want to allow other domains to access your site, you can disable Spring Security&#8217;s protection.
For example, in Java Configuration you can use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    @Override
    protected boolean sameOriginDisabled() {
        return true;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sockjs"><a class="anchor" href="#websocket-sockjs"></a>Working with SockJS</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback">SockJS</a> provides fallback transports to support older browsers.
When using the fallback options we need to relax a few security constraints to allow SockJS to work with Spring Security.</p>
</div>
<div class="sect4">
<h5 id="websocket-sockjs-sameorigin"><a class="anchor" href="#websocket-sockjs-sameorigin"></a>SockJS &amp; frame-options</h5>
<div class="paragraph">
<p>SockJS may use an <a href="https://github.com/sockjs/sockjs-client/tree/v0.3.4">transport that leverages an iframe</a>.
By default Spring Security will <a href="#headers-frame-options">deny</a> the site from being framed to prevent Clickjacking attacks.
To allow SockJS frame based transports to work, we need to configure Spring Security to allow the same origin to frame the content.</p>
</div>
<div class="paragraph">
<p>You can customize X-Frame-Options with the <a href="#nsa-frame-options">frame-options</a> element.
For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options
          policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can customize frame options to use the same origin within Java Configuration using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
   WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions
                     .sameOrigin()
                )
        );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sockjs-csrf"><a class="anchor" href="#websocket-sockjs-csrf"></a>SockJS &amp; Relaxing CSRF</h5>
<div class="paragraph">
<p>SockJS uses a POST on the CONNECT messages for any HTTP based transport.
Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers as described in <a href="#websocket-sameorigin-csrf">Adding CSRF to Stomp Headers</a>.</p>
</div>
<div class="paragraph">
<p>It also means we need to relax our CSRF protection with the web layer.
Specifically, we want to disable CSRF protection for our connect URLs.
We do NOT want to disable CSRF protection for every URL.
Otherwise our site will be vulnerable to CSRF attacks.</p>
</div>
<div class="paragraph">
<p>We can easily achieve this by providing a CSRF RequestMatcher.
Our Java Configuration makes this extremely easy.
For example, if our stomp endpoint is "/chat" we can disable CSRF protection for only URLs that start with "/chat/" using the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig
    extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -&gt; csrf
                // ignore our stomp endpoints since they are protected using Stomp headers
                .ignoringAntMatchers("/chat/**")
            )
            .headers(headers -&gt; headers
                // allow same origin to frame our site to support iframe SockJS
                .frameOptions(frameOptions -&gt; frameOptions
                    .sameOrigin()
                )
            )
            .authorizeRequests(authorize -&gt; authorize
                ...
            )
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are using XML based configuration, we can use the <a href="#nsa-csrf-request-matcher-ref">csrf@request-matcher-ref</a>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http ...&gt;
    &lt;csrf request-matcher-ref="csrfMatcher"/&gt;

    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;

    ...
&lt;/http&gt;

&lt;b:bean id="csrfMatcher"
    class="AndRequestMatcher"&gt;
    &lt;b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/&gt;
    &lt;b:constructor-arg&gt;
        &lt;b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher"&gt;
          &lt;b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"&gt;
            &lt;b:constructor-arg value="/chat/**"/&gt;
          &lt;/b:bean&gt;
        &lt;/b:bean&gt;
    &lt;/b:constructor-arg&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cors"><a class="anchor" href="#cors"></a>CORS</h3>
<div class="paragraph">
<p>Spring Framework provides <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors">first class support for CORS</a>.
CORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the <code>JSESSIONID</code>).
If the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it.</p>
</div>
<div class="paragraph">
<p>The easiest way to ensure that CORS is handled first is to use the <code>CorsFilter</code>.
Users can integrate the <code>CorsFilter</code> with Spring Security by providing a <code>CorsConfigurationSource</code> using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// by default uses a Bean by the name of corsConfigurationSource
			.cors(withDefaults())
			...
	}

	@Bean
	CorsConfigurationSource corsConfigurationSource() {
		CorsConfiguration configuration = new CorsConfiguration();
		configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
		configuration.setAllowedMethods(Arrays.asList("GET","POST"));
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", configuration);
		return source;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;cors configuration-source-ref="corsSource"/&gt;
	...
&lt;/http&gt;
&lt;b:bean id="corsSource" class="org.springframework.web.cors.UrlBasedCorsConfigurationSource"&gt;
	...
&lt;/b:bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using Spring MVC&#8217;s CORS support, you can omit specifying the <code>CorsConfigurationSource</code> and Spring Security will leverage the CORS configuration provided to Spring MVC.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// if Spring MVC is on classpath and no CorsConfigurationSource is provided,
			// Spring Security will use CORS configuration provided to Spring MVC
			.cors(withDefaults())
			...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- Default to Spring MVC's CORS configuration --&gt;
	&lt;cors /&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="taglibs"><a class="anchor" href="#taglibs"></a>JSP Tag Libraries</h3>
<div class="paragraph">
<p>Spring Security has its own taglib which provides basic support for accessing security information and applying security constraints in JSPs.</p>
</div>
<div class="sect3">
<h4 id="_declaring_the_taglib"><a class="anchor" href="#_declaring_the_taglib"></a>Declaring the Taglib</h4>
<div class="paragraph">
<p>To use any of the tags, you must have the security taglib declared in your JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-authorize"><a class="anchor" href="#taglibs-authorize"></a>The authorize Tag</h4>
<div class="paragraph">
<p>This tag is used to determine whether its contents should be evaluated or not.
In Spring Security 3.0, it can be used in two ways <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>.
The first approach uses a <a href="#el-access-web">web-security expression</a>, specified in the <code>access</code> attribute of the tag.
The expression evaluation will be delegated to the <code>SecurityExpressionHandler&lt;FilterInvocation&gt;</code> defined in the application context (you should have web expressions enabled in your <code>&lt;http&gt;</code> namespace configuration to make sure this service is available).
So, for example, you might have</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:authorize access="hasRole('supervisor')"&gt;

This content will only be visible to users who have the "supervisor" authority in their list of &lt;tt&gt;GrantedAuthority&lt;/tt&gt;s.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used in conjunction with Spring Security&#8217;s PermissionEvaluator, the tag can also be used to check permissions.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:authorize access="hasPermission(#domain,'read') or hasPermission(#domain,'write')"&gt;

This content will only be visible to users who have read or write permission to the Object found as a request attribute named "domain".

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A common requirement is to only show a particular link, if the user is actually allowed to click it.
How can we determine in advance whether something will be allowed? This tag can also operate in an alternative mode which allows you to define a particular URL as an attribute.
If the user is allowed to invoke that URL, then the tag body will be evaluated, otherwise it will be skipped.
So you might have something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:authorize url="/admin"&gt;

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use this tag there must also be an instance of <code>WebInvocationPrivilegeEvaluator</code> in your application context.
If you are using the namespace, one will automatically be registered.
This is an instance of <code>DefaultWebInvocationPrivilegeEvaluator</code>, which creates a dummy web request for the supplied URL and invokes the security interceptor to see whether the request would succeed or fail.
This allows you to delegate to the access-control setup you defined using <code>intercept-url</code> declarations within the <code>&lt;http&gt;</code> namespace configuration and saves having to duplicate the information (such as the required roles) within your JSPs.
This approach can also be combined with a <code>method</code> attribute, supplying the HTTP method, for a more specific match.</p>
</div>
<div class="paragraph">
<p>The Boolean result of evaluating the tag (whether it grants or denies access) can be stored in a page context scope variable by setting the <code>var</code> attribute to the variable name, avoiding the need for duplicating and re-evaluating the condition at other points in the page.</p>
</div>
<div class="sect4">
<h5 id="_disabling_tag_authorization_for_testing"><a class="anchor" href="#_disabling_tag_authorization_for_testing"></a>Disabling Tag Authorization for Testing</h5>
<div class="paragraph">
<p>Hiding a link in a page for unauthorized users doesn&#8217;t prevent them from accessing the URL.
They could just type it into their browser directly, for example.
As part of your testing process, you may want to reveal the hidden areas in order to check that links really are secured at the back end.
If you set the system property <code>spring.security.disableUISecurity</code> to <code>true</code>, the <code>authorize</code> tag will still run but will not hide its contents.
By default it will also surround the content with <code>&lt;span class="securityHiddenUI"&gt;&#8230;&#8203;&lt;/span&gt;</code> tags.
This allows you to display "hidden" content with a particular CSS style such as a different background colour.
Try running the "tutorial" sample application with this property enabled, for example.</p>
</div>
<div class="paragraph">
<p>You can also set the properties <code>spring.security.securedUIPrefix</code> and <code>spring.security.securedUISuffix</code> if you want to change surrounding text from the default <code>span</code> tags (or use empty strings to remove it completely).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_authentication_tag"><a class="anchor" href="#_the_authentication_tag"></a>The authentication Tag</h4>
<div class="paragraph">
<p>This tag allows access to the current <code>Authentication</code> object stored in the security context.
It renders a property of the object directly in the JSP.
So, for example, if the <code>principal</code> property of the <code>Authentication</code> is an instance of Spring Security&#8217;s <code>UserDetails</code> object, then using <code>&lt;sec:authentication property="principal.username" /&gt;</code> will render the name of the current user.</p>
</div>
<div class="paragraph">
<p>Of course, it isn&#8217;t necessary to use JSP tags for this kind of thing and some people prefer to keep as little logic as possible in the view.
You can access the <code>Authentication</code> object in your MVC controller (by calling <code>SecurityContextHolder.getContext().getAuthentication()</code>) and add the data directly to your model for rendering by the view.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_accesscontrollist_tag"><a class="anchor" href="#_the_accesscontrollist_tag"></a>The accesscontrollist Tag</h4>
<div class="paragraph">
<p>This tag is only valid when used with Spring Security&#8217;s ACL module.
It checks a comma-separated list of required permissions for a specified domain object.
If the current user has all of those permissions, then the tag body will be evaluated.
If they don&#8217;t, it will be skipped.
An example might be</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
In general this tag should be considered deprecated.
Instead use the <a href="#taglibs-authorize">The authorize Tag</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:accesscontrollist hasPermission="1,2" domainObject="${someObject}"&gt;

This will be shown if the user has all of the permissions represented by the values "1" or "2" on the given object.

&lt;/sec:accesscontrollist&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The permissions are passed to the <code>PermissionFactory</code> defined in the application context, converting them to ACL <code>Permission</code> instances, so they may be any format which is supported by the factory - they don&#8217;t have to be integers, they could be strings like <code>READ</code> or <code>WRITE</code>.
If no <code>PermissionFactory</code> is found, an instance of <code>DefaultPermissionFactory</code> will be used.
The <code>AclService</code> from the application context will be used to load the <code>Acl</code> instance for the supplied object.
The <code>Acl</code> will be invoked with the required permissions to check if all of them are granted.</p>
</div>
<div class="paragraph">
<p>This tag also supports the <code>var</code> attribute, in the same way as the <code>authorize</code> tag.</p>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-csrfinput"><a class="anchor" href="#taglibs-csrfinput"></a>The csrfInput Tag</h4>
<div class="paragraph">
<p>If CSRF protection is enabled, this tag inserts a hidden form field with the correct name and value for the CSRF protection token.
If CSRF protection is not enabled, this tag outputs nothing.</p>
</div>
<div class="paragraph">
<p>Normally Spring Security automatically inserts a CSRF form field for any <code>&lt;form:form&gt;</code> tags you use, but if for some reason you cannot use <code>&lt;form:form&gt;</code>, <code>csrfInput</code> is a handy replacement.</p>
</div>
<div class="paragraph">
<p>You should place this tag within an HTML <code>&lt;form&gt;&lt;/form&gt;</code> block, where you would normally place other input fields.
Do NOT place this tag within a Spring <code>&lt;form:form&gt;&lt;/form:form&gt;</code> block.
Spring Security handles Spring forms automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">	&lt;form method="post" action="/do/something"&gt;
		&lt;sec:csrfInput /&gt;
		Name:&lt;br /&gt;
		&lt;input type="text" name="name" /&gt;
		...
	&lt;/form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-csrfmeta"><a class="anchor" href="#taglibs-csrfmeta"></a>The csrfMetaTags Tag</h4>
<div class="paragraph">
<p>If CSRF protection is enabled, this tag inserts meta tags containing the CSRF protection token form field and header names and CSRF protection token value.
These meta tags are useful for employing CSRF protection within JavaScript in your applications.</p>
</div>
<div class="paragraph">
<p>You should place <code>csrfMetaTags</code> within an HTML <code>&lt;head&gt;&lt;/head&gt;</code> block, where you would normally place other meta tags.
Once you use this tag, you can access the form field name, header name, and token value easily using JavaScript.
JQuery is used in this example to make the task easier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt;
		&lt;meta name="description" content="This is the description for this page" /&gt;
		&lt;sec:csrfMetaTags /&gt;
		&lt;script type="text/javascript" language="javascript"&gt;

			var csrfParameter = $("meta[name='_csrf_parameter']").attr("content");
			var csrfHeader = $("meta[name='_csrf_header']").attr("content");
			var csrfToken = $("meta[name='_csrf']").attr("content");

			// using XMLHttpRequest directly to send an x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "https://www.example.org/do/something", true);
			ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded data");
			ajax.send(csrfParameter + "=" + csrfToken + "&amp;name=John&amp;...");

			// using XMLHttpRequest directly to send a non-x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "https://www.example.org/do/something", true);
			ajax.setRequestHeader(csrfHeader, csrfToken);
			ajax.send("...");

			// using JQuery to send an x-www-form-urlencoded request
			var data = {};
			data[csrfParameter] = csrfToken;
			data["name"] = "John";
			...
			$.ajax({
				url: "https://www.example.org/do/something",
				type: "POST",
				data: data,
				...
			});

			// using JQuery to send a non-x-www-form-urlencoded request
			var headers = {};
			headers[csrfHeader] = csrfToken;
			$.ajax({
				url: "https://www.example.org/do/something",
				type: "POST",
				headers: headers,
				...
			});

		&lt;script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		...
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If CSRF protection is not enabled, <code>csrfMetaTags</code> outputs nothing.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc"><a class="anchor" href="#jc"></a>Java Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>General support for <a href="https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java">Java Configuration</a> was added to Spring Framework in Spring 3.1.
Since Spring Security 3.2 there has been Spring Security Java Configuration support which enables users to easily configure Spring Security without the use of any XML.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the <a href="#ns-config">Security Namespace Configuration</a> then you should find quite a few similarities between it and the Security Java Configuration support.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration">lots of sample applications</a> which demonstrate the use of Spring Security Java Configuration.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_hello_web_security_java_configuration"><a class="anchor" href="#_hello_web_security_java_configuration"></a>Hello Web Security Java Configuration</h3>
<div class="paragraph">
<p>The first step is to create our Spring Security Java Configuration.
The configuration creates a Servlet Filter known as the <code>springSecurityFilterChain</code> which is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, etc) within your application.
You can find the most basic example of a Spring Security Java Configuration below:</p>
</div>
<div id="jc-hello-wsca" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public UserDetailsService userDetailsService() {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
		return manager;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There really isn&#8217;t much to this configuration, but it does a lot.
You can find a summary of the features below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Require authentication to every URL in your application</p>
</li>
<li>
<p>Generate a login form for you</p>
</li>
<li>
<p>Allow the user with the <strong>Username</strong> <em>user</em> and the <strong>Password</strong> <em>password</em> to authenticate with form based authentication</p>
</li>
<li>
<p>Allow the user to logout</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF attack</a> prevention</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session Fixation</a> protection</p>
</li>
<li>
<p>Security Header integration</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a> for secure requests</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> integration</p>
</li>
<li>
<p>Cache Control (can be overridden later by your application to allow caching of your static resources)</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> integration</p>
</li>
<li>
<p>X-Frame-Options integration to help prevent <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Integrate with the following Servlet API methods</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest#getRemoteUser()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest#getUserPrincipal()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest#isUserInRole(java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)">HttpServletRequest#login(java.lang.String, java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()">HttpServletRequest#logout()</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer"></a>AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>The next step is to register the <code>springSecurityFilterChain</code> with the war.
This can be done in Java Configuration with <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config">Spring&#8217;s WebApplicationInitializer support</a> in a Servlet 3.0+ environment.
Not suprisingly, Spring Security provides a base class <code>AbstractSecurityWebApplicationInitializer</code> that will ensure the <code>springSecurityFilterChain</code> gets registered for you.
The way in which we use <code>AbstractSecurityWebApplicationInitializer</code> differs depending on if we are already using Spring or if Spring Security is the only Spring component in our application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-without-existing-spring">[abstractsecuritywebapplicationinitializer-without-existing-spring]</a> - Use these instructions if you are not using Spring already</p>
</li>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-with-spring-mvc">[abstractsecuritywebapplicationinitializer-with-spring-mvc]</a> - Use these instructions if you are already using Spring</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer_without_existing_spring"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer_without_existing_spring"></a>AbstractSecurityWebApplicationInitializer without Existing Spring</h4>
<div class="paragraph">
<p>If you are not using Spring or Spring MVC, you will need to pass in the <code>WebSecurityConfig</code> into the superclass to ensure the configuration is picked up.
You can find an example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SecurityWebApplicationInitializer</code> will do the following things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Automatically register the springSecurityFilterChain Filter for every URL in your application</p>
</li>
<li>
<p>Add a ContextLoaderListener that loads the <a href="#jc-hello-wsca">WebSecurityConfig</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_abstractsecuritywebapplicationinitializer_with_spring_mvc"><a class="anchor" href="#_abstractsecuritywebapplicationinitializer_with_spring_mvc"></a>AbstractSecurityWebApplicationInitializer with Spring MVC</h4>
<div class="paragraph">
<p>If we were using Spring elsewhere in our application we probably already had a <code>WebApplicationInitializer</code> that is loading our Spring Configuration.
If we use the previous configuration we would get an error.
Instead, we should register Spring Security with the existing <code>ApplicationContext</code>.
For example, if we were using Spring MVC our <code>SecurityWebApplicationInitializer</code> would look something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would simply only register the springSecurityFilterChain Filter for every URL in your application.
After that we would ensure that <code>WebSecurityConfig</code> was loaded in our existing ApplicationInitializer.
For example, if we were using Spring MVC it would be added in the <code>getRootConfigClasses()</code></p>
</div>
<div id="message-web-application-inititializer-java" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... other overrides ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-httpsecurity"><a class="anchor" href="#jc-httpsecurity"></a>HttpSecurity</h3>
<div class="paragraph">
<p>Thus far our <a href="#jc-hello-wsca">WebSecurityConfig</a> only contains information about how to authenticate our users.
How does Spring Security know that we want to require all users to be authenticated?
How does Spring Security know we want to support form based authentication?
Actually, there is a configuration class that is being invoked behind the scenes called <code>WebSecurityConfigurerAdapter</code>.
It has a method called <code>configure</code> with the following default implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
		)
		.formLogin(withDefaults())
		.httpBasic(withDefaults());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures that any request to our application requires the user to be authenticated</p>
</li>
<li>
<p>Allows users to authenticate with form based login</p>
</li>
<li>
<p>Allows users to authenticate with HTTP Basic authentication</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will notice that this configuration is quite similar the XML Namespace configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;form-login /&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_httpsecurity"><a class="anchor" href="#_multiple_httpsecurity"></a>Multiple HttpSecurity</h3>
<div class="paragraph">
<p>We can configure multiple HttpSecurity instances just as we can have multiple <code>&lt;http&gt;</code> blocks.
The key is to extend the <code>WebSecurityConfigurerAdapter</code> multiple times.
For example, the following is an example of having a different configuration for URL&#8217;s that start with <code>/api/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class MultiHttpSecurityConfig {
	@Bean                                                             <i class="conum" data-value="1"></i><b>(1)</b>
	public UserDetailsService userDetailsService() throws Exception {
		// ensure the passwords are encoded properly
		UserBuilder users = User.withDefaultPasswordEncoder();
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(users.username("user").password("password").roles("USER").build());
		manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
		return manager;
	}

	@Configuration
	@Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
		protected void configure(HttpSecurity http) throws Exception {
			http
				.antMatcher("/api/**")                               <i class="conum" data-value="3"></i><b>(3)</b>
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().hasRole("ADMIN")
			    )
				.httpBasic(withDefaults());
		}
	}

	@Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests(authorize -&gt; authorize
					.anyRequest().authenticated()
				)
				.formLogin(withDefaults());
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure Authentication as normal</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create an instance of <code>WebSecurityConfigurerAdapter</code> that contains <code>@Order</code> to specify which <code>WebSecurityConfigurerAdapter</code> should be considered first.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>http.antMatcher</code> states that this <code>HttpSecurity</code> will only be applicable to URLs that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>WebSecurityConfigurerAdapter</code>.
If the URL does not start with <code>/api/</code> this configuration will be used.
This configuration is considered after <code>ApiWebSecurityConfigurationAdapter</code> since it has an <code>@Order</code> value after <code>1</code> (no <code>@Order</code> defaults to last).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jc-custom-dsls"><a class="anchor" href="#jc-custom-dsls"></a>Custom DSLs</h3>
<div class="paragraph">
<p>You can provide your own custom DSLs in Spring Security.
For example, you might have something that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyCustomDsl extends AbstractHttpConfigurer&lt;MyCustomDsl, HttpSecurity&gt; {
	private boolean flag;

	@Override
	public void init(HttpSecurity http) throws Exception {
		// any method that adds another configurer
		// must be done in the init method
		http.csrf().disable();
	}

	@Override
	public void configure(HttpSecurity http) throws Exception {
		ApplicationContext context = http.getSharedObject(ApplicationContext.class);

		// here we lookup from the ApplicationContext. You can also just create a new instance.
		MyFilter myFilter = context.getBean(MyFilter.class);
		myFilter.setFlag(flag);
		http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
	}

	public MyCustomDsl flag(boolean value) {
		this.flag = value;
		return this;
	}

	public static MyCustomDsl customDsl() {
		return new MyCustomDsl();
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is actually how methods like <code>HttpSecurity.authorizeRequests()</code> are implemented.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The custom DSL can then be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl())
				.flag(true)
				.and()
			...;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is invoked in the following order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Code in `Config`s configure method is invoked</p>
</li>
<li>
<p>Code in `MyCustomDsl`s init method is invoked</p>
</li>
<li>
<p>Code in `MyCustomDsl`s configure method is invoked</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want, you can have <code>WebSecurityConfigurerAdapter</code> add <code>MyCustomDsl</code> by default by using <code>SpringFactories</code>.
For example, you would create a resource on the classpath named <code>META-INF/spring.factories</code> with the following contents:</p>
</div>
<div class="listingblock">
<div class="title">META-INF/spring.factories</div>
<div class="content">
<pre>org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl</pre>
</div>
</div>
<div class="paragraph">
<p>Users wishing to disable the default can do so explicitly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl()).disable()
			...;
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="post-processing-configured-objects"><a class="anchor" href="#post-processing-configured-objects"></a>Post Processing Configured Objects</h3>
<div class="paragraph">
<p>Spring Security&#8217;s Java Configuration does not expose every property of every object that it configures.
This simplifies the configuration for a majority of users.
Afterall, if every property was exposed, users could use standard bean configuration.</p>
</div>
<div class="paragraph">
<p>While there are good reasons to not directly expose every property, users may still need more advanced configuration options.
To address this Spring Security introduces the concept of an <code>ObjectPostProcessor</code> which can be used to modify or replace many of the Object instances created by the Java Configuration.
For example, if you wanted to configure the <code>filterSecurityPublishAuthorizationSuccess</code> property on <code>FilterSecurityInterceptor</code> you could use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
				public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
						O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			})
		);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin-config"><a class="anchor" href="#kotlin-config"></a>Kotlin Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security Kotlin Configuration support has been available since Spring Security 5.3.
It enables users to easily configure Spring Security using a native Kotlin DSL.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security provides <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/kotlin/hello-security">a sample application</a> which demonstrates the use of Spring Security Kotlin Configuration.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="kotlin-config-httpsecurity"><a class="anchor" href="#kotlin-config-httpsecurity"></a>HttpSecurity</h3>
<div class="paragraph">
<p>How does Spring Security know that we want to require all users to be authenticated?
How does Spring Security know we want to support form based authentication?
There is a configuration class that is being invoked behind the scenes called <code>WebSecurityConfigurerAdapter</code>.
It has a method called <code>configure</code> with the following default implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
       formLogin { }
       httpBasic { }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures that any request to our application requires the user to be authenticated</p>
</li>
<li>
<p>Allows users to authenticate with form based login</p>
</li>
<li>
<p>Allows users to authenticate with HTTP Basic authentication</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will notice that this configuration is quite similar the XML Namespace configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
	&lt;form-login /&gt;
	&lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_httpsecurity_2"><a class="anchor" href="#_multiple_httpsecurity_2"></a>Multiple HttpSecurity</h3>
<div class="paragraph">
<p>We can configure multiple HttpSecurity instances just as we can have multiple <code>&lt;http&gt;</code> blocks.
The key is to extend the <code>WebSecurityConfigurerAdapter</code> multiple times.
For example, the following is an example of having a different configuration for URL&#8217;s that start with <code>/api/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebSecurity
class MultiHttpSecurityConfig {
    @Bean                                                            <i class="conum" data-value="1"></i><b>(1)</b>
    public fun userDetailsService(): UserDetailsService {
        val users: User.UserBuilder = User.withDefaultPasswordEncoder()
        val manager = InMemoryUserDetailsManager()
        manager.createUser(users.username("user").password("password").roles("USER").build())
        manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build())
        return manager
    }

    @Configuration
    @Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
    class ApiWebSecurityConfigurationAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                securityMatcher("/api/**")                           <i class="conum" data-value="3"></i><b>(3)</b>
                authorizeRequests {
                    authorize(anyRequest, hasRole("ADMIN"))
                }
                httpBasic { }
            }
        }
    }

    @Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
    class FormLoginWebSecurityConfigurerAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                formLogin { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure Authentication as normal</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create an instance of <code>WebSecurityConfigurerAdapter</code> that contains <code>@Order</code> to specify which <code>WebSecurityConfigurerAdapter</code> should be considered first.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>http.antMatcher</code> states that this <code>HttpSecurity</code> will only be applicable to URLs that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>WebSecurityConfigurerAdapter</code>.
If the URL does not start with <code>/api/</code> this configuration will be used.
This configuration is considered after <code>ApiWebSecurityConfigurationAdapter</code> since it has an <code>@Order</code> value after <code>1</code> (no <code>@Order</code> defaults to last).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ns-config"><a class="anchor" href="#ns-config"></a>Security Namespace Configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h3>
<div class="paragraph">
<p>Namespace configuration has been available since version 2.0 of the Spring Framework.
It allows you to supplement the traditional Spring beans application context syntax with elements from additional XML schema.
You can find more information in the Spring <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Reference Documentation</a>.
A namespace element can be used simply to allow a more concise way of configuring an individual bean or, more powerfully, to define an alternative configuration syntax which more closely matches the problem domain and hides the underlying complexity from the user.
A simple element may conceal the fact that multiple beans and processing steps are being added to the application context.
For example, adding the following element from the security namespace to an application context will start up an embedded LDAP server for testing use within the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:ldap-server /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is much simpler than wiring up the equivalent Apache Directory Server beans.
The most common alternative configuration requirements are supported by attributes on the <code>ldap-server</code> element and the user is isolated from worrying about which beans they need to create and what the bean property names are.
<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>.
Use of a good XML editor while editing the application context file should provide information on the attributes and elements that are available.
We would recommend that you try out the <a href="https://spring.io/tools/sts">Spring Tool Suite</a> as it has special features for working with standard Spring namespaces.</p>
</div>
<div class="paragraph">
<p>To start using the security namespace in your application context, you need to have the <code>spring-security-config</code> jar on your classpath.
Then all you need to do is add the schema declaration to your application context file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		https://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In many of the examples you will see (and in the sample applications), we will often use "security" as the default namespace rather than "beans", which means we can omit the prefix on all the security namespace elements, making the content easier to read.
You may also want to do this if you have your application context divided up into separate files and have most of your security configuration in one of them.
Your security application context file would then start like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		https://www.springframework.org/schema/security/spring-security.xsd"&gt;
	...
&lt;/beans:beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll assume this syntax is being used from now on in this chapter.</p>
</div>
<div class="sect3">
<h4 id="_design_of_the_namespace"><a class="anchor" href="#_design_of_the_namespace"></a>Design of the Namespace</h4>
<div class="paragraph">
<p>The namespace is designed to capture the most common uses of the framework and provide a simplified and concise syntax for enabling them within an application.
The design is based around the large-scale dependencies within the framework, and can be divided up into the following areas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Web/HTTP Security</em> - the most complex part.
Sets up the filters and related service beans used to apply the framework authentication mechanisms, to secure URLs, render login and error pages and much more.</p>
</li>
<li>
<p><em>Business Object (Method) Security</em> - options for securing the service layer.</p>
</li>
<li>
<p><em>AuthenticationManager</em> - handles authentication requests from other parts of the framework.</p>
</li>
<li>
<p><em>AccessDecisionManager</em> - provides access decisions for web and method security.
A default one will be registered, but you can also choose to use a custom one, declared using normal Spring bean syntax.</p>
</li>
<li>
<p><em>AuthenticationProvider</em>s - mechanisms against which the authentication manager authenticates users.
The namespace provides supports for several standard options and also a means of adding custom beans declared using a traditional syntax.</p>
</li>
<li>
<p><em>UserDetailsService</em> - closely related to authentication providers, but often also required by other beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ll see how to configure these in the following sections.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-getting-started"><a class="anchor" href="#ns-getting-started"></a>Getting Started with Security Namespace Configuration</h3>
<div class="paragraph">
<p>In this section, we&#8217;ll look at how you can build up a namespace configuration to use some of the main features of the framework.
Let&#8217;s assume you initially want to get up and running as quickly as possible and add authentication support and access control to an existing web application, with a few test logins.
Then we&#8217;ll look at how to change over to authenticating against a database or other security repository.
In later sections we&#8217;ll introduce more advanced namespace configuration options.</p>
</div>
<div class="sect3">
<h4 id="ns-web-xml"><a class="anchor" href="#ns-web-xml"></a>web.xml Configuration</h4>
<div class="paragraph">
<p>The first thing you need to do is add the following filter declaration to your <code>web.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This provides a hook into the Spring Security web infrastructure.
<code>DelegatingFilterProxy</code> is a Spring Framework class which delegates to a filter implementation which is defined as a Spring bean in your application context.
In this case, the bean is named "springSecurityFilterChain", which is an internal infrastructure bean created by the namespace to handle web security.
Note that you should not use this bean name yourself.
Once you&#8217;ve added this to your <code>web.xml</code>, you&#8217;re ready to start editing your application context file.
Web security services are configured using the <code>&lt;http&gt;</code> element.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-minimal"><a class="anchor" href="#ns-minimal"></a>A Minimal &lt;http&gt; Configuration</h4>
<div class="paragraph">
<p>All you need to enable web security to begin with is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="hasRole('USER')" /&gt;
&lt;form-login /&gt;
&lt;logout /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which says that we want all URLs within our application to be secured, requiring the role <code>ROLE_USER</code> to access them, we want to log in to the application using a form with username and password, and that we want a logout URL registered which will allow us to log out of the application.
<code>&lt;http&gt;</code> element is the parent for all web-related namespace functionality.
The <code>&lt;intercept-url&gt;</code> element defines a <code>pattern</code> which is matched against the URLs of incoming requests using an ant path style syntax <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup>.
You can also use regular-expression matching as an alternative (see the namespace appendix for more details).
The <code>access</code> attribute defines the access requirements for requests matching the given pattern.
With the default configuration, this is typically a comma-separated list of roles, one of which a user must have to be allowed to make the request.
The prefix "ROLE_" is a marker which indicates that a simple comparison with the user&#8217;s authorities should be made.
In other words, a normal role-based check should be used.
Access-control in Spring Security is not limited to the use of simple roles (hence the use of the prefix to differentiate between different types of security attributes).
We&#8217;ll see later how the interpretation can vary <sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>.
In Spring Security 3.0, the attribute can also be populated with an <a href="#el-access">EL expression</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use multiple <code>&lt;intercept-url&gt;</code> elements to define different access requirements for different sets of URLs, but they will be evaluated in the order listed and the first match will be used.
So you must put the most specific matches at the top.
You can also add a <code>method</code> attribute to limit the match to a particular HTTP method (<code>GET</code>, <code>POST</code>, <code>PUT</code> etc.).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To add some users, you can define a set of test data directly in the namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;user-service&gt;
	&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
	NoOpPasswordEncoder should be used. This is not safe for production, but makes reading
	in samples easier. Normally passwords should be hashed using BCrypt --&gt;
	&lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of a secure way of storing the same passwords.
The password is prefixed with <code>{bcrypt}</code> to instruct <code>DelegatingPasswordEncoder</code>, which supports any configured <code>PasswordEncoder</code> for matching, that the passwords are hashed using BCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
	&lt;user-service&gt;
	&lt;user name="jimi" password="{bcrypt}$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m"
			authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{bcrypt}$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka"
			authorities="ROLE_USER" /&gt;
	&lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
	&lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
	&lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>If you are familiar with pre-namespace versions of the framework, you can probably already guess roughly what&#8217;s going on here.
The <code>&lt;http&gt;</code> element is responsible for creating a <code>FilterChainProxy</code> and the filter beans which it uses.
Common problems like incorrect filter ordering are no longer an issue as the filter positions are predefined.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;authentication-provider&gt;</code> element creates a <code>DaoAuthenticationProvider</code> bean and the <code>&lt;user-service&gt;</code> element creates an <code>InMemoryDaoImpl</code>.
All <code>authentication-provider</code> elements must be children of the <code>&lt;authentication-manager&gt;</code> element, which creates a <code>ProviderManager</code> and registers the authentication providers with it.
You can find more detailed information on the beans that are created in the <a href="#appendix-namespace">namespace appendix</a>.
It&#8217;s worth cross-checking this if you want to start understanding what the important classes in the framework are and how they are used, particularly if you want to customise things later.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration above defines two users, their passwords and their roles within the application (which will be used for access control).
It is also possible to load user information from a standard properties file using the <code>properties</code> attribute on <code>user-service</code>.
See the section on <a href="#servlet-authentication-inmemory">in-memory authentication</a> for more details on the file format.
Using the <code>&lt;authentication-provider&gt;</code> element means that the user information will be used by the authentication manager to process authentication requests.
You can have multiple <code>&lt;authentication-provider&gt;</code> elements to define different authentication sources and each will be consulted in turn.</p>
</div>
<div class="paragraph">
<p>At this point you should be able to start up your application and you will be required to log in to proceed.
Try it out, or try experimenting with the "tutorial" sample application that comes with the project.</p>
</div>
<div class="sect4">
<h5 id="ns-form-target"><a class="anchor" href="#ns-form-target"></a>Setting a Default Post-Login Destination</h5>
<div class="paragraph">
<p>If a form login isn&#8217;t prompted by an attempt to access a protected resource, the <code>default-target-url</code> option comes into play.
This is the URL the user will be taken to after successfully logging in, and defaults to "/".
You can also configure things so that the user <em>always</em> ends up at this page (regardless of whether the login was "on-demand" or they explicitly chose to log in) by setting the <code>always-use-default-target</code> attribute to "true".
This is useful if your application always requires that the user starts at a "home" page, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http pattern="/login.htm*" security="none"/&gt;
&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern='/**' access='ROLE_USER' /&gt;
&lt;form-login login-page='/login.htm' default-target-url='/home.htm'
		always-use-default-target='true' /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For even more control over the destination, you can use the <code>authentication-success-handler-ref</code> attribute as an alternative to <code>default-target-url</code>.
The referenced bean should be an instance of <code>AuthenticationSuccessHandler</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-web-advanced"><a class="anchor" href="#ns-web-advanced"></a>Advanced Web Features</h3>
<div class="sect3">
<h4 id="ns-custom-filters"><a class="anchor" href="#ns-custom-filters"></a>Adding in Your Own Filters</h4>
<div class="paragraph">
<p>If you&#8217;ve used Spring Security before, you&#8217;ll know that the framework maintains a chain of filters in order to apply its services.
You may want to add your own filters to the stack at particular locations or use a Spring Security filter for which there isn&#8217;t currently a namespace configuration option (CAS, for example).
Or you might want to use a customized version of a standard namespace filter, such as the <code>UsernamePasswordAuthenticationFilter</code> which is created by the <code>&lt;form-login&gt;</code> element, taking advantage of some of the extra configuration options which are available by using the bean explicitly.
How can you do this with namespace configuration, since the filter chain is not directly exposed?</p>
</div>
<div class="paragraph">
<p>The order of the filters is always strictly enforced when using the namespace.
When the application context is being created, the filter beans are sorted by the namespace handling code and the standard Spring Security filters each have an alias in the namespace and a well-known position.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In previous versions, the sorting took place after the filter instances had been created, during post-processing of the application context.
In version 3.0+ the sorting is now done at the bean metadata level, before the classes have been instantiated.
This has implications for how you add your own filters to the stack as the entire filter list must be known during the parsing of the <code>&lt;http&gt;</code> element, so the syntax has changed slightly in 3.0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The filters, aliases and namespace elements/attributes which create the filters are shown in <a href="#filter-stack">Standard Filter Aliases and Ordering</a>.
The filters are listed in the order in which they occur in the filter chain.</p>
</div>
<table id="filter-stack" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Standard Filter Aliases and Ordering</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Alias</th>
<th class="tableblock halign-left valign-top">Filter Class</th>
<th class="tableblock halign-left valign-top">Namespace Element or Attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHANNEL_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ChannelProcessingFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/intercept-url@requires-channel</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SECURITY_CONTEXT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextPersistenceFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONCURRENT_SESSION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentSessionFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management/concurrency-control</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEADERS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeaderWriterFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/headers</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSRF_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsrfFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/csrf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOGOUT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LogoutFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/logout</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X509_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X509AuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/x509</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRE_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractPreAuthenticatedProcessingFilter</code> Subclasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CasAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM_LOGIN_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernamePasswordAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/form-login</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BASIC_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BasicAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/http-basic</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVLET_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextHolderAwareRequestFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@servlet-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAAS_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JaasApiIntegrationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@jaas-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REMEMBER_ME_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RememberMeAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/remember-me</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANONYMOUS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnonymousAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/anonymous</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SESSION_MANAGEMENT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionManagementFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCEPTION_TRANSLATION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionTranslationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FILTER_SECURITY_INTERCEPTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FilterSecurityInterceptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SWITCH_USER_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SwitchUserFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can add your own filter to the stack, using the <code>custom-filter</code> element and one of these names to specify the position your filter should appear at:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" /&gt;
&lt;/http&gt;

&lt;beans:bean id="myFilter" class="com.mycompany.MySpecialAuthenticationFilter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>after</code> or <code>before</code> attributes if you want your filter to be inserted before or after another filter in the stack.
The names "FIRST" and "LAST" can be used with the <code>position</code> attribute to indicate that you want your filter to appear before or after the entire stack, respectively.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Avoiding filter position conflicts</div>
<div class="paragraph">
<p>If you are inserting a custom filter which may occupy the same position as one of the standard filters created by the namespace then it&#8217;s important that you don&#8217;t include the namespace versions by mistake.
Remove any elements which create filters whose functionality you want to replace.</p>
</div>
<div class="paragraph">
<p>Note that you can&#8217;t replace filters which are created by the use of the <code>&lt;http&gt;</code> element itself - <code>SecurityContextPersistenceFilter</code>, <code>ExceptionTranslationFilter</code> or <code>FilterSecurityInterceptor</code>.
Some other filters are added by default, but you can disable them.
An <code>AnonymousAuthenticationFilter</code> is added by default and unless you have <a href="#ns-session-fixation">session-fixation protection</a> disabled, a <code>SessionManagementFilter</code> will also be added to the filter chain.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you&#8217;re replacing a namespace filter which requires an authentication entry point (i.e. where the authentication process is triggered by an attempt by an unauthenticated user to access to a secured resource), you will need to add a custom entry point bean too.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-method-security"><a class="anchor" href="#ns-method-security"></a>Method Security</h3>
<div class="paragraph">
<p>From version 2.0 onwards Spring Security has improved support substantially for adding security to your service layer methods.
It provides support for JSR-250 annotation security as well as the framework&#8217;s original <code>@Secured</code> annotation.
From 3.0 you can also make use of new <a href="#el-access">expression-based annotations</a>.
You can apply security to a single bean, using the <code>intercept-methods</code> element to decorate the bean declaration, or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-access-manager"><a class="anchor" href="#ns-access-manager"></a>The Default AccessDecisionManager</h3>
<div class="paragraph">
<p>This section assumes you have some knowledge of the underlying architecture for access-control within Spring Security.
If you don&#8217;t you can skip it and come back to it later, as this section is only really relevant for people who need to do some customization in order to use more than simple role-based security.</p>
</div>
<div class="paragraph">
<p>When you use a namespace configuration, a default instance of <code>AccessDecisionManager</code> is automatically registered for you and will be used for making access decisions for method invocations and web URL access, based on the access attributes you specify in your <code>intercept-url</code> and <code>protect-pointcut</code> declarations (and in annotations if you are using annotation secured methods).</p>
</div>
<div class="paragraph">
<p>The default strategy is to use an <code>AffirmativeBased</code> <code>AccessDecisionManager</code> with a <code>RoleVoter</code> and an <code>AuthenticatedVoter</code>.
You can find out more about these in the chapter on <a href="#authz-arch">authorization</a>.</p>
</div>
<div class="sect3">
<h4 id="ns-custom-access-mgr"><a class="anchor" href="#ns-custom-access-mgr"></a>Customizing the AccessDecisionManager</h4>
<div class="paragraph">
<p>If you need to use a more complicated access control strategy then it is easy to set an alternative for both method and web security.</p>
</div>
<div class="paragraph">
<p>For method security, you do this by setting the <code>access-decision-manager-ref</code> attribute on <code>global-method-security</code> to the <code>id</code> of the appropriate <code>AccessDecisionManager</code> bean in the application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax for web security is the same, but on the <code>http</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test"><a class="anchor" href="#test"></a>Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes the testing support provided by Spring Security.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To use the Spring Security test support, you must include <code>spring-security-test-{spring-security-version}.jar</code> as a dependency of your project.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="test-method"><a class="anchor" href="#test-method"></a>Testing Method Security</h3>
<div class="paragraph">
<p>This section demonstrates how to use Spring Security&#8217;s Test support to test method based security.
We first introduce a <code>MessageService</code> that requires the user to be authenticated in order to access it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HelloMessageService implements MessageService {

	@PreAuthorize("authenticated")
	public String getMessage() {
		Authentication authentication = SecurityContextHolder.getContext()
			.getAuthentication();
		return "Hello " + authentication;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of <code>getMessage</code> is a String saying "Hello" to the current Spring Security <code>Authentication</code>.
An example of the output is displayed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="test-method-setup"><a class="anchor" href="#test-method-setup"></a>Security Test Setup</h4>
<div class="paragraph">
<p>Before we can use Spring Security Test support, we must perform some setup. An example can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@ContextConfiguration <i class="conum" data-value="2"></i><b>(2)</b>
public class WithMockUserTests {</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a basic example of how to setup Spring Security Test. The highlights are:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RunWith</code> instructs the spring-test module that it should create an <code>ApplicationContext</code>. This is no different than using the existing Spring Test support. For additional information, refer to the <a href="https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#integration-testing-annotations-standard">Spring Reference</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@ContextConfiguration</code> instructs the spring-test the configuration to use to create the <code>ApplicationContext</code>. Since no configuration is specified, the default configuration locations will be tried. This is no different than using the existing Spring Test support. For additional information, refer to the <a href="https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#testcontext-ctx-management">Spring Reference</a></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security hooks into Spring Test support using the <code>WithSecurityContextTestExecutionListener</code> which will ensure our tests are ran with the correct user.
It does this by populating the <code>SecurityContextHolder</code> prior to running our tests.
If you are using reactive method security, you will also need <code>ReactorContextTestExecutionListener</code> which populates <code>ReactiveSecurityContextHolder</code>.
After the test is done, it will clear out the <code>SecurityContextHolder</code>.
If you only need Spring Security related support, you can replace <code>@ContextConfiguration</code> with <code>@SecurityTestExecutionListeners</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Remember we added the <code>@PreAuthorize</code> annotation to our <code>HelloMessageService</code> and so it requires an authenticated user to invoke it.
If we ran the following test, we would expect the following test will pass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test(expected = AuthenticationCredentialsNotFoundException.class)
public void getMessageUnauthenticated() {
	messageService.getMessage();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withmockuser"><a class="anchor" href="#test-method-withmockuser"></a>@WithMockUser</h4>
<div class="paragraph">
<p>The question is "How could we most easily run the test as a specific user?"
The answer is to use <code>@WithMockUser</code>.
The following test will be run as a user with the username "user", the password "password", and the roles "ROLE_USER".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser
public void getMessageWithMockUser() {
String message = messageService.getMessage();
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifically the following is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user with the username "user" does not have to exist since we are mocking the user</p>
</li>
<li>
<p>The <code>Authentication</code> that is populated in the <code>SecurityContext</code> is of type <code>UsernamePasswordAuthenticationToken</code></p>
</li>
<li>
<p>The principal on the <code>Authentication</code> is Spring Security&#8217;s <code>User</code> object</p>
</li>
<li>
<p>The <code>User</code> will have the username of "user", the password "password", and a single <code>GrantedAuthority</code> named "ROLE_USER" is used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our example is nice because we are able to leverage a lot of defaults.
What if we wanted to run the test with a different username?
The following test would run with the username "customUser". Again, the user does not need to actually exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser("customUsername")
public void getMessageWithMockUserCustomUsername() {
	String message = messageService.getMessage();
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also easily customize the roles.
For example, this test will be invoked with the username "admin" and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public void getMessageWithMockUserCustomUser() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we do not want the value to automatically be prefixed with ROLE_ we can leverage the authorities attribute.
For example, this test will be invoked with the username "admin" and the authorities "USER" and "ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser(username = "admin", authorities = { "ADMIN", "USER" })
public void getMessageWithMockUserCustomAuthorities() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course it can be a bit tedious placing the annotation on every test method.
Instead, we can place the annotation at the class level and every test will use the specified user.
For example, the following would run every test with a user with the username "admin", the password "password", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public class WithMockUserTests {</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using JUnit 5&#8217;s <code>@Nested</code> test support, you can also place the annotation on the enclosing class to apply to all nested classes.
For example, the following would run every test with a user with the username "admin", the password "password", and the roles "ROLE_USER" and "ROLE_ADMIN" for both test methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextConfiguration
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public class WithMockUserTests {

	@Nested
	public class TestSuite1 {
		// ... all test methods use admin user
	}

	@Nested
	public class TestSuite2 {
		// ... all test methods use admin user
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContext</code> is set during the <code>TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code>@Before</code>.
You can change this to happen during the <code>TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code>@Before</code> but before the test method is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithMockUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withanonymoususer"><a class="anchor" href="#test-method-withanonymoususer"></a>@WithAnonymousUser</h4>
<div class="paragraph">
<p>Using <code>@WithAnonymousUser</code> allows running as an anonymous user.
This is especially convenient when you wish to run most of your tests with a specific user, but want to run a few tests as an anonymous user.
For example, the following will run withMockUser1 and withMockUser2 using <a href="#test-method-withmockuser">@WithMockUser</a> and anonymous as an anonymous user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@WithMockUser
public class WithUserClassLevelAuthenticationTests {

	@Test
	public void withMockUser1() {
	}

	@Test
	public void withMockUser2() {
	}

	@Test
	@WithAnonymousUser
	public void anonymous() throws Exception {
		// override default to run as anonymous user
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContext</code> is set during the <code>TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code>@Before</code>.
You can change this to happen during the <code>TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code>@Before</code> but before the test method is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithAnonymousUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withuserdetails"><a class="anchor" href="#test-method-withuserdetails"></a>@WithUserDetails</h4>
<div class="paragraph">
<p>While <code>@WithMockUser</code> is a very convenient way to get started, it may not work in all instances.
For example, it is common for applications to expect that the <code>Authentication</code> principal be of a specific type.
This is done so that the application can refer to the principal as the custom type and reduce coupling on Spring Security.</p>
</div>
<div class="paragraph">
<p>The custom principal is often times returned by a custom <code>UserDetailsService</code> that returns an object that implements both <code>UserDetails</code> and the custom type.
For situations like this, it is useful to create the test user using the custom <code>UserDetailsService</code>.
That is exactly what <code>@WithUserDetails</code> does.</p>
</div>
<div class="paragraph">
<p>Assuming we have a <code>UserDetailsService</code> exposed as a bean, the following test will be invoked with an <code>Authentication</code> of type <code>UsernamePasswordAuthenticationToken</code> and a principal that is returned from the <code>UserDetailsService</code> with the username of "user".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithUserDetails
public void getMessageWithUserDetails() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also customize the username used to lookup the user from our <code>UserDetailsService</code>.
For example, this test would be run with a principal that is returned from the <code>UserDetailsService</code> with the username of "customUsername".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithUserDetails("customUsername")
public void getMessageWithUserDetailsCustomUsername() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also provide an explicit bean name to look up the <code>UserDetailsService</code>.
For example, this test would look up the username of "customUsername" using the <code>UserDetailsService</code> with the bean name "myUserDetailsService".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithUserDetails(value="customUsername", userDetailsServiceBeanName="myUserDetailsService")
public void getMessageWithUserDetailsServiceBeanName() {
	String message = messageService.getMessage();
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>@WithMockUser</code> we can also place our annotation at the class level so that every test uses the same user.
However unlike <code>@WithMockUser</code>, <code>@WithUserDetails</code> requires the user to exist.</p>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContext</code> is set during the <code>TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code>@Before</code>.
You can change this to happen during the <code>TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code>@Before</code> but before the test method is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithUserDetails(setupBefore = TestExecutionEvent.TEST_EXECUTION)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withsecuritycontext"><a class="anchor" href="#test-method-withsecuritycontext"></a>@WithSecurityContext</h4>
<div class="paragraph">
<p>We have seen that <code>@WithMockUser</code> is an excellent choice if we are not using a custom <code>Authentication</code> principal.
Next we discovered that <code>@WithUserDetails</code> would allow us to use a custom <code>UserDetailsService</code> to create our <code>Authentication</code> principal but required the user to exist.
We will now see an option that allows the most flexibility.</p>
</div>
<div class="paragraph">
<p>We can create our own annotation that uses the <code>@WithSecurityContext</code> to create any <code>SecurityContext</code> we want.
For example, we might create an annotation named <code>@WithMockCustomUser</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)
public @interface WithMockCustomUser {

	String username() default "rob";

	String name() default "Rob Winch";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that <code>@WithMockCustomUser</code> is annotated with the <code>@WithSecurityContext</code> annotation.
This is what signals to Spring Security Test support that we intend to create a <code>SecurityContext</code> for the test.
The <code>@WithSecurityContext</code> annotation requires we specify a <code>SecurityContextFactory</code> that will create a new <code>SecurityContext</code> given our <code>@WithMockCustomUser</code> annotation.
You can find our <code>WithMockCustomUserSecurityContextFactory</code> implementation below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WithMockCustomUserSecurityContextFactory
	implements WithSecurityContextFactory&lt;WithMockCustomUser&gt; {
	@Override
	public SecurityContext createSecurityContext(WithMockCustomUser customUser) {
		SecurityContext context = SecurityContextHolder.createEmptyContext();

		CustomUserDetails principal =
			new CustomUserDetails(customUser.name(), customUser.username());
		Authentication auth =
			new UsernamePasswordAuthenticationToken(principal, "password", principal.getAuthorities());
		context.setAuthentication(auth);
		return context;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now annotate a test class or a test method with our new annotation and Spring Security&#8217;s <code>WithSecurityContextTestExecutionListener</code> will ensure that our <code>SecurityContext</code> is populated appropriately.</p>
</div>
<div class="paragraph">
<p>When creating your own <code>WithSecurityContextFactory</code> implementations, it is nice to know that they can be annotated with standard Spring annotations.
For example, the <code>WithUserDetailsSecurityContextFactory</code> uses the <code>@Autowired</code> annotation to acquire the <code>UserDetailsService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final class WithUserDetailsSecurityContextFactory
	implements WithSecurityContextFactory&lt;WithUserDetails&gt; {

	private UserDetailsService userDetailsService;

	@Autowired
	public WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public SecurityContext createSecurityContext(WithUserDetails withUser) {
		String username = withUser.value();
		Assert.hasLength(username, "value() must be non-empty String");
		UserDetails principal = userDetailsService.loadUserByUsername(username);
		Authentication authentication = new UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());
		SecurityContext context = SecurityContextHolder.createEmptyContext();
		context.setAuthentication(authentication);
		return context;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContext</code> is set during the <code>TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code>@Before</code>.
You can change this to happen during the <code>TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code>@Before</code> but before the test method is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithSecurityContext(setupBefore = TestExecutionEvent.TEST_EXECUTION)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-meta-annotations"><a class="anchor" href="#test-method-meta-annotations"></a>Test Meta Annotations</h4>
<div class="paragraph">
<p>If you reuse the same user within your tests often, it is not ideal to have to repeatedly specify the attributes.
For example, if there are many tests related to an administrative user with the username "admin" and the roles <code>ROLE_USER</code> and <code>ROLE_ADMIN</code> you would have to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithMockUser(username="admin",roles={"USER","ADMIN"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rather than repeating this everywhere, we can use a meta annotation.
For example, we could create a meta annotation named <code>WithMockAdmin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithMockUser(value="rob",roles="ADMIN")
public @interface WithMockAdmin { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can use <code>@WithMockAdmin</code> in the same way as the more verbose <code>@WithMockUser</code>.</p>
</div>
<div class="paragraph">
<p>Meta annotations work with any of the testing annotations described above.
For example, this means we could create a meta annotation for <code>@WithUserDetails("admin")</code> as well.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-mockmvc"><a class="anchor" href="#test-mockmvc"></a>Spring MVC Test Integration</h3>
<div class="paragraph">
<p>Spring Security provides comprehensive integration with <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework">Spring MVC Test</a></p>
</div>
<div class="sect3">
<h4 id="test-mockmvc-setup"><a class="anchor" href="#test-mockmvc-setup"></a>Setting Up MockMvc and Spring Security</h4>
<div class="paragraph">
<p>In order to use Spring Security with Spring MVC Test it is necessary to add the Spring Security <code>FilterChainProxy</code> as a <code>Filter</code>.
It is also necessary to add Spring Security&#8217;s <code>TestSecurityContextHolderPostProcessor</code> to support <a href="#_running_as_a_user_in_spring_mvc_test_with_annotations">Running as a User in Spring MVC Test with Annotations</a>.
This can be done using Spring Security&#8217;s <code>SecurityMockMvcConfigurers.springSecurity()</code>.
For example:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security&#8217;s testing support requires spring-test-4.1.3.RELEASE or greater.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SecurityConfig.class)
@WebAppConfiguration
public class CsrfShowcaseTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setup() {
		mvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity()) <i class="conum" data-value="1"></i><b>(1)</b>
				.build();
	}

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SecurityMockMvcConfigurers.springSecurity()</code> will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="test-mockmvc-smmrpp"><a class="anchor" href="#test-mockmvc-smmrpp"></a>SecurityMockMvcRequestPostProcessors</h4>
<div class="paragraph">
<p>Spring MVC Test provides a convenient interface called a <code>RequestPostProcessor</code> that can be used to modify a request.
Spring Security provides a number of <code>RequestPostProcessor</code> implementations that make testing easier.
In order to use Spring Security&#8217;s <code>RequestPostProcessor</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-csrf"><a class="anchor" href="#test-mockmvc-csrf"></a>Testing with CSRF Protection</h5>
<div class="paragraph">
<p>When testing any non-safe HTTP methods and using Spring Security&#8217;s CSRF protection, you must be sure to include a valid CSRF Token in the request.
To specify a valid CSRF token as a request parameter using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(post("/").with(csrf()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you like you can include CSRF token in the header instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(post("/").with(csrf().asHeader()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also test providing an invalid CSRF token using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(post("/").with(csrf().useInvalidToken()))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-securitycontextholder"><a class="anchor" href="#test-mockmvc-securitycontextholder"></a>Running a Test as a User in Spring MVC Test</h5>
<div class="paragraph">
<p>It is often desirable to run tests as a specific user.
There are two simple ways of populating the user:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#test-mockmvc-securitycontextholder-rpp">Running as a User in Spring MVC Test with RequestPostProcessor</a></p>
</li>
<li>
<p><a href="#_running_as_a_user_in_spring_mvc_test_with_annotations">Running as a User in Spring MVC Test with Annotations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-securitycontextholder-rpp"><a class="anchor" href="#test-mockmvc-securitycontextholder-rpp"></a>Running as a User in Spring MVC Test with RequestPostProcessor</h5>
<div class="paragraph">
<p>There are a number of options available to associate a user to the current <code>HttpServletRequest</code>.
For example, the following will run as a user (which does not need to exist) with the username "user", the password "password", and the role "ROLE_USER":</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The support works by associating the user to the <code>HttpServletRequest</code>.
To associate the request to the <code>SecurityContextHolder</code> you need to ensure that the <code>SecurityContextPersistenceFilter</code> is associated with the <code>MockMvc</code> instance.
A few ways to do this are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invoking <a href="#test-mockmvc-setup">apply(springSecurity())</a></p>
</li>
<li>
<p>Adding Spring Security&#8217;s <code>FilterChainProxy</code> to <code>MockMvc</code></p>
</li>
<li>
<p>Manually adding <code>SecurityContextPersistenceFilter</code> to the <code>MockMvc</code> instance may make sense when using <code>MockMvcBuilders.standaloneSetup</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(user("user")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can easily make customizations.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "pass", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have a custom <code>UserDetails</code> that you would like to use, you can easily specify that as well.
For example, the following will use the specified <code>UserDetails</code> (which does not need to exist) to run with a <code>UsernamePasswordAuthenticationToken</code> that has a principal of the specified <code>UserDetails</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(user(userDetails)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can run as anonymous user using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(anonymous()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is especially useful if you are running with a default user and wish to process a few requests as an anonymous user.</p>
</div>
<div class="paragraph">
<p>If you want a custom <code>Authentication</code> (which does not need to exist) you can do so using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(authentication(authentication)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even customize the <code>SecurityContext</code> using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(securityContext(securityContext)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also ensure to run as a specific user for every request by using <code>MockMvcBuilders</code>'s default request.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "password", and the role "ROLE_ADMIN":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc = MockMvcBuilders
		.webAppContextSetup(context)
		.defaultRequest(get("/").with(user("user").roles("ADMIN")))
		.apply(springSecurity())
		.build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you find you are using the same user in many of your tests, it is recommended to move the user to a method.
For example, you can specify the following in your own class named <code>CustomSecurityMockMvcRequestPostProcessors</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static RequestPostProcessor rob() {
	return user("rob").roles("ADMIN");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can perform a static import on <code>SecurityMockMvcRequestPostProcessors</code> and use that within your tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
	.perform(get("/").with(rob()))</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_running_as_a_user_in_spring_mvc_test_with_annotations"><a class="anchor" href="#_running_as_a_user_in_spring_mvc_test_with_annotations"></a>Running as a User in Spring MVC Test with Annotations</h6>
<div class="paragraph">
<p>As an alternative to using a <code>RequestPostProcessor</code> to create your user, you can use annotations described in <a href="#test-method">Testing Method Security</a>.
For example, the following will run the test with the user with username "user", password "password", and role "ROLE_USER":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the following will run the test with the user with username "user", password "password", and role "ROLE_ADMIN":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_testing_http_basic_authentication"><a class="anchor" href="#_testing_http_basic_authentication"></a>Testing HTTP Basic Authentication</h5>
<div class="paragraph">
<p>While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values.
Now this can be done using Spring Security&#8217;s <code>httpBasic</code> <code>RequestPostProcessor</code>.
For example, the snippet below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(get("/").with(httpBasic("user","password")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>will attempt to use HTTP Basic to authenticate a user with the username "user" and the password "password" by ensuring the following header is populated on the HTTP Request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Authorization: Basic dXNlcjpwYXNzd29yZA==</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2"><a class="anchor" href="#testing-oauth2"></a>Testing OAuth 2.0</h5>
<div class="paragraph">
<p>When it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>For example, for a controller that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(Principal user) {
    return user.getName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s nothing OAuth2-specific about it, so you will likely be able to simply <a href="#test-method-withmockuser">use <code>@WithMockUser</code></a> and be fine.</p>
</div>
<div class="paragraph">
<p>But, in cases where your controllers are bound to some aspect of Spring Security&#8217;s OAuth 2.0 support, like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser user) {
    return user.getIdToken().getSubject();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then Spring Security&#8217;s test support can come in handy.</p>
</div>
</div>
<div class="sect4">
<h5 id="testing-oidc-login"><a class="anchor" href="#testing-oidc-login"></a>Testing OIDC Login</h5>
<div class="paragraph">
<p>Testing the method above with Spring MVC Test would require simulating some kind of grant flow with an authorization server.
Certainly this would be a daunting task, which is why Spring Security ships with support for removing this boilerplate.</p>
</div>
<div class="paragraph">
<p>For example, we can tell Spring Security to include a default <code>OidcUser</code> using the <code>SecurityMockMvcRequestPostProcessors#oidcLogin</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint").with(oidcLogin()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockHttpServletRequest</code> with an <code>OidcUser</code> that includes a simple <code>OidcIdToken</code>, <code>OidcUserInfo</code>, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include an <code>OidcIdToken</code> with a <code>sub</code> claim set to <code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>an <code>OidcUserInfo</code> with no claims set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getUserInfo().getClaims()).isEmpty();</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OidcUser</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OidcUser</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits into an mock <code>OAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>..</p>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-authorities"><a class="anchor" href="#testing-oidc-login-authorities"></a>Configuring Authorities</h6>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-claims"><a class="anchor" href="#testing-oidc-login-claims"></a>Configuring Claims</h6>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> claim that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that claim with the <code>idToken()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
                .idToken(token -&gt; token.claim("user_id", "1234"))
        )
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>since <code>OidcUser</code> collects its claims from <code>OidcIdToken</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-user"><a class="anchor" href="#testing-oidc-login-user"></a>Additional Configurations</h6>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>userInfo(OidcUserInfo.Builder)</code> - For configuring the <code>OidcUserInfo</code> instance</p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oidcUser(OidcUser)</code> - For configuring the complete <code>OidcUser</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OidcUser</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OidcUser</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oidcLogin().oidcUser(oidcUser))
    );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2-login"><a class="anchor" href="#testing-oauth2-login"></a>Testing OAuth 2.0 Login</h5>
<div class="paragraph">
<p>As with <a href="#testing-oidc-login">testing OIDC login</a>, testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow.
And because of that, Spring Security also has test support for non-OIDC use cases.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that gets the logged-in user as an <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return oauth2User.getAttribute("sub");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>OAuth2User</code> using the <code>SecurityMockMvcRequestPostProcessors#oauth2User</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint").with(oauth2Login()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockHttpServletRequest</code> with an <code>OAuth2User</code> that includes a simple <code>Map</code> of attributes and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat((String) user.getAttribute("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OAuth2User</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OAuth2User</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits in a mock <code>OAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>.</p>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-authorities"><a class="anchor" href="#testing-oauth2-login-authorities"></a>Configuring Authorities</h6>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-claims"><a class="anchor" href="#testing-oauth2-login-claims"></a>Configuring Claims</h6>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
                .attributes(attrs -&gt; attrs.put("user_id", "1234"))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-user"><a class="anchor" href="#testing-oauth2-login-user"></a>Additional Configurations</h6>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oauth2User(OAuth2User)</code> - For configuring the complete <code>OAuth2User</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OAuth2User</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OAuth2User</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oauth2Login().oauth2User(oauth2User))
    );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2-client"><a class="anchor" href="#testing-oauth2-client"></a>Testing OAuth 2.0 Clients</h5>
<div class="paragraph">
<p>Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.
For example, your controller may be relying on the client credentials grant to get a token that isn&#8217;t associated with the user at all:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class)
        .block();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulating this handshake with the authorization server could be cumbersome.
Instead, you can use <code>SecurityMockMvcRequestPostProcessor#oauth2Client</code> to add a <code>OAuth2AuthorizedClient</code> into a mock <code>OAuth2AuthorizedClientRepository</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint").with(oauth2Client("my-app")));</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is create an <code>OAuth2AuthorizedClient</code> that has a simple <code>ClientRegistration</code>, <code>OAuth2AccessToken</code>, and resource owner name.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>ClientRegistration</code> with a client id of "test-client" and client secret of "test-secret":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p>a resource owner name of "user":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and an <code>OAuth2AccessToken</code> with just one scope, <code>read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client can then be retrieved as normal using <code>@RegisteredOAuth2AuthorizedClient</code> in a controller method.</p>
</div>
<div class="sect5">
<h6 id="testing-oauth2-client-scopes"><a class="anchor" href="#testing-oauth2-client-scopes"></a>Configuring Scopes</h6>
<div class="paragraph">
<p>In many circumstances, the OAuth 2.0 access token comes with a set of scopes.
If your controller inspects these, say like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set&lt;String&gt; scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class)
            .block();
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then you can configure the scope using the <code>accessToken()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Client("my-app")
            .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read"))))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-client-registration"><a class="anchor" href="#testing-oauth2-client-registration"></a>Additional Configurations</h6>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principalName(String)</code> - For configuring the resource owner name</p>
</li>
<li>
<p><code>clientRegistration(Consumer&lt;ClientRegistration.Builder&gt;)</code> - For configuring the associated <code>ClientRegistration</code></p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the complete <code>ClientRegistration</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you want to use a real <code>ClientRegistration</code></p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that you are wanting to use one of your app&#8217;s <code>ClientRegistration</code> definitions, as specified in your <code>application.yml</code>.</p>
</div>
<div class="paragraph">
<p>In that case, your test can autowire the <code>ClientRegistrationRepository</code> and look up the one your test needs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
ClientRegistrationRepository clientRegistrationRepository;

// ...

mvc
    .perform(get("/endpoint")
        .with(oauth2Client()
            .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-jwt"><a class="anchor" href="#testing-jwt"></a>Testing JWT Authentication</h5>
<div class="paragraph">
<p>In order to make an authorized request on a resource server, you need a bearer token.</p>
</div>
<div class="paragraph">
<p>If your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification.
All of this can be quite daunting, especially when this isn&#8217;t the focus of your test.</p>
</div>
<div class="paragraph">
<p>Fortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.
We&#8217;ll look at two of them now:</p>
</div>
<div class="sect5">
<h6 id="_jwt_requestpostprocessor"><a class="anchor" href="#_jwt_requestpostprocessor"></a><code>jwt() RequestPostProcessor</code></h6>
<div class="paragraph">
<p>The first way is via a <code>RequestPostProcessor</code>.
The simplest of these would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint").with(jwt()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is create a mock <code>Jwt</code>, passing it correctly through any authentication APIs so that it&#8217;s available for your authorization mechanisms to verify.</p>
</div>
<div class="paragraph">
<p>By default, the <code>JWT</code> that it creates has the following characteristics:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the resulting <code>Jwt</code>, were it tested, would pass in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>These values can, of course be configured.</p>
</div>
<div class="paragraph">
<p>Any headers or claims can be configured with their corresponding methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -&gt; jwt.header("kid", "one").claim("iss", "https://idp.example.org"))));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -&gt; jwt.claims(claims -&gt; claims.remove("scope")))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>scope</code> and <code>scp</code> claims are processed the same way here as they are in a normal bearer token request.
However, this can be overridden simply by providing the list of <code>GrantedAuthority</code> instances that you need for your test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, if you have a custom <code>Jwt</code> to <code>Collection&lt;GrantedAuthority&gt;</code> converter, you can also use that to derive the authorities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new MyConverter())));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify a complete <code>Jwt</code>, for which <code>{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[Jwt.Builder]</code> comes quite handy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt)));</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_authentication_requestpostprocessor"><a class="anchor" href="#_authentication_requestpostprocessor"></a><code>authentication()</code> <code>RequestPostProcessor</code></h6>
<div class="paragraph">
<p>The second way is by using the <code>authentication()</code> <code>RequestPostProcessor</code>.
Essentially, you can instantiate your own <code>JwtAuthenticationToken</code> and provide it in your test, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

mvc
    .perform(get("/endpoint")
        .with(authentication(token)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to these, you can also mock the <code>JwtDecoder</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-opaque-token"><a class="anchor" href="#testing-opaque-token"></a>Testing Opaque Token Authentication</h5>
<div class="paragraph">
<p>Similar to <a href="#testing-jwt">JWTs</a>, opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult.
To help with that, Spring Security has test support for opaque tokens.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that retrieves the authentication as a <code>BearerTokenAuthentication</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    return (String) authentication.getTokenAttributes("sub");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>BearerTokenAuthentication</code> using the <code>SecurityMockMvcRequestPostProcessors#opaqueToken</code> method, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint").with(opaqueToken()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockHttpServletRequest</code> with a <code>BearerTokenAuthentication</code> that includes a simple <code>OAuth2AuthenticatedPrincipal</code>, <code>Map</code> of attributes, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>BearerTokenAuthentication</code> instance is available for your controller methods.</p>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-authorities"><a class="anchor" href="#testing-opaque-token-authorities"></a>Configuring Authorities</h6>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-attributes"><a class="anchor" href="#testing-opaque-token-attributes"></a>Configuring Claims</h6>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
                .attributes(attrs -&gt; attrs.put("user_id", "1234"))
        )
    );</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-principal"><a class="anchor" href="#testing-opaque-token-principal"></a>Additional Configurations</h6>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects.</p>
</div>
<div class="paragraph">
<p>One such is <code>principal(OAuth2AuthenticatedPrincipal)</code>, which you can use to configure the complete <code>OAuth2AuthenticatedPrincipal</code> instance that underlies the <code>BearerTokenAuthentication</code></p>
</div>
<div class="paragraph">
<p>It&#8217;s handy if you:
1. Have your own implementation of <code>OAuth2AuthenticatedPrincipal</code>, or
2. Want to specify a different principal name</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> attribute instead of the <code>sub</code> attribute.
In that case, you can configure an <code>OAuth2AuthenticatedPrincipal</code> by hand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

mvc
    .perform(get("/endpoint")
        .with(opaqueToken().principal(principal))
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to using <code>opaqueToken()</code> test support, you can also mock the <code>OpaqueTokenIntrospector</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_securitymockmvcrequestbuilders"><a class="anchor" href="#_securitymockmvcrequestbuilders"></a>SecurityMockMvcRequestBuilders</h4>
<div class="paragraph">
<p>Spring MVC Test also provides a <code>RequestBuilder</code> interface that can be used to create the <code>MockHttpServletRequest</code> used in your test.
Spring Security provides a few <code>RequestBuilder</code> implementations that can be used to make testing easier.
In order to use Spring Security&#8217;s <code>RequestBuilder</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_testing_form_based_authentication"><a class="anchor" href="#_testing_form_based_authentication"></a>Testing Form Based Authentication</h5>
<div class="paragraph">
<p>You can easily create a request to test a form based authentication using Spring Security&#8217;s testing support.
For example, the following will submit a POST to "/login" with the username "user", the password "password", and a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin())</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is easy to customize the request.
For example, the following will submit a POST to "/auth" with the username "admin", the password "pass", and a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin("/auth").user("admin").password("pass"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also customize the parameters names that the username and password are included on.
For example, this is the above request modified to include the username on the HTTP parameter "u" and the password on the HTTP parameter "p".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin("/auth").user("u","admin").password("p","pass"))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-logout"><a class="anchor" href="#test-logout"></a>Testing Logout</h5>
<div class="paragraph">
<p>While fairly trivial using standard Spring MVC Test, you can use Spring Security&#8217;s testing support to make testing log out easier.
For example, the following will submit a POST to "/logout" with a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(logout())</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also customize the URL to post to.
For example, the snippet below will submit a POST to "/signout" with a valid CSRF token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(logout("/signout"))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_securitymockmvcresultmatchers"><a class="anchor" href="#_securitymockmvcresultmatchers"></a>SecurityMockMvcResultMatchers</h4>
<div class="paragraph">
<p>At times it is desirable to make various security related assertions about a request.
To accommodate this need, Spring Security Test support implements Spring MVC Test&#8217;s <code>ResultMatcher</code> interface.
In order to use Spring Security&#8217;s <code>ResultMatcher</code> implementations ensure the following static import is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_unauthenticated_assertion"><a class="anchor" href="#_unauthenticated_assertion"></a>Unauthenticated Assertion</h5>
<div class="paragraph">
<p>At times it may be valuable to assert that there is no authenticated user associated with the result of a <code>MockMvc</code> invocation.
For example, you might want to test submitting an invalid username and password and verify that no user is authenticated.
You can easily do this with Spring Security&#8217;s testing support using something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin().password("invalid"))
	.andExpect(unauthenticated());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_authenticated_assertion"><a class="anchor" href="#_authenticated_assertion"></a>Authenticated Assertion</h5>
<div class="paragraph">
<p>It is often times that we must assert that an authenticated user exists.
For example, we may want to verify that we authenticated successfully.
We could verify that a form based login was successful with the following snippet of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin())
	.andExpect(authenticated());</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to assert the roles of the user, we could refine our previous code as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withRoles("USER","ADMIN"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, we could verify the username:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withUsername("admin"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also combine the assertions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin().user("admin").roles("USER","ADMIN"))
	.andExpect(authenticated().withUsername("admin"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also make arbitrary assertions on the authentication</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mvc
	.perform(formLogin())
	.andExpect(authenticated().withAuthentication(auth -&gt;
		assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class)));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="crypto"><a class="anchor" href="#crypto"></a>Spring Security Crypto Module</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="spring-security-crypto-introduction"><a class="anchor" href="#spring-security-crypto-introduction"></a>Introduction</h3>
<div class="paragraph">
<p>The Spring Security Crypto module provides support for symmetric encryption, key generation, and password encoding.
The code is distributed as part of the core module but has no dependencies on any other Spring Security (or Spring) code.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-encryption"><a class="anchor" href="#spring-security-crypto-encryption"></a>Encryptors</h3>
<div class="paragraph">
<p>The Encryptors class provides factory methods for constructing symmetric encryptors.
Using this class, you can create ByteEncryptors to encrypt data in raw byte[] form.
You can also construct TextEncryptors to encrypt text strings.
Encryptors are thread-safe.</p>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-bytes"><a class="anchor" href="#spring-security-crypto-encryption-bytes"></a>BytesEncryptor</h4>
<div class="paragraph">
<p>Use the <code>Encryptors.stronger</code> factory method to construct a BytesEncryptor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 136. BytesEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Encryptors.stronger("password", "salt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">Encryptors.stronger("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The "stronger" encryption method creates an encryptor using 256 bit AES encryption with
Galois Counter Mode (GCM).
It derives the secret key using PKCS #5&#8217;s PBKDF2 (Password-Based Key Derivation Function #2).
This method requires Java 6.
The password used to generate the SecretKey should be kept in a secure place and not be shared.
The salt is used to prevent dictionary attacks against the key in the event your encrypted data is compromised.
A 16-byte random initialization vector is also applied so each encrypted message is unique.</p>
</div>
<div class="paragraph">
<p>The provided salt should be in hex-encoded String form, be random, and be at least 8 bytes in length.
Such a salt may be generated using a KeyGenerator:</p>
</div>
<div class="exampleblock">
<div class="title">Example 137. Generating a key</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val salt = KeyGenerators.string().generateKey() // generates a random 8-byte salt that is then hex-encoded</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Users may also use the <code>standard</code> encryption method, which is 256-bit AES in Cipher Block Chaining (CBC) Mode.
This mode is not <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated</a> and does not provide any
guarantees about the authenticity of the data.
For a more secure alternative, users should prefer <code>Encryptors.stronger</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-text"><a class="anchor" href="#spring-security-crypto-encryption-text"></a>TextEncryptor</h4>
<div class="paragraph">
<p>Use the Encryptors.text factory method to construct a standard TextEncryptor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 138. TextEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Encryptors.text("password", "salt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">Encryptors.text("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A TextEncryptor uses a standard BytesEncryptor to encrypt text data.
Encrypted results are returned as hex-encoded strings for easy storage on the filesystem or in the database.</p>
</div>
<div class="paragraph">
<p>Use the Encryptors.queryableText factory method to construct a "queryable" TextEncryptor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 139. Queryable TextEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Encryptors.queryableText("password", "salt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">Encryptors.queryableText("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The difference between a queryable TextEncryptor and a standard TextEncryptor has to do with initialization vector (iv) handling.
The iv used in a queryable TextEncryptor#encrypt operation is shared, or constant, and is not randomly generated.
This means the same text encrypted multiple times will always produce the same encryption result.
This is less secure, but necessary for encrypted data that needs to be queried against.
An example of queryable encrypted text would be an OAuth apiKey.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-keygenerators"><a class="anchor" href="#spring-security-crypto-keygenerators"></a>Key Generators</h3>
<div class="paragraph">
<p>The KeyGenerators class provides a number of convenience factory methods for constructing different types of key generators.
Using this class, you can create a BytesKeyGenerator to generate byte[] keys.
You can also construct a StringKeyGenerator to generate string keys.
KeyGenerators are thread-safe.</p>
</div>
<div class="sect3">
<h4 id="_byteskeygenerator"><a class="anchor" href="#_byteskeygenerator"></a>BytesKeyGenerator</h4>
<div class="paragraph">
<p>Use the KeyGenerators.secureRandom factory methods to generate a BytesKeyGenerator backed by a SecureRandom instance:</p>
</div>
<div class="exampleblock">
<div class="title">Example 140. BytesKeyGenerator</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BytesKeyGenerator generator = KeyGenerators.secureRandom();
byte[] key = generator.generateKey();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val generator = KeyGenerators.secureRandom()
val key = generator.generateKey()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The default key length is 8 bytes.
There is also a KeyGenerators.secureRandom variant that provides control over the key length:</p>
</div>
<div class="exampleblock">
<div class="title">Example 141. KeyGenerators.secureRandom</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">KeyGenerators.secureRandom(16);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">KeyGenerators.secureRandom(16)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Use the KeyGenerators.shared factory method to construct a BytesKeyGenerator that always returns the same key on every invocation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 142. KeyGenerators.shared</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">KeyGenerators.shared(16);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">KeyGenerators.shared(16)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stringkeygenerator"><a class="anchor" href="#_stringkeygenerator"></a>StringKeyGenerator</h4>
<div class="paragraph">
<p>Use the KeyGenerators.string factory method to construct a 8-byte, SecureRandom KeyGenerator that hex-encodes each key as a String:</p>
</div>
<div class="exampleblock">
<div class="title">Example 143. StringKeyGenerator</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">KeyGenerators.string();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">KeyGenerators.string()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-passwordencoders"><a class="anchor" href="#spring-security-crypto-passwordencoders"></a>Password Encoding</h3>
<div class="paragraph">
<p>The password package of the spring-security-crypto module provides support for encoding passwords.
<code>PasswordEncoder</code> is the central service interface and has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface PasswordEncoder {

String encode(String rawPassword);

boolean matches(String rawPassword, String encodedPassword);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The matches method returns true if the rawPassword, once encoded, equals the encodedPassword.
This method is designed to support password-based authentication schemes.</p>
</div>
<div class="paragraph">
<p>The <code>BCryptPasswordEncoder</code> implementation uses the widely supported "bcrypt" algorithm to hash the passwords.
Bcrypt uses a random 16 byte salt value and is a deliberately slow algorithm, in order to hinder password crackers.
The amount of work it does can be tuned using the "strength" parameter which takes values from 4 to 31.
The higher the value, the more work has to be done to calculate the hash.
The default value is 10.
You can change this value in your deployed system without affecting existing passwords, as the value is also stored in the encoded hash.</p>
</div>
<div class="exampleblock">
<div class="title">Example 144. BCryptPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Create an encoder with strength 16
val encoder = BCryptPasswordEncoder(16)
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Pbkdf2PasswordEncoder</code> implementation uses PBKDF2 algorithm to hash the passwords.
In order to defeat password cracking PBKDF2 is a deliberately slow algorithm and should be tuned to take about .5 seconds to verify a password on your system.</p>
</div>
<div class="exampleblock">
<div class="title">Example 145. Pbkdf2PasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Create an encoder with all the defaults
val encoder = Pbkdf2PasswordEncoder()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix"><a class="anchor" href="#_appendix"></a>Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix-schema"><a class="anchor" href="#appendix-schema"></a>Security Database Schema</h3>
<div class="paragraph">
<p>There are various database schema used by the framework and this appendix provides a single reference point to them all.
You only need to provide the tables for the areas of functionality you require.</p>
</div>
<div class="paragraph">
<p>DDL statements are given for the HSQLDB database.
You can use these as a guideline for defining the schema for the database you are using.</p>
</div>
<div class="sect3">
<h4 id="_user_schema"><a class="anchor" href="#_user_schema"></a>User Schema</h4>
<div class="paragraph">
<p>The standard JDBC implementation of the <code>UserDetailsService</code> (<code>JdbcDaoImpl</code>) requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.
You will need to adjust this schema to match the database dialect you are using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(50) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_for_oracle_database"><a class="anchor" href="#_for_oracle_database"></a>For Oracle database</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_authorities"><a class="anchor" href="#_group_authorities"></a>Group Authorities</h5>
<div class="paragraph">
<p>Spring Security 2.0 introduced support for group authorities in <code>JdbcDaoImpl</code>.
The table structure if groups are enabled is as follows.
You will need to adjust this schema to match the database dialect you are using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that these tables are only required if you are using the provided JDBC <code>UserDetailsService</code> implementation.
If you write your own or choose to implement <code>AuthenticationProvider</code> without a <code>UserDetailsService</code>, then you have complete freedom over how you store the data, as long as the interface contract is satisfied.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_persistent_login_remember_me_schema"><a class="anchor" href="#_persistent_login_remember_me_schema"></a>Persistent Login (Remember-Me) Schema</h4>
<div class="paragraph">
<p>This table is used to store data used by the more secure <a href="#remember-me-persistent-token">persistent token</a> remember-me implementation.
If you are using <code>JdbcTokenRepositoryImpl</code> either directly or through the namespace, then you will need this table.
Remember to adjust this schema to match the database dialect you are using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">create table persistent_logins (
	username varchar(64) not null,
	series varchar(64) primary key,
	token varchar(64) not null,
	last_used timestamp not null
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dbschema-acl"><a class="anchor" href="#dbschema-acl"></a>ACL Schema</h4>
<div class="paragraph">
<p>There are four tables used by the Spring Security <a href="#domain-acls">ACL</a> implementation.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>acl_sid</code> stores the security identities recognised by the ACL system.
These can be unique principals or authorities which may apply to multiple principals.</p>
</li>
<li>
<p><code>acl_class</code> defines the domain object types to which ACLs apply.
The <code>class</code> column stores the Java class name of the object.</p>
</li>
<li>
<p><code>acl_object_identity</code> stores the object identity definitions of specific domain objects.</p>
</li>
<li>
<p><code>acl_entry</code> stores the ACL permissions which apply to a specific object identity and security identity.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is assumed that the database will auto-generate the primary keys for each of the identities.
The <code>JdbcMutableAclService</code> has to be able to retrieve these when it has created a new row in the <code>acl_sid</code> or <code>acl_class</code> tables.
It has two properties which define the SQL needed to retrieve these values <code>classIdentityQuery</code> and <code>sidIdentityQuery</code>.
Both of these default to <code>call identity()</code></p>
</div>
<div class="paragraph">
<p>The ACL artifact JAR contains files for creating the ACL schema in HyperSQL (HSQLDB), PostgreSQL, MySQL/MariaDB, Microsoft SQL Server, and Oracle Database.
These schemas are also demonstrated in the following sections.</p>
</div>
<div class="sect4">
<h5 id="_hypersql"><a class="anchor" href="#_hypersql"></a>HyperSQL</h5>
<div class="paragraph">
<p>The default schema works with the embedded HSQLDB database that is used in unit tests within the framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">create table acl_sid(
	id bigint generated by default as identity(start with 100) not null primary key,
	principal boolean not null,
	sid varchar_ignorecase(100) not null,
	constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
	id bigint generated by default as identity(start with 100) not null primary key,
	class varchar_ignorecase(100) not null,
	constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
	id bigint generated by default as identity(start with 100) not null primary key,
	object_id_class bigint not null,
	object_id_identity varchar_ignorecase(36) not null,
	parent_object bigint,
	owner_sid bigint,
	entries_inheriting boolean not null,
	constraint unique_uk_3 unique(object_id_class,object_id_identity),
	constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
	constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
	constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
	id bigint generated by default as identity(start with 100) not null primary key,
	acl_object_identity bigint not null,
	ace_order int not null,
	sid bigint not null,
	mask integer not null,
	granting boolean not null,
	audit_success boolean not null,
	audit_failure boolean not null,
	constraint unique_uk_4 unique(acl_object_identity,ace_order),
	constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
	constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_postgresql"><a class="anchor" href="#_postgresql"></a>PostgreSQL</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">create table acl_sid(
	id bigserial not null primary key,
	principal boolean not null,
	sid varchar(100) not null,
	constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
	id bigserial not null primary key,
	class varchar(100) not null,
	constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
	id bigserial primary key,
	object_id_class bigint not null,
	object_id_identity varchar(36) not null,
	parent_object bigint,
	owner_sid bigint,
	entries_inheriting boolean not null,
	constraint unique_uk_3 unique(object_id_class,object_id_identity),
	constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
	constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
	constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
	id bigserial primary key,
	acl_object_identity bigint not null,
	ace_order int not null,
	sid bigint not null,
	mask integer not null,
	granting boolean not null,
	audit_success boolean not null,
	audit_failure boolean not null,
	constraint unique_uk_4 unique(acl_object_identity,ace_order),
	constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
	constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will have to set the <code>classIdentityQuery</code> and <code>sidIdentityQuery</code> properties of <code>JdbcMutableAclService</code> to the following values, respectively:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_class', 'id'))</code></p>
</li>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_sid', 'id'))</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_mysql_and_mariadb"><a class="anchor" href="#_mysql_and_mariadb"></a>MySQL and MariaDB</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">CREATE TABLE acl_sid (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	principal BOOLEAN NOT NULL,
	sid VARCHAR(100) NOT NULL,
	UNIQUE KEY unique_acl_sid (sid, principal)
) ENGINE=InnoDB;

CREATE TABLE acl_class (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	class VARCHAR(100) NOT NULL,
	UNIQUE KEY uk_acl_class (class)
) ENGINE=InnoDB;

CREATE TABLE acl_object_identity (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	object_id_class BIGINT UNSIGNED NOT NULL,
	object_id_identity VARCHAR(36) NOT NULL,
	parent_object BIGINT UNSIGNED,
	owner_sid BIGINT UNSIGNED,
	entries_inheriting BOOLEAN NOT NULL,
	UNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity),
	CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
	CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;

CREATE TABLE acl_entry (
	id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
	acl_object_identity BIGINT UNSIGNED NOT NULL,
	ace_order INTEGER NOT NULL,
	sid BIGINT UNSIGNED NOT NULL,
	mask INTEGER UNSIGNED NOT NULL,
	granting BOOLEAN NOT NULL,
	audit_success BOOLEAN NOT NULL,
	audit_failure BOOLEAN NOT NULL,
	UNIQUE KEY unique_acl_entry (acl_object_identity, ace_order),
	CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_microsoft_sql_server"><a class="anchor" href="#_microsoft_sql_server"></a>Microsoft SQL Server</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">CREATE TABLE acl_sid (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	principal BIT NOT NULL,
	sid VARCHAR(100) NOT NULL,
	CONSTRAINT unique_acl_sid UNIQUE (sid, principal)
);

CREATE TABLE acl_class (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	class VARCHAR(100) NOT NULL,
	CONSTRAINT uk_acl_class UNIQUE (class)
);

CREATE TABLE acl_object_identity (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	object_id_class BIGINT NOT NULL,
	object_id_identity VARCHAR(36) NOT NULL,
	parent_object BIGINT,
	owner_sid BIGINT,
	entries_inheriting BIT NOT NULL,
	CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),
	CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
	CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
);

CREATE TABLE acl_entry (
	id BIGINT NOT NULL IDENTITY PRIMARY KEY,
	acl_object_identity BIGINT NOT NULL,
	ace_order INTEGER NOT NULL,
	sid BIGINT NOT NULL,
	mask INTEGER NOT NULL,
	granting BIT NOT NULL,
	audit_success BIT NOT NULL,
	audit_failure BIT NOT NULL,
	CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),
	CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
	CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_oracle_database"><a class="anchor" href="#_oracle_database"></a>Oracle Database</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">CREATE TABLE ACL_SID (
    ID NUMBER(18) PRIMARY KEY,
    PRINCIPAL NUMBER(1) NOT NULL CHECK (PRINCIPAL IN (0, 1 )),
    SID NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_SID_UNIQUE UNIQUE (SID, PRINCIPAL)
);
CREATE SEQUENCE ACL_SID_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_SID_SQ_TR BEFORE INSERT ON ACL_SID FOR EACH ROW
BEGIN
    SELECT ACL_SID_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_CLASS (
    ID NUMBER(18) PRIMARY KEY,
    CLASS NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_CLASS_UNIQUE UNIQUE (CLASS)
);
CREATE SEQUENCE ACL_CLASS_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_CLASS_ID_TR BEFORE INSERT ON ACL_CLASS FOR EACH ROW
BEGIN
    SELECT ACL_CLASS_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_OBJECT_IDENTITY(
    ID NUMBER(18) PRIMARY KEY,
    OBJECT_ID_CLASS NUMBER(18) NOT NULL,
    OBJECT_ID_IDENTITY NVARCHAR2(64) NOT NULL,
    PARENT_OBJECT NUMBER(18),
    OWNER_SID NUMBER(18),
    ENTRIES_INHERITING NUMBER(1) NOT NULL CHECK (ENTRIES_INHERITING IN (0, 1)),
    CONSTRAINT ACL_OBJECT_IDENTITY_UNIQUE UNIQUE (OBJECT_ID_CLASS, OBJECT_ID_IDENTITY),
    CONSTRAINT ACL_OBJECT_IDENTITY_PARENT_FK FOREIGN KEY (PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_CLASS_FK FOREIGN KEY (OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_OWNER_FK FOREIGN KEY (OWNER_SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_OBJECT_IDENTITY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_OBJECT_IDENTITY_ID_TR BEFORE INSERT ON ACL_OBJECT_IDENTITY FOR EACH ROW
BEGIN
    SELECT ACL_OBJECT_IDENTITY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_ENTRY (
    ID NUMBER(18) NOT NULL PRIMARY KEY,
    ACL_OBJECT_IDENTITY NUMBER(18) NOT NULL,
    ACE_ORDER INTEGER NOT NULL,
    SID NUMBER(18) NOT NULL,
    MASK INTEGER NOT NULL,
    GRANTING NUMBER(1) NOT NULL CHECK (GRANTING IN (0, 1)),
    AUDIT_SUCCESS NUMBER(1) NOT NULL CHECK (AUDIT_SUCCESS IN (0, 1)),
    AUDIT_FAILURE NUMBER(1) NOT NULL CHECK (AUDIT_FAILURE IN (0, 1)),
    CONSTRAINT ACL_ENTRY_UNIQUE UNIQUE (ACL_OBJECT_IDENTITY, ACE_ORDER),
    CONSTRAINT ACL_ENTRY_OBJECT_FK FOREIGN KEY (ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY (ID),
    CONSTRAINT ACL_ENTRY_ACL_FK FOREIGN KEY (SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_ENTRY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_ENTRY_ID_TRIGGER BEFORE INSERT ON ACL_ENTRY FOR EACH ROW
BEGIN
    SELECT ACL_ENTRY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dbschema-oauth2-client"><a class="anchor" href="#dbschema-oauth2-client"></a>OAuth 2.0 Client Schema</h4>
<div class="paragraph">
<p>The JDBC implementation of <a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientService</a> (<code>JdbcOAuth2AuthorizedClientService</code>) requires a table for persisting <code>OAuth2AuthorizedClient</code>(s).
You will need to adjust this schema to match the database dialect you are using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">CREATE TABLE oauth2_authorized_client (
  client_registration_id varchar(100) NOT NULL,
  principal_name varchar(200) NOT NULL,
  access_token_type varchar(100) NOT NULL,
  access_token_value blob NOT NULL,
  access_token_issued_at timestamp NOT NULL,
  access_token_expires_at timestamp NOT NULL,
  access_token_scopes varchar(1000) DEFAULT NULL,
  refresh_token_value blob DEFAULT NULL,
  refresh_token_issued_at timestamp DEFAULT NULL,
  created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
  PRIMARY KEY (client_registration_id, principal_name)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-namespace"><a class="anchor" href="#appendix-namespace"></a>The Security Namespace</h3>
<div class="paragraph">
<p>This appendix provides a reference to the elements available in the security namespace and information on the underlying beans they create (a knowledge of the individual classes and how they work together is assumed - you can find more information in the project Javadoc and elsewhere in this document).
If you haven&#8217;t used the namespace before, please read the <a href="#ns-config">introductory chapter</a> on namespace configuration, as this is intended as a supplement to the information there.
Using a good quality XML editor while editing a configuration based on the schema is recommended as this will provide contextual information on which elements and attributes are available as well as comments explaining their purpose.
The namespace is written in <a href="https://relaxng.org/">RELAX NG</a> Compact format and later converted into an XSD schema.
If you are familiar with this format, you may wish to examine the <a href="https://raw.githubusercontent.com/spring-projects/spring-security/main/config/src/main/resources/org/springframework/security/config/spring-security-4.1.rnc">schema file</a> directly.</p>
</div>
<div class="sect3">
<h4 id="nsa-web"><a class="anchor" href="#nsa-web"></a>Web Application Security</h4>
<div class="sect4">
<h5 id="nsa-debug"><a class="anchor" href="#nsa-debug"></a>&lt;debug&gt;</h5>
<div class="paragraph">
<p>Enables Spring Security debugging infrastructure.
This will provide human-readable (multi-line) debugging information to monitor requests coming into the security filters.
This may include sensitive information, such as request parameters or headers, and should only be used in a development environment.</p>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http"><a class="anchor" href="#nsa-http"></a>&lt;http&gt;</h5>
<div class="paragraph">
<p>If you use an <code>&lt;http&gt;</code> element within your application, a <code>FilterChainProxy</code> bean named "springSecurityFilterChain" is created and the configuration within the element is used to build a filter chain within
<code>FilterChainProxy</code>.
As of Spring Security 3.1, additional <code>http</code> elements can be used to add extra filter chains <sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup>.
Some core filters are always created in a filter chain and others will be added to the stack depending on the attributes and child elements which are present.
The positions of the standard filters are fixed (see
<a href="#filter-stack">the filter order table</a> in the namespace introduction), removing a common source of errors with previous versions of the framework when users had to configure the filter chain explicitly in the
<code>FilterChainProxy</code> bean.
You can, of course, still do this if you need full control of the configuration.</p>
</div>
<div class="paragraph">
<p>All filters which require a reference to the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> will be automatically injected with the internal instance created by the namespace configuration.</p>
</div>
<div class="paragraph">
<p>Each <code>&lt;http&gt;</code> namespace block always creates an <code>SecurityContextPersistenceFilter</code>, an <code>ExceptionTranslationFilter</code> and a <code>FilterSecurityInterceptor</code>.
These are fixed and cannot be replaced with alternatives.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-attributes"><a class="anchor" href="#nsa-http-attributes"></a>&lt;http&gt; Attributes</h6>
<div class="paragraph">
<p>The attributes on the <code>&lt;http&gt;</code> element control some of the properties on the core filters.</p>
</div>
<div id="nsa-http-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
Optional attribute specifying the ID of the <code>AccessDecisionManager</code> implementation which should be used for authorizing HTTP requests.
By default an <code>AffirmativeBased</code> implementation is used for with a <code>RoleVoter</code> and an <code>AuthenticatedVoter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
A reference to the <code>AuthenticationManager</code> used for the <code>FilterChain</code> created by this http element.</p>
</li>
</ul>
</div>
<div id="nsa-http-auto-config" class="ulist">
<ul>
<li>
<p><strong>auto-config</strong>
Automatically registers a login form, BASIC authentication, logout services.
If set to "true", all of these capabilities are added (although you can still customize the configuration of each by providing the respective element).
If unspecified, defaults to "false".
Use of this attribute is not recommended.
Use explicit configuration elements instead to avoid confusion.</p>
</li>
</ul>
</div>
<div id="nsa-http-create-session" class="ulist">
<ul>
<li>
<p><strong>create-session</strong>
Controls the eagerness with which an HTTP session is created by Spring Security classes.
Options include:</p>
<div class="ulist">
<ul>
<li>
<p><code>always</code> - Spring Security will proactively create a session if one does not exist.</p>
</li>
<li>
<p><code>ifRequired</code> - Spring Security will only create a session only if one is required (default value).</p>
</li>
<li>
<p><code>never</code> - Spring Security will never create a session, but will make use of one if the application does.</p>
</li>
<li>
<p><code>stateless</code> - Spring Security will not create a session and ignore the session for obtaining a Spring <code>Authentication</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="nsa-http-disable-url-rewriting" class="ulist">
<ul>
<li>
<p><strong>disable-url-rewriting</strong>
Prevents session IDs from being appended to URLs in the application.
Clients must use cookies if this attribute is set to <code>true</code>.
The default is <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
Normally the <code>AuthenticationEntryPoint</code> used will be set depending on which authentication mechanisms have been configured.
This attribute allows this behaviour to be overridden by defining a customized <code>AuthenticationEntryPoint</code> bean which will start the authentication process.</p>
</li>
</ul>
</div>
<div id="nsa-http-jaas-api-provision" class="ulist">
<ul>
<li>
<p><strong>jaas-api-provision</strong>
If available, runs the request as the <code>Subject</code> acquired from the <code>JaasAuthenticationToken</code> which is implemented by adding a <code>JaasApiIntegrationFilter</code> bean to the stack.
Defaults to <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-http-once-per-request" class="ulist">
<ul>
<li>
<p><strong>once-per-request</strong>
Corresponds to the <code>observeOncePerRequest</code> property of <code>FilterSecurityInterceptor</code>.
Defaults to <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
Defining a pattern for the <a href="#nsa-http">http</a> element controls the requests which will be filtered through the list of filters which it defines.
The interpretation is dependent on the configured <a href="#nsa-http-request-matcher">request-matcher</a>.
If no pattern is defined, all requests will be matched, so the most specific patterns should be declared first.</p>
</li>
</ul>
</div>
<div id="nsa-http-realm" class="ulist">
<ul>
<li>
<p><strong>realm</strong>
Sets the realm name used for basic authentication (if enabled).
Corresponds to the <code>realmName</code> property on <code>BasicAuthenticationEntryPoint</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
Defines the <code>RequestMatcher</code> strategy used in the <code>FilterChainProxy</code> and the beans created by the <code>intercept-url</code> to match incoming requests.
Options are currently <code>mvc</code>, <code>ant</code>, <code>regex</code> and <code>ciRegex</code>, for Spring MVC, ant, regular-expression and case-insensitive regular-expression respectively.
A separate instance is created for each <a href="#nsa-intercept-url">intercept-url</a> element using its <a href="#nsa-intercept-url-pattern">pattern</a>, <a href="#nsa-intercept-url-method">method</a> and <a href="#nsa-intercept-url-servlet-path">servlet-path</a> attributes.
Ant paths are matched using an <code>AntPathRequestMatcher</code>, regular expressions are matched using a <code>RegexRequestMatcher</code> and for Spring MVC path matching the <code>MvcRequestMatcher</code> is used.
See the Javadoc for these classes for more details on exactly how the matching is performed.
Ant paths are the default strategy.</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
A reference to a bean that implements <code>RequestMatcher</code> that will determine if this <code>FilterChain</code> should be used.
This is a more powerful alternative to <a href="#nsa-http-pattern">pattern</a>.</p>
</li>
</ul>
</div>
<div id="nsa-http-security" class="ulist">
<ul>
<li>
<p><strong>security</strong>
A request pattern can be mapped to an empty filter chain, by setting this attribute to <code>none</code>.
No security will be applied and none of Spring Security&#8217;s features will be available.</p>
</li>
</ul>
</div>
<div id="nsa-http-security-context-repository-ref" class="ulist">
<ul>
<li>
<p><strong>security-context-repository-ref</strong>
Allows injection of a custom <code>SecurityContextRepository</code> into the <code>SecurityContextPersistenceFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-servlet-api-provision" class="ulist">
<ul>
<li>
<p><strong>servlet-api-provision</strong>
Provides versions of <code>HttpServletRequest</code> security methods such as <code>isUserInRole()</code> and <code>getPrincipal()</code> which are implemented by adding a <code>SecurityContextHolderAwareRequestFilter</code> bean to the stack.
Defaults to <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
Enables EL-expressions in the <code>access</code> attribute, as described in the chapter on <a href="#el-access-web">expression-based access-control</a>.
The default value is true.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-http-children"><a class="anchor" href="#nsa-http-children"></a>Child Elements of &lt;http&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-access-denied-handler">access-denied-handler</a></p>
</li>
<li>
<p><a href="#nsa-anonymous">anonymous</a></p>
</li>
<li>
<p><a href="#nsa-cors">cors</a></p>
</li>
<li>
<p><a href="#nsa-csrf">csrf</a></p>
</li>
<li>
<p><a href="#nsa-custom-filter">custom-filter</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-form-login">form-login</a></p>
</li>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
<li>
<p><a href="#nsa-http-basic">http-basic</a></p>
</li>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
<li>
<p><a href="#nsa-jee">jee</a></p>
</li>
<li>
<p><a href="#nsa-logout">logout</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-client">oauth2-client</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-login">oauth2-login</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
<li>
<p><a href="#nsa-remember-me">remember-me</a></p>
</li>
<li>
<p><a href="#nsa-request-cache">request-cache</a></p>
</li>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
<li>
<p><a href="#nsa-x509">x509</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-access-denied-handler"><a class="anchor" href="#nsa-access-denied-handler"></a>&lt;access-denied-handler&gt;</h5>
<div class="paragraph">
<p>This element allows you to set the <code>errorPage</code> property for the default <code>AccessDeniedHandler</code> used by the <code>ExceptionTranslationFilter</code>, using the <a href="#nsa-access-denied-handler-error-page">error-page</a> attribute, or to supply your own implementation using the<a href="#nsa-access-denied-handler-ref">ref</a> attribute.
This is discussed in more detail in the section on the <a href="#servlet-exceptiontranslationfilter">ExceptionTranslationFilter</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-access-denied-handler-parents"><a class="anchor" href="#nsa-access-denied-handler-parents"></a>Parent Elements of &lt;access-denied-handler&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-access-denied-handler-attributes"><a class="anchor" href="#nsa-access-denied-handler-attributes"></a>&lt;access-denied-handler&gt; Attributes</h6>
<div id="nsa-access-denied-handler-error-page" class="ulist">
<ul>
<li>
<p><strong>error-page</strong>
The access denied page that an authenticated user will be redirected to if they request a page which they don&#8217;t have the authority to access.</p>
</li>
</ul>
</div>
<div id="nsa-access-denied-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean of type <code>AccessDeniedHandler</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cors"><a class="anchor" href="#nsa-cors"></a>&lt;cors&gt;</h5>
<div class="paragraph">
<p>This element allows for configuring a <code>CorsFilter</code>.
If no <code>CorsFilter</code> or <code>CorsConfigurationSource</code> is specified and Spring MVC is on the classpath, a <code>HandlerMappingIntrospector</code> is used as the <code>CorsConfigurationSource</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-cors-attributes"><a class="anchor" href="#nsa-cors-attributes"></a>&lt;cors&gt; Attributes</h6>
<div class="paragraph">
<p>The attributes on the <code>&lt;cors&gt;</code> element control the headers element.</p>
</div>
<div id="nsa-cors-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Optional attribute that specifies the bean name of a <code>CorsFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-cors-configuration-source-ref" class="ulist">
<ul>
<li>
<p><strong>cors-configuration-source-ref</strong>
Optional attribute that specifies the bean name of a <code>CorsConfigurationSource</code> to be injected into a <code>CorsFilter</code> created by the XML namespace.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-cors-parents"><a class="anchor" href="#nsa-cors-parents"></a>Parent Elements of &lt;cors&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-headers"><a class="anchor" href="#nsa-headers"></a>&lt;headers&gt;</h5>
<div class="paragraph">
<p>This element allows for configuring additional (security) headers to be send with the response.
It enables easy configuration for several headers and also allows for setting custom headers through the <a href="#nsa-header">header</a> element.
Additional information, can be found in the <a href="#headers">Security Headers</a> section of the reference.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cache-Control</code>, <code>Pragma</code>, and <code>Expires</code> - Can be set using the <a href="#nsa-cache-control">cache-control</a> element.
This ensures that the browser does not cache your secured pages.</p>
</li>
<li>
<p><code>Strict-Transport-Security</code> - Can be set using the <a href="#nsa-hsts">hsts</a> element.
This ensures that the browser automatically requests HTTPS for future requests.</p>
</li>
<li>
<p><code>X-Frame-Options</code> - Can be set using the <a href="#nsa-frame-options">frame-options</a> element.
The <a href="https://en.wikipedia.org/wiki/Clickjacking#X-Frame-Options">X-Frame-Options</a> header can be used to prevent clickjacking attacks.</p>
</li>
<li>
<p><code>X-XSS-Protection</code> - Can be set using the <a href="#nsa-xss-protection">xss-protection</a> element.
The <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">X-XSS-Protection </a> header can be used by browser to do basic control.</p>
</li>
<li>
<p><code>X-Content-Type-Options</code> - Can be set using the <a href="#nsa-content-type-options">content-type-options</a> element.
The <a href="https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">X-Content-Type-Options</a> header prevents Internet Explorer from MIME-sniffing a response away from the declared content-type.
This also applies to Google Chrome, when downloading extensions.</p>
</li>
<li>
<p><code>Public-Key-Pinning</code> or <code>Public-Key-Pinning-Report-Only</code> - Can be set using the <a href="#nsa-hpkp">hpkp</a> element.
This allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates.</p>
</li>
<li>
<p><code>Content-Security-Policy</code> or <code>Content-Security-Policy-Report-Only</code> - Can be set using the <a href="#nsa-content-security-policy">content-security-policy</a> element.
<a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).</p>
</li>
<li>
<p><code>Referrer-Policy</code> - Can be set using the <a href="#nsa-referrer-policy">referrer-policy</a> element, <a href="https://www.w3.org/TR/referrer-policy/">Referrer-Policy</a> is a mechanism that web applications can leverage to manage the referrer field, which contains the last page the user was on.</p>
</li>
<li>
<p><code>Feature-Policy</code> - Can be set using the <a href="#nsa-feature-policy">feature-policy</a> element, <a href="https://wicg.github.io/feature-policy/">Feature-Policy</a> is a mechanism that allows web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="nsa-headers-attributes"><a class="anchor" href="#nsa-headers-attributes"></a>&lt;headers&gt; Attributes</h6>
<div class="paragraph">
<p>The attributes on the <code>&lt;headers&gt;</code> element control the headers element.</p>
</div>
<div id="nsa-headers-defaults-disabled" class="ulist">
<ul>
<li>
<p><strong>defaults-disabled</strong>
Optional attribute that specifies to disable the default Spring Security&#8217;s HTTP response headers.
The default is false (the default headers are included).</p>
</li>
</ul>
</div>
<div id="nsa-headers-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Optional attribute that specifies to disable Spring Security&#8217;s HTTP response headers.
The default is false (the headers are enabled).</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-headers-parents"><a class="anchor" href="#nsa-headers-parents"></a>Parent Elements of &lt;headers&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-headers-children"><a class="anchor" href="#nsa-headers-children"></a>Child Elements of &lt;headers&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-cache-control">cache-control</a></p>
</li>
<li>
<p><a href="#nsa-content-security-policy">content-security-policy</a></p>
</li>
<li>
<p><a href="#nsa-content-type-options">content-type-options</a></p>
</li>
<li>
<p><a href="#nsa-feature-policy">feature-policy</a></p>
</li>
<li>
<p><a href="#nsa-frame-options">frame-options</a></p>
</li>
<li>
<p><a href="#nsa-header">header</a></p>
</li>
<li>
<p><a href="#nsa-hpkp">hpkp</a></p>
</li>
<li>
<p><a href="#nsa-hsts">hsts</a></p>
</li>
<li>
<p><a href="#nsa-permissions-policy">permission-policy</a></p>
</li>
<li>
<p><a href="#nsa-referrer-policy">referrer-policy</a></p>
</li>
<li>
<p><a href="#nsa-xss-protection">xss-protection</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cache-control"><a class="anchor" href="#nsa-cache-control"></a>&lt;cache-control&gt;</h5>
<div class="paragraph">
<p>Adds <code>Cache-Control</code>, <code>Pragma</code>, and <code>Expires</code> headers to ensure that the browser does not cache your secured pages.</p>
</div>
<div class="sect5">
<h6 id="nsa-cache-control-attributes"><a class="anchor" href="#nsa-cache-control-attributes"></a>&lt;cache-control&gt; Attributes</h6>
<div id="nsa-cache-control-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Specifies if Cache Control should be disabled.
Default false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-cache-control-parents"><a class="anchor" href="#nsa-cache-control-parents"></a>Parent Elements of &lt;cache-control&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hsts"><a class="anchor" href="#nsa-hsts"></a>&lt;hsts&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://tools.ietf.org/html/rfc6797">Strict-Transport-Security</a> header to the response for any secure request.
This allows the server to instruct browsers to automatically use HTTPS for future requests.</p>
</div>
<div class="sect5">
<h6 id="nsa-hsts-attributes"><a class="anchor" href="#nsa-hsts-attributes"></a>&lt;hsts&gt; Attributes</h6>
<div id="nsa-hsts-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Specifies if Strict-Transport-Security should be disabled.
Default false.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
Specifies if subdomains should be included.
Default true.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
Specifies the maximum amount of time the host should be considered a Known HSTS Host.
Default one year.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
The RequestMatcher instance to be used to determine if the header should be set.
Default is if HttpServletRequest.isSecure() is true.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-preload" class="ulist">
<ul>
<li>
<p><strong>preload</strong>
Specifies if preload should be included.
Default false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-hsts-parents"><a class="anchor" href="#nsa-hsts-parents"></a>Parent Elements of &lt;hsts&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hpkp"><a class="anchor" href="#nsa-hpkp"></a>&lt;hpkp&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://tools.ietf.org/html/rfc7469">Public Key Pinning Extension for HTTP</a> header to the response for any secure request.
This allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates.</p>
</div>
<div class="sect5">
<h6 id="nsa-hpkp-attributes"><a class="anchor" href="#nsa-hpkp-attributes"></a>&lt;hpkp&gt; Attributes</h6>
<div id="nsa-hpkp-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Specifies if HTTP Public Key Pinning (HPKP) should be disabled.
Default true.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
Specifies if subdomains should be included.
Default false.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
Sets the value for the max-age directive of the Public-Key-Pins header.
Default 60 days.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
Specifies if the browser should only report pin validation failures.
Default true.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-uri" class="ulist">
<ul>
<li>
<p><strong>report-uri</strong>
Specifies the URI to which the browser should report pin validation failures.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-hpkp-parents"><a class="anchor" href="#nsa-hpkp-parents"></a>Parent Elements of &lt;hpkp&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pins"><a class="anchor" href="#nsa-pins"></a>&lt;pins&gt;</h5>
<div class="paragraph">
<p>The list of pins</p>
</div>
<div class="sect5">
<h6 id="nsa-pins-children"><a class="anchor" href="#nsa-pins-children"></a>Child Elements of &lt;pins&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pin">pin</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pin"><a class="anchor" href="#nsa-pin"></a>&lt;pin&gt;</h5>
<div class="paragraph">
<p>A pin is specified using the base64-encoded SPKI fingerprint as value and the cryptographic hash algorithm as attribute</p>
</div>
<div class="sect5">
<h6 id="nsa-pin-attributes"><a class="anchor" href="#nsa-pin-attributes"></a>&lt;pin&gt; Attributes</h6>
<div id="nsa-pin-algorithm" class="ulist">
<ul>
<li>
<p><strong>algorithm</strong>
The cryptographic hash algorithm.
Default is SHA256.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pin-parents"><a class="anchor" href="#nsa-pin-parents"></a>Parent Elements of &lt;pin&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pins">pins</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-security-policy"><a class="anchor" href="#nsa-content-security-policy"></a>&lt;content-security-policy&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> header to the response.
CSP is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).</p>
</div>
<div class="sect5">
<h6 id="nsa-content-security-policy-attributes"><a class="anchor" href="#nsa-content-security-policy-attributes"></a>&lt;content-security-policy&gt; Attributes</h6>
<div id="nsa-content-security-policy-policy-directives" class="ulist">
<ul>
<li>
<p><strong>policy-directives</strong>
The security policy directive(s) for the Content-Security-Policy header or if report-only is set to true, then the Content-Security-Policy-Report-Only header is used.</p>
</li>
</ul>
</div>
<div id="nsa-content-security-policy-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
Set to true, to enable the Content-Security-Policy-Report-Only header for reporting policy violations only.
Defaults to false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-content-security-policy-parents"><a class="anchor" href="#nsa-content-security-policy-parents"></a>Parent Elements of &lt;content-security-policy&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-referrer-policy"><a class="anchor" href="#nsa-referrer-policy"></a>&lt;referrer-policy&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://www.w3.org/TR/referrer-policy/">Referrer Policy</a> header to the response.</p>
</div>
<div class="sect5">
<h6 id="nsa-referrer-policy-attributes"><a class="anchor" href="#nsa-referrer-policy-attributes"></a>&lt;referrer-policy&gt; Attributes</h6>
<div id="nsa-referrer-policy-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong>
The policy for the Referrer-Policy header.
Default "no-referrer".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-referrer-policy-parents"><a class="anchor" href="#nsa-referrer-policy-parents"></a>Parent Elements of &lt;referrer-policy&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-feature-policy"><a class="anchor" href="#nsa-feature-policy"></a>&lt;feature-policy&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://wicg.github.io/feature-policy/">Feature Policy</a> header to the response.</p>
</div>
<div class="sect5">
<h6 id="nsa-feature-policy-attributes"><a class="anchor" href="#nsa-feature-policy-attributes"></a>&lt;feature-policy&gt; Attributes</h6>
<div id="nsa-feature-policy-policy-directives" class="ulist">
<ul>
<li>
<p><strong>policy-directives</strong>
The security policy directive(s) for the Feature-Policy header.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-feature-policy-parents"><a class="anchor" href="#nsa-feature-policy-parents"></a>Parent Elements of &lt;feature-policy&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-frame-options"><a class="anchor" href="#nsa-frame-options"></a>&lt;frame-options&gt;</h5>
<div class="paragraph">
<p>When enabled adds the <a href="https://tools.ietf.org/html/draft-ietf-websec-x-frame-options">X-Frame-Options header</a> to the response, this allows newer browsers to do some security checks and prevent <a href="https://en.wikipedia.org/wiki/Clickjacking">clickjacking</a> attacks.</p>
</div>
<div class="sect5">
<h6 id="nsa-frame-options-attributes"><a class="anchor" href="#nsa-frame-options-attributes"></a>&lt;frame-options&gt; Attributes</h6>
<div id="nsa-frame-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
If disabled, the X-Frame-Options header will not be included.
Default false.</p>
</li>
</ul>
</div>
<div id="nsa-frame-options-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong></p>
<div class="ulist">
<ul>
<li>
<p><code>DENY</code> The page cannot be displayed in a frame, regardless of the site attempting to do so.
This is the default when frame-options-policy is specified.</p>
</li>
<li>
<p><code>SAMEORIGIN</code> The page can only be displayed in a frame on the same origin as the page itself</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, if you specify DENY, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site.
On the other hand, if you specify SAMEORIGIN, you can still use the page in a frame as long as the site including it in a frame it is the same as the one serving the page.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-frame-options-parents"><a class="anchor" href="#nsa-frame-options-parents"></a>Parent Elements of &lt;frame-options&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-permissions-policy"><a class="anchor" href="#nsa-permissions-policy"></a>&lt;permissions-policy&gt;</h5>
<div class="paragraph">
<p>Adds the <a href="https://w3c.github.io/webappsec-permissions-policy/">Permissions-Policy header</a> to the response.</p>
</div>
<div class="sect5">
<h6 id="nsa-permissions-policy-attributes"><a class="anchor" href="#nsa-permissions-policy-attributes"></a>&lt;permissions-policy&gt; Attributes</h6>
<div id="nsa-permissions-policy-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong>
The policy value to write for the <code>Permissions-Policy</code> header</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-permissions-policy-parents"><a class="anchor" href="#nsa-permissions-policy-parents"></a>Parent Elements of &lt;permissions-policy&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-xss-protection"><a class="anchor" href="#nsa-xss-protection"></a>&lt;xss-protection&gt;</h5>
<div class="paragraph">
<p>Adds the <a href="https://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx">X-XSS-Protection header</a> to the response to assist in protecting against <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> attacks.
This is in no-way a full protection to XSS attacks!</p>
</div>
<div class="sect5">
<h6 id="nsa-xss-protection-attributes"><a class="anchor" href="#nsa-xss-protection-attributes"></a>&lt;xss-protection&gt; Attributes</h6>
<div id="nsa-xss-protection-disabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-disabled</strong>
Do not include the header for <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> protection.</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-enabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-enabled</strong>
Explicitly enable or disable <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> protection.</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-block" class="ulist">
<ul>
<li>
<p><strong>xss-protection-block</strong>
When true and xss-protection-enabled is true, adds mode=block to the header.
This indicates to the browser that the page should not be loaded at all.
When false and xss-protection-enabled is true, the page will still be rendered when an reflected attack is detected but the response will be modified to protect against the attack.
Note that there are sometimes ways of bypassing this mode which can often times make blocking the page more desirable.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-xss-protection-parents"><a class="anchor" href="#nsa-xss-protection-parents"></a>Parent Elements of &lt;xss-protection&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-type-options"><a class="anchor" href="#nsa-content-type-options"></a>&lt;content-type-options&gt;</h5>
<div class="paragraph">
<p>Add the X-Content-Type-Options header with the value of nosniff to the response.
This <a href="https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">disables MIME-sniffing</a> for IE8+ and Chrome extensions.</p>
</div>
<div class="sect5">
<h6 id="nsa-content-type-options-attributes"><a class="anchor" href="#nsa-content-type-options-attributes"></a>&lt;content-type-options&gt; Attributes</h6>
<div id="nsa-content-type-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Specifies if Content Type Options should be disabled.
Default false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-content-type-options-parents"><a class="anchor" href="#nsa-content-type-options-parents"></a>Parent Elements of &lt;content-type-options&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-header"><a class="anchor" href="#nsa-header"></a>&lt;header&gt;</h5>
<div class="paragraph">
<p>Add additional headers to the response, both the name and value need to be specified.</p>
</div>
<div class="sect5">
<h6 id="nsa-header-attributes"><a class="anchor" href="#nsa-header-attributes"></a>&lt;header-attributes&gt; Attributes</h6>
<div id="nsa-header-name" class="ulist">
<ul>
<li>
<p><strong>header-name</strong>
The <code>name</code> of the header.</p>
</li>
</ul>
</div>
<div id="nsa-header-value" class="ulist">
<ul>
<li>
<p><strong>value</strong>
The <code>value</code> of the header to add.</p>
</li>
</ul>
</div>
<div id="nsa-header-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Reference to a custom implementation of the <code>HeaderWriter</code> interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-header-parents"><a class="anchor" href="#nsa-header-parents"></a>Parent Elements of &lt;header&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-anonymous"><a class="anchor" href="#nsa-anonymous"></a>&lt;anonymous&gt;</h5>
<div class="paragraph">
<p>Adds an <code>AnonymousAuthenticationFilter</code> to the stack and an <code>AnonymousAuthenticationProvider</code>.
Required if you are using the <code>IS_AUTHENTICATED_ANONYMOUSLY</code> attribute.</p>
</div>
<div class="sect5">
<h6 id="nsa-anonymous-parents"><a class="anchor" href="#nsa-anonymous-parents"></a>Parent Elements of &lt;anonymous&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-anonymous-attributes"><a class="anchor" href="#nsa-anonymous-attributes"></a>&lt;anonymous&gt; Attributes</h6>
<div id="nsa-anonymous-enabled" class="ulist">
<ul>
<li>
<p><strong>enabled</strong>
With the default namespace setup, the anonymous "authentication" facility is automatically enabled.
You can disable it using this property.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-granted-authority" class="ulist">
<ul>
<li>
<p><strong>granted-authority</strong>
The granted authority that should be assigned to the anonymous request.
Commonly this is used to assign the anonymous request particular roles, which can subsequently be used in authorization decisions.
If unset, defaults to <code>ROLE_ANONYMOUS</code>.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
The key shared between the provider and filter.
This generally does not need to be set.
If unset, it will default to a secure randomly generated value.
This means setting this value can improve startup time when using the anonymous functionality since secure random values can take a while to be generated.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-username" class="ulist">
<ul>
<li>
<p><strong>username</strong>
The username that should be assigned to the anonymous request.
This allows the principal to be identified, which may be important for logging and auditing.
if unset, defaults to <code>anonymousUser</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-csrf"><a class="anchor" href="#nsa-csrf"></a>&lt;csrf&gt;</h5>
<div class="paragraph">
<p>This element will add <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross Site Request Forger (CSRF)</a> protection to the application.
It also updates the default RequestCache to only replay "GET" requests upon successful authentication.
Additional information can be found in the <a href="#csrf">Cross Site Request Forgery (CSRF)</a> section of the reference.</p>
</div>
<div class="sect5">
<h6 id="nsa-csrf-parents"><a class="anchor" href="#nsa-csrf-parents"></a>Parent Elements of &lt;csrf&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-csrf-attributes"><a class="anchor" href="#nsa-csrf-attributes"></a>&lt;csrf&gt; Attributes</h6>
<div id="nsa-csrf-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Optional attribute that specifies to disable Spring Security&#8217;s CSRF protection.
The default is false (CSRF protection is enabled).
It is highly recommended to leave CSRF protection enabled.</p>
</li>
</ul>
</div>
<div id="nsa-csrf-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
The CsrfTokenRepository to use.
The default is <code>HttpSessionCsrfTokenRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-csrf-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
The RequestMatcher instance to be used to determine if CSRF should be applied.
Default is any HTTP method except "GET", "TRACE", "HEAD", "OPTIONS".</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-custom-filter"><a class="anchor" href="#nsa-custom-filter"></a>&lt;custom-filter&gt;</h5>
<div class="paragraph">
<p>This element is used to add a filter to the filter chain.
It doesn&#8217;t create any additional beans but is used to select a bean of type <code>javax.servlet.Filter</code> which is already defined in the application context and add that at a particular position in the filter chain maintained by Spring Security.
Full details can be found in the <a href="#ns-custom-filters">namespace chapter</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-custom-filter-parents"><a class="anchor" href="#nsa-custom-filter-parents"></a>Parent Elements of &lt;custom-filter&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-custom-filter-attributes"><a class="anchor" href="#nsa-custom-filter-attributes"></a>&lt;custom-filter&gt; Attributes</h6>
<div id="nsa-custom-filter-after" class="ulist">
<ul>
<li>
<p><strong>after</strong>
The filter immediately after which the custom-filter should be placed in the chain.
This feature will only be needed by advanced users who wish to mix their own filters into the security filter chain and have some knowledge of the standard Spring Security filters.
The filter names map to specific Spring Security implementation filters.</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-before" class="ulist">
<ul>
<li>
<p><strong>before</strong>
The filter immediately before which the custom-filter should be placed in the chain</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-position" class="ulist">
<ul>
<li>
<p><strong>position</strong>
The explicit position at which the custom-filter should be placed in the chain.
Use if you are replacing a standard filter.</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>Filter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-expression-handler"><a class="anchor" href="#nsa-expression-handler"></a>&lt;expression-handler&gt;</h5>
<div class="paragraph">
<p>Defines the <code>SecurityExpressionHandler</code> instance which will be used if expression-based access-control is enabled.
A default implementation (with no ACL support) will be used if not supplied.</p>
</div>
<div class="sect5">
<h6 id="nsa-expression-handler-parents"><a class="anchor" href="#nsa-expression-handler-parents"></a>Parent Elements of &lt;expression-handler&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
<li>
<p><a href="#nsa-method-security">method-security</a></p>
</li>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-expression-handler-attributes"><a class="anchor" href="#nsa-expression-handler-attributes"></a>&lt;expression-handler&gt; Attributes</h6>
<div id="nsa-expression-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>SecurityExpressionHandler</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-form-login"><a class="anchor" href="#nsa-form-login"></a>&lt;form-login&gt;</h5>
<div class="paragraph">
<p>Used to add an <code>UsernamePasswordAuthenticationFilter</code> to the filter stack and an <code>LoginUrlAuthenticationEntryPoint</code> to the application context to provide authentication on demand.
This will always take precedence over other namespace-created entry points.
If no attributes are supplied, a login page will be generated automatically at the URL "/login" <sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup> The behaviour can be customized using the <a href="#nsa-form-login-attributes"><code>&lt;form-login&gt;</code> Attributes</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-form-login-parents"><a class="anchor" href="#nsa-form-login-parents"></a>Parent Elements of &lt;form-login&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-form-login-attributes"><a class="anchor" href="#nsa-form-login-attributes"></a>&lt;form-login&gt; Attributes</h6>
<div id="nsa-form-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>always-use-default-target</strong>
If set to <code>true</code>, the user will always start at the value given by <a href="#nsa-form-login-default-target-url">default-target-url</a>, regardless of how they arrived at the login page.
Maps to the <code>alwaysUseDefaultTargetUrl</code> property of <code>UsernamePasswordAuthenticationFilter</code>.
Default value is <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
Reference to an <code>AuthenticationDetailsSource</code> which will be used by the authentication filter</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
Can be used as an alternative to <a href="#nsa-form-login-authentication-failure-url">authentication-failure-url</a>, giving you full control over the navigation flow after an authentication failure.
The value should be the name of an <code>AuthenticationFailureHandler</code> bean in the application context.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
Maps to the <code>authenticationFailureUrl</code> property of <code>UsernamePasswordAuthenticationFilter</code>.
Defines the URL the browser will be redirected to on login failure.
Defaults to <code>/login?error</code>, which will be automatically handled by the automatic login page generator, re-rendering the login page with an error message.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
This can be used as an alternative to <a href="#nsa-form-login-default-target-url">default-target-url</a> and <a href="#nsa-form-login-always-use-default-target">always-use-default-target</a>, giving you full control over the navigation flow after a successful authentication.
The value should be the name of an <code>AuthenticationSuccessHandler</code> bean in the application context.
By default, an implementation of <code>SavedRequestAwareAuthenticationSuccessHandler</code> is used and injected with the <a href="#nsa-form-login-default-target-url">default-target-url </a>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
Maps to the <code>defaultTargetUrl</code> property of <code>UsernamePasswordAuthenticationFilter</code>.
If not set, the default value is "/" (the application root).
A user will be taken to this URL after logging in, provided they were not asked to login while attempting to access a secured resource, when they will be taken to the originally requested URL.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
The URL that should be used to render the login page.
Maps to the <code>loginFormUrl</code> property of the <code>LoginUrlAuthenticationEntryPoint</code>.
Defaults to "/login".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
Maps to the <code>filterProcessesUrl</code> property of <code>UsernamePasswordAuthenticationFilter</code>.
The default value is "/login".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
The name of the request parameter which contains the password.
Defaults to "password".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
The name of the request parameter which contains the username.
Defaults to "username".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
Maps a <code>ForwardAuthenticationSuccessHandler</code> to <code>authenticationSuccessHandler</code> property of <code>UsernamePasswordAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
Maps a <code>ForwardAuthenticationFailureHandler</code> to <code>authenticationFailureHandler</code> property of <code>UsernamePasswordAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-login"><a class="anchor" href="#nsa-oauth2-login"></a>&lt;oauth2-login&gt;</h5>
<div class="paragraph">
<p>The <a href="#oauth2login">OAuth 2.0 Login</a> feature configures authentication support using an OAuth 2.0 and/or OpenID Connect 1.0 Provider.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-login-parents"><a class="anchor" href="#nsa-oauth2-login-parents"></a>Parent Elements of &lt;oauth2-login&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-login-attributes"><a class="anchor" href="#nsa-oauth2-login-attributes"></a>&lt;oauth2-login&gt; Attributes</h6>
<div id="nsa-oauth2-login-client-registration-repository-ref" class="ulist">
<ul>
<li>
<p><strong>client-registration-repository-ref</strong>
Reference to the <code>ClientRegistrationRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorized-client-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-repository-ref</strong>
Reference to the <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorized-client-service-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-service-ref</strong>
Reference to the <code>OAuth2AuthorizedClientService</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorization-request-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-repository-ref</strong>
Reference to the <code>AuthorizationRequestRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorization-request-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-resolver-ref</strong>
Reference to the <code>OAuth2AuthorizationRequestResolver</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-access-token-response-client-ref" class="ulist">
<ul>
<li>
<p><strong>access-token-response-client-ref</strong>
Reference to the <code>OAuth2AccessTokenResponseClient</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-user-authorities-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-authorities-mapper-ref</strong>
Reference to the <code>GrantedAuthoritiesMapper</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
Reference to the <code>OAuth2UserService</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-oidc-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>oidc-user-service-ref</strong>
Reference to the OpenID Connect <code>OAuth2UserService</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
The URI where the filter processes authentication requests.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
The URI to send users to login.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
Reference to the <code>AuthenticationSuccessHandler</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
Reference to the <code>AuthenticationFailureHandler</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-jwt-decoder-factory-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-decoder-factory-ref</strong>
Reference to the <code>JwtDecoderFactory</code> used by <code>OidcAuthorizationCodeAuthenticationProvider</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-client"><a class="anchor" href="#nsa-oauth2-client"></a>&lt;oauth2-client&gt;</h5>
<div class="paragraph">
<p>Configures <a href="#oauth2client">OAuth 2.0 Client</a> support.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-parents"><a class="anchor" href="#nsa-oauth2-client-parents"></a>Parent Elements of &lt;oauth2-client&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-attributes"><a class="anchor" href="#nsa-oauth2-client-attributes"></a>&lt;oauth2-client&gt; Attributes</h6>
<div id="nsa-oauth2-client-client-registration-repository-ref" class="ulist">
<ul>
<li>
<p><strong>client-registration-repository-ref</strong>
Reference to the <code>ClientRegistrationRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-client-authorized-client-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-repository-ref</strong>
Reference to the <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-client-authorized-client-service-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-service-ref</strong>
Reference to the <code>OAuth2AuthorizedClientService</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-children"><a class="anchor" href="#nsa-oauth2-client-children"></a>Child Elements of &lt;oauth2-client&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authorization-code-grant">authorization-code-grant</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authorization-code-grant"><a class="anchor" href="#nsa-authorization-code-grant"></a>&lt;authorization-code-grant&gt;</h5>
<div class="paragraph">
<p>Configures <a href="#oauth2Client-auth-grant-support">OAuth 2.0 Authorization Code Grant</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-authorization-code-grant-parents"><a class="anchor" href="#nsa-authorization-code-grant-parents"></a>Parent Elements of &lt;authorization-code-grant&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-client">oauth2-client</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authorization-code-grant-attributes"><a class="anchor" href="#nsa-authorization-code-grant-attributes"></a>&lt;authorization-code-grant&gt; Attributes</h6>
<div id="nsa-authorization-code-grant-authorization-request-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-repository-ref</strong>
Reference to the <code>AuthorizationRequestRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-authorization-code-grant-authorization-request-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-resolver-ref</strong>
Reference to the <code>OAuth2AuthorizationRequestResolver</code>.</p>
</li>
</ul>
</div>
<div id="nsa-authorization-code-grant-access-token-response-client-ref" class="ulist">
<ul>
<li>
<p><strong>access-token-response-client-ref</strong>
Reference to the <code>OAuth2AccessTokenResponseClient</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-client-registrations"><a class="anchor" href="#nsa-client-registrations"></a>&lt;client-registrations&gt;</h5>
<div class="paragraph">
<p>A container element for client(s) registered (<a href="#oauth2Client-client-registration">ClientRegistration</a>) with an OAuth 2.0 or OpenID Connect 1.0 Provider.</p>
</div>
<div class="sect5">
<h6 id="nsa-client-registrations-children"><a class="anchor" href="#nsa-client-registrations-children"></a>Child Elements of &lt;client-registrations&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registration">client-registration</a></p>
</li>
<li>
<p><a href="#nsa-provider">provider</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-client-registration"><a class="anchor" href="#nsa-client-registration"></a>&lt;client-registration&gt;</h5>
<div class="paragraph">
<p>Represents a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.</p>
</div>
<div class="sect5">
<h6 id="nsa-client-registration-parents"><a class="anchor" href="#nsa-client-registration-parents"></a>Parent Elements of &lt;client-registration&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registrations">client-registrations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-client-registration-attributes"><a class="anchor" href="#nsa-client-registration-attributes"></a>&lt;client-registration&gt; Attributes</h6>
<div id="nsa-client-registration-registration-id" class="ulist">
<ul>
<li>
<p><strong>registration-id</strong>
The ID that uniquely identifies the <code>ClientRegistration</code>.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-id" class="ulist">
<ul>
<li>
<p><strong>client-id</strong>
The client identifier.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-secret" class="ulist">
<ul>
<li>
<p><strong>client-secret</strong>
The client secret.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-authentication-method" class="ulist">
<ul>
<li>
<p><strong>client-authentication-method</strong>
The method used to authenticate the Client with the Provider.
The supported values are <strong>client_secret_basic</strong>, <strong>client_secret_post</strong>, <strong>private_key_jwt</strong>, <strong>client_secret_jwt</strong> and <strong>none</strong> <a href="https://tools.ietf.org/html/rfc6749#section-2.1">(public clients)</a>.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-authorization-grant-type" class="ulist">
<ul>
<li>
<p><strong>authorization-grant-type</strong>
The OAuth 2.0 Authorization Framework defines four <a href="https://tools.ietf.org/html/rfc6749#section-1.3">Authorization Grant</a> types.
The supported values are <code>authorization_code</code>, <code>client_credentials</code>, <code>password</code>, as well as, extension grant type <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-redirect-uri" class="ulist">
<ul>
<li>
<p><strong>redirect-uri</strong>
The client&#8217;s registered redirect URI that the <em>Authorization Server</em> redirects the end-user&#8217;s user-agent to after the end-user has authenticated and authorized access to the client.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-scope" class="ulist">
<ul>
<li>
<p><strong>scope</strong>
The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-name" class="ulist">
<ul>
<li>
<p><strong>client-name</strong>
A descriptive name used for the client.
The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-provider-id" class="ulist">
<ul>
<li>
<p><strong>provider-id</strong>
A reference to the associated provider. May reference a <code>&lt;provider&gt;</code> element or use one of the common providers (google, github, facebook, okta).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-provider"><a class="anchor" href="#nsa-provider"></a>&lt;provider&gt;</h5>
<div class="paragraph">
<p>The configuration information for an OAuth 2.0 or OpenID Connect 1.0 Provider.</p>
</div>
<div class="sect5">
<h6 id="nsa-provider-parents"><a class="anchor" href="#nsa-provider-parents"></a>Parent Elements of &lt;provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registrations">client-registrations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-provider-attributes"><a class="anchor" href="#nsa-provider-attributes"></a>&lt;provider&gt; Attributes</h6>
<div id="nsa-provider-provider-id" class="ulist">
<ul>
<li>
<p><strong>provider-id</strong>
The ID that uniquely identifies the provider.</p>
</li>
</ul>
</div>
<div id="nsa-provider-authorization-uri" class="ulist">
<ul>
<li>
<p><strong>authorization-uri</strong>
The Authorization Endpoint URI for the Authorization Server.</p>
</li>
</ul>
</div>
<div id="nsa-provider-token-uri" class="ulist">
<ul>
<li>
<p><strong>token-uri</strong>
The Token Endpoint URI for the Authorization Server.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-uri" class="ulist">
<ul>
<li>
<p><strong>user-info-uri</strong>
The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-authentication-method" class="ulist">
<ul>
<li>
<p><strong>user-info-authentication-method</strong>
The authentication method used when sending the access token to the UserInfo Endpoint.
The supported values are <strong>header</strong>, <strong>form</strong> and <strong>query</strong>.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-user-name-attribute" class="ulist">
<ul>
<li>
<p><strong>user-info-user-name-attribute</strong>
The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.</p>
</li>
</ul>
</div>
<div id="nsa-provider-jwk-set-uri" class="ulist">
<ul>
<li>
<p><strong>jwk-set-uri</strong>
The URI used to retrieve the <a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a> Set from the Authorization Server, which contains the cryptographic key(s) used to verify the <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a> of the ID Token and optionally the UserInfo Response.</p>
</li>
</ul>
</div>
<div id="nsa-provider-issuer-uri" class="ulist">
<ul>
<li>
<p><strong>issuer-uri</strong>
The URI used to initially configure a <code>ClientRegistration</code> using discovery of an OpenID Connect Provider&#8217;s <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> or an Authorization Server&#8217;s <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-resource-server"><a class="anchor" href="#nsa-oauth2-resource-server"></a>&lt;oauth2-resource-server&gt;</h5>
<div class="paragraph">
<p>Adds a <code>BearerTokenAuthenticationFilter</code>, <code>BearerTokenAuthenticationEntryPoint</code>, and <code>BearerTokenAccessDeniedHandler</code> to the configuration.
In addition, either <code>&lt;jwt&gt;</code> or <code>&lt;opaque-token&gt;</code> must be specified.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-parents"><a class="anchor" href="#nsa-oauth2-resource-server-parents"></a>Parents Elements of &lt;oauth2-resource-server&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-children"><a class="anchor" href="#nsa-oauth2-resource-server-children"></a>Child Elements of &lt;oauth2-resource-server&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-jwt">jwt</a></p>
</li>
<li>
<p><a href="#nsa-opaque-token">opaque-token</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-attributes"><a class="anchor" href="#nsa-oauth2-resource-server-attributes"></a>&lt;oauth2-resource-server&gt; Attributes</h6>
<div id="nsa-oauth2-resource-server-authentication-manager-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-resolver-ref</strong>
Reference to an <code>AuthenticationManagerResolver</code> which will resolve the <code>AuthenticationManager</code> at request time</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-resource-server-bearer-token-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>bearer-token-resolver-ref</strong>
Reference to a <code>BearerTokenResolver</code> which will retrieve the bearer token from the request</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-resource-server-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
Reference to a <code>AuthenticationEntryPoint</code> which will handle unauthorized requests</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jwt"><a class="anchor" href="#nsa-jwt"></a>&lt;jwt&gt;</h5>
<div class="paragraph">
<p>Represents an OAuth 2.0 Resource Server that will authorize JWTs</p>
</div>
<div class="sect5">
<h6 id="nsa-jwt-parents"><a class="anchor" href="#nsa-jwt-parents"></a>Parent Elements of &lt;jwt&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-jwt-attributes"><a class="anchor" href="#nsa-jwt-attributes"></a>&lt;jwt&gt; Attributes</h6>
<div id="nsa-jwt-jwt-authentication-converter-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-authentication-converter-ref</strong>
Reference to a <code>Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code></p>
</li>
</ul>
</div>
<div id="nsa-jwt-decoder-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-decoder-ref</strong>
Reference to a <code>JwtDecoder</code>. This is a larger component that overrides <code>jwk-set-uri</code></p>
</li>
</ul>
</div>
<div id="nsa-jwt-jwk-set-uri" class="ulist">
<ul>
<li>
<p><strong>jwk-set-uri</strong>
The JWK Set Uri used to load signing verification keys from an OAuth 2.0 Authorization Server</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-opaque-token"><a class="anchor" href="#nsa-opaque-token"></a>&lt;opaque-token&gt;</h5>
<div class="paragraph">
<p>Represents an OAuth 2.0 Resource Server that will authorize opaque tokens</p>
</div>
<div class="sect5">
<h6 id="nsa-opaque-token-parents"><a class="anchor" href="#nsa-opaque-token-parents"></a>Parent Elements of &lt;opaque-token&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-opaque-token-attributes"><a class="anchor" href="#nsa-opaque-token-attributes"></a>&lt;opaque-token&gt; Attributes</h6>
<div id="nsa-opaque-token-introspector-ref" class="ulist">
<ul>
<li>
<p><strong>introspector-ref</strong>
Reference to an <code>OpaqueTokenIntrospector</code>. This is a larger component that overrides <code>introspection-uri</code>, <code>client-id</code>, and <code>client-secret</code>.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-introspection-uri" class="ulist">
<ul>
<li>
<p><strong>introspection-uri</strong>
The Introspection Uri used to introspect the details of an opaque token. Should be accompanied with a <code>client-id</code> and <code>client-secret</code>.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-client-id" class="ulist">
<ul>
<li>
<p><strong>client-id</strong>
The Client Id to use for client authentication against the provided <code>introspection-uri</code>.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-client-secret" class="ulist">
<ul>
<li>
<p><strong>client-secret</strong>
The Client Secret to use for client authentication against the provided <code>introspection-uri</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-basic"><a class="anchor" href="#nsa-http-basic"></a>&lt;http-basic&gt;</h5>
<div class="paragraph">
<p>Adds a <code>BasicAuthenticationFilter</code> and <code>BasicAuthenticationEntryPoint</code> to the configuration.
The latter will only be used as the configuration entry point if form-based login is not enabled.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-basic-parents"><a class="anchor" href="#nsa-http-basic-parents"></a>Parent Elements of &lt;http-basic&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-http-basic-attributes"><a class="anchor" href="#nsa-http-basic-attributes"></a>&lt;http-basic&gt; Attributes</h6>
<div id="nsa-http-basic-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
Reference to an <code>AuthenticationDetailsSource</code> which will be used by the authentication filter</p>
</li>
</ul>
</div>
<div id="nsa-http-basic-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
Sets the <code>AuthenticationEntryPoint</code> which is used by the <code>BasicAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-firewall"><a class="anchor" href="#nsa-http-firewall"></a>&lt;http-firewall&gt; Element</h5>
<div class="paragraph">
<p>This is a top-level element which can be used to inject a custom implementation of <code>HttpFirewall</code> into the <code>FilterChainProxy</code> created by the namespace.
The default implementation should be suitable for most applications.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-firewall-attributes"><a class="anchor" href="#nsa-http-firewall-attributes"></a>&lt;http-firewall&gt; Attributes</h6>
<div id="nsa-http-firewall-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>HttpFirewall</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-url"><a class="anchor" href="#nsa-intercept-url"></a>&lt;intercept-url&gt;</h5>
<div class="paragraph">
<p>This element is used to define the set of URL patterns that the application is interested in and to configure how they should be handled.
It is used to construct the <code>FilterInvocationSecurityMetadataSource</code> used by the <code>FilterSecurityInterceptor</code>.
It is also responsible for configuring a <code>ChannelProcessingFilter</code> if particular URLs need to be accessed by HTTPS, for example.
When matching the specified patterns against an incoming request, the matching is done in the order in which the elements are declared.
So the most specific patterns should come first and the most general should come last.</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-url-parents"><a class="anchor" href="#nsa-intercept-url-parents"></a>Parent Elements of &lt;intercept-url&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-url-attributes"><a class="anchor" href="#nsa-intercept-url-attributes"></a>&lt;intercept-url&gt; Attributes</h6>
<div id="nsa-intercept-url-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
Lists the access attributes which will be stored in the <code>FilterInvocationSecurityMetadataSource</code> for the defined URL pattern/method combination.
This should be a comma-separated list of the security configuration attributes (such as role names).</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
The HTTP Method which will be used in combination with the pattern and servlet path (optional) to match an incoming request.
If omitted, any method will match.
If an identical pattern is specified with and without a method, the method-specific match will take precedence.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
The pattern which defines the URL path.
The content will depend on the <code>request-matcher</code> attribute from the containing http element, so will default to ant path syntax.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
A reference to a <code>RequestMatcher</code> that will be used to determine if this <code>&lt;intercept-url&gt;</code> is used.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-requires-channel" class="ulist">
<ul>
<li>
<p><strong>requires-channel</strong>
Can be "http" or "https" depending on whether a particular URL pattern should be accessed over HTTP or HTTPS respectively.
Alternatively the value "any" can be used when there is no preference.
If this attribute is present on any <code>&lt;intercept-url&gt;</code> element, then a <code>ChannelProcessingFilter</code> will be added to the filter stack and its additional dependencies added to the application context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a <code>&lt;port-mappings&gt;</code> configuration is added, this will be used to by the <code>SecureChannelProcessor</code> and <code>InsecureChannelProcessor</code> beans to determine the ports used for redirecting to HTTP/HTTPS.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property is invalid for <a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>
</td>
</tr>
</table>
</div>
<div id="nsa-intercept-url-servlet-path" class="ulist">
<ul>
<li>
<p><strong>servlet-path</strong>
The servlet path which will be used in combination with the pattern and HTTP method to match an incoming request.
This attribute is only applicable when <a href="#nsa-http-request-matcher">request-matcher</a> is 'mvc'.
In addition, the value is only required in the following 2 use cases: 1) There are 2 or more <code>HttpServlet</code> 's registered in the <code>ServletContext</code> that have mappings starting with <code>'/'</code> and are different; 2) The pattern starts with the same value of a registered <code>HttpServlet</code> path, excluding the default (root) <code>HttpServlet</code> <code>'/'</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property is invalid for <a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jee"><a class="anchor" href="#nsa-jee"></a>&lt;jee&gt;</h5>
<div class="paragraph">
<p>Adds a J2eePreAuthenticatedProcessingFilter to the filter chain to provide integration with container authentication.</p>
</div>
<div class="sect5">
<h6 id="nsa-jee-parents"><a class="anchor" href="#nsa-jee-parents"></a>Parent Elements of &lt;jee&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-jee-attributes"><a class="anchor" href="#nsa-jee-attributes"></a>&lt;jee&gt; Attributes</h6>
<div id="nsa-jee-mappable-roles" class="ulist">
<ul>
<li>
<p><strong>mappable-roles</strong>
A comma-separate list of roles to look for in the incoming HttpServletRequest.</p>
</li>
</ul>
</div>
<div id="nsa-jee-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
A reference to a user-service (or UserDetailsService bean) Id</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-logout"><a class="anchor" href="#nsa-logout"></a>&lt;logout&gt;</h5>
<div class="paragraph">
<p>Adds a <code>LogoutFilter</code> to the filter stack.
This is configured with a <code>SecurityContextLogoutHandler</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-logout-parents"><a class="anchor" href="#nsa-logout-parents"></a>Parent Elements of &lt;logout&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-logout-attributes"><a class="anchor" href="#nsa-logout-attributes"></a>&lt;logout&gt; Attributes</h6>
<div id="nsa-logout-delete-cookies" class="ulist">
<ul>
<li>
<p><strong>delete-cookies</strong>
A comma-separated list of the names of cookies which should be deleted when the user logs out.</p>
</li>
</ul>
</div>
<div id="nsa-logout-invalidate-session" class="ulist">
<ul>
<li>
<p><strong>invalidate-session</strong>
Maps to the <code>invalidateHttpSession</code> of the <code>SecurityContextLogoutHandler</code>.
Defaults to "true", so the session will be invalidated on logout.</p>
</li>
</ul>
</div>
<div id="nsa-logout-logout-success-url" class="ulist">
<ul>
<li>
<p><strong>logout-success-url</strong>
The destination URL which the user will be taken to after logging out.
Defaults to &lt;form-login-login-page&gt;/?logout (i.e. /login?logout)</p>
<div class="paragraph">
<p>Setting this attribute will inject the <code>SessionManagementFilter</code> with a <code>SimpleRedirectInvalidSessionStrategy</code> configured with the attribute value.
When an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL.</p>
</div>
</li>
</ul>
</div>
<div id="nsa-logout-logout-url" class="ulist">
<ul>
<li>
<p><strong>logout-url</strong>
The URL which will cause a logout (i.e. which will be processed by the filter).
Defaults to "/logout".</p>
</li>
</ul>
</div>
<div id="nsa-logout-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>success-handler-ref</strong>
May be used to supply an instance of <code>LogoutSuccessHandler</code> which will be invoked to control the navigation after logging out.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-login"><a class="anchor" href="#nsa-openid-login"></a>&lt;openid-login&gt;</h5>
<div class="paragraph">
<p>Similar to <code>&lt;form-login&gt;</code> and has the same attributes.
The default value for <code>login-processing-url</code> is "/login/openid".
An <code>OpenIDAuthenticationFilter</code> and <code>OpenIDAuthenticationProvider</code> will be registered.
The latter requires a reference to a <code>UserDetailsService</code>.
Again, this can be specified by <code>id</code>, using the <code>user-service-ref</code> attribute, or will be located automatically in the application context.</p>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-parents"><a class="anchor" href="#nsa-openid-login-parents"></a>Parent Elements of &lt;openid-login&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-attributes"><a class="anchor" href="#nsa-openid-login-attributes"></a>&lt;openid-login&gt; Attributes</h6>
<div id="nsa-openid-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>always-use-default-target</strong>
Whether the user should always be redirected to the default-target-url after login.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
Reference to an AuthenticationDetailsSource which will be used by the authentication filter</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
Reference to an AuthenticationFailureHandler bean which should be used to handle a failed authentication request.
Should not be used in combination with authentication-failure-url as the implementation should always deal with navigation to the subsequent destination</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
The URL for the login failure page.
If no login failure URL is specified, Spring Security will automatically create a failure login URL at /login?login_error and a corresponding filter to render that login failure URL when requested.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
Maps a <code>ForwardAuthenticationSuccessHandler</code> to <code>authenticationSuccessHandler</code> property of <code>UsernamePasswordAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
Maps a <code>ForwardAuthenticationFailureHandler</code> to <code>authenticationFailureHandler</code> property of <code>UsernamePasswordAuthenticationFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
Reference to an AuthenticationSuccessHandler bean which should be used to handle a successful authentication request.
Should not be used in combination with <a href="#nsa-openid-login-default-target-url">default-target-url</a> (or <a href="#nsa-openid-login-always-use-default-target">always-use-default-target</a>) as the implementation should always deal with navigation to the subsequent destination</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
The URL that will be redirected to after successful authentication, if the user&#8217;s previous action could not be resumed.
This generally happens if the user visits a login page without having first requested a secured operation that triggers authentication.
If unspecified, defaults to the root of the application.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
The URL for the login page.
If no login URL is specified, Spring Security will automatically create a login URL at /login and a corresponding filter to render that login URL when requested.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
The URL that the login form is posted to.
If unspecified, it defaults to /login.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
The name of the request parameter which contains the password.
Defaults to "password".</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
A reference to a user-service (or UserDetailsService bean) Id</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
The name of the request parameter which contains the username.
Defaults to "username".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-children"><a class="anchor" href="#nsa-openid-login-children"></a>Child Elements of &lt;openid-login&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-attribute-exchange"><a class="anchor" href="#nsa-attribute-exchange"></a>&lt;attribute-exchange&gt;</h5>
<div class="paragraph">
<p>The <code>attribute-exchange</code> element defines the list of attributes which should be requested from the identity provider.
An example can be found in the <a href="#servlet-openid">OpenID Support</a> section of the namespace configuration chapter.
More than one can be used, in which case each must have an <code>identifier-match</code> attribute, containing a regular expression which is matched against the supplied OpenID identifier.
This allows different attribute lists to be fetched from different providers (Google, Yahoo etc).</p>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-parents"><a class="anchor" href="#nsa-attribute-exchange-parents"></a>Parent Elements of &lt;attribute-exchange&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-attributes"><a class="anchor" href="#nsa-attribute-exchange-attributes"></a>&lt;attribute-exchange&gt; Attributes</h6>
<div id="nsa-attribute-exchange-identifier-match" class="ulist">
<ul>
<li>
<p><strong>identifier-match</strong>
A regular expression which will be compared against the claimed identity, when deciding which attribute-exchange configuration to use during authentication.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-children"><a class="anchor" href="#nsa-attribute-exchange-children"></a>Child Elements of &lt;attribute-exchange&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-attribute">openid-attribute</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-attribute"><a class="anchor" href="#nsa-openid-attribute"></a>&lt;openid-attribute&gt;</h5>
<div class="paragraph">
<p>Attributes used when making an OpenID AX <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html#fetch_request"> Fetch Request</a></p>
</div>
<div class="sect5">
<h6 id="nsa-openid-attribute-parents"><a class="anchor" href="#nsa-openid-attribute-parents"></a>Parent Elements of &lt;openid-attribute&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-attribute-attributes"><a class="anchor" href="#nsa-openid-attribute-attributes"></a>&lt;openid-attribute&gt; Attributes</h6>
<div id="nsa-openid-attribute-count" class="ulist">
<ul>
<li>
<p><strong>count</strong>
Specifies the number of attributes that you wish to get back.
For example, return 3 emails.
The default value is 1.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
Specifies the name of the attribute that you wish to get back.
For example, email.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-required" class="ulist">
<ul>
<li>
<p><strong>required</strong>
Specifies if this attribute is required to the OP, but does not error out if the OP does not return the attribute.
Default is false.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-type" class="ulist">
<ul>
<li>
<p><strong>type</strong>
Specifies the attribute type.
For example, <a href="https://axschema.org/contact/email" class="bare">https://axschema.org/contact/email</a>.
See your OP&#8217;s documentation for valid attribute types.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mappings"><a class="anchor" href="#nsa-port-mappings"></a>&lt;port-mappings&gt;</h5>
<div class="paragraph">
<p>By default, an instance of <code>PortMapperImpl</code> will be added to the configuration for use in redirecting to secure and insecure URLs.
This element can optionally be used to override the default mappings which that class defines.
Each child <code>&lt;port-mapping&gt;</code> element defines a pair of HTTP:HTTPS ports.
The default mappings are 80:443 and 8080:8443.
An example of overriding these can be found in <a href="#servlet-http-redirect">Redirect to HTTPS</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-port-mappings-parents"><a class="anchor" href="#nsa-port-mappings-parents"></a>Parent Elements of &lt;port-mappings&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-port-mappings-children"><a class="anchor" href="#nsa-port-mappings-children"></a>Child Elements of &lt;port-mappings&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mapping">port-mapping</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mapping"><a class="anchor" href="#nsa-port-mapping"></a>&lt;port-mapping&gt;</h5>
<div class="paragraph">
<p>Provides a method to map http ports to https ports when forcing a redirect.</p>
</div>
<div class="sect5">
<h6 id="nsa-port-mapping-parents"><a class="anchor" href="#nsa-port-mapping-parents"></a>Parent Elements of &lt;port-mapping&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-port-mapping-attributes"><a class="anchor" href="#nsa-port-mapping-attributes"></a>&lt;port-mapping&gt; Attributes</h6>
<div id="nsa-port-mapping-http" class="ulist">
<ul>
<li>
<p><strong>http</strong>
The http port to use.</p>
</li>
</ul>
</div>
<div id="nsa-port-mapping-https" class="ulist">
<ul>
<li>
<p><strong>https</strong>
The https port to use.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-remember-me"><a class="anchor" href="#nsa-remember-me"></a>&lt;remember-me&gt;</h5>
<div class="paragraph">
<p>Adds the <code>RememberMeAuthenticationFilter</code> to the stack.
This in turn will be configured with either a <code>TokenBasedRememberMeServices</code>, a <code>PersistentTokenBasedRememberMeServices</code> or a user-specified bean implementing <code>RememberMeServices</code> depending on the attribute settings.</p>
</div>
<div class="sect5">
<h6 id="nsa-remember-me-parents"><a class="anchor" href="#nsa-remember-me-parents"></a>Parent Elements of &lt;remember-me&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-remember-me-attributes"><a class="anchor" href="#nsa-remember-me-attributes"></a>&lt;remember-me&gt; Attributes</h6>
<div id="nsa-remember-me-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
Sets the <code>authenticationSuccessHandler</code> property on the <code>RememberMeAuthenticationFilter</code> if custom navigation is required.
The value should be the name of a <code>AuthenticationSuccessHandler</code> bean in the application context.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
A reference to a <code>DataSource</code> bean.
If this is set, <code>PersistentTokenBasedRememberMeServices</code> will be used and configured with a <code>JdbcTokenRepositoryImpl</code> instance.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-parameter" class="ulist">
<ul>
<li>
<p><strong>remember-me-parameter</strong>
The name of the request parameter which toggles remember-me authentication.
Defaults to "remember-me".
Maps to the "parameter" property of <code>AbstractRememberMeServices</code>.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-cookie" class="ulist">
<ul>
<li>
<p><strong>remember-me-cookie</strong>
The name of cookie which store the token for remember-me authentication.
Defaults to "remember-me".
Maps to the "cookieName" property of <code>AbstractRememberMeServices</code>.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
Maps to the "key" property of <code>AbstractRememberMeServices</code>.
Should be set to a unique value to ensure that remember-me cookies are only valid within the one application <sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>.
If this is not set a secure random value will be generated.
Since generating secure random values can take a while, setting this value explicitly can help improve startup times when using the remember-me functionality.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-alias" class="ulist">
<ul>
<li>
<p><strong>services-alias</strong>
Exports the internally defined <code>RememberMeServices</code> as a bean alias, allowing it to be used by other beans in the application context.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-ref" class="ulist">
<ul>
<li>
<p><strong>services-ref</strong>
Allows complete control of the <code>RememberMeServices</code> implementation that will be used by the filter.
The value should be the <code>id</code> of a bean in the application context which implements this interface.
Should also implement <code>LogoutHandler</code> if a logout filter is in use.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
Configures a <code>PersistentTokenBasedRememberMeServices</code> but allows the use of a custom <code>PersistentTokenRepository</code> bean.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-validity-seconds" class="ulist">
<ul>
<li>
<p><strong>token-validity-seconds</strong>
Maps to the <code>tokenValiditySeconds</code> property of <code>AbstractRememberMeServices</code>.
Specifies the period in seconds for which the remember-me cookie should be valid.
By default it will be valid for 14 days.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-use-secure-cookie" class="ulist">
<ul>
<li>
<p><strong>use-secure-cookie</strong>
It is recommended that remember-me cookies are only submitted over HTTPS and thus should be flagged as "secure".
By default, a secure cookie will be used if the connection over which the login request is made is secure (as it should be).
If you set this property to <code>false</code>, secure cookies will not be used.
Setting it to <code>true</code> will always set the secure flag on the cookie.
This attribute maps to the <code>useSecureCookie</code> property of <code>AbstractRememberMeServices</code>.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
The remember-me services implementations require access to a <code>UserDetailsService</code>, so there has to be one defined in the application context.
If there is only one, it will be selected and used automatically by the namespace configuration.
If there are multiple instances, you can specify a bean <code>id</code> explicitly using this attribute.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-request-cache"><a class="anchor" href="#nsa-request-cache"></a>&lt;request-cache&gt; Element</h5>
<div class="paragraph">
<p>Sets the <code>RequestCache</code> instance which will be used by the <code>ExceptionTranslationFilter</code> to store request information before invoking an <code>AuthenticationEntryPoint</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-request-cache-parents"><a class="anchor" href="#nsa-request-cache-parents"></a>Parent Elements of &lt;request-cache&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-request-cache-attributes"><a class="anchor" href="#nsa-request-cache-attributes"></a>&lt;request-cache&gt; Attributes</h6>
<div id="nsa-request-cache-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that is a <code>RequestCache</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-session-management"><a class="anchor" href="#nsa-session-management"></a>&lt;session-management&gt;</h5>
<div class="paragraph">
<p>Session-management related functionality is implemented by the addition of a <code>SessionManagementFilter</code> to the filter stack.</p>
</div>
<div class="sect5">
<h6 id="nsa-session-management-parents"><a class="anchor" href="#nsa-session-management-parents"></a>Parent Elements of &lt;session-management&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-session-management-attributes"><a class="anchor" href="#nsa-session-management-attributes"></a>&lt;session-management&gt; Attributes</h6>
<div id="nsa-session-management-invalid-session-url" class="ulist">
<ul>
<li>
<p><strong>invalid-session-url</strong>
Setting this attribute will inject the <code>SessionManagementFilter</code> with a <code>SimpleRedirectInvalidSessionStrategy</code> configured with the attribute value.
When an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-invalid-session-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>invalid-session-url</strong>
Allows injection of the InvalidSessionStrategy instance used by the SessionManagementFilter.
Use either this or the <code>invalid-session-url</code> attribute but not both.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-authentication-error-url" class="ulist">
<ul>
<li>
<p><strong>session-authentication-error-url</strong>
Defines the URL of the error page which should be shown when the SessionAuthenticationStrategy raises an exception.
If not set, an unauthorized (401) error code will be returned to the client.
Note that this attribute doesn&#8217;t apply if the error occurs during a form-based login, where the URL for authentication failure will take precedence.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-authentication-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>session-authentication-strategy-ref</strong>
Allows injection of the SessionAuthenticationStrategy instance used by the SessionManagementFilter</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-fixation-protection" class="ulist">
<ul>
<li>
<p><strong>session-fixation-protection</strong>
Indicates how session fixation protection will be applied when a user authenticates.
If set to "none", no protection will be applied.
"newSession" will create a new empty session, with only Spring Security-related attributes migrated.
"migrateSession" will create a new session and copy all session attributes to the new session.
In Servlet 3.1 (Java EE 7) and newer containers, specifying "changeSessionId" will keep the existing session and use the container-supplied session fixation protection (HttpServletRequest#changeSessionId()).
Defaults to "changeSessionId" in Servlet 3.1 and newer containers, "migrateSession" in older containers.
Throws an exception if "changeSessionId" is used in older containers.</p>
<div class="paragraph">
<p>If session fixation protection is enabled, the <code>SessionManagementFilter</code> is injected with an appropriately configured <code>DefaultSessionAuthenticationStrategy</code>.
See the Javadoc for this class for more details.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-session-management-children"><a class="anchor" href="#nsa-session-management-children"></a>Child Elements of &lt;session-management&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-concurrency-control">concurrency-control</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-concurrency-control"><a class="anchor" href="#nsa-concurrency-control"></a>&lt;concurrency-control&gt;</h5>
<div class="paragraph">
<p>Adds support for concurrent session control, allowing limits to be placed on the number of active sessions a user can have.
A <code>ConcurrentSessionFilter</code> will be created, and a <code>ConcurrentSessionControlAuthenticationStrategy</code> will be used with the <code>SessionManagementFilter</code>.
If a <code>form-login</code> element has been declared, the strategy object will also be injected into the created authentication filter.
An instance of <code>SessionRegistry</code> (a <code>SessionRegistryImpl</code> instance unless the user wishes to use a custom bean) will be created for use by the strategy.</p>
</div>
<div class="sect5">
<h6 id="nsa-concurrency-control-parents"><a class="anchor" href="#nsa-concurrency-control-parents"></a>Parent Elements of &lt;concurrency-control&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-concurrency-control-attributes"><a class="anchor" href="#nsa-concurrency-control-attributes"></a>&lt;concurrency-control&gt; Attributes</h6>
<div id="nsa-concurrency-control-error-if-maximum-exceeded" class="ulist">
<ul>
<li>
<p><strong>error-if-maximum-exceeded</strong>
If set to "true" a <code>SessionAuthenticationException</code> will be raised when a user attempts to exceed the maximum allowed number of sessions.
The default behaviour is to expire the original session.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-expired-url" class="ulist">
<ul>
<li>
<p><strong>expired-url</strong>
The URL a user will be redirected to if they attempt to use a session which has been "expired" by the concurrent session controller because the user has exceeded the number of allowed sessions and has logged in again elsewhere.
Should be set unless <code>exception-if-maximum-exceeded</code> is set.
If no value is supplied, an expiry message will just be written directly back to the response.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-expired-session-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>expired-url</strong>
Allows injection of the ExpiredSessionStrategy instance used by the ConcurrentSessionFilter</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-max-sessions" class="ulist">
<ul>
<li>
<p><strong>max-sessions</strong>
Maps to the <code>maximumSessions</code> property of <code>ConcurrentSessionControlAuthenticationStrategy</code>.
Specify <code>-1</code> as the value to support unlimited sessions.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-alias" class="ulist">
<ul>
<li>
<p><strong>session-registry-alias</strong>
It can also be useful to have a reference to the internal session registry for use in your own beans or an admin interface.
You can expose the internal bean using the <code>session-registry-alias</code> attribute, giving it a name that you can use elsewhere in your configuration.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-ref" class="ulist">
<ul>
<li>
<p><strong>session-registry-ref</strong>
The user can supply their own <code>SessionRegistry</code> implementation using the <code>session-registry-ref</code> attribute.
The other concurrent session control beans will be wired up to use it.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-x509"><a class="anchor" href="#nsa-x509"></a>&lt;x509&gt;</h5>
<div class="paragraph">
<p>Adds support for X.509 authentication.
An <code>X509AuthenticationFilter</code> will be added to the stack and an <code>Http403ForbiddenEntryPoint</code> bean will be created.
The latter will only be used if no other authentication mechanisms are in use (its only functionality is to return an HTTP 403 error code).
A <code>PreAuthenticatedAuthenticationProvider</code> will also be created which delegates the loading of user authorities to a <code>UserDetailsService</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-x509-parents"><a class="anchor" href="#nsa-x509-parents"></a>Parent Elements of &lt;x509&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-x509-attributes"><a class="anchor" href="#nsa-x509-attributes"></a>&lt;x509&gt; Attributes</h6>
<div id="nsa-x509-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
A reference to an <code>AuthenticationDetailsSource</code></p>
</li>
</ul>
</div>
<div id="nsa-x509-subject-principal-regex" class="ulist">
<ul>
<li>
<p><strong>subject-principal-regex</strong>
Defines a regular expression which will be used to extract the username from the certificate (for use with the <code>UserDetailsService</code>).</p>
</li>
</ul>
</div>
<div id="nsa-x509-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
Allows a specific <code>UserDetailsService</code> to be used with X.509 in the case where multiple instances are configured.
If not set, an attempt will be made to locate a suitable instance automatically and use that.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-map"><a class="anchor" href="#nsa-filter-chain-map"></a>&lt;filter-chain-map&gt;</h5>
<div class="paragraph">
<p>Used to explicitly configure a FilterChainProxy instance with a FilterChainMap</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-map-attributes"><a class="anchor" href="#nsa-filter-chain-map-attributes"></a>&lt;filter-chain-map&gt; Attributes</h6>
<div id="nsa-filter-chain-map-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
Defines the strategy to use for matching incoming requests.
Currently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-map-children"><a class="anchor" href="#nsa-filter-chain-map-children"></a>Child Elements of &lt;filter-chain-map&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain">filter-chain</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain"><a class="anchor" href="#nsa-filter-chain"></a>&lt;filter-chain&gt;</h5>
<div class="paragraph">
<p>Used within to define a specific URL pattern and the list of filters which apply to the URLs matching that pattern.
When multiple filter-chain elements are assembled in a list in order to configure a FilterChainProxy, the most specific patterns must be placed at the top of the list, with most general ones at the bottom.</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-parents"><a class="anchor" href="#nsa-filter-chain-parents"></a>Parent Elements of &lt;filter-chain&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain-map">filter-chain-map</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-attributes"><a class="anchor" href="#nsa-filter-chain-attributes"></a>&lt;filter-chain&gt; Attributes</h6>
<div id="nsa-filter-chain-filters" class="ulist">
<ul>
<li>
<p><strong>filters</strong>
A comma separated list of references to Spring beans that implement <code>Filter</code>.
The value "none" means that no <code>Filter</code> should be used for this <code>FilterChain</code>.</p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
A pattern that creates RequestMatcher in combination with the <a href="#nsa-filter-chain-map-request-matcher">request-matcher</a></p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
A reference to a <code>RequestMatcher</code> that will be used to determine if any <code>Filter</code> from the <code>filters</code> attribute should be invoked.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-security-metadata-source"><a class="anchor" href="#nsa-filter-security-metadata-source"></a>&lt;filter-security-metadata-source&gt;</h5>
<div class="paragraph">
<p>Used to explicitly configure a FilterSecurityMetadataSource bean for use with a FilterSecurityInterceptor.
Usually only needed if you are configuring a FilterChainProxy explicitly, rather than using the&lt;http&gt; element.
The intercept-url elements used should only contain pattern, method and access attributes.
Any others will result in a configuration error.</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-security-metadata-source-attributes"><a class="anchor" href="#nsa-filter-security-metadata-source-attributes"></a>&lt;filter-security-metadata-source&gt; Attributes</h6>
<div id="nsa-filter-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
Defines the strategy use for matching incoming requests.
Currently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
Enables the use of expressions in the 'access' attributes in &lt;intercept-url&gt; elements rather than the traditional list of configuration attributes.
Defaults to 'true'.
If enabled, each attribute should contain a single Boolean expression.
If the expression evaluates to 'true', access will be granted.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-security-metadata-source-children"><a class="anchor" href="#nsa-filter-security-metadata-source-children"></a>Child Elements of &lt;filter-security-metadata-source&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-websocket-security"><a class="anchor" href="#nsa-websocket-security"></a>WebSocket Security</h4>
<div class="paragraph">
<p>Spring Security 4.0+ provides support for authorizing messages.
One concrete example of where this is useful is to provide authorization in WebSocket based applications.</p>
</div>
<div class="sect4">
<h5 id="nsa-websocket-message-broker"><a class="anchor" href="#nsa-websocket-message-broker"></a>&lt;websocket-message-broker&gt;</h5>
<div class="paragraph">
<p>The websocket-message-broker element has two different modes.
If the <a href="#nsa-websocket-message-broker-id">websocket-message-broker@id</a> is not specified, then it will do the following things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure that any SimpAnnotationMethodMessageHandler has the AuthenticationPrincipalArgumentResolver registered as a custom argument resolver.
This allows the use of <code>@AuthenticationPrincipal</code> to resolve the principal of the current <code>Authentication</code></p>
</li>
<li>
<p>Ensures that the SecurityContextChannelInterceptor is automatically registered for the clientInboundChannel.
This populates the SecurityContextHolder with the user that is found in the Message</p>
</li>
<li>
<p>Ensures that a ChannelSecurityInterceptor is registered with the clientInboundChannel.
This allows authorization rules to be specified for a message.</p>
</li>
<li>
<p>Ensures that a CsrfChannelInterceptor is registered with the clientInboundChannel.
This ensures that only requests from the original domain are enabled.</p>
</li>
<li>
<p>Ensures that a CsrfTokenHandshakeInterceptor is registered with WebSocketHttpRequestHandler, TransportHandlingSockJsService, or DefaultSockJsService.
This ensures that the expected CsrfToken from the HttpServletRequest is copied into the WebSocket Session attributes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If additional control is necessary, the id can be specified and a ChannelSecurityInterceptor will be assigned to the specified id.
All the wiring with Spring&#8217;s messaging infrastructure can then be done manually.
This is more cumbersome, but provides greater control over the configuration.</p>
</div>
<div class="sect5">
<h6 id="nsa-websocket-message-broker-attributes"><a class="anchor" href="#nsa-websocket-message-broker-attributes"></a>&lt;websocket-message-broker&gt; Attributes</h6>
<div id="nsa-websocket-message-broker-id" class="ulist">
<ul>
<li>
<p><strong>id</strong> A bean identifier, used for referring to the ChannelSecurityInterceptor bean elsewhere in the context.
If specified, Spring Security requires explicit configuration within Spring Messaging.
If not specified, Spring Security will automatically integrate with the messaging infrastructure as described in <a href="#nsa-websocket-message-broker">&lt;websocket-message-broker&gt;</a></p>
</li>
</ul>
</div>
<div id="nsa-websocket-message-broker-same-origin-disabled" class="ulist">
<ul>
<li>
<p><strong>same-origin-disabled</strong> Disables the requirement for CSRF token to be present in the Stomp headers (default false).
Changing the default is useful if it is necessary to allow other origins to make SockJS connections.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-websocket-message-broker-children"><a class="anchor" href="#nsa-websocket-message-broker-children"></a>Child Elements of &lt;websocket-message-broker&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-intercept-message">intercept-message</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-message"><a class="anchor" href="#nsa-intercept-message"></a>&lt;intercept-message&gt;</h5>
<div class="paragraph">
<p>Defines an authorization rule for a message.</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-message-parents"><a class="anchor" href="#nsa-intercept-message-parents"></a>Parent Elements of &lt;intercept-message&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-message-attributes"><a class="anchor" href="#nsa-intercept-message-attributes"></a>&lt;intercept-message&gt; Attributes</h6>
<div id="nsa-intercept-message-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong> An ant based pattern that matches on the Message destination.
For example, "/<strong>" matches any Message with a destination; "/admin/</strong>" matches any Message that has a destination that starts with "/admin/**".</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-type" class="ulist">
<ul>
<li>
<p><strong>type</strong> The type of message to match on.
Valid values are defined in SimpMessageType (i.e. CONNECT, CONNECT_ACK, HEARTBEAT, MESSAGE, SUBSCRIBE, UNSUBSCRIBE, DISCONNECT, DISCONNECT_ACK, OTHER).</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-access" class="ulist">
<ul>
<li>
<p><strong>access</strong> The expression used to secure the Message.
For example, "denyAll" will deny access to all of the matching Messages; "permitAll" will grant access to all of the matching Messages; "hasRole('ADMIN') requires the current user to have the role 'ROLE_ADMIN' for the matching Messages.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-authentication"><a class="anchor" href="#nsa-authentication"></a>Authentication Services</h4>
<div class="paragraph">
<p>Before Spring Security 3.0, an <code>AuthenticationManager</code> was automatically registered internally.
Now you must register one explicitly using the <code>&lt;authentication-manager&gt;</code> element.
This creates an instance of Spring Security&#8217;s <code>ProviderManager</code> class, which needs to be configured with a list of one or more <code>AuthenticationProvider</code> instances.
These can either be created using syntax elements provided by the namespace, or they can be standard bean definitions, marked for addition to the list using the <code>authentication-provider</code> element.</p>
</div>
<div class="sect4">
<h5 id="nsa-authentication-manager"><a class="anchor" href="#nsa-authentication-manager"></a>&lt;authentication-manager&gt;</h5>
<div class="paragraph">
<p>Every Spring Security application which uses the namespace must have include this element somewhere.
It is responsible for registering the <code>AuthenticationManager</code> which provides authentication services to the application.
All elements which create <code>AuthenticationProvider</code> instances should be children of this element.</p>
</div>
<div class="sect5">
<h6 id="nsa-authentication-manager-attributes"><a class="anchor" href="#nsa-authentication-manager-attributes"></a>&lt;authentication-manager&gt; Attributes</h6>
<div id="nsa-authentication-manager-alias" class="ulist">
<ul>
<li>
<p><strong>alias</strong>
This attribute allows you to define an alias name for the internal instance for use in your own configuration.</p>
</li>
</ul>
</div>
<div id="nsa-authentication-manager-erase-credentials" class="ulist">
<ul>
<li>
<p><strong>erase-credentials</strong>
If set to true, the AuthenticationManager will attempt to clear any credentials data in the returned Authentication object, once the user has been authenticated.
Literally it maps to the <code>eraseCredentialsAfterAuthentication</code> property of the <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</li>
</ul>
</div>
<div id="nsa-authentication-manager-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
This attribute allows you to define an id for the internal instance for use in your own configuration.
It is the same as the alias element, but provides a more consistent experience with elements that use the id attribute.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-manager-children"><a class="anchor" href="#nsa-authentication-manager-children"></a>Child Elements of &lt;authentication-manager&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authentication-provider"><a class="anchor" href="#nsa-authentication-provider"></a>&lt;authentication-provider&gt;</h5>
<div class="paragraph">
<p>Unless used with a <code>ref</code> attribute, this element is shorthand for configuring a <code>DaoAuthenticationProvider</code>.
<code>DaoAuthenticationProvider</code> loads user information from a <code>UserDetailsService</code> and compares the username/password combination with the values supplied at login.
The <code>UserDetailsService</code> instance can be defined either by using an available namespace element (<code>jdbc-user-service</code> or by using the <code>user-service-ref</code> attribute to point to a bean defined elsewhere in the application context).</p>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-parents"><a class="anchor" href="#nsa-authentication-provider-parents"></a>Parent Elements of &lt;authentication-provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-attributes"><a class="anchor" href="#nsa-authentication-provider-attributes"></a>&lt;authentication-provider&gt; Attributes</h6>
<div id="nsa-authentication-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>AuthenticationProvider</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you have written your own <code>AuthenticationProvider</code> implementation (or want to configure one of Spring Security&#8217;s own implementations as a traditional bean for some reason, then you can use the following syntax to add it to the internal list of <code>ProviderManager</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:authentication-manager&gt;
&lt;security:authentication-provider ref="myAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;
&lt;bean id="myAuthenticationProvider" class="com.something.MyAuthenticationProvider"/&gt;</code></pre>
</div>
</div>
<div id="nsa-authentication-provider-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
A reference to a bean that implements UserDetailsService that may be created using the standard bean element or the custom user-service element.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-children"><a class="anchor" href="#nsa-authentication-provider-children"></a>Child Elements of &lt;authentication-provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-jdbc-user-service">jdbc-user-service</a></p>
</li>
<li>
<p><a href="#nsa-ldap-user-service">ldap-user-service</a></p>
</li>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jdbc-user-service"><a class="anchor" href="#nsa-jdbc-user-service"></a>&lt;jdbc-user-service&gt;</h5>
<div class="paragraph">
<p>Causes creation of a JDBC-based UserDetailsService.</p>
</div>
<div class="sect5">
<h6 id="nsa-jdbc-user-service-attributes"><a class="anchor" href="#nsa-jdbc-user-service-attributes"></a>&lt;jdbc-user-service&gt; Attributes</h6>
<div id="nsa-jdbc-user-service-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>authorities-by-username-query</strong>
An SQL statement to query for a user&#8217;s granted authorities given a username.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">select username, authority from authorities where username = ?</code></pre>
</div>
</div>
<div id="nsa-jdbc-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
Defines a reference to a cache for use with a UserDetailsService.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
The bean ID of the DataSource which provides the required tables.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-group-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>group-authorities-by-username-query</strong>
An SQL statement to query user&#8217;s group authorities given a username.
The default is</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">select
g.id, g.group_name, ga.authority
from
groups g, group_members gm, group_authorities ga
where
gm.username = ? and g.id = ga.group_id and g.id = gm.group_id</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
A non-empty string prefix that will be added to role strings loaded from persistent storage (default is "ROLE_").
Use the value "none" for no prefix in cases where the default is non-empty.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-users-by-username-query" class="ulist">
<ul>
<li>
<p><strong>users-by-username-query</strong>
An SQL statement to query a username, password, and enabled status given a username.
The default is</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">select username, password, enabled from users where username = ?</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-encoder"><a class="anchor" href="#nsa-password-encoder"></a>&lt;password-encoder&gt;</h5>
<div class="paragraph">
<p>Authentication providers can optionally be configured to use a password encoder as described in the <a href="#authentication-password-storage">[authentication-password-storage]</a>.
This will result in the bean being injected with the appropriate <code>PasswordEncoder</code> instance.</p>
</div>
<div class="sect5">
<h6 id="nsa-password-encoder-parents"><a class="anchor" href="#nsa-password-encoder-parents"></a>Parent Elements of &lt;password-encoder&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-encoder-attributes"><a class="anchor" href="#nsa-password-encoder-attributes"></a>&lt;password-encoder&gt; Attributes</h6>
<div id="nsa-password-encoder-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
Defines the hashing algorithm used on user passwords.
We recommend strongly against using MD4, as it is a very weak hashing algorithm.</p>
</li>
</ul>
</div>
<div id="nsa-password-encoder-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>PasswordEncoder</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user-service"><a class="anchor" href="#nsa-user-service"></a>&lt;user-service&gt;</h5>
<div class="paragraph">
<p>Creates an in-memory UserDetailsService from a properties file or a list of "user" child elements.
Usernames are converted to lower-case internally to allow for case-insensitive lookups, so this should not be used if case-sensitivity is required.</p>
</div>
<div class="sect5">
<h6 id="nsa-user-service-attributes"><a class="anchor" href="#nsa-user-service-attributes"></a>&lt;user-service&gt; Attributes</h6>
<div id="nsa-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-user-service-properties" class="ulist">
<ul>
<li>
<p><strong>properties</strong>
The location of a Properties file where each line is in the format of</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-user-service-children"><a class="anchor" href="#nsa-user-service-children"></a>Child Elements of &lt;user-service&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user">user</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user"><a class="anchor" href="#nsa-user"></a>&lt;user&gt;</h5>
<div class="paragraph">
<p>Represents a user in the application.</p>
</div>
<div class="sect5">
<h6 id="nsa-user-parents"><a class="anchor" href="#nsa-user-parents"></a>Parent Elements of &lt;user&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-user-attributes"><a class="anchor" href="#nsa-user-attributes"></a>&lt;user&gt; Attributes</h6>
<div id="nsa-user-authorities" class="ulist">
<ul>
<li>
<p><strong>authorities</strong>
One of more authorities granted to the user.
Separate authorities with a comma (but no space).
For example, "ROLE_USER,ROLE_ADMINISTRATOR"</p>
</li>
</ul>
</div>
<div id="nsa-user-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
Can be set to "true" to mark an account as disabled and unusable.</p>
</li>
</ul>
</div>
<div id="nsa-user-locked" class="ulist">
<ul>
<li>
<p><strong>locked</strong>
Can be set to "true" to mark an account as locked and unusable.</p>
</li>
</ul>
</div>
<div id="nsa-user-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
The username assigned to the user.</p>
</li>
</ul>
</div>
<div id="nsa-user-password" class="ulist">
<ul>
<li>
<p><strong>password</strong>
The password assigned to the user.
This may be hashed if the corresponding authentication provider supports hashing (remember to set the "hash" attribute of the "user-service" element).
This attribute be omitted in the case where the data will not be used for authentication, but only for accessing authorities.
If omitted, the namespace will generate a random value, preventing its accidental use for authentication.
Cannot be empty.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_method_security"><a class="anchor" href="#_method_security"></a>Method Security</h4>
<div class="sect4">
<h5 id="nsa-method-security"><a class="anchor" href="#nsa-method-security"></a>&lt;method-security&gt;</h5>
<div class="paragraph">
<p>This element is the primary means of adding support for securing methods on Spring Security beans.
Methods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts.</p>
</div>
<div class="sect5">
<h6 id="nsa-method-security-attributes"><a class="anchor" href="#nsa-method-security-attributes"></a>&lt;method-security&gt; attributes</h6>
<div id="nsa-method-security-pre-post-enabled" class="ulist">
<ul>
<li>
<p><strong>pre-post-enabled</strong>
Enables Spring Security&#8217;s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) for this application context.
Defaults to "true".</p>
</li>
</ul>
</div>
<div id="nsa-method-security-secured-enabled" class="ulist">
<ul>
<li>
<p><strong>secured-enabled</strong>
Enables Spring Security&#8217;s @Secured annotation for this application context.
Defaults to "false".</p>
</li>
</ul>
</div>
<div id="nsa-method-security-jsr250-enabled" class="ulist">
<ul>
<li>
<p><strong>jsr250-enabled</strong>
Enables JSR-250 authorization annotations (@RolesAllowed, @PermitAll, @DenyAll) for this application context.
Defaults to "false".</p>
</li>
</ul>
</div>
<div id="nsa-method-security-proxy-target-class" class="ulist">
<ul>
<li>
<p><strong>proxy-target-class</strong>
If true, class based proxying will be used instead of interface based proxying.
Defaults to "false".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-method-security-children"><a class="anchor" href="#nsa-method-security-children"></a>Child Elements of &lt;method-security&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-global-method-security"><a class="anchor" href="#nsa-global-method-security"></a>&lt;global-method-security&gt;</h5>
<div class="paragraph">
<p>This element is the primary means of adding support for securing methods on Spring Security beans.
Methods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts as child elements, using AspectJ syntax.</p>
</div>
<div class="sect5">
<h6 id="nsa-global-method-security-attributes"><a class="anchor" href="#nsa-global-method-security-attributes"></a>&lt;global-method-security&gt; Attributes</h6>
<div id="nsa-global-method-security-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
Method security uses the same <code>AccessDecisionManager</code> configuration as web security, but this can be overridden using this attribute.
By default an AffirmativeBased implementation is used for with a RoleVoter and an AuthenticatedVoter.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
A reference to an <code>AuthenticationManager</code> that should be used for method security.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-jsr250-annotations" class="ulist">
<ul>
<li>
<p><strong>jsr250-annotations</strong>
Specifies whether JSR-250 style attributes are to be used (for example "RolesAllowed").
This will require the javax.annotation.security classes on the classpath.
Setting this to true also adds a <code>Jsr250Voter</code> to the <code>AccessDecisionManager</code>, so you need to make sure you do this if you are using a custom implementation and want to use these annotations.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-metadata-source-ref" class="ulist">
<ul>
<li>
<p><strong>metadata-source-ref</strong>
An external <code>MethodSecurityMetadataSource</code> instance can be supplied which will take priority over other sources (such as the default annotations).</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-mode" class="ulist">
<ul>
<li>
<p><strong>mode</strong>
This attribute can be set to "aspectj" to specify that AspectJ should be used instead of the default Spring AOP.
Secured methods must be woven with the <code>AnnotationSecurityAspect</code> from the <code>spring-security-aspects</code> module.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is important to note that AspectJ follows Java&#8217;s rule that annotations on interfaces are not inherited.
This means that methods that define the Security annotations on the interface will not be secured.
Instead, you must place the Security annotation on the class when using AspectJ.</p>
</div>
<div id="nsa-global-method-security-order" class="ulist">
<ul>
<li>
<p><strong>order</strong>
Allows the advice "order" to be set for the method security interceptor.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-pre-post-annotations" class="ulist">
<ul>
<li>
<p><strong>pre-post-annotations</strong>
Specifies whether the use of Spring Security&#8217;s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) should be enabled for this application context.
Defaults to "disabled".</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-proxy-target-class" class="ulist">
<ul>
<li>
<p><strong>proxy-target-class</strong>
If true, class based proxying will be used instead of interface based proxying.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-run-as-manager-ref" class="ulist">
<ul>
<li>
<p><strong>run-as-manager-ref</strong>
A reference to an optional <code>RunAsManager</code> implementation which will be used by the configured <code>MethodSecurityInterceptor</code></p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-secured-annotations" class="ulist">
<ul>
<li>
<p><strong>secured-annotations</strong>
Specifies whether the use of Spring Security&#8217;s @Secured annotations should be enabled for this application context.
Defaults to "disabled".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-global-method-security-children"><a class="anchor" href="#nsa-global-method-security-children"></a>Child Elements of &lt;global-method-security&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-after-invocation-provider">after-invocation-provider</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
<li>
<p><a href="#nsa-protect-pointcut">protect-pointcut</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-after-invocation-provider"><a class="anchor" href="#nsa-after-invocation-provider"></a>&lt;after-invocation-provider&gt;</h5>
<div class="paragraph">
<p>This element can be used to decorate an <code>AfterInvocationProvider</code> for use by the security interceptor maintained by the <code>&lt;global-method-security&gt;</code> namespace.
You can define zero or more of these within the <code>global-method-security</code> element, each with a <code>ref</code> attribute pointing to an <code>AfterInvocationProvider</code> bean instance within your application context.</p>
</div>
<div class="sect5">
<h6 id="nsa-after-invocation-provider-parents"><a class="anchor" href="#nsa-after-invocation-provider-parents"></a>Parent Elements of &lt;after-invocation-provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-after-invocation-provider-attributes"><a class="anchor" href="#nsa-after-invocation-provider-attributes"></a>&lt;after-invocation-provider&gt; Attributes</h6>
<div id="nsa-after-invocation-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean that implements <code>AfterInvocationProvider</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-post-annotation-handling"><a class="anchor" href="#nsa-pre-post-annotation-handling"></a>&lt;pre-post-annotation-handling&gt;</h5>
<div class="paragraph">
<p>Allows the default expression-based mechanism for handling Spring Security&#8217;s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) to be replaced entirely.
Only applies if these annotations are enabled.</p>
</div>
<div class="sect5">
<h6 id="nsa-pre-post-annotation-handling-parents"><a class="anchor" href="#nsa-pre-post-annotation-handling-parents"></a>Parent Elements of &lt;pre-post-annotation-handling&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pre-post-annotation-handling-children"><a class="anchor" href="#nsa-pre-post-annotation-handling-children"></a>Child Elements of &lt;pre-post-annotation-handling&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-invocation-attribute-factory">invocation-attribute-factory</a></p>
</li>
<li>
<p><a href="#nsa-post-invocation-advice">post-invocation-advice</a></p>
</li>
<li>
<p><a href="#nsa-pre-invocation-advice">pre-invocation-advice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-invocation-attribute-factory"><a class="anchor" href="#nsa-invocation-attribute-factory"></a>&lt;invocation-attribute-factory&gt;</h5>
<div class="paragraph">
<p>Defines the PrePostInvocationAttributeFactory instance which is used to generate pre and post invocation metadata from the annotated methods.</p>
</div>
<div class="sect5">
<h6 id="nsa-invocation-attribute-factory-parents"><a class="anchor" href="#nsa-invocation-attribute-factory-parents"></a>Parent Elements of &lt;invocation-attribute-factory&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-invocation-attribute-factory-attributes"><a class="anchor" href="#nsa-invocation-attribute-factory-attributes"></a>&lt;invocation-attribute-factory&gt; Attributes</h6>
<div id="nsa-invocation-attribute-factory-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-post-invocation-advice"><a class="anchor" href="#nsa-post-invocation-advice"></a>&lt;post-invocation-advice&gt;</h5>
<div class="paragraph">
<p>Customizes the <code>PostInvocationAdviceProvider</code> with the ref as the <code>PostInvocationAuthorizationAdvice</code> for the &lt;pre-post-annotation-handling&gt; element.</p>
</div>
<div class="sect5">
<h6 id="nsa-post-invocation-advice-parents"><a class="anchor" href="#nsa-post-invocation-advice-parents"></a>Parent Elements of &lt;post-invocation-advice&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-post-invocation-advice-attributes"><a class="anchor" href="#nsa-post-invocation-advice-attributes"></a>&lt;post-invocation-advice&gt; Attributes</h6>
<div id="nsa-post-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-invocation-advice"><a class="anchor" href="#nsa-pre-invocation-advice"></a>&lt;pre-invocation-advice&gt;</h5>
<div class="paragraph">
<p>Customizes the <code>PreInvocationAuthorizationAdviceVoter</code> with the ref as the <code>PreInvocationAuthorizationAdviceVoter</code> for the &lt;pre-post-annotation-handling&gt; element.</p>
</div>
<div class="sect5">
<h6 id="nsa-pre-invocation-advice-parents"><a class="anchor" href="#nsa-pre-invocation-advice-parents"></a>Parent Elements of &lt;pre-invocation-advice&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pre-invocation-advice-attributes"><a class="anchor" href="#nsa-pre-invocation-advice-attributes"></a>&lt;pre-invocation-advice&gt; Attributes</h6>
<div id="nsa-pre-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
Defines a reference to a Spring bean Id.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect-pointcut"><a class="anchor" href="#nsa-protect-pointcut"></a>Securing Methods using</h5>
<div class="paragraph">
<p><code>&lt;protect-pointcut&gt;</code>
Rather than defining security attributes on an individual method or class basis using the <code>@Secured</code> annotation, you can define cross-cutting security constraints across whole sets of methods and interfaces in your service layer using the <code>&lt;protect-pointcut&gt;</code> element.
You can find an example in the <a href="#ns-protect-pointcut">namespace introduction</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-protect-pointcut-parents"><a class="anchor" href="#nsa-protect-pointcut-parents"></a>Parent Elements of &lt;protect-pointcut&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-protect-pointcut-attributes"><a class="anchor" href="#nsa-protect-pointcut-attributes"></a>&lt;protect-pointcut&gt; Attributes</h6>
<div id="nsa-protect-pointcut-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
Access configuration attributes list that applies to all methods matching the pointcut, e.g.
"ROLE_A,ROLE_B"</p>
</li>
</ul>
</div>
<div id="nsa-protect-pointcut-expression" class="ulist">
<ul>
<li>
<p><strong>expression</strong>
An AspectJ expression, including the <code>execution</code> keyword.
For example, <code>execution(int com.foo.TargetObject.countLength(String))</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-methods"><a class="anchor" href="#nsa-intercept-methods"></a>&lt;intercept-methods&gt;</h5>
<div class="paragraph">
<p>Can be used inside a bean definition to add a security interceptor to the bean and set up access configuration attributes for the bean&#8217;s methods</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-methods-attributes"><a class="anchor" href="#nsa-intercept-methods-attributes"></a>&lt;intercept-methods&gt; Attributes</h6>
<div id="nsa-intercept-methods-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
Optional AccessDecisionManager bean ID to be used by the created method security interceptor.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-methods-children"><a class="anchor" href="#nsa-intercept-methods-children"></a>Child Elements of &lt;intercept-methods&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-method-security-metadata-source"><a class="anchor" href="#nsa-method-security-metadata-source"></a>&lt;method-security-metadata-source&gt;</h5>
<div class="paragraph">
<p>Creates a MethodSecurityMetadataSource instance</p>
</div>
<div class="sect5">
<h6 id="nsa-method-security-metadata-source-attributes"><a class="anchor" href="#nsa-method-security-metadata-source-attributes"></a>&lt;method-security-metadata-source&gt; Attributes</h6>
<div id="nsa-method-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-method-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
Enables the use of expressions in the 'access' attributes in &lt;intercept-url&gt; elements rather than the traditional list of configuration attributes.
Defaults to 'false'.
If enabled, each attribute should contain a single Boolean expression.
If the expression evaluates to 'true', access will be granted.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-method-security-metadata-source-children"><a class="anchor" href="#nsa-method-security-metadata-source-children"></a>Child Elements of &lt;method-security-metadata-source&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect"><a class="anchor" href="#nsa-protect"></a>&lt;protect&gt;</h5>
<div class="paragraph">
<p>Defines a protected method and the access control configuration attributes that apply to it.
We strongly advise you NOT to mix "protect" declarations with any services provided "global-method-security".</p>
</div>
<div class="sect5">
<h6 id="nsa-protect-parents"><a class="anchor" href="#nsa-protect-parents"></a>Parent Elements of &lt;protect&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-methods">intercept-methods</a></p>
</li>
<li>
<p><a href="#nsa-method-security-metadata-source">method-security-metadata-source</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-protect-attributes"><a class="anchor" href="#nsa-protect-attributes"></a>&lt;protect&gt; Attributes</h6>
<div id="nsa-protect-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
Access configuration attributes list that applies to the method, e.g.
"ROLE_A,ROLE_B".</p>
</li>
</ul>
</div>
<div id="nsa-protect-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
A method name</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-ldap"><a class="anchor" href="#nsa-ldap"></a>LDAP Namespace Options</h4>
<div class="paragraph">
<p>LDAP is covered in some details in <a href="#servlet-authentication-ldap">its own chapter</a>.
We will expand on that here with some explanation of how the namespace options map to Spring beans.
The LDAP implementation uses Spring LDAP extensively, so some familiarity with that project&#8217;s API may be useful.</p>
</div>
<div class="sect4">
<h5 id="nsa-ldap-server"><a class="anchor" href="#nsa-ldap-server"></a>Defining the LDAP Server using the</h5>
<div class="paragraph">
<p><code>&lt;ldap-server&gt;</code> Element
This element sets up a Spring LDAP <code>ContextSource</code> for use by the other LDAP beans, defining the location of the LDAP server and other information (such as a username and password, if it doesn&#8217;t allow anonymous access) for connecting to it.
It can also be used to create an embedded server for testing.
Details of the syntax for both options are covered in the <a href="#servlet-authentication-ldap">LDAP chapter</a>.
The actual <code>ContextSource</code> implementation is <code>DefaultSpringSecurityContextSource</code> which extends Spring LDAP&#8217;s <code>LdapContextSource</code> class.
The <code>manager-dn</code> and <code>manager-password</code> attributes map to the latter&#8217;s <code>userDn</code> and <code>password</code> properties respectively.</p>
</div>
<div class="paragraph">
<p>If you only have one server defined in your application context, the other LDAP namespace-defined beans will use it automatically.
Otherwise, you can give the element an "id" attribute and refer to it from other namespace beans using the <code>server-ref</code> attribute.
This is actually the bean <code>id</code> of the <code>ContextSource</code> instance, if you want to use it in other traditional Spring beans.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-server-attributes"><a class="anchor" href="#nsa-ldap-server-attributes"></a>&lt;ldap-server&gt; Attributes</h6>
<div id="nsa-ldap-server-mode" class="ulist">
<ul>
<li>
<p><strong>mode</strong>
Explicitly specifies which embedded ldap server should use. Values are <code>apacheds</code> and <code>unboundid</code>. By default, it will depends if the library is available in the classpath.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-ldif" class="ulist">
<ul>
<li>
<p><strong>ldif</strong>
Explicitly specifies an ldif file resource to load into an embedded LDAP server.
The ldif should be a Spring resource pattern (i.e. classpath:init.ldif).
The default is classpath*:*.ldif</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-dn" class="ulist">
<ul>
<li>
<p><strong>manager-dn</strong>
Username (DN) of the "manager" user identity which will be used to authenticate to a (non-embedded) LDAP server.
If omitted, anonymous access will be used.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-password" class="ulist">
<ul>
<li>
<p><strong>manager-password</strong>
The password for the manager DN.
This is required if the manager-dn is specified.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-port" class="ulist">
<ul>
<li>
<p><strong>port</strong>
Specifies an IP port number.
Used to configure an embedded LDAP server, for example.
The default value is 33389.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-root" class="ulist">
<ul>
<li>
<p><strong>root</strong>
Optional root suffix for the embedded LDAP server.
Default is "dc=springframework,dc=org"</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-url" class="ulist">
<ul>
<li>
<p><strong>url</strong>
Specifies the ldap server URL when not using the embedded LDAP server.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-authentication-provider"><a class="anchor" href="#nsa-ldap-authentication-provider"></a>&lt;ldap-authentication-provider&gt;</h5>
<div class="paragraph">
<p>This element is shorthand for the creation of an <code>LdapAuthenticationProvider</code> instance.
By default this will be configured with a <code>BindAuthenticator</code> instance and a <code>DefaultAuthoritiesPopulator</code>.
As with all namespace authentication providers, it must be included as a child of the <code>authentication-provider</code> element.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-parents"><a class="anchor" href="#nsa-ldap-authentication-provider-parents"></a>Parent Elements of &lt;ldap-authentication-provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-attributes"><a class="anchor" href="#nsa-ldap-authentication-provider-attributes"></a>&lt;ldap-authentication-provider&gt; Attributes</h6>
<div id="nsa-ldap-authentication-provider-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
The LDAP attribute name which contains the role name which will be used within Spring Security.
Maps to the <code>DefaultLdapAuthoritiesPopulator</code>'s <code>groupRoleAttribute</code> property.
Defaults to "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
Search base for group membership searches.
Maps to the <code>DefaultLdapAuthoritiesPopulator</code>'s <code>groupSearchBase</code> constructor argument.
Defaults to "" (searching from the root).</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
Group search filter.
Maps to the <code>DefaultLdapAuthoritiesPopulator</code>'s <code>groupSearchFilter</code> property.
Defaults to <code>(uniqueMember={0})</code>.
The substituted parameter is the DN of the user.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
A non-empty string prefix that will be added to role strings loaded from persistent.
Maps to the <code>DefaultLdapAuthoritiesPopulator</code>'s <code>rolePrefix</code> property.
Defaults to "ROLE_".
Use the value "none" for no prefix in cases where the default is non-empty.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
The optional server to use.
If omitted, and a default LDAP server is registered (using &lt;ldap-server&gt; with no Id), that server will be used.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
Allows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user&#8217;s directory entry</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
Allows the objectClass of the user entry to be specified.
If set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-dn-pattern" class="ulist">
<ul>
<li>
<p><strong>user-dn-pattern</strong>
If your users are at a fixed location in the directory (i.e. you can work out the DN directly from the username without doing a directory search), you can use this attribute to map directly to the DN.
It maps directly to the <code>userDnPatterns</code> property of <code>AbstractLdapAuthenticator</code>.
The value is a specific pattern used to build the user&#8217;s DN, for example <code>uid={0},ou=people</code>.
The key <code>{0}</code> must be present and will be substituted with the username.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
Search base for user searches.
Defaults to "".
Only used with a 'user-search-filter'.</p>
<div class="paragraph">
<p>If you need to perform a search to locate the user in the directory, then you can set these attributes to control the search.
The <code>BindAuthenticator</code> will be configured with a <code>FilterBasedLdapUserSearch</code> and the attribute values map directly to the first two arguments of that bean&#8217;s constructor.
If these attributes aren&#8217;t set and no <code>user-dn-pattern</code> has been supplied as an alternative, then the default search values of <code>user-search-filter="(uid={0})"</code> and <code>user-search-base=""</code> will be used.</p>
</div>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong>
The LDAP filter used to search for users (optional).
For example <code>(uid={0})</code>.
The substituted parameter is the user&#8217;s login name.</p>
<div class="paragraph">
<p>If you need to perform a search to locate the user in the directory, then you can set these attributes to control the search.
The <code>BindAuthenticator</code> will be configured with a <code>FilterBasedLdapUserSearch</code> and the attribute values map directly to the first two arguments of that bean&#8217;s constructor.
If these attributes aren&#8217;t set and no <code>user-dn-pattern</code> has been supplied as an alternative, then the default search values of <code>user-search-filter="(uid={0})"</code> and <code>user-search-base=""</code> will be used.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-children"><a class="anchor" href="#nsa-ldap-authentication-provider-children"></a>Child Elements of &lt;ldap-authentication-provider&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-compare"><a class="anchor" href="#nsa-password-compare"></a>&lt;password-compare&gt;</h5>
<div class="paragraph">
<p>This is used as child element to <code>&lt;ldap-provider&gt;</code> and switches the authentication strategy from <code>BindAuthenticator</code> to <code>PasswordComparisonAuthenticator</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-parents"><a class="anchor" href="#nsa-password-compare-parents"></a>Parent Elements of &lt;password-compare&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-attributes"><a class="anchor" href="#nsa-password-compare-attributes"></a>&lt;password-compare&gt; Attributes</h6>
<div id="nsa-password-compare-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
Defines the hashing algorithm used on user passwords.
We recommend strongly against using MD4, as it is a very weak hashing algorithm.</p>
</li>
</ul>
</div>
<div id="nsa-password-compare-password-attribute" class="ulist">
<ul>
<li>
<p><strong>password-attribute</strong>
The attribute in the directory which contains the user password.
Defaults to "userPassword".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-children"><a class="anchor" href="#nsa-password-compare-children"></a>Child Elements of &lt;password-compare&gt;</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-user-service"><a class="anchor" href="#nsa-ldap-user-service"></a>&lt;ldap-user-service&gt;</h5>
<div class="paragraph">
<p>This element configures an LDAP <code>UserDetailsService</code>.
The class used is <code>LdapUserDetailsService</code> which is a combination of a <code>FilterBasedLdapUserSearch</code> and a <code>DefaultLdapAuthoritiesPopulator</code>.
The attributes it supports have the same usage as in <code>&lt;ldap-provider&gt;</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-user-service-attributes"><a class="anchor" href="#nsa-ldap-user-service-attributes"></a>&lt;ldap-user-service&gt; Attributes</h6>
<div id="nsa-ldap-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
Defines a reference to a cache for use with a UserDetailsService.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
The LDAP attribute name which contains the role name which will be used within Spring Security.
Defaults to "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
Search base for group membership searches.
Defaults to "" (searching from the root).</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
Group search filter.
Defaults to <code>(uniqueMember={0})</code>.
The substituted parameter is the DN of the user.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
A bean identifier, used for referring to the bean elsewhere in the context.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
A non-empty string prefix that will be added to role strings loaded from persistent storage (e.g.
"ROLE_").
Use the value "none" for no prefix in cases where the default is non-empty.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
The optional server to use.
If omitted, and a default LDAP server is registered (using &lt;ldap-server&gt; with no Id), that server will be used.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
Allows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user&#8217;s directory entry</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
Allows the objectClass of the user entry to be specified.
If set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
Search base for user searches.
Defaults to "".
Only used with a 'user-search-filter'.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong>
The LDAP filter used to search for users (optional).
For example <code>(uid={0})</code>.
The substituted parameter is the user&#8217;s login name.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-faq"><a class="anchor" href="#appendix-faq"></a>Spring Security FAQ</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#appendix-faq-general-questions">General Questions</a></p>
</li>
<li>
<p><a href="#appendix-faq-common-problems">Common Problems</a></p>
</li>
<li>
<p><a href="#appendix-faq-architecture">Spring Security Architecture Questions</a></p>
</li>
<li>
<p><a href="#appendix-faq-howto">Common "Howto" Requests</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="appendix-faq-general-questions"><a class="anchor" href="#appendix-faq-general-questions"></a>General Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-other-concerns">Will Spring Security take care of all my application security requirements?</a></p>
</li>
<li>
<p><a href="#appendix-faq-web-xml">Why not just use web.xml security?</a></p>
</li>
<li>
<p><a href="#appendix-faq-requirements">What Java and Spring Framework versions are required?</a></p>
</li>
<li>
<p><a href="#appendix-faq-start-simple">I&#8217;m new to Spring Security and I need to build an application that supports CAS single sign-on over HTTPS, while allowing Basic authentication locally for certain URLs, authenticating against multiple back end user information sources (LDAP and JDBC). I&#8217;ve copied some configuration files I found but it doesn&#8217;t work.</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-other-concerns"><a class="anchor" href="#appendix-faq-other-concerns"></a>Will Spring Security take care of all my application security requirements?</h5>
<div class="paragraph">
<p>Spring Security provides you with a very flexible framework for your authentication and authorization requirements, but there are many other considerations for building a secure application that are outside its scope.
Web applications are vulnerable to all kinds of attacks which you should be familiar with, preferably before you start development so you can design and code with them in mind from the beginning.
Check out the <a href="https://www.owasp.org/">OWASP web site</a> for information on the major issues facing web application developers and the countermeasures you can use against them.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-web-xml"><a class="anchor" href="#appendix-faq-web-xml"></a>Why not just use web.xml security?</h5>
<div class="paragraph">
<p>Let&#8217;s assume you&#8217;re developing an enterprise application based on Spring.
There are four security concerns you typically need to address: authentication, web request security, service layer security (i.e. your methods that implement business logic), and domain object instance security (i.e. different domain objects have different permissions). With these typical requirements in mind:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Authentication</em>: The servlet specification provides an approach to authentication.
However, you will need to configure the container to perform authentication which typically requires editing of container-specific "realm" settings.
This makes a non-portable configuration, and if you need to write an actual Java class to implement the container&#8217;s authentication interface, it becomes even more non-portable.
With Spring Security you achieve complete portability - right down to the WAR level.
Also, Spring Security offers a choice of production-proven authentication providers and mechanisms, meaning you can switch your authentication approaches at deployment time.
This is particularly valuable for software vendors writing products that need to work in an unknown target environment.</p>
</li>
<li>
<p><em>Web request security:</em> The servlet specification provides an approach to secure your request URIs.
However, these URIs can only be expressed in the servlet specification&#8217;s own limited URI path format.
Spring Security provides a far more comprehensive approach.
For instance, you can use Ant paths or regular expressions, you can consider parts of the URI other than simply the requested page (e.g.
you can consider HTTP GET parameters) and you can implement your own runtime source of configuration data.
This means your web request security can be dynamically changed during the actual execution of your webapp.</p>
</li>
<li>
<p><em>Service layer and domain object security:</em> The absence of support in the servlet specification for services layer security or domain object instance security represent serious limitations for multi-tiered applications.
Typically developers either ignore these requirements, or implement security logic within their MVC controller code (or even worse, inside the views). There are serious disadvantages with this approach:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><em>Separation of concerns:</em> Authorization is a crosscutting concern and should be implemented as such.
MVC controllers or views implementing authorization code makes it more difficult to test both the controller and authorization logic, more difficult to debug, and will often lead to code duplication.</p>
</li>
<li>
<p><em>Support for rich clients and web services:</em> If an additional client type must ultimately be supported, any authorization code embedded within the web layer is non-reusable.
It should be considered that Spring remoting exporters only export service layer beans (not MVC controllers). As such authorization logic needs to be located in the services layer to support a multitude of client types.</p>
</li>
<li>
<p><em>Layering issues:</em> An MVC controller or view is simply the incorrect architectural layer to implement authorization decisions concerning services layer methods or domain object instances.
Whilst the Principal may be passed to the services layer to enable it to make the authorization decision, doing so would introduce an additional argument on every services layer method.
A more elegant approach is to use a ThreadLocal to hold the Principal, although this would likely increase development time to a point where it would become more economical (on a cost-benefit basis) to simply use a dedicated security framework.</p>
</li>
<li>
<p><em>Authorisation code quality:</em> It is often said of web frameworks that they "make it easier to do the right things, and harder to do the wrong things". Security frameworks are the same, because they are designed in an abstract manner for a wide range of purposes.
Writing your own authorization code from scratch does not provide the "design check" a framework would offer, and in-house authorization code will typically lack the improvements that emerge from widespread deployment, peer review and new versions.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>For simple applications, servlet specification security may just be enough.
Although when considered within the context of web container portability, configuration requirements, limited web request security flexibility, and non-existent services layer and domain object instance security, it becomes clear why developers often look to alternative solutions.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-requirements"><a class="anchor" href="#appendix-faq-requirements"></a>What Java and Spring Framework versions are required?</h5>
<div class="paragraph">
<p>Spring Security 3.0 and 3.1 require at least JDK 1.5 and also require Spring 3.0.3 as a minimum.
Ideally you should be using the latest release versions to avoid problems.</p>
</div>
<div class="paragraph">
<p>Spring Security 2.0.x requires a minimum JDK version of 1.4 and is built against Spring 2.0.x.
It should also be compatible with applications using Spring 2.5.x.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-start-simple"><a class="anchor" href="#appendix-faq-start-simple"></a>I&#8217;m new to Spring Security and I need to build an application that supports CAS single sign-on over HTTPS, while allowing Basic authentication locally for certain URLs, authenticating against multiple back end user information sources (LDAP and JDBC). I&#8217;ve copied some configuration files I found but it doesn&#8217;t work.</h5>
<div class="paragraph">
<p>What could be wrong?</p>
</div>
<div class="paragraph">
<p>Or substitute an alternative complex scenario&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Realistically, you need an understanding of the technologies you are intending to use before you can successfully build applications with them.
Security is complicated.
Setting up a simple configuration using a login form and some hard-coded users using Spring Security&#8217;s namespace is reasonably straightforward.
Moving to using a backed JDBC database is also easy enough.
But if you try and jump straight to a complicated deployment scenario like this you will almost certainly be frustrated.
There is a big jump in the learning curve required to set up systems like CAS, configure LDAP servers and install SSL certificates properly.
So you need to take things one step at a time.</p>
</div>
<div class="paragraph">
<p>From a Spring Security perspective, the first thing you should do is follow the "Getting Started" guide on the web site.
This will take you through a series of steps to get up and running and get some idea of how the framework operates.
If you are using other technologies which you aren&#8217;t familiar with then you should do some research and try to make sure you can use them in isolation before combining them in a complex system.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-common-problems"><a class="anchor" href="#appendix-faq-common-problems"></a>Common Problems</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Authentication</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-bad-credentials">When I try to log in, I get an error message that says "Bad Credentials". What&#8217;s wrong?</a></p>
</li>
<li>
<p><a href="#appendix-faq-login-loop">My application goes into an "endless loop" when I try to login, what&#8217;s going on?</a></p>
</li>
<li>
<p><a href="#appendix-faq-anon-access-denied">I get an exception with the message "Access is denied (user is anonymous);". What&#8217;s wrong?</a></p>
</li>
<li>
<p><a href="#appendix-faq-cached-secure-page">Why can I still see a secured page even after I&#8217;ve logged out of my application?</a></p>
</li>
<li>
<p><a href="#auth-exception-credentials-not-found">I get an exception with the message "An Authentication object was not found in the SecurityContext". What&#8217;s wrong?</a></p>
</li>
<li>
<p><a href="#appendix-faq-ldap-authentication">I can&#8217;t get LDAP authentication to work.</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>Session Management</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-concurrent-session-same-browser">I&#8217;m using Spring Security&#8217;s concurrent session control to prevent users from logging in more than once at a time.</a></p>
</li>
<li>
<p><a href="#appendix-faq-new-session-on-authentication">Why does the session Id change when I authenticate through Spring Security?</a></p>
</li>
<li>
<p><a href="#appendix-faq-tomcat-https-session">I&#8217;m using Tomcat (or some other servlet container) and have enabled HTTPS for my login page, switching back to HTTP afterwards.</a></p>
</li>
<li>
<p><a href="#appendix-faq-session-listener-missing">I&#8217;m trying to use the concurrent session-control support but it won&#8217;t let me log back in, even if I&#8217;m sure I&#8217;ve logged out and haven&#8217;t exceeded the allowed sessions.</a></p>
</li>
<li>
<p><a href="#appendix-faq-unwanted-session-creation">Spring Security is creating a session somewhere, even though I&#8217;ve configured it not to, by setting the create-session attribute to never.</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>Miscellaneous</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-forbidden-csrf">I get a 403 Forbidden when performing a POST</a></p>
</li>
<li>
<p><a href="#appendix-faq-no-security-on-forward">I&#8217;m forwarding a request to another URL using the RequestDispatcher, but my security constraints aren&#8217;t being applied.</a></p>
</li>
<li>
<p><a href="#appendix-faq-method-security-in-web-context">I have added Spring Security&#8217;s &lt;global-method-security&gt; element to my application context but if I add security annotations to my Spring MVC controller beans (Struts actions etc.) then they don&#8217;t seem to have an effect.</a></p>
</li>
<li>
<p><a href="#appendix-faq-no-filters-no-context">I have a user who has definitely been authenticated, but when I try to access the SecurityContextHolder during some requests, the Authentication is null.</a></p>
</li>
<li>
<p><a href="#appendix-faq-method-security-with-taglib">The authorize JSP Tag doesn&#8217;t respect my method security annotations when using the URL attribute.</a></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-bad-credentials"><a class="anchor" href="#appendix-faq-bad-credentials"></a>When I try to log in, I get an error message that says "Bad Credentials". What&#8217;s wrong?</h5>
<div class="paragraph">
<p>This means that authentication has failed.
It doesn&#8217;t say why, as it is good practice to avoid giving details which might help an attacker guess account names or passwords.</p>
</div>
<div class="paragraph">
<p>This also means that if you ask this question in the forum, you will not get an answer unless you provide additional information.
As with any issue you should check the output from the debug log, note any exception stacktraces and related messages.
Step through the code in a debugger to see where the authentication fails and why.
Write a test case which exercises your authentication configuration outside of the application.
More often than not, the failure is due to a difference in the password data stored in a database and that entered by the user.
If you are using hashed passwords, make sure the value stored in your database is <em>exactly</em> the same as the value produced by the <code>PasswordEncoder</code> configured in your application.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-login-loop"><a class="anchor" href="#appendix-faq-login-loop"></a>My application goes into an "endless loop" when I try to login, what&#8217;s going on?</h5>
<div class="paragraph">
<p>A common user problem with infinite loop and redirecting to the login page is caused by accidentally configuring the login page as a "secured" resource.
Make sure your configuration allows anonymous access to the login page, either by excluding it from the security filter chain or marking it as requiring ROLE_ANONYMOUS.</p>
</div>
<div class="paragraph">
<p>If your AccessDecisionManager includes an AuthenticatedVoter, you can use the attribute "IS_AUTHENTICATED_ANONYMOUSLY". This is automatically available if you are using the standard namespace configuration setup.</p>
</div>
<div class="paragraph">
<p>From Spring Security 2.0.1 onwards, when you are using namespace-based configuration, a check will be made on loading the application context and a warning message logged if your login page appears to be protected.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-anon-access-denied"><a class="anchor" href="#appendix-faq-anon-access-denied"></a>I get an exception with the message "Access is denied (user is anonymous);". What&#8217;s wrong?</h5>
<div class="paragraph">
<p>This is a debug level message which occurs the first time an anonymous user attempts to access a protected resource.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">DEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point
org.springframework.security.AccessDeniedException: Access is denied
at org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68)
at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is normal and shouldn&#8217;t be anything to worry about.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-cached-secure-page"><a class="anchor" href="#appendix-faq-cached-secure-page"></a>Why can I still see a secured page even after I&#8217;ve logged out of my application?</h5>
<div class="paragraph">
<p>The most common reason for this is that your browser has cached the page and you are seeing a copy which is being retrieved from the browsers cache.
Verify this by checking whether the browser is actually sending the request (check your server access logs, the debug log or use a suitable browser debugging plugin such as "Tamper Data" for Firefox). This has nothing to do with Spring Security and you should configure your application or server to set the appropriate <code>Cache-Control</code> response headers.
Note that SSL requests are never cached.</p>
</div>
</div>
<div class="sect4">
<h5 id="auth-exception-credentials-not-found"><a class="anchor" href="#auth-exception-credentials-not-found"></a>I get an exception with the message "An Authentication object was not found in the SecurityContext". What&#8217;s wrong?</h5>
<div class="paragraph">
<p>This is a another debug level message which occurs the first time an anonymous user attempts to access a protected resource, but when you do not have an <code>AnonymousAuthenticationFilter</code> in your filter chain configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">DEBUG [ExceptionTranslationFilter] - Authentication exception occurred; redirecting to authentication entry point
org.springframework.security.AuthenticationCredentialsNotFoundException:
							An Authentication object was not found in the SecurityContext
at org.springframework.security.intercept.AbstractSecurityInterceptor.credentialsNotFound(AbstractSecurityInterceptor.java:342)
at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:254)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is normal and shouldn&#8217;t be anything to worry about.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-ldap-authentication"><a class="anchor" href="#appendix-faq-ldap-authentication"></a>I can&#8217;t get LDAP authentication to work.</h5>
<div class="paragraph">
<p>What&#8217;s wrong with my configuration?</p>
</div>
<div class="paragraph">
<p>Note that the permissions for an LDAP directory often do not allow you to read the password for a user.
Hence it is often not possible to use the <a href="#appendix-faq-what-is-userdetailservice">What is a UserDetailsService and do I need one?</a> where Spring Security compares the stored password with the one submitted by the user.
The most common approach is to use LDAP "bind", which is one of the operations supported by <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">the LDAP protocol</a>. With this approach, Spring Security validates the password by attempting to authenticate to the directory as the user.</p>
</div>
<div class="paragraph">
<p>The most common problem with LDAP authentication is a lack of knowledge of the directory server tree structure and configuration.
This will be different in different companies, so you have to find it out yourself.
Before adding a Spring Security LDAP configuration to an application, it&#8217;s a good idea to write a simple test using standard Java LDAP code (without Spring Security involved), and make sure you can get that to work first.
For example, to authenticate a user, you could use the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void ldapAuthenticationIsSuccessful() throws Exception {
		Hashtable&lt;String,String&gt; env = new Hashtable&lt;String,String&gt;();
		env.put(Context.SECURITY_AUTHENTICATION, "simple");
		env.put(Context.SECURITY_PRINCIPAL, "cn=joe,ou=users,dc=mycompany,dc=com");
		env.put(Context.PROVIDER_URL, "ldap://mycompany.com:389/dc=mycompany,dc=com");
		env.put(Context.SECURITY_CREDENTIALS, "joespassword");
		env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");

		InitialLdapContext ctx = new InitialLdapContext(env, null);

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_session_management"><a class="anchor" href="#_session_management"></a>Session Management</h5>
<div class="paragraph">
<p>Session management issues are a common source of forum questions.
If you are developing Java web applications, you should understand how the session is maintained between the servlet container and the user&#8217;s browser.
You should also understand the difference between secure and non-secure cookies and the implications of using HTTP/HTTPS and switching between the two.
Spring Security has nothing to do with maintaining the session or providing session identifiers.
This is entirely handled by the servlet container.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-concurrent-session-same-browser"><a class="anchor" href="#appendix-faq-concurrent-session-same-browser"></a>I&#8217;m using Spring Security&#8217;s concurrent session control to prevent users from logging in more than once at a time.</h5>
<div class="paragraph">
<p>When I open another browser window after logging in, it doesn&#8217;t stop me from logging in again.
Why can I log in more than once?</p>
</div>
<div class="paragraph">
<p>Browsers generally maintain a single session per browser instance.
You cannot have two separate sessions at once.
So if you log in again in another window or tab you are just reauthenticating in the same session.
The server doesn&#8217;t know anything about tabs, windows or browser instances.
All it sees are HTTP requests and it ties those to a particular session according to the value of the JSESSIONID cookie that they contain.
When a user authenticates during a session, Spring Security&#8217;s concurrent session control checks the number of <em>other authenticated sessions</em> that they have.
If they are already authenticated with the same session, then re-authenticating will have no effect.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-new-session-on-authentication"><a class="anchor" href="#appendix-faq-new-session-on-authentication"></a>Why does the session Id change when I authenticate through Spring Security?</h5>
<div class="paragraph">
<p>With the default configuration, Spring Security changes the session ID when the user authenticates.
If you&#8217;re using a Servlet 3.1 or newer container, the session ID is simply changed.
If you&#8217;re using an older container, Spring Security invalidates the existing session, creates a new session, and transfers the session data to the new session.
Changing the session identifier in this manner prevents"session-fixation" attacks.
You can find more about this online and in the reference manual.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-tomcat-https-session"><a class="anchor" href="#appendix-faq-tomcat-https-session"></a>I&#8217;m using Tomcat (or some other servlet container) and have enabled HTTPS for my login page, switching back to HTTP afterwards.</h5>
<div class="paragraph">
<p>It doesn&#8217;t work - I just end up back at the login page after authenticating.</p>
</div>
<div class="paragraph">
<p>This happens because sessions created under HTTPS, for which the session cookie is marked as "secure", cannot subsequently be used under HTTP. The browser will not send the cookie back to the server and any session state will be lost (including the security context information). Starting a session in HTTP first should work as the session cookie won&#8217;t be marked as secure.
However, Spring Security&#8217;s <a href="https://docs.spring.io/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#ns-session-fixation">Session Fixation Protection</a> can interfere with this because it results in a new session ID cookie being sent back to the user&#8217;s browser, usually with the secure flag.
To get around this, you can disable session fixation protection, but in newer Servlet containers you can also configure session cookies to never use the secure flag.
Note that switching between HTTP and HTTPS is not a good idea in general, as any application which uses HTTP at all is vulnerable to man-in-the-middle attacks.
To be truly secure, the user should begin accessing your site in HTTPS and continue using it until they log out.
Even clicking on an HTTPS link from a page accessed over HTTP is potentially risky.
If you need more convincing, check out a tool like <a href="https://www.thoughtcrime.org/software/sslstrip/">sslstrip</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_im_not_switching_between_http_and_https_but_my_session_is_still_getting_lost"><a class="anchor" href="#_im_not_switching_between_http_and_https_but_my_session_is_still_getting_lost"></a>I&#8217;m not switching between HTTP and HTTPS but my session is still getting lost</h5>
<div class="paragraph">
<p>Sessions are maintained either by exchanging a session cookie or by adding a <code>jsessionid</code> parameter to URLs (this happens automatically if you are using JSTL to output URLs, or if you call <code>HttpServletResponse.encodeUrl</code> on URLs (before a redirect, for example). If clients have cookies disabled, and you are not rewriting URLs to include the <code>jsessionid</code>, then the session will be lost.
Note that the use of cookies is preferred for security reasons, as it does not expose the session information in the URL.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-session-listener-missing"><a class="anchor" href="#appendix-faq-session-listener-missing"></a>I&#8217;m trying to use the concurrent session-control support but it won&#8217;t let me log back in, even if I&#8217;m sure I&#8217;ve logged out and haven&#8217;t exceeded the allowed sessions.</h5>
<div class="paragraph">
<p>Make sure you have added the listener to your web.xml file.
It is essential to make sure that the Spring Security session registry is notified when a session is destroyed.
Without it, the session information will not be removed from the registry.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
		&lt;listener-class&gt;org.springframework.security.web.session.HttpSessionEventPublisher&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-unwanted-session-creation"><a class="anchor" href="#appendix-faq-unwanted-session-creation"></a>Spring Security is creating a session somewhere, even though I&#8217;ve configured it not to, by setting the create-session attribute to never.</h5>
<div class="paragraph">
<p>This usually means that the user&#8217;s application is creating a session somewhere, but that they aren&#8217;t aware of it.
The most common culprit is a JSP. Many people aren&#8217;t aware that JSPs create sessions by default.
To prevent a JSP from creating a session, add the directive <code>&lt;%@ page session="false" %&gt;</code> to the top of the page.</p>
</div>
<div class="paragraph">
<p>If you are having trouble working out where a session is being created, you can add some debugging code to track down the location(s). One way to do this would be to add a <code>javax.servlet.http.HttpSessionListener</code> to your application, which calls <code>Thread.dumpStack()</code> in the <code>sessionCreated</code> method.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-forbidden-csrf"><a class="anchor" href="#appendix-faq-forbidden-csrf"></a>I get a 403 Forbidden when performing a POST</h5>
<div class="paragraph">
<p>If an HTTP 403 Forbidden is returned for HTTP POST, but works for HTTP GET then the issue is most likely related to <a href="https://docs.spring.io/spring-security/site/docs/3.2.x/reference/htmlsingle/#csrf">CSRF</a>. Either provide the CSRF Token or disable CSRF protection (not recommended).</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-no-security-on-forward"><a class="anchor" href="#appendix-faq-no-security-on-forward"></a>I&#8217;m forwarding a request to another URL using the RequestDispatcher, but my security constraints aren&#8217;t being applied.</h5>
<div class="paragraph">
<p>Filters are not applied by default to forwards or includes.
If you really want the security filters to be applied to forwards and/or includes, then you have to configure these explicitly in your web.xml using the &lt;dispatcher&gt; element, a child element of &lt;filter-mapping&gt;.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-method-security-in-web-context"><a class="anchor" href="#appendix-faq-method-security-in-web-context"></a>I have added Spring Security&#8217;s &lt;global-method-security&gt; element to my application context but if I add security annotations to my Spring MVC controller beans (Struts actions etc.) then they don&#8217;t seem to have an effect.</h5>
<div class="paragraph">
<p>In a Spring web application, the application context which holds the Spring MVC beans for the dispatcher servlet is often separate from the main application context.
It is often defined in a file called <code>myapp-servlet.xml</code>, where "myapp" is the name assigned to the Spring <code>DispatcherServlet</code> in <code>web.xml</code>. An application can have multiple <code>DispatcherServlet</code>s, each with its own isolated application context.
The beans in these "child" contexts are not visible to the rest of the application.
The"parent" application context is loaded by the <code>ContextLoaderListener</code> you define in your <code>web.xml</code> and is visible to all the child contexts.
This parent context is usually where you define your security configuration, including the <code>&lt;global-method-security&gt;</code> element). As a result any security constraints applied to methods in these web beans will not be enforced, since the beans cannot be seen from the <code>DispatcherServlet</code> context.
You need to either move the <code>&lt;global-method-security&gt;</code> declaration to the web context or moved the beans you want secured into the main application context.</p>
</div>
<div class="paragraph">
<p>Generally we would recommend applying method security at the service layer rather than on individual web controllers.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-no-filters-no-context"><a class="anchor" href="#appendix-faq-no-filters-no-context"></a>I have a user who has definitely been authenticated, but when I try to access the SecurityContextHolder during some requests, the Authentication is null.</h5>
<div class="paragraph">
<p>Why can&#8217;t I see the user information?</p>
</div>
<div class="paragraph">
<p>If you have excluded the request from the security filter chain using the attribute <code>filters='none'</code> in the <code>&lt;intercept-url&gt;</code> element that matches the URL pattern, then the <code>SecurityContextHolder</code> will not be populated for that request.
Check the debug log to see whether the request is passing through the filter chain.
(You are reading the debug log, right?).</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-method-security-with-taglib"><a class="anchor" href="#appendix-faq-method-security-with-taglib"></a>The authorize JSP Tag doesn&#8217;t respect my method security annotations when using the URL attribute.</h5>
<div class="paragraph">
<p>Method security will not hide links when using the <code>url</code> attribute in <code>&lt;sec:authorize&gt;</code> because we cannot readily reverse engineer what URL is mapped to what controller endpoint as controllers can rely on headers, current user, etc to determine what method to invoke.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-architecture"><a class="anchor" href="#appendix-faq-architecture"></a>Spring Security Architecture Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-where-is-class-x">How do I know which package class X is in?</a></p>
</li>
<li>
<p><a href="#appendix-faq-namespace-to-bean-mapping">How do the namespace elements map to conventional bean configurations?</a></p>
</li>
<li>
<p><a href="#appendix-faq-role-prefix">What does "ROLE_" mean and why do I need it on my role names?</a></p>
</li>
<li>
<p><a href="#appendix-faq-what-dependencies">How do I know which dependencies to add to my application to work with Spring Security?</a></p>
</li>
<li>
<p><a href="#appendix-faq-apacheds-deps">What dependencies are needed to run an embedded ApacheDS LDAP server?</a></p>
</li>
<li>
<p><a href="#appendix-faq-what-is-userdetailservice">What is a UserDetailsService and do I need one?</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-where-is-class-x"><a class="anchor" href="#appendix-faq-where-is-class-x"></a>How do I know which package class X is in?</h5>
<div class="paragraph">
<p>The best way of locating classes is by installing the Spring Security source in your IDE. The distribution includes source jars for each of the modules the project is divided up into.
Add these to your project source path and you can navigate directly to Spring Security classes (<code>Ctrl-Shift-T</code> in Eclipse). This also makes debugging easier and allows you to troubleshoot exceptions by looking directly at the code where they occur to see what&#8217;s going on there.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-namespace-to-bean-mapping"><a class="anchor" href="#appendix-faq-namespace-to-bean-mapping"></a>How do the namespace elements map to conventional bean configurations?</h5>
<div class="paragraph">
<p>There is a general overview of what beans are created by the namespace in the namespace appendix of the reference guide.
There is also a detailed blog article called "Behind the Spring Security Namespace" on <a href="https://spring.io/blog/2010/03/06/behind-the-spring-security-namespace/">blog.springsource.com</a>. If want to know the full details then the code is in the <code>spring-security-config</code> module within the Spring Security 3.0 distribution.
You should probably read the chapters on namespace parsing in the standard Spring Framework reference documentation first.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-role-prefix"><a class="anchor" href="#appendix-faq-role-prefix"></a>What does "ROLE_" mean and why do I need it on my role names?</h5>
<div class="paragraph">
<p>Spring Security has a voter-based architecture which means that an access decision is made by a series of <code>AccessDecisionVoter</code>s.
The voters act on the "configuration attributes" which are specified for a secured resource (such as a method invocation). With this approach, not all attributes may be relevant to all voters and a voter needs to know when it should ignore an attribute (abstain) and when it should vote to grant or deny access based on the attribute value.
The most common voter is the <code>RoleVoter</code> which by default votes whenever it finds an attribute with the "ROLE_" prefix.
It makes a simple comparison of the attribute (such as "ROLE_USER") with the names of the authorities which the current user has been assigned.
If it finds a match (they have an authority called "ROLE_USER"), it votes to grant access, otherwise it votes to deny access.</p>
</div>
<div class="paragraph">
<p>The prefix can be changed by setting the <code>rolePrefix</code> property of <code>RoleVoter</code>. If you only need to use roles in your application and have no need for other custom voters, then you can set the prefix to a blank string, in which case the <code>RoleVoter</code> will treat all attributes as roles.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-what-dependencies"><a class="anchor" href="#appendix-faq-what-dependencies"></a>How do I know which dependencies to add to my application to work with Spring Security?</h5>
<div class="paragraph">
<p>It will depend on what features you are using and what type of application you are developing.
With Spring Security 3.0, the project jars are divided into clearly distinct areas of functionality, so it is straightforward to work out which Spring Security jars you need from your application requirements.
All applications will need the <code>spring-security-core</code> jar.
If you&#8217;re developing a web application, you need the <code>spring-security-web</code> jar.
If you&#8217;re using security namespace configuration you need the <code>spring-security-config</code> jar, for LDAP support you need the <code>spring-security-ldap</code> jar and so on.</p>
</div>
<div class="paragraph">
<p>For third-party jars the situation isn&#8217;t always quite so obvious.
A good starting point is to copy those from one of the pre-built sample applications WEB-INF/lib directories.
For a basic application, you can start with the tutorial sample.
If you want to use LDAP, with an embedded test server, then use the LDAP sample as a starting point.
The reference manual also includes <a href="https://static.springsource.org/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#appendix-dependencies">an appendix</a> listing the first-level dependencies for each Spring Security module with some information on whether they are optional and what they are required for.</p>
</div>
<div class="paragraph">
<p>If you are building your project with maven, then adding the appropriate Spring Security modules as dependencies to your pom.xml will automatically pull in the core jars that the framework requires.
Any which are marked as "optional" in the Spring Security POM files will have to be added to your own pom.xml file if you need them.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-apacheds-deps"><a class="anchor" href="#appendix-faq-apacheds-deps"></a>What dependencies are needed to run an embedded ApacheDS LDAP server?</h5>
<div class="paragraph">
<p>If you are using Maven, you need to add the following to your pom dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;dependency&gt;
		&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
		&lt;artifactId&gt;apacheds-core&lt;/artifactId&gt;
		&lt;version&gt;1.5.5&lt;/version&gt;
		&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
		&lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
		&lt;artifactId&gt;apacheds-server-jndi&lt;/artifactId&gt;
		&lt;version&gt;1.5.5&lt;/version&gt;
		&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The other required jars should be pulled in transitively.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-what-is-userdetailservice"><a class="anchor" href="#appendix-faq-what-is-userdetailservice"></a>What is a UserDetailsService and do I need one?</h5>
<div class="paragraph">
<p><code>UserDetailsService</code> is a DAO interface for loading data that is specific to a user account.
It has no other function other to load that data for use by other components within the framework.
It is not responsible for authenticating the user.
Authenticating a user with a username/password combination is most commonly performed by the <code>DaoAuthenticationProvider</code>, which is injected with a <code>UserDetailsService</code> to allow it to load the password (and other data) for a user in order to compare it with the submitted value.
Note that if you are using LDAP, <a href="#appendix-faq-ldap-authentication">this approach may not work</a>.</p>
</div>
<div class="paragraph">
<p>If you want to customize the authentication process then you should implement <code>AuthenticationProvider</code> yourself.
See this <a href="https://spring.io/blog/2010/08/02/spring-security-in-google-app-engine/"> blog article</a> for an example integrating Spring Security authentication with Google App Engine.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-howto"><a class="anchor" href="#appendix-faq-howto"></a>Common "Howto" Requests</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-extra-login-fields">I need to login in with more information than just the username.</a></p>
</li>
<li>
<p><a href="#appendix-faq-matching-url-fragments">How do I apply different intercept-url constraints where only the fragment value of the requested URLs differs (e.g./foo#bar and /foo#blah?</a></p>
</li>
<li>
<p><a href="#appendix-faq-request-details-in-user-service">How do I access the user&#8217;s IP Address (or other web-request data) in a UserDetailsService?</a></p>
</li>
<li>
<p><a href="#appendix-faq-access-session-from-user-service">How do I access the HttpSession from a UserDetailsService?</a></p>
</li>
<li>
<p><a href="#appendix-faq-password-in-user-service">How do I access the user&#8217;s password in a UserDetailsService?</a></p>
</li>
<li>
<p><a href="#appendix-faq-dynamic-url-metadata">How do I define the secured URLs within an application dynamically?</a></p>
</li>
<li>
<p><a href="#appendix-faq-ldap-authorities">How do I authenticate against LDAP but load user roles from a database?</a></p>
</li>
<li>
<p><a href="#appendix-faq-namespace-post-processor">I want to modify the property of a bean that is created by the namespace, but there is nothing in the schema to support it.</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-extra-login-fields"><a class="anchor" href="#appendix-faq-extra-login-fields"></a>I need to login in with more information than just the username.</h5>
<div class="paragraph">
<p>How do I add support for extra login fields (e.g.
a company name)?</p>
</div>
<div class="paragraph">
<p>This question comes up repeatedly in the Spring Security forum so you                           will find more information there by searching the archives (or through google).</p>
</div>
<div class="paragraph">
<p>The submitted login information is processed by an instance of <code>UsernamePasswordAuthenticationFilter</code>. You will need to customize this class to handle the extra data field(s). One option is to use your own customized authentication token class (rather than the standard <code>UsernamePasswordAuthenticationToken</code>), another is simply to concatenate the extra fields with the username (for example, using a ":" as the separator) and pass them in the username property of <code>UsernamePasswordAuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p>You will also need to customize the actual authentication process.
If you are using a custom authentication token class, for example, you will have to write an <code>AuthenticationProvider</code> to handle it (or extend the standard <code>DaoAuthenticationProvider</code>). If you have concatenated the fields, you can implement your own <code>UserDetailsService</code> which splits them up and loads the appropriate user data for authentication.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-matching-url-fragments"><a class="anchor" href="#appendix-faq-matching-url-fragments"></a>How do I apply different intercept-url constraints where only the fragment value of the requested URLs differs (e.g./foo#bar and /foo#blah?</h5>
<div class="paragraph">
<p>You can&#8217;t do this, since the fragment is not transmitted from the browser to the server.
The URLs above are identical from the server&#8217;s perspective.
This is a common question from GWT users.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-request-details-in-user-service"><a class="anchor" href="#appendix-faq-request-details-in-user-service"></a>How do I access the user&#8217;s IP Address (or other web-request data) in a UserDetailsService?</h5>
<div class="paragraph">
<p>Obviously you can&#8217;t (without resorting to something like thread-local variables) since the only information supplied to the interface is the username.
Instead of implementing <code>UserDetailsService</code>, you should implement <code>AuthenticationProvider</code> directly and extract the information from the supplied <code>Authentication</code> token.</p>
</div>
<div class="paragraph">
<p>In a standard web setup, the <code>getDetails()</code> method on the <code>Authentication</code> object will return an instance of <code>WebAuthenticationDetails</code>. If you need additional information, you can inject a custom <code>AuthenticationDetailsSource</code> into the authentication filter you are using.
If you are using the namespace, for example with the <code>&lt;form-login&gt;</code> element, then you should remove this element and replace it with a <code>&lt;custom-filter&gt;</code> declaration pointing to an explicitly configured <code>UsernamePasswordAuthenticationFilter</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-access-session-from-user-service"><a class="anchor" href="#appendix-faq-access-session-from-user-service"></a>How do I access the HttpSession from a UserDetailsService?</h5>
<div class="paragraph">
<p>You can&#8217;t, since the <code>UserDetailsService</code> has no awareness of the servlet API. If you want to store custom user data, then you should customize the <code>UserDetails</code> object which is returned.
This can then be accessed at any point, via the thread-local <code>SecurityContextHolder</code>. A call to <code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code> will return this custom object.</p>
</div>
<div class="paragraph">
<p>If you really need to access the session, then it must be done by customizing the web tier.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-password-in-user-service"><a class="anchor" href="#appendix-faq-password-in-user-service"></a>How do I access the user&#8217;s password in a UserDetailsService?</h5>
<div class="paragraph">
<p>You can&#8217;t (and shouldn&#8217;t). You are probably misunderstanding its purpose.
See "<a href="#appendix-faq-what-is-userdetailservice">What is a UserDetailsService?</a>" above.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-dynamic-url-metadata"><a class="anchor" href="#appendix-faq-dynamic-url-metadata"></a>How do I define the secured URLs within an application dynamically?</h5>
<div class="paragraph">
<p>People often ask about how to store the mapping between secured URLs and security metadata attributes in a database, rather than in the application context.</p>
</div>
<div class="paragraph">
<p>The first thing you should ask yourself is if you really need to do this.
If an application requires securing, then it also requires that the security be tested thoroughly based on a defined policy.
It may require auditing and acceptance testing before being rolled out into a production environment.
A security-conscious organization should be aware that the benefits of their diligent testing process could be wiped out instantly by allowing the security settings to be modified at runtime by changing a row or two in a configuration database.
If you have taken this into account (perhaps using multiple layers of security within your application) then Spring Security allows you to fully customize the source of security metadata.
You can make it fully dynamic if you choose.</p>
</div>
<div class="paragraph">
<p>Both method and web security are protected by subclasses of <code>AbstractSecurityInterceptor</code> which is configured with a <code>SecurityMetadataSource</code> from which it obtains the metadata for a particular method or filter invocation.
For web security, the interceptor class is <code>FilterSecurityInterceptor</code> and it uses the marker interface <code>FilterInvocationSecurityMetadataSource</code>. The "secured object" type it operates on is a <code>FilterInvocation</code>. The default implementation which is used (both in the namespace <code>&lt;http&gt;</code> and when configuring the interceptor explicitly, stores the list of URL patterns and their corresponding list of "configuration attributes" (instances of <code>ConfigAttribute</code>) in an in-memory map.</p>
</div>
<div class="paragraph">
<p>To load the data from an alternative source, you must be using an explicitly declared security filter chain (typically Spring Security&#8217;s <code>FilterChainProxy</code>) in order to customize the <code>FilterSecurityInterceptor</code> bean.
You can&#8217;t use the namespace.
You would then implement <code>FilterInvocationSecurityMetadataSource</code> to load the data as you please for a particular <code>FilterInvocation</code> <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>. A very basic outline would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">	public class MyFilterSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

		public List&lt;ConfigAttribute&gt; getAttributes(Object object) {
			FilterInvocation fi = (FilterInvocation) object;
				String url = fi.getRequestUrl();
				String httpMethod = fi.getRequest().getMethod();
				List&lt;ConfigAttribute&gt; attributes = new ArrayList&lt;ConfigAttribute&gt;();

				// Lookup your database (or other source) using this information and populate the
				// list of attributes

				return attributes;
		}

		public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
			return null;
		}

		public boolean supports(Class&lt;?&gt; clazz) {
			return FilterInvocation.class.isAssignableFrom(clazz);
		}
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, look at the code for <code>DefaultFilterInvocationSecurityMetadataSource</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-ldap-authorities"><a class="anchor" href="#appendix-faq-ldap-authorities"></a>How do I authenticate against LDAP but load user roles from a database?</h5>
<div class="paragraph">
<p>The <code>LdapAuthenticationProvider</code> bean (which handles normal LDAP authentication in Spring Security) is configured with two separate strategy interfaces, one which performs the authentication and one which loads the user authorities, called <code>LdapAuthenticator</code> and <code>LdapAuthoritiesPopulator</code> respectively.
The <code>DefaultLdapAuthoritiesPopulator</code> loads the user authorities from the LDAP directory and has various configuration parameters to allow you to specify how these should be retrieved.</p>
</div>
<div class="paragraph">
<p>To use JDBC instead, you can implement the interface yourself, using whatever SQL is appropriate for your schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">	public class MyAuthoritiesPopulator implements LdapAuthoritiesPopulator {
		@Autowired
		JdbcTemplate template;

		List&lt;GrantedAuthority&gt; getGrantedAuthorities(DirContextOperations userData, String username) {
			List&lt;GrantedAuthority&gt; = template.query("select role from roles where username = ?",
																									new String[] {username},
																									new RowMapper&lt;GrantedAuthority&gt;() {
				/**
				 *  We're assuming here that you're using the standard convention of using the role
				 *  prefix "ROLE_" to mark attributes which are supported by Spring Security's RoleVoter.
				 */
				public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {
					return new SimpleGrantedAuthority("ROLE_" + rs.getString(1);
				}
			}
		}
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You would then add a bean of this type to your application context and inject it into the <code>LdapAuthenticationProvider</code>. This is covered in the section on configuring LDAP using explicit Spring beans in the LDAP chapter of the reference manual.
Note that you can&#8217;t use the namespace for configuration in this case.
You should also consult the Javadoc for the relevant classes and interfaces.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-namespace-post-processor"><a class="anchor" href="#appendix-faq-namespace-post-processor"></a>I want to modify the property of a bean that is created by the namespace, but there is nothing in the schema to support it.</h5>
<div class="paragraph">
<p>What can I do short of abandoning namespace use?</p>
</div>
<div class="paragraph">
<p>The namespace functionality is intentionally limited, so it doesn&#8217;t cover everything that you can do with plain beans.
If you want to do something simple, like modify a bean, or inject a different dependency, you can do this by adding a <code>BeanPostProcessor</code> to your configuration.
More information can be found in the <a href="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-factory-extension-bpp">Spring Reference Manual</a>. In order to do this, you need to know a bit about which beans are created, so you should also read the blog article in the above question on <a href="#appendix-faq-namespace-to-bean-mapping">how the namespace maps to Spring beans</a>.</p>
</div>
<div class="paragraph">
<p>Normally, you would add the functionality you require to the <code>postProcessBeforeInitialization</code> method of <code>BeanPostProcessor</code>. Let&#8217;s say that you want to customize the <code>AuthenticationDetailsSource</code> used by the <code>UsernamePasswordAuthenticationFilter</code>, (created by the <code>form-login</code> element). You want to extract a particular header called <code>CUSTOM_HEADER</code> from the request and make use of it while authenticating the user.
The processor class would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class BeanPostProcessor implements BeanPostProcessor {

		public Object postProcessAfterInitialization(Object bean, String name) {
				if (bean instanceof UsernamePasswordAuthenticationFilter) {
						System.out.println("********* Post-processing " + name);
						((UsernamePasswordAuthenticationFilter)bean).setAuthenticationDetailsSource(
										new AuthenticationDetailsSource() {
												public Object buildDetails(Object context) {
														return ((HttpServletRequest)context).getHeader("CUSTOM_HEADER");
												}
										});
				}
				return bean;
		}

		public Object postProcessBeforeInitialization(Object bean, String name) {
				return bean;
		}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You would then register this bean in your application context.
Spring will automatically invoke it on the beans defined in the application context.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. It is also possible to obtain the server&#8217;s IP address using a DNS lookup. This is not currently supported, but hopefully will be in a future version.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Authentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by <code>SessionManagementFilter</code>, as the filter will not be invoked during the authenticating request. Session-management functionality has to be handled separately in these cases.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Essentially, the username is not included in the cookie, to prevent exposing a valid login name unecessarily. There is a discussion on this in the comments section of this article.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. The use of the <code>key</code> property should not be regarded as providing any real security here. It is merely a book-keeping exercise. If you are sharing a <code>ProviderManager</code> which contains an <code>AnonymousAuthenticationProvider</code> in a scenario where it is possible for an authenticating client to construct the <code>Authentication</code> object (such as with RMI invocations), then a malicious client could submit an <code>AnonymousAuthenticationToken</code> which it had created itself (with chosen username and authority list). If the <code>key</code> is guessable or can be found out, then the token would be accepted by the anonymous provider. This isn&#8217;t a problem with normal usage but if you are using RMI you would be best to use a customized <code>ProviderManager</code> which omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. You have probably seen this when a browser doesn&#8217;t support cookies and the <code>jsessionid</code> parameter is appended to the URL after a semi-colon. However the RFC allows the presence of these parameters in any path segment of the URL
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. The original values will be returned once the request leaves the <code>FilterChainProxy</code>, so will still be available to the application.
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. So, for example, an original request path <code>/secure;hack=1/somefile.html;hack=2</code> will be returned as <code>/secure/somefile.html</code>.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. The legacy options from Spring Security 2.0 are also supported, but discouraged.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. You can find out more about the use of the <code>ldap-server</code> element in the chapter on <a href="#servlet-authentication-ldap">LDAP Authentication</a>.
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. See the section on <a href="#servlet-httpfirewall">`HttpFirewall`</a> for more details on how matches are actually performed.
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. The interpretation of the comma-separated values in the <code>access</code> attribute depends on the implementation of the <a href="#ns-access-manager">AccessDecisionManager</a> which is used.
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. See the <a href="#ns-web-xml">introductory chapter</a> for how to set up the mapping from your <code>web.xml</code>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. This feature is really just provided for convenience and is not intended for production (where a view technology will have been chosen and can be used to render a customized login page). The class <code>DefaultLoginPageGeneratingFilter</code> is responsible for rendering the login page and will provide login forms for both normal form login and/or OpenID if required.
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. This doesn&#8217;t affect the use of <code>PersistentTokenBasedRememberMeServices</code>, where the tokens are stored on the server side.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. The <code>FilterInvocation</code> object contains the <code>HttpServletRequest</code>, so you can obtain the URL or any other relevant information on which to base your decision on what the list of returned attributes will contain.
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
