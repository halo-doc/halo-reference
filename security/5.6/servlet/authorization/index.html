<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Authorization :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../../_/css/site.css">
<link rel="stylesheet" href="../../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="5.6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../overview/prerequisites.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/index.html">Servet Security: The Big Picture</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../6/overview/prerequisites.html">6</a>
        </li>
        <li class="version is-current">
          <a href="../../overview/prerequisites.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../framework/5.3/overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../overview/prerequisites.html">Spring Security</a></li>
    <li><a href="index.html">Authorization</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">5.6</button>
  <div class="version-menu">
    <a class="version" href="../../../6/servlet/authorization/index.html">6</a>
    <a class="version is-current" href="index.html">5.6</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-security/edit/antora-2.x/docs/modules/ROOT/pages/servlet/authorization/index.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Authorization</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this part we&#8217;ll explore the different <code>AbstractSecurityInterceptor</code> implementations, which were introduced in Part I.
We then move on to explore how to fine-tune authorization through use of domain access control lists.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="authz-arch"><a class="anchor" href="#authz-arch"></a>Authorization Architecture</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="authz-authorities"><a class="anchor" href="#authz-authorities"></a>Authorities</h3>
<div class="paragraph">
<p><a href="#servlet-authentication-authentication"><code>Authentication</code></a>, discusses how all <code>Authentication</code> implementations store a list of <code>GrantedAuthority</code> objects.
These represent the authorities that have been granted to the principal.
the <code>GrantedAuthority</code> objects are inserted into the <code>Authentication</code> object by the <code>AuthenticationManager</code> and are later read by <code>AccessDecisionManager</code> s when making authorization decisions.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code> is an interface with only one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String getAuthority();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method allows
<code>AccessDecisionManager</code> s to obtain a precise <code>String</code> representation of the <code>GrantedAuthority</code>.
By returning a representation as a <code>String</code>, a <code>GrantedAuthority</code> can be easily "read" by most <code>AccessDecisionManager</code> s.
If a <code>GrantedAuthority</code> cannot be precisely represented as a <code>String</code>, the <code>GrantedAuthority</code> is considered "complex" and <code>getAuthority()</code> must return <code>null</code>.</p>
</div>
<div class="paragraph">
<p>An example of a "complex" <code>GrantedAuthority</code> would be an implementation that stores a list of operations and authority thresholds that apply to different customer account numbers.
Representing this complex <code>GrantedAuthority</code> as a <code>String</code> would be quite difficult, and as a result the <code>getAuthority()</code> method should return <code>null</code>.
This will indicate to any <code>AccessDecisionManager</code> that it will need to specifically support the <code>GrantedAuthority</code> implementation in order to understand its contents.</p>
</div>
<div class="paragraph">
<p>Spring Security includes one concrete <code>GrantedAuthority</code> implementation, <code>SimpleGrantedAuthority</code>.
This allows any user-specified <code>String</code> to be converted into a <code>GrantedAuthority</code>.
All <code>AuthenticationProvider</code> s included with the security architecture use <code>SimpleGrantedAuthority</code> to populate the <code>Authentication</code> object.</p>
</div>
</div>
<div class="sect2">
<h3 id="authz-pre-invocation"><a class="anchor" href="#authz-pre-invocation"></a>Pre-Invocation Handling</h3>
<div class="paragraph">
<p>Spring Security provides interceptors which control access to secure objects such as method invocations or web requests.
A pre-invocation decision on whether the invocation is allowed to proceed is made by the <code>AccessDecisionManager</code>.</p>
</div>
<div class="sect3">
<h4 id="authz-access-decision-manager"><a class="anchor" href="#authz-access-decision-manager"></a>The AccessDecisionManager</h4>
<div class="paragraph">
<p>The <code>AccessDecisionManager</code> is called by the <code>AbstractSecurityInterceptor</code> and is responsible for making final access control decisions.
The <code>AccessDecisionManager</code> interface contains three methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void decide(Authentication authentication, Object secureObject,
	Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AccessDecisionManager</code>'s <code>decide</code> method is passed all the relevant information it needs in order to make an authorization decision.
In particular, passing the secure <code>Object</code> enables those arguments contained in the actual secure object invocation to be inspected.
For example, let&#8217;s assume the secure object was a <code>MethodInvocation</code>.
It would be easy to query the <code>MethodInvocation</code> for any <code>Customer</code> argument, and then implement some sort of security logic in the <code>AccessDecisionManager</code> to ensure the principal is permitted to operate on that customer.
Implementations are expected to throw an <code>AccessDeniedException</code> if access is denied.</p>
</div>
<div class="paragraph">
<p>The <code>supports(ConfigAttribute)</code> method is called by the <code>AbstractSecurityInterceptor</code> at startup time to determine if the <code>AccessDecisionManager</code> can process the passed <code>ConfigAttribute</code>.
The <code>supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code>AccessDecisionManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
</div>
<div class="sect3">
<h4 id="authz-voting-based"><a class="anchor" href="#authz-voting-based"></a>Voting-Based AccessDecisionManager Implementations</h4>
<div class="paragraph">
<p>Whilst users can implement their own <code>AccessDecisionManager</code> to control all aspects of authorization, Spring Security includes several <code>AccessDecisionManager</code> implementations that are based on voting.
<a href="#authz-access-voting">Voting Decision Manager</a> illustrates the relevant classes.</p>
</div>
<div id="authz-access-voting" class="imageblock">
<div class="content">
<img src="images/access-decision-voting.png" alt="access decision voting">
</div>
<div class="title">Figure 1. Voting Decision Manager</div>
</div>
<div class="paragraph">
<p>Using this approach, a series of <code>AccessDecisionVoter</code> implementations are polled on an authorization decision.
The <code>AccessDecisionManager</code> then decides whether or not to throw an <code>AccessDeniedException</code> based on its assessment of the votes.</p>
</div>
<div class="paragraph">
<p>The <code>AccessDecisionVoter</code> interface has three methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Concrete implementations return an <code>int</code>, with possible values               being reflected in the <code>AccessDecisionVoter</code> static fields <code>ACCESS_ABSTAIN</code>, <code>ACCESS_DENIED</code> and <code>ACCESS_GRANTED</code>.
A voting implementation will return <code>ACCESS_ABSTAIN</code> if it has no opinion on an authorization decision.
If it does have an opinion, it must return either <code>ACCESS_DENIED</code> or <code>ACCESS_GRANTED</code>.</p>
</div>
<div class="paragraph">
<p>There are three concrete <code>AccessDecisionManager</code> s provided with Spring Security that tally the votes.
The <code>ConsensusBased</code> implementation will grant or deny access based on the consensus of non-abstain votes.
Properties are provided to control behavior in the event of an equality of votes or if all votes are abstain.
The <code>AffirmativeBased</code> implementation will grant access if one or more <code>ACCESS_GRANTED</code> votes were received (i.e. a deny vote will be ignored, provided there was at least one grant vote).
Like the <code>ConsensusBased</code> implementation, there is a parameter that controls the behavior if all voters abstain.
The <code>UnanimousBased</code> provider expects unanimous <code>ACCESS_GRANTED</code> votes in order to grant access, ignoring abstains.
It will deny access if there is any <code>ACCESS_DENIED</code> vote.
Like the other implementations, there is a parameter that controls the behaviour if all voters abstain.</p>
</div>
<div class="paragraph">
<p>It is possible to implement a custom <code>AccessDecisionManager</code> that tallies votes differently.
For example, votes from a particular <code>AccessDecisionVoter</code> might receive additional weighting, whilst a deny vote from a particular voter may have a veto effect.</p>
</div>
<div class="sect4">
<h5 id="authz-role-voter"><a class="anchor" href="#authz-role-voter"></a>RoleVoter</h5>
<div class="paragraph">
<p>The most commonly used <code>AccessDecisionVoter</code> provided with Spring Security is the simple <code>RoleVoter</code>, which treats configuration attributes as simple role names and votes to grant access if the user has been assigned that role.</p>
</div>
<div class="paragraph">
<p>It will vote if any <code>ConfigAttribute</code> begins with the prefix <code>ROLE_</code>.
It will vote to grant access if there is a <code>GrantedAuthority</code> which returns a <code>String</code> representation (via the <code>getAuthority()</code> method) exactly equal to one or more <code>ConfigAttributes</code> starting with the prefix <code>ROLE_</code>.
If there is no exact match of any <code>ConfigAttribute</code> starting with <code>ROLE_</code>, the <code>RoleVoter</code> will vote to deny access.
If no <code>ConfigAttribute</code> begins with <code>ROLE_</code>, the voter will abstain.</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-authenticated-voter"><a class="anchor" href="#authz-authenticated-voter"></a>AuthenticatedVoter</h5>
<div class="paragraph">
<p>Another voter which we&#8217;ve implicitly seen is the <code>AuthenticatedVoter</code>, which can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users.
Many sites allow certain limited access under remember-me authentication, but require a user to confirm their identity by logging in for full access.</p>
</div>
<div class="paragraph">
<p>When we&#8217;ve used the attribute <code>IS_AUTHENTICATED_ANONYMOUSLY</code> to grant anonymous access, this attribute was being processed by the <code>AuthenticatedVoter</code>.
See the Javadoc for this class for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-custom-voter"><a class="anchor" href="#authz-custom-voter"></a>Custom Voters</h5>
<div class="paragraph">
<p>Obviously, you can also implement a custom <code>AccessDecisionVoter</code> and you can put just about any access-control logic you want in it.
It might be specific to your application (business-logic related) or it might implement some security administration logic.
For example, you&#8217;ll find a <a href="https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time">blog article</a> on the Spring web site which describes how to use a voter to deny access in real-time to users whose accounts have been suspended.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="authz-after-invocation-handling"><a class="anchor" href="#authz-after-invocation-handling"></a>After Invocation Handling</h3>
<div class="paragraph">
<p>Whilst the <code>AccessDecisionManager</code> is called by the <code>AbstractSecurityInterceptor</code> before proceeding with the secure object invocation, some applications need a way of modifying the object actually returned by the secure object invocation.
Whilst you could easily implement your own AOP concern to achieve this, Spring Security provides a convenient hook that has several concrete implementations that integrate with its ACL capabilities.</p>
</div>
<div class="paragraph">
<p><a href="#authz-after-invocation">After Invocation Implementation</a> illustrates Spring Security&#8217;s <code>AfterInvocationManager</code> and its concrete implementations.</p>
</div>
<div id="authz-after-invocation" class="imageblock">
<div class="content">
<img src="images/after-invocation.png" alt="after invocation">
</div>
<div class="title">Figure 2. After Invocation Implementation</div>
</div>
<div class="paragraph">
<p>Like many other parts of Spring Security, <code>AfterInvocationManager</code> has a single concrete implementation, <code>AfterInvocationProviderManager</code>, which polls a list of <code>AfterInvocationProvider</code> s.
Each <code>AfterInvocationProvider</code> is allowed to modify the return object or throw an <code>AccessDeniedException</code>.
Indeed multiple providers can modify the object, as the result of the previous provider is passed to the next in the list.</p>
</div>
<div class="paragraph">
<p>Please be aware that if you&#8217;re using <code>AfterInvocationManager</code>, you will still need configuration attributes that allow the <code>MethodSecurityInterceptor</code>'s <code>AccessDecisionManager</code> to allow an operation.
If you&#8217;re using the typical Spring Security included <code>AccessDecisionManager</code> implementations, having no configuration attributes defined for a particular secure method invocation will cause each <code>AccessDecisionVoter</code> to abstain from voting.
In turn, if the <code>AccessDecisionManager</code> property           &#8220;allowIfAllAbstainDecisions&#8221; is <code>false</code>, an <code>AccessDeniedException</code> will be thrown.
You may avoid this potential issue by either (i) setting &#8220;allowIfAllAbstainDecisions&#8221; to <code>true</code> (although this is generally not recommended) or (ii) simply ensure that there is at least one configuration attribute that an <code>AccessDecisionVoter</code> will vote to grant access for.
This latter (recommended) approach is usually achieved through a <code>ROLE_USER</code> or <code>ROLE_AUTHENTICATED</code> configuration attribute.</p>
</div>
</div>
<div class="sect2">
<h3 id="authz-hierarchical-roles"><a class="anchor" href="#authz-hierarchical-roles"></a>Hierarchical Roles</h3>
<div class="paragraph">
<p>It is a common requirement that a particular role in an application should automatically "include" other roles.
For example, in an application which has the concept of an "admin" and a "user" role, you may want an admin to be able to do everything a normal user can.
To achieve this, you can either make sure that all admin users are also assigned the "user" role.
Alternatively, you can modify every access constraint which requires the "user" role to also include the "admin" role.
This can get quite complicated if you have a lot of different roles in your application.</p>
</div>
<div class="paragraph">
<p>The use of a role-hierarchy allows you to configure which roles (or authorities) should include others.
An extended version of Spring Security&#8217;s <a href="#authz-role-voter">RoleVoter</a>, <code>RoleHierarchyVoter</code>, is configured with a <code>RoleHierarchy</code>, from which it obtains all the "reachable authorities" which the user is assigned.
A typical configuration might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="roleVoter" class="org.springframework.security.access.vote.RoleHierarchyVoter"&gt;
	&lt;constructor-arg ref="roleHierarchy" /&gt;
&lt;/bean&gt;
&lt;bean id="roleHierarchy"
		class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"&gt;
	&lt;property name="hierarchy"&gt;
		&lt;value&gt;
			ROLE_ADMIN &gt; ROLE_STAFF
			ROLE_STAFF &gt; ROLE_USER
			ROLE_USER &gt; ROLE_GUEST
		&lt;/value&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have four roles in a hierarchy <code>ROLE_ADMIN &#8658; ROLE_STAFF &#8658; ROLE_USER &#8658; ROLE_GUEST</code>.
A user who is authenticated with <code>ROLE_ADMIN</code>, will behave as if they have all four roles when security constraints are evaluated against an <code>AccessDecisionManager</code> configured with the above <code>RoleHierarchyVoter</code>.
The <code>&gt;</code> symbol can be thought of as meaning "includes".</p>
</div>
<div class="paragraph">
<p>Role hierarchies offer a convenient means of simplifying the access-control configuration data for your application and/or reducing the number of authorities which you need to assign to a user.
For more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authorization-filtersecurityinterceptor"><a class="anchor" href="#servlet-authorization-filtersecurityinterceptor"></a>Authorize HttpServletRequest with FilterSecurityInterceptor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section builds on <a href="#servlet-architecture">Servlet Architecture and Implementation</a> by digging deeper into how <a href="#servlet-authorization">authorization</a> works within Servlet based applications.</p>
</div>
<div class="paragraph">
<p>The {security-api-url}org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html[<code>FilterSecurityInterceptor</code>] provides <a href="#servlet-authorization">authorization</a> for <code>HttpServletRequest</code>s.
It is inserted into the <a href="#servlet-filterchainproxy">[servlet-filterchainproxy]</a> as one of the <a href="#servlet-security-filters">[servlet-security-filters]</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/servlet/authorization/filtersecurityinterceptor.png" alt="filtersecurityinterceptor">
</div>
<div class="title">Figure 3. Authorize HttpServletRequest</div>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="images/icons/number_1.png" alt="number 1"></span> First, the <code>FilterSecurityInterceptor</code> obtains an  <a href="#servlet-authentication-authentication">[servlet-authentication-authentication]</a> from the <a href="#servlet-authentication-securitycontextholder">[servlet-authentication-securitycontextholder]</a>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_2.png" alt="number 2"></span> Second, <code>FilterSecurityInterceptor</code> creates a {security-api-url}org/springframework/security/web/FilterInvocation.html[<code>FilterInvocation</code>] from the <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, and <code>FilterChain</code> that are passed into the <code>FilterSecurityInterceptor</code>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_3.png" alt="number 3"></span> Next, it passes the <code>FilterInvocation</code> to <code>SecurityMetadataSource</code> to get the <code>ConfigAttribute</code>s.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_4.png" alt="number 4"></span> Finally, it passes the <code>Authentication</code>, <code>FilterInvocation</code>, and <code>ConfigAttribute</code>s to the <code>AccessDecisionManager</code>.</p>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="images/icons/number_5.png" alt="number 5"></span> If authorization is denied, an <code>AccessDeniedException</code> is thrown.
In this case the <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> handles the <code>AccessDeniedException</code>.</p>
</li>
<li>
<p><span class="image"><img src="images/icons/number_6.png" alt="number 6"></span> If access is granted, <code>FilterSecurityInterceptor</code> continues with the <a href="#servlet-filters-review">FilterChain</a> which allows the application to process normally.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, Spring Security&#8217;s authorization will require all requests to be authenticated.
The explicit configuration looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Every Request Must be Authenticated</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.authorizeRequests(authorize -&gt; authorize
			.anyRequest().authenticated()
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;!-- ... --&gt;
	&lt;intercept-url pattern="/**" access="authenticated"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We can configure Spring Security to have different rules by adding more rules in order of precedence.</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Authorize Requests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.authorizeRequests(authorize -&gt; authorize                                  <i class="conum" data-value="1"></i><b>(1)</b>
			.mvcMatchers("/resources/**", "/signup", "/about").permitAll()         <i class="conum" data-value="2"></i><b>(2)</b>
			.mvcMatchers("/admin/**").hasRole("ADMIN")                             <i class="conum" data-value="3"></i><b>(3)</b>
			.mvcMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")   <i class="conum" data-value="4"></i><b>(4)</b>
			.anyRequest().denyAll()                                                <i class="conum" data-value="5"></i><b>(5)</b>
		);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt; <i class="conum" data-value="1"></i><b>(1)</b>
	&lt;!-- ... --&gt;
	<i class="conum" data-value="2"></i><b>(2)</b>
	&lt;intercept-url pattern="/resources/**" access="permitAll"/&gt;
	&lt;intercept-url pattern="/signup" access="permitAll"/&gt;
	&lt;intercept-url pattern="/about" access="permitAll"/&gt;

	&lt;intercept-url pattern="/admin/**" access="hasRole('ADMIN')"/&gt; <i class="conum" data-value="3"></i><b>(3)</b>
	&lt;intercept-url pattern="/db/**" access="hasRole('ADMIN') and hasRole('DBA')"/&gt; <i class="conum" data-value="4"></i><b>(4)</b>
	&lt;intercept-url pattern="/**" access="denyAll"/&gt; <i class="conum" data-value="5"></i><b>(5)</b>
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests { <i class="conum" data-value="1"></i><b>(1)</b>
            authorize("/resources/**", permitAll) <i class="conum" data-value="2"></i><b>(2)</b>
            authorize("/signup", permitAll)
            authorize("/about", permitAll)

            authorize("/admin/**", hasRole("ADMIN")) <i class="conum" data-value="3"></i><b>(3)</b>
            authorize("/db/**", "hasRole('ADMIN') and hasRole('DBA')") <i class="conum" data-value="4"></i><b>(4)</b>
            authorize(anyRequest, denyAll) <i class="conum" data-value="5"></i><b>(5)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There are multiple authorization rules specified.
Each rule is considered in the order they were declared.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We specified multiple URL patterns that any user can access.
Specifically, any user can access a request if the URL starts with "/resources/", equals "/signup", or equals "/about".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any URL that starts with "/admin/" will be restricted to users who have the role "ROLE_ADMIN".
You will notice that since we are invoking the <code>hasRole</code> method we do not need to specify the "ROLE_" prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any URL that starts with "/db/" requires the user to have both "ROLE_ADMIN" and "ROLE_DBA".
You will notice that since we are using the <code>hasRole</code> expression we do not need to specify the "ROLE_" prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any URL that has not already been matched on is denied access.
This is a good strategy if you do not want to accidentally forget to update your authorization rules.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="el-access"><a class="anchor" href="#el-access"></a>Expression-Based Access Control</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 3.0 introduced the ability to use Spring EL expressions as an authorization mechanism in addition to the simple use of configuration attributes and access-decision voters which have seen before.
Expression-based access control is built on the same architecture but allows complicated Boolean logic to be encapsulated in a single expression.</p>
</div>
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h3>
<div class="paragraph">
<p>Spring Security uses Spring EL for expression support and you should look at how that works if you are interested in understanding the topic in more depth.
Expressions are evaluated with a "root object" as part of the evaluation context.
Spring Security uses specific classes for web and method security as the root object, in order to provide built-in expressions and access to values such as the current principal.</p>
</div>
<div class="sect3">
<h4 id="el-common-built-in"><a class="anchor" href="#el-common-built-in"></a>Common Built-In Expressions</h4>
<div class="paragraph">
<p>The base class for expression root objects is <code>SecurityExpressionRoot</code>.
This provides some common expressions which are available in both web and method security.</p>
</div>
<table id="common-expressions" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Common built-in expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasRole(String role)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified role.</p>
<p class="tableblock">For example, <code>hasRole('admin')</code></p>
<p class="tableblock">By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code>defaultRolePrefix</code> on <code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyRole(String&#8230;&#8203; roles)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied roles (given as a comma-separated list of strings).</p>
<p class="tableblock">For example, <code>hasAnyRole('admin', 'user')</code></p>
<p class="tableblock">By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code>defaultRolePrefix</code> on <code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAuthority(String authority)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified authority.</p>
<p class="tableblock">For example, <code>hasAuthority('read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyAuthority(String&#8230;&#8203; authorities)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied authorities (given as a comma-separated list of strings)</p>
<p class="tableblock">For example, <code>hasAnyAuthority('read', 'write')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the principal object representing the current user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the current <code>Authentication</code> object obtained from the <code>SecurityContext</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>permitAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>denyAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAnonymous()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is an anonymous user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isRememberMe()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is a remember-me user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not anonymous</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isFullyAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not an anonymous or a remember-me user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object target, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the given permission.
For example, <code>hasPermission(domainObject, 'read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object targetId, String targetType, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the given permission.
For example, <code>hasPermission(1, 'com.example.domain.Message', 'read')</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="el-access-web"><a class="anchor" href="#el-access-web"></a>Web Security Expressions</h3>
<div class="paragraph">
<p>To use expressions to secure individual URLs, you would first need to set the <code>use-expressions</code> attribute in the <code>&lt;http&gt;</code> element to <code>true</code>.
Spring Security will then expect the <code>access</code> attributes of the <code>&lt;intercept-url&gt;</code> elements to contain Spring EL expressions.
The expressions should evaluate to a Boolean, defining whether access should be allowed or not.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/admin*"
		access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have defined that the "admin" area of an application (defined by the URL pattern) should only be available to users who have the granted authority "admin" and whose IP address matches a local subnet.
We&#8217;ve already seen the built-in <code>hasRole</code> expression in the previous section.
The expression <code>hasIpAddress</code> is an additional built-in expression which is specific to web security.
It is defined by the <code>WebSecurityExpressionRoot</code> class, an instance of which is used as the expression root object when evaluating web-access expressions.
This object also directly exposed the <code>HttpServletRequest</code> object under the name <code>request</code> so you can invoke the request directly in an expression.
If expressions are being used, a <code>WebExpressionVoter</code> will be added to the <code>AccessDecisionManager</code> which is used by the namespace.
So if you aren&#8217;t using the namespace and want to use expressions, you will have to add one of these to your configuration.</p>
</div>
<div class="sect3">
<h4 id="el-access-web-beans"><a class="anchor" href="#el-access-web-beans"></a>Referring to Beans in Web Security Expressions</h4>
<div class="paragraph">
<p>If you wish to extend the expressions that are available, you can easily refer to any Spring Bean you expose.
For example, assuming you have a Bean with the name of <code>webSecurity</code> that contains the following method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WebSecurity {
		public boolean check(Authentication authentication, HttpServletRequest request) {
				...
		}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class WebSecurity {
    fun check(authentication: Authentication?, request: HttpServletRequest?): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You could refer to the method using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Refer to method</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .antMatchers("/user/**").access("@webSecurity.check(authentication,request)")
        ...
    )</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/**"
		access="@webSecurity.check(authentication,request)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/**", "@webSecurity.check(authentication,request)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="el-access-web-path-variables"><a class="anchor" href="#el-access-web-path-variables"></a>Path Variables in Web Security Expressions</h4>
<div class="paragraph">
<p>At times it is nice to be able to refer to path variables within a URL.
For example, consider a RESTful application that looks up a user by id from the URL path in the format <code>/user/{userId}</code>.</p>
</div>
<div class="paragraph">
<p>You can easily refer to the path variable by placing it in the pattern.
For example, if you had a Bean with the name of <code>webSecurity</code> that contains the following method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class WebSecurity {
		public boolean checkUserId(Authentication authentication, int id) {
				...
		}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class WebSecurity {
    fun checkUserId(authentication: Authentication?, id: Int): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You could refer to the method using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Path Variables</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">http
	.authorizeRequests(authorize -&gt; authorize
		.antMatchers("/user/{userId}/**").access("@webSecurity.checkUserId(authentication,#userId)")
		...
	);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
	&lt;intercept-url pattern="/user/{userId}/**"
		access="@webSecurity.checkUserId(authentication,#userId)"/&gt;
	...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/{userId}/**", "@webSecurity.checkUserId(authentication,#userId)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration URLs that match would pass in the path variable (and convert it) into checkUserId method.
For example, if the URL were <code>/user/123/resource</code>, then the id passed in would be <code>123</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_method_security_expressions"><a class="anchor" href="#_method_security_expressions"></a>Method Security Expressions</h3>
<div class="paragraph">
<p>Method security is a bit more complicated than a simple allow or deny rule.
Spring Security 3.0 introduced some new annotations in order to allow comprehensive support for the use of expressions.</p>
</div>
<div class="sect3">
<h4 id="el-pre-post-annotations"><a class="anchor" href="#el-pre-post-annotations"></a>@Pre and @Post Annotations</h4>
<div class="paragraph">
<p>There are four annotations which support expression attributes to allow pre and post-invocation authorization checks and also to support filtering of submitted collection arguments or return values.
They are <code>@PreAuthorize</code>, <code>@PreFilter</code>, <code>@PostAuthorize</code> and <code>@PostFilter</code>.
Their use is enabled through the <code>global-method-security</code> namespace element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled"/&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_access_control_using_preauthorize_and_postauthorize"><a class="anchor" href="#_access_control_using_preauthorize_and_postauthorize"></a>Access Control using @PreAuthorize and @PostAuthorize</h5>
<div class="paragraph">
<p>The most obviously useful annotation is <code>@PreAuthorize</code> which decides whether a method can actually be invoked or not.
For example (from the "Contacts" sample application)</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasRole('USER')")
public void create(Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
fun create(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>which means that access will only be allowed for users with the role "ROLE_USER".
Obviously the same thing could easily be achieved using a traditional configuration and a simple configuration attribute for the required role.
But what about:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasPermission(#contact, 'admin')")
public void deletePermission(Contact contact, Sid recipient, Permission permission);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasPermission(#contact, 'admin')")
fun deletePermission(contact: Contact?, recipient: Sid?, permission: Permission?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here we&#8217;re actually using a method argument as part of the expression to decide whether the current user has the "admin"permission for the given contact.
The built-in <code>hasPermission()</code> expression is linked into the Spring Security ACL module through the application context, as we&#8217;ll <a href="#el-permission-evaluator">see below</a>.
You can access any of the method arguments by name as expression variables.</p>
</div>
<div class="paragraph">
<p>There are a number of ways in which Spring Security can resolve the method arguments.
Spring Security uses <code>DefaultSecurityParameterNameDiscoverer</code> to discover the parameter names.
By default, the following options are tried for a method as a whole.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If Spring Security&#8217;s <code>@P</code> annotation is present on a single argument to the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.security.access.method.P;

...

@PreAuthorize("#c.name == authentication.name")
public void doSomething(@P("c") Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.security.access.method.P

...

@PreAuthorize("#c.name == authentication.name")
fun doSomething(@P("c") contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes this is implemented using <code>AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</div>
</li>
<li>
<p>If Spring Data&#8217;s <code>@Param</code> annotation is present on at least one parameter for the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.data.repository.query.Param;

...

@PreAuthorize("#n == authentication.name")
Contact findContactByName(@Param("n") String name);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.data.repository.query.Param

...

@PreAuthorize("#n == authentication.name")
fun findContactByName(@Param("n") name: String?): Contact?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes this is implemented using <code>AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</div>
</li>
<li>
<p>If JDK 8 was used to compile the source with the -parameters argument and Spring 4+ is being used, then the standard JDK reflection API is used to discover the parameter names.
This works on both classes and interfaces.</p>
</li>
<li>
<p>Last, if the code was compiled with the debug symbols, the parameter names will be discovered using the debug symbols.
This will not work for interfaces since they do not have debug information about the parameter names.
For interfaces, annotations or the JDK 8 approach must be used.</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-spel"></a></div>
<div class="content">
<div class="paragraph">
<p>Any Spring-EL functionality is available within the expression, so you can also access properties on the arguments.
For example, if you wanted a particular method to only allow access to a user whose username matched that of the contact, you could write</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("#contact.name == authentication.name")
public void doSomething(Contact contact);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("#contact.name == authentication.name")
fun doSomething(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here we are accessing another built-in expression, <code>authentication</code>, which is the <code>Authentication</code> stored in the security context.
You can also access its "principal" property directly, using the expression <code>principal</code>.
The value will often be a <code>UserDetails</code> instance, so you might use an expression like <code>principal.username</code> or <code>principal.enabled</code>.</p>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-post"></a></div>
<div class="content">
<div class="paragraph">
<p>Less commonly, you may wish to perform an access-control check after the method has been invoked.
This can be achieved using the <code>@PostAuthorize</code> annotation.
To access the return value from a method, use the built-in name <code>returnObject</code> in the expression.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_using_prefilter_and_postfilter"><a class="anchor" href="#_filtering_using_prefilter_and_postfilter"></a>Filtering using @PreFilter and @PostFilter</h5>
<div class="paragraph">
<p>Spring Security supports filtering of collections, arrays, maps and streams using expressions.
This is most commonly performed on the return value of a method.
For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
public List&lt;Contact&gt; getAll();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
fun getAll(): List&lt;Contact?&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using the <code>@PostFilter</code> annotation, Spring Security iterates through the returned collection or map and removes any elements for which the supplied expression is false.
For an array, a new array instance will be returned containing filtered elements.
The name <code>filterObject</code> refers to the current object in the collection.
In case when a map is used it will refer to the current <code>Map.Entry</code> object which allows one to use <code>filterObject.key</code> or <code>filterObject.value</code> in the expresion.
You can also filter before the method call, using <code>@PreFilter</code>, though this is a less common requirement.
The syntax is just the same, but if there is more than one argument which is a collection type then you have to select one by name using the <code>filterTarget</code> property of this annotation.</p>
</div>
<div class="paragraph">
<p>Note that filtering is obviously not a substitute for tuning your data retrieval queries.
If you are filtering large collections and removing many of the entries then this is likely to be inefficient.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="el-method-built-in"><a class="anchor" href="#el-method-built-in"></a>Built-In Expressions</h4>
<div class="paragraph">
<p>There are some built-in expressions which are specific to method security, which we have already seen in use above.
The <code>filterTarget</code> and <code>returnValue</code> values are simple enough, but the use of the <code>hasPermission()</code> expression warrants a closer look.</p>
</div>
<div class="sect4">
<h5 id="el-permission-evaluator"><a class="anchor" href="#el-permission-evaluator"></a>The PermissionEvaluator interface</h5>
<div class="paragraph">
<p><code>hasPermission()</code> expressions are delegated to an instance of <code>PermissionEvaluator</code>.
It is intended to bridge between the expression system and Spring Security&#8217;s ACL system, allowing you to specify authorization constraints on domain objects, based on abstract permissions.
It has no explicit dependencies on the ACL module, so you could swap that out for an alternative implementation if required.
The interface has two methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean hasPermission(Authentication authentication, Object targetDomainObject,
							Object permission);

boolean hasPermission(Authentication authentication, Serializable targetId,
							String targetType, Object permission);</code></pre>
</div>
</div>
<div class="paragraph">
<p>which map directly to the available versions of the expression, with the exception that the first argument (the <code>Authentication</code> object) is not supplied.
The first is used in situations where the domain object, to which access is being controlled, is already loaded.
Then expression will return true if the current user has the given permission for that object.
The second version is used in cases where the object is not loaded, but its identifier is known.
An abstract "type" specifier for the domain object is also required, allowing the correct ACL permissions to be loaded.
This has traditionally been the Java class of the object, but does not have to be as long as it is consistent with how the permissions are loaded.</p>
</div>
<div class="paragraph">
<p>To use <code>hasPermission()</code> expressions, you have to explicitly configure a <code>PermissionEvaluator</code> in your application context.
This would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:global-method-security pre-post-annotations="enabled"&gt;
&lt;security:expression-handler ref="expressionHandler"/&gt;
&lt;/security:global-method-security&gt;

&lt;bean id="expressionHandler" class=
"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"&gt;
	&lt;property name="permissionEvaluator" ref="myPermissionEvaluator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>myPermissionEvaluator</code> is the bean which implements <code>PermissionEvaluator</code>.
Usually this will be the implementation from the ACL module which is called <code>AclPermissionEvaluator</code>.
See the "Contacts" sample application configuration for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="_method_security_meta_annotations"><a class="anchor" href="#_method_security_meta_annotations"></a>Method Security Meta Annotations</h5>
<div class="paragraph">
<p>You can make use of meta annotations for method security to make your code more readable.
This is especially convenient if you find that you are repeating the same complex expression throughout your code base.
For example, consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("#contact.name == authentication.name")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of repeating this everywhere, we can create a meta annotation that can be used instead.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
public @interface ContactPermission {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
annotation class ContactPermission</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Meta annotations can be used for any of the Spring Security method security annotations.
In order to remain compliant with the specification JSR-250 annotations do not support meta annotations.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="secure-object-impls"><a class="anchor" href="#secure-object-impls"></a>Secure Object Implementations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-alliance"><a class="anchor" href="#aop-alliance"></a>AOP Alliance (MethodInvocation) Security Interceptor</h3>
<div class="paragraph">
<p>Prior to Spring Security 2.0, securing <code>MethodInvocation</code> s needed quite a lot of boiler plate configuration.
Now the recommended approach for method security is to use <a href="#ns-method-security">namespace configuration</a>.
This way the method security infrastructure beans are configured automatically for you so you don&#8217;t really need to know about the implementation classes.
We&#8217;ll just provide a quick overview of the classes that are involved here.</p>
</div>
<div class="paragraph">
<p>Method security is enforced using a <code>MethodSecurityInterceptor</code>, which secures <code>MethodInvocation</code> s.
Depending on the configuration approach, an interceptor may be specific to a single bean or shared between multiple beans.
The interceptor uses a <code>MethodSecurityMetadataSource</code> instance to obtain the configuration attributes that apply to a particular method invocation.
<code>MapBasedMethodSecurityMetadataSource</code> is used to store configuration attributes keyed by method names (which can be wildcarded) and will be used internally when the attributes are defined in the application context using the <code>&lt;intercept-methods&gt;</code> or <code>&lt;protect-point&gt;</code> elements.
Other implementations will be used to handle annotation-based configuration.</p>
</div>
<div class="sect3">
<h4 id="_explicit_methodsecurityinterceptor_configuration"><a class="anchor" href="#_explicit_methodsecurityinterceptor_configuration"></a>Explicit MethodSecurityInterceptor Configuration</h4>
<div class="paragraph">
<p>You can of course configure a <code>MethodSecurityInterceptor</code> directly in your application context for use with one of Spring AOP&#8217;s proxying mechanisms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aspectj"><a class="anchor" href="#aspectj"></a>AspectJ (JoinPoint) Security Interceptor</h3>
<div class="paragraph">
<p>The AspectJ security interceptor is very similar to the AOP Alliance security interceptor discussed in the previous section.
Indeed we will only discuss the differences in this section.</p>
</div>
<div class="paragraph">
<p>The AspectJ interceptor is named <code>AspectJSecurityInterceptor</code>.
Unlike the AOP Alliance security interceptor, which relies on the Spring application context to weave in the security interceptor via proxying, the <code>AspectJSecurityInterceptor</code> is weaved in via the AspectJ compiler.
It would not be uncommon to use both types of security interceptors in the same application, with <code>AspectJSecurityInterceptor</code> being used for domain object instance security and the AOP Alliance <code>MethodSecurityInterceptor</code> being used for services layer security.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first consider how the <code>AspectJSecurityInterceptor</code> is configured in the Spring application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
	"org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
	&lt;sec:method-security-metadata-source&gt;
	&lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
	&lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
	&lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, aside from the class name, the <code>AspectJSecurityInterceptor</code> is exactly the same as the AOP Alliance security interceptor.
Indeed the two interceptors can share the same <code>securityMetadataSource</code>, as the <code>SecurityMetadataSource</code> works with <code>java.lang.reflect.Method</code> s rather than an AOP library-specific class.
Of course, your access decisions have access to the relevant AOP library-specific invocation (ie <code>MethodInvocation</code> or <code>JoinPoint</code>) and as such can consider a range of addition criteria when making access decisions (such as method arguments).</p>
</div>
<div class="paragraph">
<p>Next you&#8217;ll need to define an AspectJ <code>aspect</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.security.samples.aspectj;

import org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
import org.springframework.security.access.intercept.aspectj.AspectJCallback;
import org.springframework.beans.factory.InitializingBean;

public aspect DomainObjectInstanceSecurityAspect implements InitializingBean {

	private AspectJSecurityInterceptor securityInterceptor;

	pointcut domainObjectInstanceExecution(): target(PersistableEntity)
		&amp;&amp; execution(public * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

	Object around(): domainObjectInstanceExecution() {
		if (this.securityInterceptor == null) {
			return proceed();
		}

		AspectJCallback callback = new AspectJCallback() {
			public Object proceedWithObject() {
				return proceed();
			}
		};

		return this.securityInterceptor.invoke(thisJoinPoint, callback);
	}

	public AspectJSecurityInterceptor getSecurityInterceptor() {
		return securityInterceptor;
	}

	public void setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
		this.securityInterceptor = securityInterceptor;
	}

	public void afterPropertiesSet() throws Exception {
		if (this.securityInterceptor == null)
			throw new IllegalArgumentException("securityInterceptor required");
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the security interceptor will be applied to every instance of <code>PersistableEntity</code>, which is an abstract class not shown (you can use any other class or <code>pointcut</code> expression you like).
For those curious, <code>AspectJCallback</code> is needed because the <code>proceed();</code> statement has special meaning only within an <code>around()</code> body.
The <code>AspectJSecurityInterceptor</code> calls this anonymous <code>AspectJCallback</code> class when it wants the target object to continue.</p>
</div>
<div class="paragraph">
<p>You will need to configure Spring to load the aspect and wire it with the <code>AspectJSecurityInterceptor</code>.
A bean declaration which achieves this is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="domainObjectInstanceSecurityAspect"
	class="security.samples.aspectj.DomainObjectInstanceSecurityAspect"
	factory-method="aspectOf"&gt;
&lt;property name="securityInterceptor" ref="bankManagerSecurity"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it!
Now you can create your beans from anywhere within your application, using whatever means you think fit (e.g. <code>new Person();</code>) and they will have the security interceptor applied.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-method"><a class="anchor" href="#jc-method"></a>Method Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>From version 2.0 onwards Spring Security has improved support substantially for adding security to your service layer methods.
It provides support for JSR-250 annotation security as well as the framework&#8217;s original <code>@Secured</code> annotation.
From 3.0 you can also make use of new <a href="#el-access">expression-based annotations</a>.
You can apply security to a single bean, using the <code>intercept-methods</code> element to decorate the bean declaration, or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.</p>
</div>
<div class="sect2">
<h3 id="_enablemethodsecurity"><a class="anchor" href="#_enablemethodsecurity"></a>EnableMethodSecurity</h3>
<div class="paragraph">
<p>In Spring Security 5.6, we can enable annotation-based security using the <code>@EnableMethodSecurity</code> annotation on any <code>@Configuration</code> instance.</p>
</div>
<div class="paragraph">
<p>This improves upon <code>@EnableGlobalMethodSecurity</code> in a number of ways. <code>@EnableMethodSecurity</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Uses the simplified <code>AuthorizationManager</code> API instead of metadata sources, config attributes, decision managers, and voters.
This simplifies reuse and customization.</p>
</li>
<li>
<p>Favors direct bean-based configuration, instead of requiring extending <code>GlobalMethodSecurityConfiguration</code> to customize beans</p>
</li>
<li>
<p>Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize</p>
</li>
<li>
<p>Checks for conflicting annotations to ensure an unambiguous security configuration</p>
</li>
<li>
<p>Complies with JSR-250</p>
</li>
<li>
<p>Enables <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, and <code>@PostFilter</code> by default</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For earlier versions, please read about similar support with <a href="#jc-enable-global-method-security">@EnableGlobalMethodSecurity</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the following would enable Spring Security&#8217;s <code>@PreAuthorize</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Method Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the <code>DefaultAuthorizationMethodInterceptorChain</code> for it to make the actual decision:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Method Security Annotation Usage</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {
	@PreAuthorize("hasRole('USER')")
	Account readAccount(Long id);

	@PreAuthorize("hasRole('USER')")
	List&lt;Account&gt; findAccounts();

	@PreAuthorize("hasRole('TELLER')")
	Account post(Account account, Double amount);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface BankService {
	@PreAuthorize("hasRole('USER')")
	fun readAccount(id : Long) : Account

	@PreAuthorize("hasRole('USER')")
	fun findAccounts() : List&lt;Account&gt;

	@PreAuthorize("hasRole('TELLER')")
	fun post(account : Account, amount : Double) : Account
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable support for Spring Security&#8217;s <code>@Secured</code> annotation using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. @Secured Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(securedEnabled = true)
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security secured-enabled="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>or JSR-250 using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. JSR-250 Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(jsr250Enabled = true)
class MethodSecurityConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security jsr250-enabled="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_customizing_authorization"><a class="anchor" href="#_customizing_authorization"></a>Customizing Authorization</h4>
<div class="paragraph">
<p>Spring Security&#8217;s <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, and <code>@PostFilter</code> ship with rich expression-based support.</p>
</div>
<div id="jc-method-security-custom-expression-handler" class="paragraph">
<p>If you need to customize the way that expressions are handled, you can expose a custom <code>MethodSecurityExpressionHandler</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Custom MethodSecurityExpressionHandler</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler() {
	DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
	handler.setTrustResolver(myCustomTrustResolver);
	return handler;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">companion object {
	@Bean
	fun methodSecurityExpressionHandler() : MethodSecurityExpressionHandler {
		val handler = DefaultMethodSecurityExpressionHandler();
		handler.setTrustResolver(myCustomTrustResolver);
		return handler;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security&gt;
	&lt;sec:expression-handler ref="myExpressionHandler"/&gt;
&lt;/sec:method-security&gt;

&lt;bean id="myExpressionHandler"
		class="org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler"&gt;
	&lt;property name="trustResolver" ref="myCustomTrustResolver"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We expose <code>MethodSecurityExpressionHandler</code> using a <code>static</code> method to ensure that Spring publishes it before it initializes Spring Security&#8217;s method security <code>@Configuration</code> classes</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, for role-based authorization, Spring Security adds a default <code>ROLE_</code> prefix, which is uses when evaluating expressions like <code>hasRole</code>.</p>
</div>
<div id="jc-method-security-custom-granted-authority-defaults" class="paragraph">
<p>You can configure the authorization rules to use a different prefix by exposing a <code>GrantedAuthorityDefaults</code> bean, like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Custom MethodSecurityExpressionHandler</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
static GrantedAuthorityDefaults grantedAuthorityDefaults() {
	return new GrantedAuthorityDefaults("MYPREFIX_");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">companion object {
	@Bean
	fun grantedAuthorityDefaults() : GrantedAuthorityDefaults {
		return GrantedAuthorityDefaults("MYPREFIX_");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;bean id="grantedAuthorityDefaults" class="org.springframework.security.config.core.GrantedAuthorityDefaults"&gt;
	&lt;constructor-arg value="MYPREFIX_"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We expose <code>GrantedAuthorityDefaults</code> using a <code>static</code> method to ensure that Spring publishes it before it initializes Spring Security&#8217;s method security <code>@Configuration</code> classes</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jc-method-security-custom-authorization-manager"><a class="anchor" href="#jc-method-security-custom-authorization-manager"></a>Custom Authorization Managers</h4>
<div class="paragraph">
<p>Method authorization is a combination of before- and after-method authorization.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Before-method authorization is performed before the method is invoked.
If that authorization denies access, the method is not invoked, and an <code>AccessDeniedException</code> is thrown
After-method authorization is performed after the method is invoked, but before the method returns to the caller.
If that authorization denies access, the value is not returned, and an <code>AccessDeniedException</code> is thrown</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To recreate what adding <code>@EnableMethodSecurity</code> does by default, you would publish the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Full Pre-post Method Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preFilterAuthorizationMethodInterceptor() {
		return new PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postAuthorizeAuthorizationMethodInterceptor() {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postFilterAuthorizationMethodInterceptor() {
		return new PostFilterAuthorizationMethodInterceptor();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preFilterAuthorizationMethodInterceptor() : Advisor {
		return PreFilterAuthorizationMethodInterceptor();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postAuthorizeAuthorizationMethodInterceptor() : Advisor {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postFilterAuthorizationMethodInterceptor() : Advisor {
		return PostFilterAuthorizationMethodInterceptor();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security pre-post-enabled="false"/&gt;

&lt;aop:config/&gt;

&lt;bean id="preFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor"/&gt;
&lt;bean id="preAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
		factory-method="preAuthorize"/&gt;
&lt;bean id="postAuthorizeAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"
		factory-method="postAuthorize"/&gt;
&lt;bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that Spring Security&#8217;s method security is built using Spring AOP.
So, interceptors are invoked based on the order specified.
This can be customized by calling <code>setOrder</code> on the interceptor instances like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Publish Custom Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
Advisor postFilterAuthorizationMethodInterceptor() {
	PostFilterAuthorizationMethodInterceptor interceptor = new PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
fun postFilterAuthorizationMethodInterceptor() : Advisor {
	val interceptor = PostFilterAuthorizationMethodInterceptor();
	interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1);
	return interceptor;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="postFilterAuthorizationMethodInterceptor"
		class="org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor"&gt;
	&lt;property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).POST_AUTHORIZE.getOrder() -1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may want to only support <code>@PreAuthorize</code> in your application, in which case you can do the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Only @PreAuthorize Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorize() {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorize() : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize()
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security pre-post-enabled="false"/&gt;

&lt;aop:config/&gt;

&lt;bean id="preAuthorizeAuthorizationMethodInterceptor"
	class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
	factory-method="preAuthorize"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you may have a custom before-method <code>AuthorizationManager</code> that you want to add to the list.</p>
</div>
<div class="paragraph">
<p>In this case, you will need to tell Spring Security both the <code>AuthorizationManager</code> and to which methods and classes your authorization manager applies.</p>
</div>
<div class="paragraph">
<p>Thus, you can configure Spring Security to invoke your <code>AuthorizationManager</code> in between <code>@PreAuthorize</code> and <code>@PostAuthorize</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Custom Before Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize() {
		JdkRegexpMethodPointcut pattern = new JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		AuthorizationManager&lt;MethodInvocation&gt; rule = AuthorityAuthorizationManager.isAuthenticated();
		AuthorizationManagerBeforeMethodInterceptor interceptor = new AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize() : Advisor {
		val pattern = JdkRegexpMethodPointcut();
		pattern.setPattern("org.mycompany.myapp.service.*");
		val rule = AuthorityAuthorizationManager.isAuthenticated();
		val interceptor = AuthorizationManagerBeforeMethodInterceptor(pattern, rule);
		interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;aop:config/&gt;

&lt;bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
			&lt;property name="pattern" value="org.mycompany.myapp.service.*"/&gt;
		&lt;/bean&gt;
	&lt;/constructor-arg&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/&gt;
	&lt;/constructor-arg&gt;
	&lt;property name="order"
			value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can place your interceptor in between Spring Security method interceptors using the order constants specified in <code>AuthorizationInterceptorsOrder</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same can be done for after-method authorization.
After-method authorization is generally concerned with analysing the return value to verify access.</p>
</div>
<div class="paragraph">
<p>For example, you might have a method that confirms that the account requested actually belongs to the logged-in user like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. @PostAuthorize example</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	Account readAccount(Long id);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface BankService {

	@PreAuthorize("hasRole('USER')")
	@PostAuthorize("returnObject.owner == authentication.name")
	fun readAccount(id : Long) : Account
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can supply your own <code>AuthorizationMethodInterceptor</code> to customize how access to the return value is evaluated.</p>
</div>
<div class="paragraph">
<p>For example, if you have your own custom annotation, you can configure it like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Custom After Advisor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public Advisor customAuthorize(AuthorizationManager&lt;MethodInvocationResult&gt; rules) {
		AnnotationMethodMatcher pattern = new AnnotationMethodMatcher(MySecurityAnnotation.class);
		AuthorizationManagerAfterMethodInterceptor interceptor = new AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableMethodSecurity
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun customAuthorize(rules : AuthorizationManager&lt;MethodInvocationResult&gt;) : Advisor {
		val pattern = AnnotationMethodMatcher(MySecurityAnnotation::class.java);
		val interceptor = AuthorizationManagerAfterMethodInterceptor(pattern, rules);
		interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1);
		return interceptor;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;sec:method-security/&gt;

&lt;aop:config/&gt;

&lt;bean id="customAuthorize"
		class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.aop.support.annotation.AnnotationMethodMatcher"&gt;
			&lt;constructor-arg value="#{T(org.mycompany.MySecurityAnnotation)}"/&gt;
		&lt;/bean&gt;
	&lt;/constructor-arg&gt;
	&lt;constructor-arg&gt;
		&lt;bean class="org.springframework.security.authorization.AuthorityAuthorizationManager"
				factory-method="isAuthenticated"/&gt;
	&lt;/constructor-arg&gt;
	&lt;property name="order"
		value="#{T(org.springframework.security.authorization.method.AuthorizationInterceptorsOrder).PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and it will be invoked after the <code>@PostAuthorize</code> interceptor.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-enable-global-method-security"><a class="anchor" href="#jc-enable-global-method-security"></a>EnableGlobalMethodSecurity</h3>
<div class="paragraph">
<p>We can enable annotation-based security using the <code>@EnableGlobalMethodSecurity</code> annotation on any <code>@Configuration</code> instance.
For example, the following would enable Spring Security&#8217;s <code>@Secured</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the AccessDecisionManager for it to make the actual decision:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for JSR-250 annotations can be enabled using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security&#8217;s native annotations.
To use the new expression-based syntax, you would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the equivalent Java code would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_globalmethodsecurityconfiguration"><a class="anchor" href="#_globalmethodsecurityconfiguration"></a>GlobalMethodSecurityConfiguration</h3>
<div class="paragraph">
<p>Sometimes you may need to perform operations that are more complicated than are possible with the <code>@EnableGlobalMethodSecurity</code> annotation allow.
For these instances, you can extend the <code>GlobalMethodSecurityConfiguration</code> ensuring that the <code>@EnableGlobalMethodSecurity</code> annotation is present on your subclass.
For example, if you wanted to provide a custom <code>MethodSecurityExpressionHandler</code>, you could use the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For additional information about methods that can be overridden, refer to the <code>GlobalMethodSecurityConfiguration</code> Javadoc.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-global-method"><a class="anchor" href="#ns-global-method"></a>The &lt;global-method-security&gt; Element</h3>
<div class="paragraph">
<p>This element is used to enable annotation-based security in your application (by setting the appropriate attributes on the element), and also to group together security pointcut declarations which will be applied across your entire application context.
You should only declare one <code>&lt;global-method-security&gt;</code> element.
The following declaration would enable support for Spring Security&#8217;s <code>@Secured</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security secured-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an annotation to a method (on an class or interface) would then limit the access to that method accordingly.
Spring Security&#8217;s native annotation support defines a set of attributes for the method.
These will be passed to the <code>AccessDecisionManager</code> for it to make the actual decision:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for JSR-250 annotations can be enabled using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security jsr250-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security&#8217;s native annotations.
To use the new expression-based syntax, you would use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the equivalent Java code would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expression-based annotations are a good choice if you need to define simple rules that go beyond checking the role names against the user&#8217;s list of authorities.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The annotated methods will only be secured for instances which are defined as Spring beans (in the same application context in which method-security is enabled).
If you want to secure instances which are not created by Spring (using the <code>new</code> operator, for example) then you need to use AspectJ.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can enable more than one type of annotation in the same application, but only one type should be used for any interface or class as the behaviour will not be well-defined otherwise.
If two annotations are found which apply to a particular method, then only one of them will be applied.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ns-protect-pointcut"><a class="anchor" href="#ns-protect-pointcut"></a>Adding Security Pointcuts using protect-pointcut</h3>
<div class="paragraph">
<p>The use of <code>protect-pointcut</code> is particularly powerful, as it allows you to apply security to many beans with only a simple declaration.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;global-method-security&gt;
&lt;protect-pointcut expression="execution(* com.mycompany.*Service.*(..))"
	access="ROLE_USER"/&gt;
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will protect all methods on beans declared in the application context whose classes are in the <code>com.mycompany</code> package and whose class names end in "Service".
Only users with the <code>ROLE_USER</code> role will be able to invoke these methods.
As with URL matching, the most specific matches must come first in the list of pointcuts, as the first matching expression will be used.
Security annotations take precedence over pointcuts.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="domain-acls"><a class="anchor" href="#domain-acls"></a>Domain Object Security (ACLs)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="domain-acls-overview"><a class="anchor" href="#domain-acls-overview"></a>Overview</h3>
<div class="paragraph">
<p>Complex applications often will find the need to define access permissions not simply at a web request or method invocation level.
Instead, security decisions need to comprise both who (<code>Authentication</code>), where (<code>MethodInvocation</code>) and what (<code>SomeDomainObject</code>).
In other words, authorization decisions also need to consider the actual domain object instance subject of a method invocation.</p>
</div>
<div class="paragraph">
<p>Imagine you&#8217;re designing an application for a pet clinic.
There will be two main groups of users of your Spring-based application: staff of the pet clinic, as well as the pet clinic&#8217;s customers.
The staff will have access to all of the data, whilst your customers will only be able to see their own customer records.
To make it a little more interesting, your customers can allow other users to see their customer records, such as their "puppy preschool" mentor or president of their local "Pony Club".
Using Spring Security as the foundation, you have several approaches that can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write your business methods to enforce the security.
You could consult a collection within the <code>Customer</code> domain object instance to determine which users have access.
By using the <code>SecurityContextHolder.getContext().getAuthentication()</code>, you&#8217;ll be able to access the <code>Authentication</code> object.</p>
</li>
<li>
<p>Write an <code>AccessDecisionVoter</code> to enforce the security from the <code>GrantedAuthority[]</code> s stored in the <code>Authentication</code> object.
This would mean your <code>AuthenticationManager</code> would need to populate the <code>Authentication</code> with custom <code>GrantedAuthority[]</code>s representing each of the <code>Customer</code> domain object instances the principal has access to.</p>
</li>
<li>
<p>Write an <code>AccessDecisionVoter</code> to enforce the security and open the target <code>Customer</code> domain object directly.
This would mean your voter needs access to a DAO that allows it to retrieve the <code>Customer</code> object.
It would then access the <code>Customer</code> object&#8217;s collection of approved users and make the appropriate decision.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each one of these approaches is perfectly legitimate.
However, the first couples your authorization checking to your business code.
The main problems with this include the enhanced difficulty of unit testing and the fact it would be more difficult to reuse the <code>Customer</code> authorization logic elsewhere.
Obtaining the <code>GrantedAuthority[]</code> s from the <code>Authentication</code> object is also fine, but will not scale to large numbers of <code>Customer</code> s.
If a user might be able to access 5,000 <code>Customer</code> s (unlikely in this case, but imagine if it were a popular vet for a large Pony Club!) the amount of memory consumed and time required to construct the <code>Authentication</code> object would be undesirable.
The final method, opening the <code>Customer</code> directly from external code, is probably the best of the three.
It achieves separation of concerns, and doesn&#8217;t misuse memory or CPU cycles, but it is still inefficient in that both the <code>AccessDecisionVoter</code> and the eventual business method itself will perform a call to the DAO responsible for retrieving the <code>Customer</code> object.
Two accesses per method invocation is clearly undesirable.
In addition, with every approach listed you&#8217;ll need to write your own access control list (ACL) persistence and business logic from scratch.</p>
</div>
<div class="paragraph">
<p>Fortunately, there is another alternative, which we&#8217;ll talk about below.</p>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls-key-concepts"><a class="anchor" href="#domain-acls-key-concepts"></a>Key Concepts</h3>
<div class="paragraph">
<p>Spring Security&#8217;s ACL services are shipped in the <code>spring-security-acl-xxx.jar</code>.
You will need to add this JAR to your classpath to use Spring Security&#8217;s domain object instance security capabilities.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s domain object instance security capabilities centre on the concept of an access control list (ACL).
Every domain object instance in your system has its own ACL, and the ACL records details of who can and can&#8217;t work with that domain object.
With this in mind, Spring Security delivers three main ACL-related capabilities to your application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A way of efficiently retrieving ACL entries for all of your domain objects (and modifying those ACLs)</p>
</li>
<li>
<p>A way of ensuring a given principal is permitted to work with your objects, before methods are called</p>
</li>
<li>
<p>A way of ensuring a given principal is permitted to work with your objects (or something they return), after methods are called</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As indicated by the first bullet point, one of the main capabilities of the Spring Security ACL module is providing a high-performance way of retrieving ACLs.
This ACL repository capability is extremely important, because every domain object instance in your system might have several access control entries, and each ACL might inherit from other ACLs in a tree-like structure (this is supported out-of-the-box by Spring Security, and is very commonly used).
Spring Security&#8217;s ACL capability has been carefully designed to provide high performance retrieval of ACLs, together with pluggable caching, deadlock-minimizing database updates, independence from ORM frameworks (we use JDBC directly), proper encapsulation, and transparent database updating.</p>
</div>
<div class="paragraph">
<p>Given databases are central to the operation of the ACL module, let&#8217;s explore the four main tables used by default in the implementation.
The tables are presented below in order of size in a typical Spring Security ACL deployment, with the table with the most rows listed last:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ACL_SID allows us to uniquely identify any principal or authority in the system ("SID" stands for "security identity").
The only columns are the ID, a textual representation of the SID, and a flag to indicate whether the textual                   representation refers to a principal name or a <code>GrantedAuthority</code>.
Thus, there is a single row for each unique principal or <code>GrantedAuthority</code>.
When used in the context of receiving a permission, a SID is generally called a "recipient".</p>
</li>
<li>
<p>ACL_CLASS allows us to uniquely identify any domain object class in the system.
The only columns are the ID and the Java class name.
Thus, there is a single row for each unique Class we wish to store ACL permissions for.</p>
</li>
<li>
<p>ACL_OBJECT_IDENTITY stores information for each unique domain object instance in the system.
Columns include the ID, a foreign key to the ACL_CLASS table, a unique identifier so we know which ACL_CLASS instance we&#8217;re providing information for, the parent, a foreign key to the ACL_SID table to represent the owner of the domain object instance, and whether we allow ACL entries to inherit from any parent ACL.
We have a single row for every domain object instance we&#8217;re storing ACL permissions for.</p>
</li>
<li>
<p>Finally, ACL_ENTRY stores the individual permissions assigned to each recipient.
Columns include a foreign key to the ACL_OBJECT_IDENTITY, the recipient (i.e. a foreign key to ACL_SID), whether we&#8217;ll be auditing or not, and the integer bit mask that represents the actual permission being granted or denied.
We have a single row for every recipient that receives a permission to work with a domain object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned in the last paragraph, the ACL system uses integer bit masking.
Don&#8217;t worry, you need not be aware of the finer points of bit shifting to use the ACL system, but suffice to say that we have 32 bits we can switch on or off.
Each of these bits represents a permission, and by default the permissions are read (bit 0), write (bit 1), create (bit 2), delete (bit 3) and administer (bit 4).
It&#8217;s easy to implement your own <code>Permission</code> instance if you wish to use other permissions, and the remainder of the ACL framework will operate without knowledge of your extensions.</p>
</div>
<div class="paragraph">
<p>It is important to understand that the number of domain objects in your system has absolutely no bearing on the fact we&#8217;ve chosen to use integer bit masking.
Whilst you have 32 bits available for permissions, you could have billions of domain object instances (which will mean billions of rows in ACL_OBJECT_IDENTITY and quite probably ACL_ENTRY).
We make this point because we&#8217;ve found sometimes people mistakenly believe they need a bit for each potential domain object, which is not the case.</p>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve provided a basic overview of what the ACL system does, and what it looks like at a table structure, let&#8217;s explore the key interfaces.
The key interfaces are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Acl</code>: Every domain object has one and only one <code>Acl</code> object, which internally holds the <code>AccessControlEntry</code> s as well as knows the owner of the <code>Acl</code>.
An Acl does not refer directly to the domain object, but instead to an <code>ObjectIdentity</code>.
The <code>Acl</code> is stored in the ACL_OBJECT_IDENTITY table.</p>
</li>
<li>
<p><code>AccessControlEntry</code>: An <code>Acl</code> holds multiple <code>AccessControlEntry</code> s, which are often abbreviated as ACEs in the framework.
Each ACE refers to a specific tuple of <code>Permission</code>, <code>Sid</code> and <code>Acl</code>.
An ACE can also be granting or non-granting and contain audit settings.
The ACE is stored in the ACL_ENTRY table.</p>
</li>
<li>
<p><code>Permission</code>: A permission represents a particular immutable bit mask, and offers convenience functions for bit masking and outputting information.
The basic permissions presented above (bits 0 through 4) are contained in the <code>BasePermission</code> class.</p>
</li>
<li>
<p><code>Sid</code>: The ACL module needs to refer to principals and <code>GrantedAuthority[]</code> s.
A level of indirection is provided by the <code>Sid</code> interface, which is an abbreviation of "security identity".
Common classes include <code>PrincipalSid</code> (to represent the principal inside an <code>Authentication</code> object) and <code>GrantedAuthoritySid</code>.
The security identity information is stored in the ACL_SID table.</p>
</li>
<li>
<p><code>ObjectIdentity</code>: Each domain object is represented internally within the ACL module by an <code>ObjectIdentity</code>.
The default implementation is called <code>ObjectIdentityImpl</code>.</p>
</li>
<li>
<p><code>AclService</code>: Retrieves the <code>Acl</code> applicable for a given <code>ObjectIdentity</code>.
In the included implementation (<code>JdbcAclService</code>), retrieval operations are delegated to a <code>LookupStrategy</code>.
The <code>LookupStrategy</code> provides a highly optimized strategy for retrieving ACL information, using batched retrievals (<code>BasicLookupStrategy</code>) and supporting custom implementations that leverage materialized views, hierarchical queries and similar performance-centric, non-ANSI SQL capabilities.</p>
</li>
<li>
<p><code>MutableAclService</code>: Allows a modified <code>Acl</code> to be presented for persistence.
It is not essential to use this interface if you do not wish.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please note that our out-of-the-box AclService and related database classes all use ANSI SQL.
This should therefore work with all major databases.
At the time of writing, the system had been successfully tested using Hypersonic SQL, PostgreSQL, Microsoft SQL Server and Oracle.</p>
</div>
<div class="paragraph">
<p>Two samples ship with Spring Security that demonstrate the ACL module.
The first is the Contacts Sample, and the other is the Document Management System (DMS) Sample.
We suggest taking a look over these for examples.</p>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls-getting-started"><a class="anchor" href="#domain-acls-getting-started"></a>Getting Started</h3>
<div class="paragraph">
<p>To get starting using Spring Security&#8217;s ACL capability, you will need to store your ACL information somewhere.
This necessitates the instantiation of a <code>DataSource</code> using Spring.
The <code>DataSource</code> is then injected into a <code>JdbcMutableAclService</code> and <code>BasicLookupStrategy</code> instance.
The latter provides high-performance ACL retrieval capabilities, and the former provides mutator capabilities.
Refer to one of the samples that ship with Spring Security for an example configuration.
You&#8217;ll also need to populate the database with the four ACL-specific tables listed in the last section (refer to the ACL samples for the appropriate SQL statements).</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve created the required schema and instantiated <code>JdbcMutableAclService</code>, you&#8217;ll next need to ensure your domain model supports interoperability with the Spring Security ACL package.
Hopefully <code>ObjectIdentityImpl</code> will prove sufficient, as it provides a large number of ways in which it can be used.
Most people will have domain objects that contain a <code>public Serializable getId()</code> method.
If the return type is long, or compatible with long (e.g. an int), you will find you need not give further consideration to <code>ObjectIdentity</code> issues.
Many parts of the ACL module rely on long identifiers.
If you&#8217;re not using long (or an int, byte etc), there is a very good chance you&#8217;ll need to reimplement a number of classes.
We do not intend to support non-long identifiers in Spring Security&#8217;s ACL module, as longs are already compatible with all database sequences, the most common identifier data type, and are of sufficient length to accommodate all common usage scenarios.</p>
</div>
<div class="paragraph">
<p>The following fragment of code shows how to create an <code>Acl</code>, or modify an existing <code>Acl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Prepare the information we'd like in our access control entry (ACE)
ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));
Sid sid = new PrincipalSid("Samantha");
Permission p = BasePermission.ADMINISTRATION;

// Create or update the relevant ACL
MutableAcl acl = null;
try {
acl = (MutableAcl) aclService.readAclById(oi);
} catch (NotFoundException nfe) {
acl = aclService.createAcl(oi);
}

// Now grant some permissions via an access control entry (ACE)
acl.insertAce(acl.getEntries().length, p, sid, true);
aclService.updateAcl(acl);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we&#8217;re retrieving the ACL associated with the "Foo" domain object with identifier number 44.
We&#8217;re then adding an ACE so that a principal named "Samantha" can "administer" the object.
The code fragment is relatively self-explanatory, except the insertAce method.
The first argument to the insertAce method is determining at what position in the Acl the new entry will be inserted.
In the example above, we&#8217;re just putting the new ACE at the end of the existing ACEs.
The final argument is a Boolean indicating whether the ACE is granting or denying.
Most of the time it will be granting (true), but if it is denying (false), the permissions are effectively being blocked.</p>
</div>
<div class="paragraph">
<p>Spring Security does not provide any special integration to automatically create, update or delete ACLs as part of your DAO or repository operations.
Instead, you will need to write code like shown above for your individual domain objects.
It&#8217;s worth considering using AOP on your services layer to automatically integrate the ACL information with your services layer operations.
We&#8217;ve found this quite an effective approach in the past.</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve used the above techniques to store some ACL information in the database, the next step is to actually use the ACL information as part of authorization decision logic.
You have a number of choices here.
You could write your own <code>AccessDecisionVoter</code> or <code>AfterInvocationProvider</code> that respectively fires before or after a method invocation.
Such classes would use <code>AclService</code> to retrieve the relevant ACL and then call <code>Acl.isGranted(Permission[] permission, Sid[] sids, boolean administrativeMode)</code> to decide whether permission is granted or denied.
Alternately, you could use our <code>AclEntryVoter</code>, <code>AclEntryAfterInvocationProvider</code> or <code>AclEntryAfterInvocationCollectionFilteringProvider</code> classes.
All of these classes provide a declarative-based approach to evaluating ACL information at runtime, freeing you from needing to write any code.
Please refer to the sample applications to learn how to use these classes.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/tabs.js"></script>
<script src="../../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
