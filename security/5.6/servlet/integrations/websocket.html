<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../../_/css/site.css">
<link rel="stylesheet" href="../../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="5.6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../overview/prerequisites.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview/samples.html">Samples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/index.html">Servet Security: The Big Picture</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore" style="display: none;">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../6/overview/prerequisites.html">6</a>
        </li>
        <li class="version is-current">
          <a href="../../overview/prerequisites.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="" role="navigation">
<button class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="websocket"><a class="anchor" href="#websocket"></a>WebSocket Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 4 added support for securing <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">Spring&#8217;s WebSocket support</a>.
This section describes how to use Spring Security&#8217;s WebSocket support.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Direct JSR-356 Support</div>
<div class="paragraph">
<p>Spring Security does not provide direct JSR-356 support because doing so would provide little value.
This is because the format is unknown, so there is <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol">little Spring can do to secure an unknown format</a>.
Additionally, JSR-356 does not provide a way to intercept messages, so security would be rather invasive.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-configuration"><a class="anchor" href="#websocket-configuration"></a>WebSocket Configuration</h3>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig
      extends AbstractSecurityWebSocketMessageBrokerConfigurer { <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers("/user/**").authenticated() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;websocket-message-broker&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
    <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any inbound CONNECT message requires a valid CSRF token to enforce <a href="#websocket-sameorigin">Same Origin Policy</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a href="#websocket-authorization">WebSocket Authorization</a></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="websocket-authentication"><a class="anchor" href="#websocket-authentication"></a>WebSocket Authentication</h3>
<div class="paragraph">
<p>WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made.
This means that the <code>Principal</code> on the <code>HttpServletRequest</code> will be handed off to WebSockets.
If you are using Spring Security, the <code>Principal</code> on the <code>HttpServletRequest</code> is overridden automatically.</p>
</div>
<div class="paragraph">
<p>More concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-authorization"><a class="anchor" href="#websocket-authorization"></a>WebSocket Authorization</h3>
<div class="paragraph">
<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code>MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() <i class="conum" data-value="1"></i><b>(1)</b>
                .simpSubscribeDestMatchers("/user/queue/errors").permitAll() <i class="conum" data-value="2"></i><b>(2)</b>
                .simpDestMatchers("/app/**").hasRole("USER") <i class="conum" data-value="3"></i><b>(3)</b>
                .simpSubscribeDestMatchers("/user/**", "/topic/friends/*").hasRole("USER") <i class="conum" data-value="4"></i><b>(4)</b>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() <i class="conum" data-value="5"></i><b>(5)</b>
                .anyMessage().denyAll(); <i class="conum" data-value="6"></i><b>(6)</b>

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message without a destination (i.e. anything other than Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other Message is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security also provides <a href="#nsa-websocket-security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;websocket-message-broker&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;intercept-message type="CONNECT" access="permitAll" /&gt;
    &lt;intercept-message type="UNSUBSCRIBE" access="permitAll" /&gt;
    &lt;intercept-message type="DISCONNECT" access="permitAll" /&gt;

    &lt;intercept-message pattern="/user/queue/errors" type="SUBSCRIBE" access="permitAll" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;intercept-message pattern="/app/**" access="hasRole('USER')" /&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

    <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
    &lt;intercept-message pattern="/topic/friends/*" access="hasRole('USER')" /&gt;

    <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;intercept-message type="MESSAGE" access="denyAll" /&gt;
    &lt;intercept-message type="SUBSCRIBE" access="denyAll" /&gt;

    &lt;intercept-message pattern="/**" access="denyAll" /&gt; <i class="conum" data-value="6"></i><b>(6)</b>
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will ensure that:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any message of type CONNECT, UNSUBSCRIBE, or DISCONNECT will require the user to be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Anyone can subscribe to /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Any other message with a destination is rejected. This is a good idea to ensure that you do not miss any messages.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="websocket-authorization-notes"><a class="anchor" href="#websocket-authorization-notes"></a>WebSocket Authorization Notes</h4>
<div class="paragraph">
<p>In order to properly secure your application it is important to understand Spring&#8217;s WebSocket support.</p>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-messagetypes"><a class="anchor" href="#websocket-authorization-notes-messagetypes"></a>WebSocket Authorization on Message Types</h5>
<div class="paragraph">
<p>It is important to understand the distinction between SUBSCRIBE and MESSAGE types of messages and how it works within Spring.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The system can send notifications MESSAGE to all users through a destination of "/topic/system/notifications"</p>
</li>
<li>
<p>Clients can receive notifications by SUBSCRIBE to the "/topic/system/notifications".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While we want clients to be able to SUBSCRIBE to "/topic/system/notifications", we do not want to enable them to send a MESSAGE to that destination.
If we allowed sending a MESSAGE to "/topic/system/notifications", then clients could send a message directly to that endpoint and impersonate the system.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any MESSAGE sent to a destination that starts with the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-destinations"><a class="anchor" href="#websocket-authorization-notes-destinations"></a>WebSocket Authorization on Destinations</h5>
<div class="paragraph">
<p>It is also is important to understand how destinations are transformed.</p>
</div>
<div class="paragraph">
<p>Consider a chat application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Users can send messages to a specific user by sending a message to the destination of "/app/chat".</p>
</li>
<li>
<p>The application sees the message, ensures that the "from" attribute is specified as the current user (we cannot trust the client).</p>
</li>
<li>
<p>The application then sends the message to the recipient using <code>SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)</code>.</p>
</li>
<li>
<p>The message gets turned into the destination of "/queue/user/messages-&lt;sessionid&gt;"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the application above, we want to allow our client to listen to "/user/queue" which is transformed into "/queue/user/messages-&lt;sessionid&gt;".
However, we do not want the client to be able to listen to "/queue/*" because that would allow the client to see messages for every user.</p>
</div>
<div class="paragraph">
<p>In general, it is common for applications to deny any SUBSCRIBE sent to a message that starts with the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">broker prefix</a> (i.e. "/topic/" or "/queue/").
Of course we may provide exceptions to account for things like</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authorization-notes-outbound"><a class="anchor" href="#websocket-authorization-notes-outbound"></a>Outbound Messages</h4>
<div class="paragraph">
<p>Spring contains a section titled <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow">Flow of Messages</a> that describes how messages flow through the system.
It is important to note that Spring Security only secures the <code>clientInboundChannel</code>.
Spring Security does not attempt to secure the <code>clientOutboundChannel</code>.</p>
</div>
<div class="paragraph">
<p>The most important reason for this is performance.
For every message that goes in, there are typically many more that go out.
Instead of securing the outbound messages, we encourage securing the subscription to the endpoints.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-sameorigin"><a class="anchor" href="#websocket-sameorigin"></a>Enforcing Same Origin Policy</h3>
<div class="paragraph">
<p>It is important to emphasize that the browser does not enforce the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same Origin Policy</a> for WebSocket connections.
This is an extremely important consideration.</p>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-why"><a class="anchor" href="#websocket-sameorigin-why"></a>Why Same Origin?</h4>
<div class="paragraph">
<p>Consider the following scenario.
A user visits bank.com and authenticates to their account.
The same user opens another tab in their browser and visits evil.com.
The Same Origin Policy ensures that evil.com cannot read or write data to bank.com.</p>
</div>
<div class="paragraph">
<p>With WebSockets the Same Origin Policy does not apply.
In fact, unless bank.com explicitly forbids it, evil.com can read and write data on behalf of the user.
This means that anything the user can do over the webSocket (i.e. transfer money), evil.com can do on that users behalf.</p>
</div>
<div class="paragraph">
<p>Since SockJS tries to emulate WebSockets it also bypasses the Same Origin Policy.
This means developers need to explicitly protect their applications from external domains when using SockJS.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-spring"><a class="anchor" href="#websocket-sameorigin-spring"></a>Spring WebSocket Allowed Origin</h4>
<div class="paragraph">
<p>Fortunately, since Spring 4.1.5 Spring&#8217;s WebSocket and SockJS support restricts access to the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins">current domain</a>.
Spring Security adds an additional layer of protection to provide <a href="https://en.wikipedia.org/wiki/Defense_in_depth_%2528computing%2529">defence in depth</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-csrf"><a class="anchor" href="#websocket-sameorigin-csrf"></a>Adding CSRF to Stomp Headers</h4>
<div class="paragraph">
<p>By default Spring Security requires the <a href="#csrf">CSRF token</a> in any CONNECT message type.
This ensures that only a site that has access to the CSRF token can connect.
Since only the <strong>Same Origin</strong> can access the CSRF token, external domains are not allowed to make a connection.</p>
</div>
<div class="paragraph">
<p>Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers</p>
</div>
<div class="paragraph">
<p>Applications can <a href="#servlet-csrf-include">obtain a CSRF token</a> by accessing the request attribute named _csrf.
For example, the following will allow accessing the <code>CsrfToken</code> in a JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var headerName = "${_csrf.headerName}";
var token = "${_csrf.token}";</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using static HTML, you can expose the <code>CsrfToken</code> on a REST endpoint.
For example, the following would expose the <code>CsrfToken</code> on the URL /csrf</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JavaScript can make a REST call to the endpoint and use the response to populate the headerName and the token.</p>
</div>
<div class="paragraph">
<p>We can now include the token in our Stomp client.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">...
var headers = {};
headers[headerName] = token;
stompClient.connect(headers, function(frame) {
  ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin-disable"><a class="anchor" href="#websocket-sameorigin-disable"></a>Disable CSRF within WebSockets</h4>
<div class="paragraph">
<p>If you want to allow other domains to access your site, you can disable Spring Security&#8217;s protection.
For example, in Java Configuration you can use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    @Override
    protected boolean sameOriginDisabled() {
        return true;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-sockjs"><a class="anchor" href="#websocket-sockjs"></a>Working with SockJS</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback">SockJS</a> provides fallback transports to support older browsers.
When using the fallback options we need to relax a few security constraints to allow SockJS to work with Spring Security.</p>
</div>
<div class="sect3">
<h4 id="websocket-sockjs-sameorigin"><a class="anchor" href="#websocket-sockjs-sameorigin"></a>SockJS &amp; frame-options</h4>
<div class="paragraph">
<p>SockJS may use an <a href="https://github.com/sockjs/sockjs-client/tree/v0.3.4">transport that leverages an iframe</a>.
By default Spring Security will <a href="#headers-frame-options">deny</a> the site from being framed to prevent Clickjacking attacks.
To allow SockJS frame based transports to work, we need to configure Spring Security to allow the same origin to frame the content.</p>
</div>
<div class="paragraph">
<p>You can customize X-Frame-Options with the <a href="#nsa-frame-options">frame-options</a> element.
For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options
          policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can customize frame options to use the same origin within Java Configuration using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
   WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions
                     .sameOrigin()
                )
        );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sockjs-csrf"><a class="anchor" href="#websocket-sockjs-csrf"></a>SockJS &amp; Relaxing CSRF</h4>
<div class="paragraph">
<p>SockJS uses a POST on the CONNECT messages for any HTTP based transport.
Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers as described in <a href="#websocket-sameorigin-csrf">Adding CSRF to Stomp Headers</a>.</p>
</div>
<div class="paragraph">
<p>It also means we need to relax our CSRF protection with the web layer.
Specifically, we want to disable CSRF protection for our connect URLs.
We do NOT want to disable CSRF protection for every URL.
Otherwise our site will be vulnerable to CSRF attacks.</p>
</div>
<div class="paragraph">
<p>We can easily achieve this by providing a CSRF RequestMatcher.
Our Java Configuration makes this extremely easy.
For example, if our stomp endpoint is "/chat" we can disable CSRF protection for only URLs that start with "/chat/" using the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig
    extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -&gt; csrf
                // ignore our stomp endpoints since they are protected using Stomp headers
                .ignoringAntMatchers("/chat/**")
            )
            .headers(headers -&gt; headers
                // allow same origin to frame our site to support iframe SockJS
                .frameOptions(frameOptions -&gt; frameOptions
                    .sameOrigin()
                )
            )
            .authorizeRequests(authorize -&gt; authorize
                ...
            )
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are using XML based configuration, we can use the <a href="#nsa-csrf-request-matcher-ref">csrf@request-matcher-ref</a>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http ...&gt;
    &lt;csrf request-matcher-ref="csrfMatcher"/&gt;

    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;

    ...
&lt;/http&gt;

&lt;b:bean id="csrfMatcher"
    class="AndRequestMatcher"&gt;
    &lt;b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/&gt;
    &lt;b:constructor-arg&gt;
        &lt;b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher"&gt;
          &lt;b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"&gt;
            &lt;b:constructor-arg value="/chat/**"/&gt;
          &lt;/b:bean&gt;
        &lt;/b:bean&gt;
    &lt;/b:constructor-arg&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/tabs.js"></script>
<script src="../../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
