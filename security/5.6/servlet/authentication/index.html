<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Authentication :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../../_/css/site.css">
<link rel="stylesheet" href="../../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="5.6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../overview/index.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Overview</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../overview/features/index.html">Features</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../overview/features/authentication/index.html">Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../overview/features/exploits/index.html">Protection Against Exploits</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../overview/samples.html">Samples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/index.html">The Big Picture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Authentication</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="architecture/index.html">Authentication Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="unpwd/index.html">Username/Password</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reading Username/Password</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/form.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/basic.html">Basic</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/digest.html">Digest</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Password Storage</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/in-memory.html">In Memory</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/user-details.html">UserDetails</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/user-details-service.html">UserDetailsService</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/password-encoder.html">PasswordEncoder</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/dao-authentication-provider.html">DaoAuthenticationProvider</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="unpwd/ldap.html">LDAP</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="session-management.html">Session Management</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="rememberme.html">Remember Me</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="openid.html">OpenID</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="anonymous.html">Anonymous</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="preauth.html">Pre-Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="jaas.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="cas.html">CAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="x509.html">X509</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="runas.html">Run-As</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="logout.html">Logout</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="events.html">Authentication Events</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Authorization</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/architecture.html">Authorization Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/authorize-requests.html">Authorize HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/expression-based.html">Expression-Based Access Control</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/secure-objects.html">Secure Object Implementations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/method-security.html">Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../authorization/acls.html">Domain Object Security ACLs</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../oauth2/oauth2-login.html">OAuth2 Log In</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../oauth2/oauth2-client.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../oauth2/oauth2-resourceserver.html">OAuth2 Resource Server</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../saml2/index.html">SAML2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../exploits/index.html">Protection Against Exploits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/index.html">Integrations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../java-configuration/index.html">Java Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../kotlin-configuration/index.html">Kotlin Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../namespace/index.html">Namespace Configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../test/index.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../crypto/index.html">Cryptography</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../appendix/index.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reactive Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/webflux.html">WebFlux Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/exploits/index.html">Protection Against Exploits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/oauth2/index.html">OAuth2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/registered-oauth2-authorized-client.html">@RegisteredOAuth2AuthorizedClient</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/x509.html">X.509 Authentication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/webclient.html">WebClient</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/method.html">EnableReactiveMethodSecurity</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/cors.html">CORS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/test.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../reactive/rsocket.html">RSocket</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore" style="display: none;">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../6/overview/prerequisites.html">6</a>
        </li>
        <li class="version is-current">
          <a href="../../overview/index.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="" role="navigation">
<button class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Authentication</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides comprehensive support for <a href="#authentication">[authentication]</a>.
This section discusses:</p>
</div>
<div id="servlet-authentication-architecture" class="paragraph">
<p><strong>Architecture Components</strong></p>
</div>
<div class="paragraph">
<p>This section describes the main architectural components of Spring Security&#8217;s used in Servlet authentication.
If you need concrete flows that explain how these pieces fit together, look at the <a href="#servlet-authentication-mechanisms">Authentication Mechanism</a> specific sections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> - The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-securitycontext">SecurityContext</a> - is obtained from the <code>SecurityContextHolder</code> and contains the <code>Authentication</code> of the currently authenticated user.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication</a> - Can be the input to <code>AuthenticationManager</code> to provide the credentials a user has provided to authenticate or the current user from the <code>SecurityContext</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-granted-authority">GrantedAuthority</a> - An authority that is granted to the principal on the <code>Authentication</code> (i.e. roles, scopes, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationmanager">AuthenticationManager</a> -  the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.</p>
</li>
<li>
<p><a href="#servlet-authentication-providermanager">ProviderManager</a> -  the most common implementation of <code>AuthenticationManager</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> - used by <code>ProviderManager</code> to perform a specific type of authentication.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationentrypoint">Request Credentials with <code>AuthenticationEntryPoint</code></a> - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a <code>WWW-Authenticate</code> response, etc.)</p>
</li>
<li>
<p><a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a> - a base <code>Filter</code> used for authentication.
This also gives a good idea of the high level flow of authentication and how pieces work together.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-mechanisms" class="paragraph">
<p><strong>Authentication Mechanisms</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-unpwd">Username and Password</a> - how to authenticate with a username/password</p>
</li>
<li>
<p><a href="#oauth2login">OAuth 2.0 Login</a> - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)</p>
</li>
<li>
<p><a href="#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 Log In</p>
</li>
<li>
<p><a href="#servlet-cas">Central Authentication Server (CAS)</a> - Central Authentication Server (CAS) Support</p>
</li>
<li>
<p><a href="#servlet-rememberme">Remember Me</a> - How to remember a user past session expiration</p>
</li>
<li>
<p><a href="#servlet-jaas">JAAS Authentication</a> - Authenticate with JAAS</p>
</li>
<li>
<p><a href="#servlet-openid">OpenID</a> - OpenID Authentication (not to be confused with OpenID Connect)</p>
</li>
<li>
<p><a href="#servlet-preauth">Pre-Authentication Scenarios</a> - Authenticate with an external mechanism such as <a href="https://www.siteminder.com/">SiteMinder</a> or Java EE security but still use Spring Security for authorization and protection against common exploits.</p>
</li>
<li>
<p><a href="#servlet-x509">X509 Authentication</a> - X509 Authentication</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-securitycontextholder"><a class="anchor" href="#servlet-authentication-securitycontextholder"></a>SecurityContextHolder</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the heart of Spring Security&#8217;s authentication model is the <code>SecurityContextHolder</code>.
It contains the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="servlet/architecture/securitycontextholder.png" alt="securitycontextholder">
</div>
</div>
<div class="paragraph">
<p>The <code>SecurityContextHolder</code> is where Spring Security stores the details of who is <a href="#authentication">authenticated</a>.
Spring Security does not care how the <code>SecurityContextHolder</code> is populated.
If it contains a value, then it is used as the currently authenticated user.</p>
</div>
<div class="paragraph">
<p>The simplest way to indicate a user is authenticated is to set the <code>SecurityContextHolder</code> directly.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Setting <code>SecurityContextHolder</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext(); <i class="conum" data-value="1"></i><b>(1)</b>
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); <i class="conum" data-value="2"></i><b>(2)</b>
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context: SecurityContext = SecurityContextHolder.createEmptyContext() <i class="conum" data-value="1"></i><b>(1)</b>
val authentication: Authentication = TestingAuthenticationToken("username", "password", "ROLE_USER") <i class="conum" data-value="2"></i><b>(2)</b>
context.authentication = authentication

SecurityContextHolder.setContext(context) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start by creating an empty <code>SecurityContext</code>.
It is important to create a new <code>SecurityContext</code> instance instead of using <code>SecurityContextHolder.getContext().setAuthentication(authentication)</code> to avoid race conditions across multiple threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next we create a new <a href="#servlet-authentication-authentication"><code>Authentication</code></a> object.
Spring Security does not care what type of <code>Authentication</code> implementation is set on the <code>SecurityContext</code>.
Here we use <code>TestingAuthenticationToken</code> because it is very simple.
A more common production scenario is <code>UsernamePasswordAuthenticationToken(userDetails, password, authorities)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, we set the <code>SecurityContext</code> on the <code>SecurityContextHolder</code>.
Spring Security will use this information for <a href="#servlet-authorization">authorization</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you wish to obtain information about the authenticated principal, you can do so by accessing the <code>SecurityContextHolder</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Access Currently Authenticated User</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val context = SecurityContextHolder.getContext()
val authentication = context.authentication
val username = authentication.name
val principal = authentication.principal
val authorities = authentication.authorities</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default the <code>SecurityContextHolder</code> uses a <code>ThreadLocal</code> to store these details, which means that the <code>SecurityContext</code> is always available to methods in the same thread, even if the <code>SecurityContext</code> is not explicitly passed around as an argument to those methods.
Using a <code>ThreadLocal</code> in this way is quite safe if care is taken to clear the thread after the present principal&#8217;s request is processed.
Spring Security&#8217;s <a href="#servlet-filterchainproxy">FilterChainProxy</a> ensures that the <code>SecurityContext</code> is always cleared.</p>
</div>
<div class="paragraph">
<p>Some applications aren&#8217;t entirely suitable for using a <code>ThreadLocal</code>, because of the specific way they work with threads.
For example, a Swing client might want all threads in a Java Virtual Machine to use the same security context.
<code>SecurityContextHolder</code> can be configured with a strategy on startup to specify how you would like the context to be stored.
For a standalone application you would use the <code>SecurityContextHolder.MODE_GLOBAL</code> strategy.
Other applications might want to have threads spawned by the secure thread also assume the same security identity.
This is achieved by using <code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>.
You can change the mode from the default <code>SecurityContextHolder.MODE_THREADLOCAL</code> in two ways.
The first is to set a system property, the second is to call a static method on <code>SecurityContextHolder</code>.
Most applications won&#8217;t need to change from the default, but if you do, take a look at the JavaDoc for <code>SecurityContextHolder</code> to learn more.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-securitycontext"><a class="anchor" href="#servlet-authentication-securitycontext"></a>SecurityContext</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/context/SecurityContext.html"><code>SecurityContext</code></a> is obtained from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>SecurityContext</code> contains an <a href="#servlet-authentication-authentication">Authentication</a> object.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authentication"><a class="anchor" href="#servlet-authentication-authentication"></a>Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/Authentication.html"><code>Authentication</code></a> serves two main purposes within Spring Security:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An input to <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to provide the credentials a user has provided to authenticate.
When used in this scenario, <code>isAuthenticated()</code> returns <code>false</code>.</p>
</li>
<li>
<p>Represents the currently authenticated user.
The current <code>Authentication</code> can be obtained from the <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Authentication</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principal</code> - identifies the user.
When authenticating with a username/password this is often an instance of <a href="#servlet-authentication-userdetails"><code>UserDetails</code></a>.</p>
</li>
<li>
<p><code>credentials</code> - Often a password.
In many cases this will be cleared after the user is authenticated to ensure it is not leaked.</p>
</li>
<li>
<p><code>authorities</code> - the <a href="#servlet-authentication-granted-authority"><code>GrantedAuthority</code>s</a> are high level permissions the user is granted.
A few examples are roles or scopes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-granted-authority"><a class="anchor" href="#servlet-authentication-granted-authority"></a>GrantedAuthority</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/GrantedAuthority.html"><code>GrantedAuthority</code>s</a> are high level permissions the user is granted. A few examples are roles or scopes.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code>s can be obtained from the <a href="#servlet-authentication-authentication"><code>Authentication.getAuthorities()</code></a> method.
This method provides a <code>Collection</code> of <code>GrantedAuthority</code> objects.
A <code>GrantedAuthority</code> is, not surprisingly, an authority that is granted to the principal.
Such authorities are usually "roles", such as <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>.
These roles are later on configured for web authorization, method authorization and domain object authorization.
Other parts of Spring Security are capable of interpreting these authorities, and expect them to be present.
When using username/password based authentication <code>GrantedAuthority</code>s are usually loaded by the <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>.</p>
</div>
<div class="paragraph">
<p>Usually the <code>GrantedAuthority</code> objects are application-wide permissions.
They are not specific to a given domain object.
Thus, you wouldn&#8217;t likely have a <code>GrantedAuthority</code> to represent a permission to <code>Employee</code> object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user).
Of course, Spring Security is expressly designed to handle this common requirement, but you&#8217;d instead use the project&#8217;s domain object security capabilities for this purpose.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationmanager"><a class="anchor" href="#servlet-authentication-authenticationmanager"></a>AuthenticationManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AuthenticationManager.html"><code>AuthenticationManager</code></a> is the API that defines how Spring Security&#8217;s Filters perform  <a href="#authentication">authentication</a>.
The <a href="#servlet-authentication-authentication"><code>Authentication</code></a> that is returned is then set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> by the controller (i.e. <a href="#servlet-security-filters">Spring Security&#8217;s <code>Filters</code>s</a>) that invoked the <code>AuthenticationManager</code>.
If you are not integrating with <em>Spring Security&#8217;s <code>Filters</code>s</em> you can set the <code>SecurityContextHolder</code> directly and are not required to use an <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>While the implementation of <code>AuthenticationManager</code> could be anything, the most common implementation is <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-providermanager"><a class="anchor" href="#servlet-authentication-providermanager"></a>ProviderManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/ProviderManager.html"><code>ProviderManager</code></a> is the most commonly used implementation of <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>.
<code>ProviderManager</code> delegates to a <code>List</code> of <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code>s</a>.
Each <code>AuthenticationProvider</code> has an opportunity to indicate that authentication should be successful, fail, or indicate it cannot make a decision and allow a downstream <code>AuthenticationProvider</code> to decide.
If none of the configured <code>AuthenticationProvider</code>s can authenticate, then authentication will fail with a <code>ProviderNotFoundException</code> which is a special <code>AuthenticationException</code> that indicates the <code>ProviderManager</code> was not configured to support the type of <code>Authentication</code> that was passed into it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="servlet/architecture/providermanager.png" alt="providermanager">
</div>
</div>
<div class="paragraph">
<p>In practice each <code>AuthenticationProvider</code> knows how to perform a specific type of authentication.
 For example, one <code>AuthenticationProvider</code> might be able to validate a username/password, while another might be able to authenticate a SAML assertion.
This allows each <code>AuthenticationProvider</code> to do a very specific type of authentication, while supporting multiple types of authentication and only exposing a single <code>AuthenticationManager</code> bean.</p>
</div>
<div class="paragraph">
<p><code>ProviderManager</code> also allows configuring an optional parent <code>AuthenticationManager</code> which is consulted in the event that no <code>AuthenticationProvider</code> can perform authentication.
The parent can be any type of <code>AuthenticationManager</code>, but it is often an instance of <code>ProviderManager</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="servlet/architecture/providermanager-parent.png" alt="providermanager parent">
</div>
</div>
<div class="paragraph">
<p>In fact, multiple <code>ProviderManager</code> instances might share the same parent <code>AuthenticationManager</code>.
This is somewhat common in scenarios where there are multiple <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> instances that have some authentication in common (the shared parent <code>AuthenticationManager</code>), but also different authentication mechanisms (the different <code>ProviderManager</code> instances).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="servlet/architecture/providermanagers-parent.png" alt="providermanagers parent">
</div>
</div>
<div id="servlet-authentication-providermanager-erasing-credentials" class="paragraph">
<p>By default <code>ProviderManager</code> will attempt to clear any sensitive credentials information from the <code>Authentication</code> object which is returned by a successful authentication request.
This prevents information like passwords being retained longer than necessary in the <code>HttpSession</code>.</p>
</div>
<div class="paragraph">
<p>This may cause issues when you are using a cache of user objects, for example, to improve performance in a stateless application.
If the <code>Authentication</code> contains a reference to an object in the cache (such as a <code>UserDetails</code> instance) and this has its credentials removed, then it will no longer be possible to authenticate against the cached value.
You need to take this into account if you are using a cache.
An obvious solution is to make a copy of the object first, either in the cache implementation or in the <code>AuthenticationProvider</code> which creates the returned <code>Authentication</code> object.
Alternatively, you can disable the <code>eraseCredentialsAfterAuthentication</code> property on <code>ProviderManager</code>.
See the <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/ProviderManager.html">Javadoc</a> for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationprovider"><a class="anchor" href="#servlet-authentication-authenticationprovider"></a>AuthenticationProvider</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multiple <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AuthenticationProvider.html"><code>AuthenticationProvider</code>s</a> can be injected into <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.
Each <code>AuthenticationProvider</code> performs a specific type of authentication.
For example, <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a> supports username/password based authentication while <code>JwtAuthenticationProvider</code> supports authenticating a JWT token.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-authenticationentrypoint"><a class="anchor" href="#servlet-authentication-authenticationentrypoint"></a>Request Credentials with <code>AuthenticationEntryPoint</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/AuthenticationEntryPoint.html"><code>AuthenticationEntryPoint</code></a> is used to send an HTTP response that requests credentials from a client.</p>
</div>
<div class="paragraph">
<p>Sometimes a client will proactively include credentials such as a username/password to request a resource.
In these cases, Spring Security does not need to provide an HTTP response that requests credentials from the client since they are already included.</p>
</div>
<div class="paragraph">
<p>In other cases, a client will make an unauthenticated request to a resource that they are not authorized to access.
In this case, an implementation of <code>AuthenticationEntryPoint</code> is used to request credentials from the client.
The <code>AuthenticationEntryPoint</code> implementation might perform a <a href="#servlet-authentication-form">redirect to a log in page</a>, respond with an <a href="#servlet-authentication-basic">WWW-Authenticate</a> header, etc.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-abstractprocessingfilter"><a class="anchor" href="#servlet-authentication-abstractprocessingfilter"></a>AbstractAuthenticationProcessingFilter</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html"><code>AbstractAuthenticationProcessingFilter</code></a> is used as a base <code>Filter</code> for authenticating a user&#8217;s credentials.
Before the credentials can be authenticated, Spring Security typically requests the credentials using <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>.</p>
</div>
<div class="paragraph">
<p>Next, the <code>AbstractAuthenticationProcessingFilter</code> can authenticate any authentication requests that are submitted to it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="servlet/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter">
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/icons/number_1.png" alt="number 1"></span> When the user submits their credentials, the <code>AbstractAuthenticationProcessingFilter</code> creates an <a href="#servlet-authentication-authentication"><code>Authentication</code></a> from the <code>HttpServletRequest</code> to be authenticated.
The type of <code>Authentication</code> created depends on the subclass of <code>AbstractAuthenticationProcessingFilter</code>.
For example, <a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a> creates a <code>UsernamePasswordAuthenticationToken</code> from a <em>username</em> and <em>password</em> that are submitted in the <code>HttpServletRequest</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/icons/number_2.png" alt="number 2"></span> Next, the <a href="#servlet-authentication-authentication"><code>Authentication</code></a> is passed into the <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> to be authenticated.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/icons/number_3.png" alt="number 3"></span> If authentication fails, then <em>Failure</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> is cleared out.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/icons/number_4.png" alt="number 4"></span> If authentication is successful, then <em>Success</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SessionAuthenticationStrategy</code> is notified of a new log in.</p>
</li>
<li>
<p>The <a href="#servlet-authentication-authentication">Authentication</a> is set on the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
Later the <code>SecurityContextPersistenceFilter</code> saves the <code>SecurityContext</code> to the <code>HttpSession</code>.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> is invoked.
If remember me is not configured, this is a no-op.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> publishes an <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p><code>AuthenticationSuccessHandler</code> is invoked.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication-unpwd"><a class="anchor" href="#servlet-authentication-unpwd"></a>Username/Password Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the most common ways to authenticate a user is by validating a username and password.
As such, Spring Security provides comprehensive support for authenticating with a username and password.</p>
</div>
<div class="sect2">
<h3 id="servlet-authentication-unpwd-input"><a class="anchor" href="#servlet-authentication-unpwd-input"></a>Reading the Username &amp; Password</h3>
<div class="paragraph">
<p>Spring Security provides the following built in mechanisms for reading a username and password from the <code>HttpServletRequest</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-form">Form Login</a></p>
</li>
<li>
<p><a href="#servlet-authentication-basic">Basic Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-digest">Digest Authentication</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-unpwd-storage"><a class="anchor" href="#servlet-authentication-unpwd-storage"></a>Storage Mechanisms</h3>
<div class="paragraph">
<p>Each of the supported mechanisms for reading a username and password can leverage any of the supported storage mechanisms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple Storage with <a href="#servlet-authentication-inmemory">[servlet-authentication-inmemory]</a></p>
</li>
<li>
<p>Relational Databases with <a href="#servlet-authentication-jdbc">[servlet-authentication-jdbc]</a></p>
</li>
<li>
<p>Custom data stores with <a href="#servlet-authentication-userdetailsservice">[servlet-authentication-userdetailsservice]</a></p>
</li>
<li>
<p>LDAP storage with <a href="#servlet-authentication-ldap">[servlet-authentication-ldap]</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="session-mgmt"><a class="anchor" href="#session-mgmt"></a>Session Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP session related functionality is handled by a combination of the <code>SessionManagementFilter</code> and the <code>SessionAuthenticationStrategy</code> interface, which the filter delegates to.
Typical usage includes session-fixation protection attack prevention, detection of session timeouts and restrictions on how many sessions an authenticated user may have open concurrently.</p>
</div>
<div class="sect2">
<h3 id="_detecting_timeouts"><a class="anchor" href="#_detecting_timeouts"></a>Detecting Timeouts</h3>
<div class="paragraph">
<p>You can configure Spring Security to detect the submission of an invalid session ID and redirect the user to an appropriate URL.
This is achieved through the <code>session-management</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management invalid-session-url="/invalidSession.htm" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you use this mechanism to detect session timeouts, it may falsely report an error if the user logs out and then logs back in without closing the browser.
This is because the session cookie is not cleared when you invalidate the session and will be resubmitted even if the user has logged out.
You may be able to explicitly delete the JSESSIONID cookie on logging out, for example by using the following syntax in the logout handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;logout delete-cookies="JSESSIONID" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately this can&#8217;t be guaranteed to work with every servlet container, so you will need to test it in your environment</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are running your application behind a proxy, you may also be able to remove the session cookie by configuring the proxy server.
For example, using Apache HTTPD&#8217;s mod_headers, the following directive would delete the <code>JSESSIONID</code> cookie by expiring it in the response to a logout request (assuming the application is deployed under the path <code>/tutorial</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;LocationMatch "/tutorial/logout"&gt;
Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
&lt;/LocationMatch&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ns-concurrent-sessions"><a class="anchor" href="#ns-concurrent-sessions"></a>Concurrent Session Control</h3>
<div class="paragraph">
<p>If you wish to place constraints on a single user&#8217;s ability to log in to your application, Spring Security supports this out of the box with the following simple additions.
First you need to add the following listener to your <code>web.xml</code> file to keep Spring Security updated about session lifecycle events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the following lines to your application context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will prevent a user from logging in multiple times - a second login will cause the first to be invalidated.
Often you would prefer to prevent a second login, in which case you can use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
	&lt;concurrency-control max-sessions="1" error-if-maximum-exceeded="true" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second login will then be rejected.
By "rejected", we mean that the user will be sent to the <code>authentication-failure-url</code> if form-based login is being used.
If the second authentication takes place through another non-interactive mechanism, such as "remember-me", an "unauthorized" (401) error will be sent to the client.
If instead you want to use an error page, you can add the attribute <code>session-authentication-error-url</code> to the <code>session-management</code> element.</p>
</div>
<div class="paragraph">
<p>If you are using a customized authentication filter for form-based login, then you have to configure concurrent session control support explicitly.
More details can be found in the <a href="#session-mgmt">Session Management chapter</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-session-fixation"><a class="anchor" href="#ns-session-fixation"></a>Session Fixation Attack Protection</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session fixation</a> attacks are a potential risk where it is possible for a malicious attacker to create a session by accessing a site, then persuade another user to log in with the same session (by sending them a link containing the session identifier as a parameter, for example).
Spring Security protects against this automatically by creating a new session or otherwise changing the session ID when a user logs in.
If you don&#8217;t require this protection, or it conflicts with some other requirement, you can control the behavior using the <code>session-fixation-protection</code> attribute on <code>&lt;session-management&gt;</code>, which has four options</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> - Don&#8217;t do anything.
The original session will be retained.</p>
</li>
<li>
<p><code>newSession</code> - Create a new "clean" session, without copying the existing session data (Spring Security-related attributes will still be copied).</p>
</li>
<li>
<p><code>migrateSession</code> - Create a new session and copy all existing session attributes to the new session.
This is the default in Servlet 3.0 or older containers.</p>
</li>
<li>
<p><code>changeSessionId</code> - Do not create a new session.
Instead, use the session fixation protection provided by the Servlet container (<code>HttpServletRequest#changeSessionId()</code>).
This option is only available in Servlet 3.1 (Java EE 7) and newer containers.
Specifying it in older containers will result in an exception.
This is the default in Servlet 3.1 and newer containers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When session fixation protection occurs, it results in a <code>SessionFixationProtectionEvent</code> being published in the application context.
If you use <code>changeSessionId</code>, this protection will <em>also</em> result in any  <code>javax.servlet.http.HttpSessionIdListener</code> s being notified, so use caution if your code listens for both events.
See the <a href="#session-mgmt">Session Management</a> chapter for additional information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sessionmanagementfilter"><a class="anchor" href="#_sessionmanagementfilter"></a>SessionManagementFilter</h3>
<div class="paragraph">
<p>The <code>SessionManagementFilter</code> checks the contents of the <code>SecurityContextRepository</code> against the current contents of the <code>SecurityContextHolder</code> to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me  <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.
If the repository contains a security context, the filter does nothing.
If it doesn&#8217;t, and the thread-local <code>SecurityContext</code> contains a (non-anonymous) <code>Authentication</code> object, the filter assumes they have been authenticated by a previous filter in the stack.
It will then invoke the configured <code>SessionAuthenticationStrategy</code>.</p>
</div>
<div class="paragraph">
<p>If the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured <code>InvalidSessionStrategy</code>, if one is set.
The most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation <code>SimpleRedirectInvalidSessionStrategy</code>.
The latter is also used when configuring an invalid session URL through the namespace,<a href="#session-mgmt">as described earlier</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sessionauthenticationstrategy"><a class="anchor" href="#_sessionauthenticationstrategy"></a>SessionAuthenticationStrategy</h3>
<div class="paragraph">
<p><code>SessionAuthenticationStrategy</code> is used by both <code>SessionManagementFilter</code> and <code>AbstractAuthenticationProcessingFilter</code>, so if you are using a customized form-login class, for example, you will need to inject it into both of these.
In this case, a typical configuration, combining the namespace and custom beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
	&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
	...
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class=
"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the use of the default, <code>SessionFixationProtectionStrategy</code> may cause issues if you are storing beans in the session which implement <code>HttpSessionBindingListener</code>, including Spring session-scoped beans.
See the Javadoc for this class for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent-sessions"><a class="anchor" href="#concurrent-sessions"></a>Concurrency Control</h3>
<div class="paragraph">
<p>Spring Security is able to prevent a principal from concurrently authenticating to the same application more than a specified number of times.
Many ISVs take advantage of this to enforce licensing, whilst network administrators like this feature because it helps prevent people from sharing login names.
You can, for example, stop user "Batman" from logging onto the web application from two different sessions.
You can either expire their previous login or you can report an error when they try to log in again, preventing the second login.
Note that if you are using the second approach, a user who has not explicitly logged out (but who has just closed their browser, for example) will not be able to log in again until their original session expires.</p>
</div>
<div class="paragraph">
<p>Concurrency control is supported by the namespace, so please check the earlier namespace chapter for the simplest configuration.
Sometimes you need to customize things though.</p>
</div>
<div class="paragraph">
<p>The implementation uses a specialized version of <code>SessionAuthenticationStrategy</code>, called <code>ConcurrentSessionControlAuthenticationStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Previously the concurrent authentication check was made by the <code>ProviderManager</code>, which could be injected with a <code>ConcurrentSessionController</code>.
The latter would check if the user was attempting to exceed the number of permitted sessions.
However, this approach required that an HTTP session be created in advance, which is undesirable.
In Spring Security 3, the user is first authenticated by the <code>AuthenticationManager</code> and once they are successfully authenticated, a session is created and the check is made whether they are allowed to have another session open.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use concurrent session support, you&#8217;ll need to add the following to <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;listener&gt;
	&lt;listener-class&gt;
	org.springframework.security.web.session.HttpSessionEventPublisher
	&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you will need to add the <code>ConcurrentSessionFilter</code> to your <code>FilterChainProxy</code>.
The <code>ConcurrentSessionFilter</code> requires two constructor arguments, <code>sessionRegistry</code>, which generally points to an instance of <code>SessionRegistryImpl</code>, and <code>sessionInformationExpiredStrategy</code>, which defines the strategy to apply when a session has expired.
A configuration using the namespace to create the <code>FilterChainProxy</code> and other default beans might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="redirectSessionInformationExpiredStrategy"
class="org.springframework.security.web.session.SimpleRedirectSessionInformationExpiredStrategy"&gt;
&lt;beans:constructor-arg name="invalidSessionUrl" value="/session-expired.htm" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="concurrencyFilter"
class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
&lt;beans:constructor-arg name="sessionRegistry" ref="sessionRegistry" /&gt;
&lt;beans:constructor-arg name="sessionInformationExpiredStrategy" ref="redirectSessionInformationExpiredStrategy" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
&lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class="org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"&gt;
&lt;beans:constructor-arg&gt;
	&lt;beans:list&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
		&lt;beans:property name="maximumSessions" value="1" /&gt;
		&lt;beans:property name="exceptionIfMaximumExceeded" value="true" /&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
	&lt;/beans:bean&gt;
	&lt;beans:bean class="org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"&gt;
		&lt;beans:constructor-arg ref="sessionRegistry"/&gt;
	&lt;/beans:bean&gt;
	&lt;/beans:list&gt;
&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sessionRegistry"
	class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding the listener to <code>web.xml</code> causes an <code>ApplicationEvent</code> to be published to the Spring <code>ApplicationContext</code> every time a <code>HttpSession</code> commences or ends.
This is critical, as it allows the <code>SessionRegistryImpl</code> to be notified when a session ends.
Without it, a user will never be able to log back in again once they have exceeded their session allowance, even if they log out of another session or it times out.</p>
</div>
<div class="sect3">
<h4 id="list-authenticated-principals"><a class="anchor" href="#list-authenticated-principals"></a>Querying the SessionRegistry for currently authenticated users and their sessions</h4>
<div class="paragraph">
<p>Setting up concurrency-control, either through the namespace or using plain beans has the useful side effect of providing you with a reference to the <code>SessionRegistry</code> which you can use directly within your application, so even if you don&#8217;t want to restrict the number of sessions a user may have, it may be worth setting up the infrastructure anyway.
You can set the <code>maximumSession</code> property to -1 to allow unlimited sessions.
If you&#8217;re using the namespace, you can set an alias for the internally-created <code>SessionRegistry</code> using the <code>session-registry-alias</code> attribute, providing a reference which you can inject into your own beans.</p>
</div>
<div class="paragraph">
<p>The <code>getAllPrincipals()</code> method supplies you with a list of the currently authenticated users.
You can list a user&#8217;s sessions by calling the <code>getAllSessions(Object principal, boolean includeExpiredSessions)</code> method, which returns a list of <code>SessionInformation</code> objects.
You can also expire a user&#8217;s session by calling <code>expireNow()</code> on a <code>SessionInformation</code> instance.
When the user returns to the application, they will be prevented from proceeding.
You may find these methods useful in an administration application, for example.
Have a look at the Javadoc for more information.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-rememberme"><a class="anchor" href="#servlet-rememberme"></a>Remember-Me Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="remember-me-overview"><a class="anchor" href="#remember-me-overview"></a>Overview</h3>
<div class="paragraph">
<p>Remember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions.
This is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place.
Spring Security provides the necessary hooks for these operations to take place, and has two concrete remember-me implementations.
One uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens.</p>
</div>
<div class="paragraph">
<p>Note that both implementations require a <code>UserDetailsService</code>.
If you are using an authentication provider which doesn&#8217;t use a <code>UserDetailsService</code> (for example, the LDAP provider) then it won&#8217;t work unless you also have a <code>UserDetailsService</code> bean in your application context.</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-hash-token"><a class="anchor" href="#remember-me-hash-token"></a>Simple Hash-Based Token Approach</h3>
<div class="paragraph">
<p>This approach uses hashing to achieve a useful remember-me strategy.
In essence a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token</code></pre>
</div>
</div>
<div class="paragraph">
<p>As such the remember-me token is valid only for the period specified, and provided that the username, password and key does not change.
Notably, this has a potential security issue in that a captured remember-me token will be usable from any user agent until such time as the token expires.
This is the same issue as with digest authentication.
If a principal is aware a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue.
If more significant security is needed you should use the approach described in the next section.
Alternatively remember-me services should simply not be used at all.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the topics discussed in the chapter on <a href="#ns-config">namespace configuration</a>, you can enable remember-me authentication just by adding the <code>&lt;remember-me&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me key="myAppKey"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UserDetailsService</code> will normally be selected automatically.
If you have more than one in your application context, you need to specify which one should be used with the <code>user-service-ref</code> attribute, where the value is the name of your <code>UserDetailsService</code> bean.</p>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-persistent-token"><a class="anchor" href="#remember-me-persistent-token"></a>Persistent Token Approach</h3>
<div class="paragraph">
<p>This approach is based on the article <a href="https://web.archive.org/web/20180819014446/http://jaspan.com/improved_persistent_login_cookie_best_practice">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> with some minor modifications  <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.
To use the this approach with namespace configuration, you would supply a datasource reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
&lt;remember-me data-source-ref="someDataSource"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The database should contain a <code>persistent_logins</code> table, created using the following SQL (or equivalent):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ddl hljs" data-lang="ddl">create table persistent_logins (username varchar(64) not null,
								series varchar(64) primary key,
								token varchar(64) not null,
								last_used timestamp not null)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remember-me-impls"><a class="anchor" href="#remember-me-impls"></a>Remember-Me Interfaces and Implementations</h3>
<div class="paragraph">
<p>Remember-me is used with <code>UsernamePasswordAuthenticationFilter</code>, and is implemented via hooks in the <code>AbstractAuthenticationProcessingFilter</code> superclass.
It is also used within <code>BasicAuthenticationFilter</code>.
The hooks will invoke a concrete <code>RememberMeServices</code> at the appropriate times.
The interface looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response,
	Authentication successfulAuthentication);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the Javadoc for a fuller discussion on what the methods do, although note at this stage that <code>AbstractAuthenticationProcessingFilter</code> only calls the <code>loginFail()</code> and <code>loginSuccess()</code> methods.
The <code>autoLogin()</code> method is called by <code>RememberMeAuthenticationFilter</code> whenever the <code>SecurityContextHolder</code> does not contain an <code>Authentication</code>.
This interface therefore provides the underlying remember-me implementation with sufficient notification of authentication-related events, and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered.
This design allows any number of remember-me implementation strategies.
We&#8217;ve seen above that Spring Security provides two implementations.
We&#8217;ll look at these in turn.</p>
</div>
<div class="sect3">
<h4 id="_tokenbasedremembermeservices"><a class="anchor" href="#_tokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>This implementation supports the simpler approach described in <a href="#remember-me-hash-token">Simple Hash-Based Token Approach</a>.
<code>TokenBasedRememberMeServices</code> generates a <code>RememberMeAuthenticationToken</code>, which is processed by <code>RememberMeAuthenticationProvider</code>.
A <code>key</code> is shared between this authentication provider and the <code>TokenBasedRememberMeServices</code>.
In addition, <code>TokenBasedRememberMeServices</code> requires A UserDetailsService from which it can retrieve the username and password for signature comparison purposes, and generate the <code>RememberMeAuthenticationToken</code> to contain the correct <code>GrantedAuthority</code> s.
Some sort of logout command should be provided by the application that invalidates the cookie if the user requests this.
<code>TokenBasedRememberMeServices</code> also implements Spring Security&#8217;s <code>LogoutHandler</code> interface so can be used with <code>LogoutFilter</code> to have the cookie cleared automatically.</p>
</div>
<div class="paragraph">
<p>The beans required in an application context to enable remember-me services are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rememberMeFilter" class=
"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"&gt;
&lt;property name="rememberMeServices" ref="rememberMeServices"/&gt;
&lt;property name="authenticationManager" ref="theAuthenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeServices" class=
"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"&gt;
&lt;property name="userDetailsService" ref="myUserDetailsService"/&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeAuthenticationProvider" class=
"org.springframework.security.authentication.RememberMeAuthenticationProvider"&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to add your <code>RememberMeServices</code> implementation to your <code>UsernamePasswordAuthenticationFilter.setRememberMeServices()</code> property, include the <code>RememberMeAuthenticationProvider</code> in your <code>AuthenticationManager.setProviders()</code> list, and add <code>RememberMeAuthenticationFilter</code> into your <code>FilterChainProxy</code> (typically immediately after your <code>UsernamePasswordAuthenticationFilter</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_persistenttokenbasedremembermeservices"><a class="anchor" href="#_persistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h4>
<div class="paragraph">
<p>This class can be used in the same way as <code>TokenBasedRememberMeServices</code>, but it additionally needs to be configured with a <code>PersistentTokenRepository</code> to store the tokens.
There are two standard implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenRepositoryImpl</code> which is intended for testing only.</p>
</li>
<li>
<p><code>JdbcTokenRepositoryImpl</code> which stores the tokens in a database.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The database schema is described above in <a href="#remember-me-persistent-token">Persistent Token Approach</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-openid"><a class="anchor" href="#servlet-openid"></a>OpenID Support</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The OpenID 1.0 and 2.0 protocols have been deprecated and users are encouraged to migrate to OpenID Connect, which is supported by spring-security-oauth2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The namespace supports <a href="https://openid.net/">OpenID</a> login either instead of, or in addition to normal form-based login, with a simple change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;openid-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should then register yourself with an OpenID provider (such as myopenid.com), and add the user information to your in-memory <code>&lt;user-service&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user name="https://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should be able to login using the <code>myopenid.com</code> site to authenticate.
It is also possible to select a specific <code>UserDetailsService</code> bean for use OpenID by setting the <code>user-service-ref</code> attribute on the <code>openid-login</code> element.
Note that we have omitted the password attribute from the above user configuration, since this set of user data is only being used to load the authorities for the user.
A random password will be generated internally, preventing you from accidentally using this user data as an authentication source elsewhere in your configuration.</p>
</div>
<div class="sect2">
<h3 id="_attribute_exchange"><a class="anchor" href="#_attribute_exchange"></a>Attribute Exchange</h3>
<div class="paragraph">
<p>Support for OpenID <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html">attribute exchange</a>.
As an example, the following configuration would attempt to retrieve the email and full name from the OpenID provider, for use by the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;openid-login&gt;
&lt;attribute-exchange&gt;
	&lt;openid-attribute name="email" type="https://axschema.org/contact/email" required="true"/&gt;
	&lt;openid-attribute name="name" type="https://axschema.org/namePerson"/&gt;
&lt;/attribute-exchange&gt;
&lt;/openid-login&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "type" of each OpenID attribute is a URI, determined by a particular schema, in this case <a href="https://axschema.org/">https://axschema.org/</a>.
If an attribute must be retrieved for successful authentication, the <code>required</code> attribute can be set.
The exact schema and attributes supported will depend on your OpenID provider.
The attribute values are returned as part of the authentication process and can be accessed afterwards using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenIDAuthenticationToken token =
	(OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can obtain the <code>OpenIDAuthenticationToken</code> from the <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.
The <code>OpenIDAttribute</code> contains the attribute type and the retrieved value (or values in the case of multi-valued attributes).
You can supply multiple <code>attribute-exchange</code> elements, using an <code>identifier-matcher</code> attribute on each.
This contains a regular expression which will be matched against the OpenID identifier supplied by the user.
See the OpenID sample application in the codebase for an example configuration, providing different attribute lists for the Google, Yahoo and MyOpenID providers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anonymous"><a class="anchor" href="#anonymous"></a>Anonymous Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="anonymous-overview"><a class="anchor" href="#anonymous-overview"></a>Overview</h3>
<div class="paragraph">
<p>It&#8217;s generally considered good security practice to adopt a "deny-by-default" where you explicitly specify what is allowed and disallow everything else.
Defining what is accessible to unauthenticated users is a similar situation, particularly for web applications.
Many sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages).
In this case it is easiest to define access configuration attributes for these specific URLs rather than have for every secured resource.
Put differently, sometimes it is nice to say <code>ROLE_SOMETHING</code> is required by default and only allow certain exceptions to this rule, such as for login, logout and home pages of an application.
You could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users.</p>
</div>
<div class="paragraph">
<p>This is what we mean by anonymous authentication.
Note that there is no real conceptual difference between a user who is "anonymously authenticated" and an unauthenticated user.
Spring Security&#8217;s anonymous authentication just gives you a more convenient way to configure your access-control attributes.
Calls to servlet API calls such as <code>getCallerPrincipal</code>, for example, will still return null even though there is actually an anonymous authentication object in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>There are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the <code>SecurityContextHolder</code> to identify which principal was responsible for a given operation.
Classes can be authored more robustly if they know the <code>SecurityContextHolder</code> always contains an <code>Authentication</code> object, and never <code>null</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-config"><a class="anchor" href="#anonymous-config"></a>Configuration</h3>
<div class="paragraph">
<p>Anonymous authentication support is provided automatically when using the HTTP configuration Spring Security 3.0 and can be customized (or disabled) using the <code>&lt;anonymous&gt;</code> element.
You don&#8217;t need to configure the beans described here unless you are using traditional bean configuration.</p>
</div>
<div class="paragraph">
<p>Three classes that together provide the anonymous authentication feature.
<code>AnonymousAuthenticationToken</code> is an implementation of <code>Authentication</code>, and stores the <code>GrantedAuthority</code> s which apply to the anonymous principal.
There is a corresponding <code>AnonymousAuthenticationProvider</code>, which is chained into the <code>ProviderManager</code> so that <code>AnonymousAuthenticationToken</code> s are accepted.
Finally, there is an <code>AnonymousAuthenticationFilter</code>, which is chained after the normal authentication mechanisms and automatically adds an <code>AnonymousAuthenticationToken</code> to the <code>SecurityContextHolder</code> if there is no existing <code>Authentication</code> held there.
The definition of the filter and authentication provider appears as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="anonymousAuthFilter"
	class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
	class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>key</code> is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.
The <code>userAttribute</code> is expressed in the form of <code>usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code>.
This is the same syntax as used after the equals sign for the <code>userMap</code> property of <code>InMemoryDaoImpl</code>.</p>
</div>
<div class="paragraph">
<p>As explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
&lt;property name="securityMetadata"&gt;
	&lt;security:filter-security-metadata-source&gt;
	&lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
	&lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
	&lt;/security:filter-security-metadata-source&gt;" +
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-auth-trust-resolver"><a class="anchor" href="#anonymous-auth-trust-resolver"></a>AuthenticationTrustResolver</h3>
<div class="paragraph">
<p>Rounding out the anonymous authentication discussion is the <code>AuthenticationTrustResolver</code> interface, with its corresponding <code>AuthenticationTrustResolverImpl</code> implementation.
This interface provides an <code>isAnonymous(Authentication)</code> method, which allows interested classes to take into account this special type of authentication status.
The <code>ExceptionTranslationFilter</code> uses this interface in processing <code>AccessDeniedException</code> s.
If an <code>AccessDeniedException</code> is thrown, and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter will instead commence the <code>AuthenticationEntryPoint</code> so the principal can authenticate properly.
This is a necessary distinction, otherwise principals would always be deemed "authenticated" and never be given an opportunity to login via form, basic, digest or some other normal authentication mechanism.</p>
</div>
<div class="paragraph">
<p>You will often see the <code>ROLE_ANONYMOUS</code> attribute in the above interceptor configuration replaced with <code>IS_AUTHENTICATED_ANONYMOUSLY</code>, which is effectively the same thing when defining access controls.
This is an example of the use of the <code>AuthenticatedVoter</code> which we will see in the <a href="#authz-authenticated-voter">authorization chapter</a>.
It uses an <code>AuthenticationTrustResolver</code> to process this particular configuration attribute and grant access to anonymous users.
The <code>AuthenticatedVoter</code> approach is more powerful, since it allows you to differentiate between anonymous, remember-me and fully-authenticated users.
If you don&#8217;t need this functionality though, then you can stick with <code>ROLE_ANONYMOUS</code>, which will be processed by Spring Security&#8217;s standard <code>RoleVoter</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="anonymous-auth-mvc-controller"><a class="anchor" href="#anonymous-auth-mvc-controller"></a>Getting Anonymous Authentications with Spring MVC</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments">Spring MVC resolves parameters of type <code>Principal</code></a> using its own argument resolver.</p>
</div>
<div class="paragraph">
<p>This means that a construct like this one:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String method(Authentication authentication) {
	if (authentication instanceof AnonymousAuthenticationToken) {
		return "anonymous";
	} else {
		return "not anonymous";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun method(authentication: Authentication?): String {
    return if (authentication is AnonymousAuthenticationToken) {
        "anonymous"
    } else {
        "not anonymous"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>will always return "not anonymous", even for anonymous requests.
The reason is that Spring MVC resolves the parameter using <code>HttpServletRequest#getPrincipal</code>, which is <code>null</code> when the request is anonymous.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to obtain the <code>Authentication</code> in anonymous requests, use <code>@CurrentSecurityContext</code> instead:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Use CurrentSecurityContext for Anonymous requests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String method(@CurrentSecurityContext SecurityContext context) {
	return context.getAuthentication().getName();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun method(@CurrentSecurityContext context : SecurityContext) : String =
		context!!.authentication!!.name</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-preauth"><a class="anchor" href="#servlet-preauth"></a>Pre-Authentication Scenarios</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are situations where you want to use Spring Security for authorization, but the user has already been reliably authenticated by some external system prior to accessing the application.
We refer to these situations as "pre-authenticated" scenarios.
Examples include X.509, Siteminder and authentication by the Java EE container in which the application is running.
When using pre-authentication, Spring Security has to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the user making the request.</p>
</li>
<li>
<p>Obtain the authorities for the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The details will depend on the external authentication mechanism.
A user might be identified by their certificate information in the case of X.509, or by an HTTP request header in the case of Siteminder.
If relying on container authentication, the user will be identified by calling the <code>getUserPrincipal()</code> method on the incoming HTTP request.
In some cases, the external mechanism may supply role/authority information for the user but in others the authorities must be obtained from a separate source, such as a <code>UserDetailsService</code>.</p>
</div>
<div class="sect2">
<h3 id="_pre_authentication_framework_classes"><a class="anchor" href="#_pre_authentication_framework_classes"></a>Pre-Authentication Framework Classes</h3>
<div class="paragraph">
<p>Because most pre-authentication mechanisms follow the same pattern, Spring Security has a set of classes which provide an internal framework for implementing pre-authenticated authentication providers.
This removes duplication and allows new implementations to be added in a structured fashion, without having to write everything from scratch.
You don&#8217;t need to know about these classes if you want to use something like <a href="#servlet-x509">X.509 authentication</a>, as it already has a namespace configuration option which is simpler to use and get started with.
If you need to use explicit bean configuration or are planning on writing your own implementation then an understanding of how the provided implementations work will be useful.
You will find classes under the <code>org.springframework.security.web.authentication.preauth</code>.
We just provide an outline here so you should consult the Javadoc and source where appropriate.</p>
</div>
<div class="sect3">
<h4 id="_abstractpreauthenticatedprocessingfilter"><a class="anchor" href="#_abstractpreauthenticatedprocessingfilter"></a>AbstractPreAuthenticatedProcessingFilter</h4>
<div class="paragraph">
<p>This class will check the current contents of the security context and, if empty, it will attempt to extract user information from the HTTP request and submit it to the <code>AuthenticationManager</code>.
Subclasses override the following methods to obtain this information:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Override AbstractPreAuthenticatedProcessingFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?

protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After calling these, the filter will create a <code>PreAuthenticatedAuthenticationToken</code> containing the returned data and submit it for authentication.
By "authentication" here, we really just mean further processing to perhaps load the user&#8217;s authorities, but the standard Spring Security authentication architecture is followed.</p>
</div>
<div class="paragraph">
<p>Like other Spring Security authentication filters, the pre-authentication filter has an <code>authenticationDetailsSource</code> property which by default will create a <code>WebAuthenticationDetails</code> object to store additional information such as the session-identifier and originating IP address in the <code>details</code> property of the <code>Authentication</code> object.
In cases where user role information can be obtained from the pre-authentication mechanism, the data is also stored in this property, with the details implementing the <code>GrantedAuthoritiesContainer</code> interface.
This enables the authentication provider to read the authorities which were externally allocated to the user.
We&#8217;ll look at a concrete example next.</p>
</div>
<div class="sect4">
<h5 id="j2ee-preauth-details"><a class="anchor" href="#j2ee-preauth-details"></a>J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</h5>
<div class="paragraph">
<p>If the filter is configured with an <code>authenticationDetailsSource</code> which is an instance of this class, the authority information is obtained by calling the <code>isUserInRole(String role)</code> method for each of a pre-determined set of "mappable roles".
The class gets these from a configured <code>MappableAttributesRetriever</code>.
Possible implementations include hard-coding a list in the application context and reading the role information from the <code>&lt;security-role&gt;</code> information in a <code>web.xml</code> file.
The pre-authentication sample application uses the latter approach.</p>
</div>
<div class="paragraph">
<p>There is an additional stage where the roles (or attributes) are mapped to Spring Security <code>GrantedAuthority</code> objects using a configured <code>Attributes2GrantedAuthoritiesMapper</code>.
The default will just add the usual <code>ROLE_</code> prefix to the names, but it gives you full control over the behaviour.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_preauthenticatedauthenticationprovider"><a class="anchor" href="#_preauthenticatedauthenticationprovider"></a>PreAuthenticatedAuthenticationProvider</h4>
<div class="paragraph">
<p>The pre-authenticated provider has little more to do than load the <code>UserDetails</code> object for the user.
It does this by delegating to an <code>AuthenticationUserDetailsService</code>.
The latter is similar to the standard <code>UserDetailsService</code> but takes an <code>Authentication</code> object rather than just user name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface AuthenticationUserDetailsService {
	UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface may have also other uses but with pre-authentication it allows access to the authorities which were packaged in the <code>Authentication</code> object, as we saw in the previous section.
The <code>PreAuthenticatedGrantedAuthoritiesUserDetailsService</code> class does this.
Alternatively, it may delegate to a standard <code>UserDetailsService</code> via the <code>UserDetailsByNameServiceWrapper</code> implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_http403forbiddenentrypoint"><a class="anchor" href="#_http403forbiddenentrypoint"></a>Http403ForbiddenEntryPoint</h4>
<div class="paragraph">
<p>The <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> is responsible for kick-starting the authentication process for an unauthenticated user (when they try to access a protected resource), but in the pre-authenticated case this doesn&#8217;t apply.
You would only configure the <code>ExceptionTranslationFilter</code> with an instance of this class if you aren&#8217;t using pre-authentication in combination with other authentication mechanisms.
It will be called if the user is rejected by the <code>AbstractPreAuthenticatedProcessingFilter</code> resulting in a null authentication.
It always returns a <code>403</code>-forbidden response code if called.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_concrete_implementations"><a class="anchor" href="#_concrete_implementations"></a>Concrete Implementations</h3>
<div class="paragraph">
<p>X.509 authentication is covered in its <a href="#servlet-x509">own chapter</a>.
Here we&#8217;ll look at some classes which provide support for other pre-authenticated scenarios.</p>
</div>
<div class="sect3">
<h4 id="_request_header_authentication_siteminder"><a class="anchor" href="#_request_header_authentication_siteminder"></a>Request-Header Authentication (Siteminder)</h4>
<div class="paragraph">
<p>An external authentication system may supply information to the application by setting specific headers on the HTTP request.
A well-known example of this is Siteminder, which passes the username in a header called <code>SM_USER</code>.
This mechanism is supported by the class <code>RequestHeaderAuthenticationFilter</code> which simply extracts the username from the header.
It defaults to using the name <code>SM_USER</code> as the header name.
See the Javadoc for more details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that when using a system like this, the framework performs no authentication checks at all and it is <em>extremely</em> important that the external system is configured properly and protects all access to the application.
If an attacker is able to forge the headers in their original request without this being detected then they could potentially choose any username they wished.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_siteminder_example_configuration"><a class="anchor" href="#_siteminder_example_configuration"></a>Siteminder Example Configuration</h5>
<div class="paragraph">
<p>A typical configuration using this filter would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http&gt;
&lt;!-- Additional http configuration omitted --&gt;
&lt;security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter"&gt;
&lt;property name="principalRequestHeader" value="SM_USER"/&gt;
&lt;property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
&lt;property name="preAuthenticatedUserDetailsService"&gt;
	&lt;bean id="userDetailsServiceWrapper"
		class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;property name="userDetailsService" ref="userDetailsService"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
&lt;/security:authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve assumed here that the <a href="#ns-config">security namespace</a> is being used for configuration.
It&#8217;s also assumed that you have added a <code>UserDetailsService</code> (called "userDetailsService") to your configuration to load the user&#8217;s roles.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_java_ee_container_authentication"><a class="anchor" href="#_java_ee_container_authentication"></a>Java EE Container Authentication</h4>
<div class="paragraph">
<p>The class <code>J2eePreAuthenticatedProcessingFilter</code> will extract the username from the <code>userPrincipal</code> property of the <code>HttpServletRequest</code>.
Use of this filter would usually be combined with the use of Java EE roles as described above in <a href="#j2ee-preauth-details">J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource</a>.</p>
</div>
<div class="paragraph">
<p>There is a <a href="https://github.com/spring-projects/spring-security/tree/5.4.x/samples/xml/preauth">sample application</a> in the samples project which uses this approach, so get hold of the code from GitHub and have a look at the application context file if you are interested.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-jaas"><a class="anchor" href="#servlet-jaas"></a>Java Authentication and Authorization Service (JAAS) Provider</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h3>
<div class="paragraph">
<p>Spring Security provides a package able to delegate authentication requests to the Java Authentication and Authorization Service (JAAS).
This package is discussed in detail below.</p>
</div>
</div>
<div class="sect2">
<h3 id="jaas-abstractjaasauthenticationprovider"><a class="anchor" href="#jaas-abstractjaasauthenticationprovider"></a>AbstractJaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>AbstractJaasAuthenticationProvider</code> is the basis for the provided JAAS <code>AuthenticationProvider</code> implementations.
Subclasses must implement a method that creates the <code>LoginContext</code>.
The <code>AbstractJaasAuthenticationProvider</code> has a number of dependencies that can be injected into it that are discussed below.</p>
</div>
<div class="sect3">
<h4 id="jaas-callbackhandler"><a class="anchor" href="#jaas-callbackhandler"></a>JAAS CallbackHandler</h4>
<div class="paragraph">
<p>Most JAAS <code>LoginModule</code> s require a callback of some sort.
These callbacks are usually used to obtain the username and password from the user.</p>
</div>
<div class="paragraph">
<p>In a Spring Security deployment, Spring Security is responsible for this user interaction (via the authentication mechanism).
Thus, by the time the authentication request is delegated through to JAAS, Spring Security&#8217;s authentication mechanism will already have fully-populated an <code>Authentication</code> object containing all the information required by the JAAS <code>LoginModule</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, the JAAS package for Spring Security provides two default callback handlers, <code>JaasNameCallbackHandler</code> and <code>JaasPasswordCallbackHandler</code>.
Each of these callback handlers implement <code>JaasAuthenticationCallbackHandler</code>.
In most cases these callback handlers can simply be used without understanding the internal mechanics.</p>
</div>
<div class="paragraph">
<p>For those needing full control over the callback behavior, internally <code>AbstractJaasAuthenticationProvider</code> wraps these <code>JaasAuthenticationCallbackHandler</code> s with an <code>InternalCallbackHandler</code>.
The <code>InternalCallbackHandler</code> is the class that actually implements JAAS normal <code>CallbackHandler</code> interface.
Any time that the JAAS <code>LoginModule</code> is used, it is passed a list of application context configured <code>InternalCallbackHandler</code> s.
If the <code>LoginModule</code> requests a callback against the <code>InternalCallbackHandler</code> s, the callback is in-turn passed to the <code>JaasAuthenticationCallbackHandler</code> s being wrapped.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-authoritygranter"><a class="anchor" href="#jaas-authoritygranter"></a>JAAS AuthorityGranter</h4>
<div class="paragraph">
<p>JAAS works with principals.
Even "roles" are represented as principals in JAAS.
Spring Security, on the other hand, works with <code>Authentication</code> objects.
Each <code>Authentication</code> object contains a single principal, and multiple <code>GrantedAuthority</code> s.
To facilitate mapping between these different concepts, Spring Security&#8217;s JAAS package includes an <code>AuthorityGranter</code> interface.</p>
</div>
<div class="paragraph">
<p>An <code>AuthorityGranter</code> is responsible for inspecting a JAAS principal and returning a set of <code>String</code> s, representing the authorities assigned to the principal.
For each returned authority string, the <code>AbstractJaasAuthenticationProvider</code> creates a <code>JaasGrantedAuthority</code> (which implements Spring Security&#8217;s <code>GrantedAuthority</code> interface) containing the authority string and the JAAS principal that the <code>AuthorityGranter</code> was passed.
The <code>AbstractJaasAuthenticationProvider</code> obtains the JAAS principals by firstly successfully authenticating the user&#8217;s credentials using the JAAS <code>LoginModule</code>, and then accessing the <code>LoginContext</code> it returns.
A call to <code>LoginContext.getSubject().getPrincipals()</code> is made, with each resulting principal passed to each <code>AuthorityGranter</code> defined against the <code>AbstractJaasAuthenticationProvider.setAuthorityGranters(List)</code> property.</p>
</div>
<div class="paragraph">
<p>Spring Security does not include any production <code>AuthorityGranter</code> s given that every JAAS principal has an implementation-specific meaning.
However, there is a <code>TestAuthorityGranter</code> in the unit tests that demonstrates a simple <code>AuthorityGranter</code> implementation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-defaultjaasauthenticationprovider"><a class="anchor" href="#jaas-defaultjaasauthenticationprovider"></a>DefaultJaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>DefaultJaasAuthenticationProvider</code> allows a JAAS <code>Configuration</code> object to be injected into it as a dependency.
It then creates a <code>LoginContext</code> using the injected JAAS <code>Configuration</code>.
This means that <code>DefaultJaasAuthenticationProvider</code> is not bound any particular implementation of <code>Configuration</code> as <code>JaasAuthenticationProvider</code> is.</p>
</div>
<div class="sect3">
<h4 id="jaas-inmemoryconfiguration"><a class="anchor" href="#jaas-inmemoryconfiguration"></a>InMemoryConfiguration</h4>
<div class="paragraph">
<p>In order to make it easy to inject a <code>Configuration</code> into <code>DefaultJaasAuthenticationProvider</code>, a default in-memory implementation named <code>InMemoryConfiguration</code> is provided.
The implementation constructor accepts a <code>Map</code> where each key represents a login configuration name and the value represents an <code>Array</code> of <code>AppConfigurationEntry</code> s.
<code>InMemoryConfiguration</code> also supports a default <code>Array</code> of <code>AppConfigurationEntry</code> objects that will be used if no mapping is found within the provided <code>Map</code>.
For details, refer to the class level javadoc of <code>InMemoryConfiguration</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-djap-config"><a class="anchor" href="#jaas-djap-config"></a>DefaultJaasAuthenticationProvider Example Configuration</h4>
<div class="paragraph">
<p>While the Spring configuration for <code>InMemoryConfiguration</code> can be more verbose than the standard JAAS configuration files, using it in conjunction with <code>DefaultJaasAuthenticationProvider</code> is more flexible than <code>JaasAuthenticationProvider</code> since it not dependant on the default <code>Configuration</code> implementation.</p>
</div>
<div class="paragraph">
<p>An example configuration of <code>DefaultJaasAuthenticationProvider</code> using <code>InMemoryConfiguration</code> is provided below.
Note that custom implementations of <code>Configuration</code> can easily be injected into <code>DefaultJaasAuthenticationProvider</code> as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthProvider"
class="org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider"&gt;
&lt;property name="configuration"&gt;
&lt;bean class="org.springframework.security.authentication.jaas.memory.InMemoryConfiguration"&gt;
&lt;constructor-arg&gt;
	&lt;map&gt;
	&lt;!--
	SPRINGSECURITY is the default loginContextName
	for AbstractJaasAuthenticationProvider
	--&gt;
	&lt;entry key="SPRINGSECURITY"&gt;
	&lt;array&gt;
	&lt;bean class="javax.security.auth.login.AppConfigurationEntry"&gt;
		&lt;constructor-arg value="sample.SampleLoginModule" /&gt;
		&lt;constructor-arg&gt;
		&lt;util:constant static-field=
			"javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED"/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg&gt;
		&lt;map&gt;&lt;/map&gt;
		&lt;/constructor-arg&gt;
		&lt;/bean&gt;
	&lt;/array&gt;
	&lt;/entry&gt;
	&lt;/map&gt;
	&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
&lt;list&gt;
	&lt;!-- You will need to write your own implementation of AuthorityGranter --&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-jaasauthenticationprovider"><a class="anchor" href="#jaas-jaasauthenticationprovider"></a>JaasAuthenticationProvider</h3>
<div class="paragraph">
<p>The <code>JaasAuthenticationProvider</code> assumes the default <code>Configuration</code> is an instance of <a href="https://docs.oracle.com/javase/8/docs/jre/api/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html"> ConfigFile</a>.
This assumption is made in order to attempt to update the <code>Configuration</code>.
The <code>JaasAuthenticationProvider</code> then uses the default <code>Configuration</code> to create the <code>LoginContext</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a JAAS login configuration file, <code>/WEB-INF/login.conf</code>, with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-txt hljs" data-lang="txt">JAASTest {
	sample.SampleLoginModule required;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like all Spring Security beans, the <code>JaasAuthenticationProvider</code> is configured via the application context.
The following definitions would correspond to the above JAAS login configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jaasAuthenticationProvider"
class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
&lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
&lt;property name="loginContextName" value="JAASTest"/&gt;
&lt;property name="callbackHandlers"&gt;
&lt;list&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
&lt;bean
	class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
	&lt;list&gt;
	&lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
	&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-apiprovision"><a class="anchor" href="#jaas-apiprovision"></a>Running as a Subject</h3>
<div class="paragraph">
<p>If configured, the <code>JaasApiIntegrationFilter</code> will attempt to run as the <code>Subject</code> on the <code>JaasAuthenticationToken</code>.
This means that the <code>Subject</code> can be accessed using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Subject subject = Subject.getSubject(AccessController.getContext());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This integration can easily be configured using the <a href="#nsa-http-jaas-api-provision">jaas-api-provision</a> attribute.
This feature is useful when integrating with legacy or external API&#8217;s that rely on the JAAS Subject being populated.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-cas"><a class="anchor" href="#servlet-cas"></a>CAS Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cas-overview"><a class="anchor" href="#cas-overview"></a>Overview</h3>
<div class="paragraph">
<p>JA-SIG produces an enterprise-wide single sign on system known as CAS.
Unlike other initiatives, JA-SIG&#8217;s Central Authentication Service is open source, widely used, simple to understand, platform independent, and supports proxy capabilities.
Spring Security fully supports CAS, and provides an easy migration path from single-application deployments of Spring Security through to multiple-application deployments secured by an enterprise-wide CAS server.</p>
</div>
<div class="paragraph">
<p>You can learn more about CAS at <a href="https://www.apereo.org" class="bare">https://www.apereo.org</a>.
You will also need to visit this site to download the CAS Server files.</p>
</div>
</div>
<div class="sect2">
<h3 id="cas-how-it-works"><a class="anchor" href="#cas-how-it-works"></a>How CAS Works</h3>
<div class="paragraph">
<p>Whilst the CAS web site contains documents that detail the architecture of CAS, we present the general overview again here within the context of Spring Security.
Spring Security 3.x supports CAS 3.
At the time of writing, the CAS server was at version 3.4.</p>
</div>
<div class="paragraph">
<p>Somewhere in your enterprise you will need to setup a CAS server.
The CAS server is simply a standard WAR file, so there isn&#8217;t anything difficult about setting up your server.
Inside the WAR file you will customise the login and other single sign on pages displayed to users.</p>
</div>
<div class="paragraph">
<p>When deploying a CAS 3.4 server, you will also need to specify an <code>AuthenticationHandler</code> in the <code>deployerConfigContext.xml</code> included with CAS.
The <code>AuthenticationHandler</code> has a simple method that returns a boolean as to whether a given set of Credentials is valid.
Your <code>AuthenticationHandler</code> implementation will need to link into some type of backend authentication repository, such as an LDAP server or database.
CAS itself includes numerous <code>AuthenticationHandler</code> s out of the box to assist with this.
When you download and deploy the server war file, it is set up to successfully authenticate users who enter a password matching their username, which is useful for testing.</p>
</div>
<div class="paragraph">
<p>Apart from the CAS server itself, the other key players are of course the secure web applications deployed throughout your enterprise.
These web applications are known as "services".
There are three types of services.
Those that authenticate service tickets, those that can obtain proxy tickets, and those that authenticate proxy tickets.
Authenticating a proxy ticket differs because the list of proxies must be validated and often times a proxy ticket can be reused.</p>
</div>
<div class="sect3">
<h4 id="cas-sequence"><a class="anchor" href="#cas-sequence"></a>Spring Security and CAS Interaction Sequence</h4>
<div class="paragraph">
<p>The basic interaction between a web browser, CAS server and a Spring Security-secured service is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The web user is browsing the service&#8217;s public pages.
CAS or Spring Security is not involved.</p>
</li>
<li>
<p>The user eventually requests a page that is either secure or one of the beans it uses is secure.
Spring Security&#8217;s <code>ExceptionTranslationFilter</code> will detect the <code>AccessDeniedException</code> or <code>AuthenticationException</code>.</p>
</li>
<li>
<p>Because the user&#8217;s <code>Authentication</code> object (or lack thereof) caused an <code>AuthenticationException</code>, the <code>ExceptionTranslationFilter</code> will call the configured <code>AuthenticationEntryPoint</code>.
If using CAS, this will be the <code>CasAuthenticationEntryPoint</code> class.</p>
</li>
<li>
<p>The <code>CasAuthenticationEntryPoint</code> will redirect the user&#8217;s browser to the CAS server.
It will also indicate a <code>service</code> parameter, which is the callback URL for the Spring Security service (your application).
For example, the URL to which the browser is redirected might be <a href="https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas" class="bare">https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas</a>.</p>
</li>
<li>
<p>After the user&#8217;s browser redirects to CAS, they will be prompted for their username and password.
If the user presents a session cookie which indicates they&#8217;ve previously logged on, they will not be prompted to login again (there is an exception to this procedure, which we&#8217;ll cover later).
CAS will use the <code>PasswordHandler</code> (or <code>AuthenticationHandler</code> if using CAS 3.0) discussed above to decide whether the username and password is valid.</p>
</li>
<li>
<p>Upon successful login, CAS will redirect the user&#8217;s browser back to the original service.
It will also include a <code>ticket</code> parameter, which is an opaque string representing the "service ticket".
Continuing our earlier example, the URL the browser is redirected to might be <a href="https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ" class="bare">https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ</a>.</p>
</li>
<li>
<p>Back in the service web application, the <code>CasAuthenticationFilter</code> is always listening for requests to <code>/login/cas</code> (this is configurable, but we&#8217;ll use the defaults in this introduction).
The processing filter will construct a <code>UsernamePasswordAuthenticationToken</code> representing the service ticket.
The principal will be equal to <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>, whilst the credentials will be the service ticket opaque value.
This authentication request will then be handed to the configured <code>AuthenticationManager</code>.</p>
</li>
<li>
<p>The <code>AuthenticationManager</code> implementation will be the <code>ProviderManager</code>, which is in turn configured with the <code>CasAuthenticationProvider</code>.
The <code>CasAuthenticationProvider</code> only responds to <code>UsernamePasswordAuthenticationToken</code> s containing the CAS-specific principal (such as <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>) and <code>CasAuthenticationToken</code> s (discussed later).</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will validate the service ticket using a <code>TicketValidator</code> implementation.
This will typically be a <code>Cas20ServiceTicketValidator</code> which is one of the classes included in the CAS client library.
In the event the application needs to validate proxy tickets, the <code>Cas20ProxyTicketValidator</code> is used.
The <code>TicketValidator</code> makes an HTTPS request to the CAS server in order to validate the service ticket.
It may also include a proxy callback URL, which is included in this example: <a href="https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor" class="bare">https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor</a>.</p>
</li>
<li>
<p>Back on the CAS server, the validation request will be received.
If the presented service ticket matches the service URL the ticket was issued to, CAS will provide an affirmative response in XML indicating the username.
If any proxy was involved in the authentication (discussed below), the list of proxies is also included in the XML response.</p>
</li>
<li>
<p>[OPTIONAL] If the request to the CAS validation service included the proxy callback URL (in the <code>pgtUrl</code> parameter), CAS will include a <code>pgtIou</code> string in the XML response.
This <code>pgtIou</code> represents a proxy-granting ticket IOU.
The CAS server will then create its own HTTPS connection back to the <code>pgtUrl</code>.
This is to mutually authenticate the CAS server and the claimed service URL.
The HTTPS connection will be used to send a proxy granting ticket to the original web application.
For example, <a href="https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH" class="bare">https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&amp;pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH</a>.</p>
</li>
<li>
<p>The <code>Cas20TicketValidator</code> will parse the XML received from the CAS server.
It will return to the <code>CasAuthenticationProvider</code> a <code>TicketResponse</code>, which includes the username (mandatory), proxy list (if any were involved), and proxy-granting ticket IOU (if the proxy callback was requested).</p>
</li>
<li>
<p>Next <code>CasAuthenticationProvider</code> will call a configured <code>CasProxyDecider</code>.
The <code>CasProxyDecider</code> indicates whether the proxy list in the <code>TicketResponse</code> is acceptable to the service.
Several implementations are provided with Spring Security: <code>RejectProxyTickets</code>, <code>AcceptAnyCasProxy</code> and <code>NamedCasProxyDecider</code>.
These names are largely self-explanatory, except <code>NamedCasProxyDecider</code> which allows a <code>List</code> of trusted proxies to be provided.</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> will next request a <code>AuthenticationUserDetailsService</code> to load the <code>GrantedAuthority</code> objects that apply to the user contained in the <code>Assertion</code>.</p>
</li>
<li>
<p>If there were no problems, <code>CasAuthenticationProvider</code> constructs a <code>CasAuthenticationToken</code> including the details contained in the <code>TicketResponse</code> and the <code>GrantedAuthority</code>s.</p>
</li>
<li>
<p>Control then returns to <code>CasAuthenticationFilter</code>, which places the created <code>CasAuthenticationToken</code> in the security context.</p>
</li>
<li>
<p>The user&#8217;s browser is redirected to the original page that caused the <code>AuthenticationException</code> (or a custom destination depending on the configuration).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s good that you&#8217;re still here!
Let&#8217;s now look at how this is configured</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cas-client"><a class="anchor" href="#cas-client"></a>Configuration of CAS Client</h3>
<div class="paragraph">
<p>The web application side of CAS is made easy due to Spring Security.
It is assumed you already know the basics of using Spring Security, so these are not covered again below.
We&#8217;ll assume a namespace based configuration is being used and add in the CAS beans as required.
Each section builds upon the previous section.
A full CAS sample application can be found in the Spring Security <a href="#samples">Samples</a>.</p>
</div>
<div class="sect3">
<h4 id="cas-st"><a class="anchor" href="#cas-st"></a>Service Ticket Authentication</h4>
<div class="paragraph">
<p>This section describes how to setup Spring Security to authenticate Service Tickets.
Often times this is all a web application requires.
You will need to add a <code>ServiceProperties</code> bean to your application context.
This represents your CAS service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
&lt;property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/&gt;
&lt;property name="sendRenew" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>service</code> must equal a URL that will be monitored by the <code>CasAuthenticationFilter</code>.
The <code>sendRenew</code> defaults to false, but should be set to true if your application is particularly sensitive.
What this parameter does is tell the CAS login service that a single sign on login is unacceptable.
Instead, the user will need to re-enter their username and password in order to gain access to the service.</p>
</div>
<div class="paragraph">
<p>The following beans should be configured to commence the CAS authentication process (assuming you&#8217;re using a namespace configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:custom-filter position="CAS_FILTER" ref="casFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
&lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For CAS to operate, the <code>ExceptionTranslationFilter</code> must have its <code>authenticationEntryPoint</code> property set to the <code>CasAuthenticationEntryPoint</code> bean.
This can easily be done using <a href="#nsa-http-entry-point-ref">entry-point-ref</a> as is done in the example above.
The <code>CasAuthenticationEntryPoint</code> must refer to the <code>ServiceProperties</code> bean (discussed above), which provides the URL to the enterprise&#8217;s CAS login server.
This is where the user&#8217;s browser will be redirected.</p>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationFilter</code> has very similar properties to the <code>UsernamePasswordAuthenticationFilter</code> (used for form-based logins).
You can use these properties to customize things like behavior for authentication success and failure.</p>
</div>
<div class="paragraph">
<p>Next you need to add a <code>CasAuthenticationProvider</code> and its collaborators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
&lt;property name="authenticationUserDetailsService"&gt;
	&lt;bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
	&lt;constructor-arg ref="userService" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="serviceProperties" ref="serviceProperties" /&gt;
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
	&lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
&lt;/bean&gt;

&lt;security:user-service id="userService"&gt;
&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used.
This is not safe for production, but makes reading
in samples easier.
Normally passwords should be hashed using BCrypt --&gt;
&lt;security:user name="joe" password="{noop}joe" authorities="ROLE_USER" /&gt;
...
&lt;/security:user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> uses a <code>UserDetailsService</code> instance to load the authorities for a user, once they have been authenticated by CAS.
We&#8217;ve shown a simple in-memory setup here.
Note that the <code>CasAuthenticationProvider</code> does not actually use the password for authentication, but it does use the authorities.</p>
</div>
<div class="paragraph">
<p>The beans are all reasonably self-explanatory if you refer back to the <a href="#cas-how-it-works">How CAS Works</a> section.</p>
</div>
<div class="paragraph">
<p>This completes the most basic configuration for CAS.
If you haven&#8217;t made any mistakes, your web application should happily work within the framework of CAS single sign on.
No other parts of Spring Security need to be concerned about the fact CAS handled authentication.
In the following sections we will discuss some (optional) more advanced configurations.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-singlelogout"><a class="anchor" href="#cas-singlelogout"></a>Single Logout</h4>
<div class="paragraph">
<p>The CAS protocol supports Single Logout and can be easily added to your Spring Security configuration.
Below are updates to the Spring Security configuration that handle Single Logout</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:logout logout-success-url="/cas-logout.jsp"/&gt;
&lt;security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt;
&lt;security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt;
&lt;/security:http&gt;

&lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt;
&lt;bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt;

&lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt;
&lt;bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt;
&lt;constructor-arg value="https://localhost:9443/cas/logout"/&gt;
&lt;constructor-arg&gt;
	&lt;bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt;
&lt;/constructor-arg&gt;
&lt;property name="filterProcessesUrl" value="/logout/cas"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>logout</code> element logs the user out of the local application, but does not end the session with the CAS server or any other applications that have been logged into.
The <code>requestSingleLogoutFilter</code> filter will allow the URL of <code>/spring_security_cas_logout</code> to be requested to redirect the application to the configured CAS Server logout URL.
Then the CAS Server will send a Single Logout request to all the services that were signed into.
The <code>singleLogoutFilter</code> handles the Single Logout request by looking up the <code>HttpSession</code> in a static <code>Map</code> and then invalidating it.</p>
</div>
<div class="paragraph">
<p>It might be confusing why both the <code>logout</code> element and the <code>singleLogoutFilter</code> are needed.
It is considered best practice to logout locally first since the <code>SingleSignOutFilter</code> just stores the <code>HttpSession</code> in a static <code>Map</code> in order to call invalidate on it.
With the configuration above, the flow of logout would be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The user requests <code>/logout</code> which would log the user out of the local application and send the user to the logout success page.</p>
</li>
<li>
<p>The logout success page, <code>/cas-logout.jsp</code>, should instruct the user to click a link pointing to <code>/logout/cas</code> in order to logout out of all applications.</p>
</li>
<li>
<p>When the user clicks the link, the user is redirected to the CAS single logout URL (<a href="https://localhost:9443/cas/logout" class="bare">https://localhost:9443/cas/logout</a>).</p>
</li>
<li>
<p>On the CAS Server side, the CAS single logout URL then submits single logout requests to all the CAS Services.
On the CAS Service side, JASIG&#8217;s <code>SingleSignOutFilter</code> processes the logout request by invalidating the original session.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next step is to add the following to your web.xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;filter-class&gt;
	org.springframework.web.filter.CharacterEncodingFilter
&lt;/filter-class&gt;
&lt;init-param&gt;
	&lt;param-name&gt;encoding&lt;/param-name&gt;
	&lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
&lt;listener-class&gt;
	org.jasig.cas.client.session.SingleSignOutHttpSessionListener
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the SingleSignOutFilter you might encounter some encoding issues.
Therefore it is recommended to add the <code>CharacterEncodingFilter</code> to ensure that the character encoding is correct when using the <code>SingleSignOutFilter</code>.
Again, refer to JASIG&#8217;s documentation for details.
The <code>SingleSignOutHttpSessionListener</code> ensures that when an <code>HttpSession</code> expires, the mapping used for single logout is removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt-client"><a class="anchor" href="#cas-pt-client"></a>Authenticating to a Stateless Service with CAS</h4>
<div class="paragraph">
<p>This section describes how to authenticate to a service using CAS.
In other words, this section discusses how to setup a client that uses a service that authenticates with CAS.
The next section describes how to setup a stateless service to Authenticate using CAS.</p>
</div>
<div class="sect4">
<h5 id="cas-pt-client-config"><a class="anchor" href="#cas-pt-client-config"></a>Configuring CAS to Obtain Proxy Granting Tickets</h5>
<div class="paragraph">
<p>In order to authenticate to a stateless service, the application needs to obtain a proxy granting ticket (PGT).
This section describes how to configure Spring Security to obtain a PGT building upon thencas-st[Service Ticket Authentication] configuration.</p>
</div>
<div class="paragraph">
<p>The first step is to include a <code>ProxyGrantingTicketStorage</code> in your Spring Security configuration.
This is used to store PGT&#8217;s that are obtained by the <code>CasAuthenticationFilter</code> so that they can be used to obtain proxy tickets.
An example configuration is shown below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!--
NOTE: In a real application you should not use an in memory implementation.
You will also want to ensure to clean up expired tickets by calling
ProxyGrantingTicketStorage.cleanup()
--&gt;
&lt;bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to update the <code>CasAuthenticationProvider</code> to be able to obtain proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
The <code>proxyCallbackUrl</code> should be set to a URL that the application will receive PGT&#8217;s at.
Last, the configuration should also reference the <code>ProxyGrantingTicketStorage</code> so it can use a PGT to obtain proxy tickets.
You can find an example of the configuration changes that should be made below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
		&lt;property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/&gt;
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last step is to update the <code>CasAuthenticationFilter</code> to accept PGT and to store them in the <code>ProxyGrantingTicketStorage</code>.
It is important the <code>proxyReceptorUrl</code> matches the <code>proxyCallbackUrl</code> of the <code>Cas20ProxyTicketValidator</code>.
An example configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
	...
	&lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
	&lt;property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt-client-sample"><a class="anchor" href="#cas-pt-client-sample"></a>Calling a Stateless Service Using a Proxy Ticket</h5>
<div class="paragraph">
<p>Now that Spring Security obtains PGTs, you can use them to create proxy tickets which can be used to authenticate to a stateless service.
The CAS <a href="#samples">sample application</a> contains a working example in the <code>ProxyTicketSampleServlet</code>.
Example code can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">protected fun doGet(request: HttpServletRequest, response: HttpServletResponse?) {
    // NOTE: The CasAuthenticationToken can also be obtained using
    // SecurityContextHolder.getContext().getAuthentication()
    val token = request.userPrincipal as CasAuthenticationToken
    // proxyTicket could be reused to make calls to the CAS service even if the
    // target url differs
    val proxyTicket = token.assertion.principal.getProxyTicketFor(targetUrl)

    // Make a remote call using the proxy ticket
    val serviceUrl: String = targetUrl + "?ticket=" + URLEncoder.encode(proxyTicket, "UTF-8")
    val proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-pt"><a class="anchor" href="#cas-pt"></a>Proxy Ticket Authentication</h4>
<div class="paragraph">
<p>The <code>CasAuthenticationProvider</code> distinguishes between stateful and stateless clients.
A stateful client is considered any that submits to the <code>filterProcessUrl</code> of the <code>CasAuthenticationFilter</code>.
A stateless client is any that presents an authentication request to <code>CasAuthenticationFilter</code> on a URL other than the <code>filterProcessUrl</code>.</p>
</div>
<div class="paragraph">
<p>Because remoting protocols have no way of presenting themselves within the context of an <code>HttpSession</code>, it isn&#8217;t possible to rely on the default practice of storing the security context in the session between requests.
Furthermore, because the CAS server invalidates a ticket after it has been validated by the <code>TicketValidator</code>, presenting the same proxy ticket on subsequent requests will not work.</p>
</div>
<div class="paragraph">
<p>One obvious option is to not use CAS at all for remoting protocol clients.
However, this would eliminate many of the desirable features of CAS.
As a middle-ground, the <code>CasAuthenticationProvider</code> uses a <code>StatelessTicketCache</code>.
This is used solely for stateless clients which use a principal equal to <code>CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER</code>.
What happens is the <code>CasAuthenticationProvider</code> will store the resulting <code>CasAuthenticationToken</code> in the <code>StatelessTicketCache</code>, keyed on the proxy ticket.
Accordingly, remoting protocol clients can present the same proxy ticket and the <code>CasAuthenticationProvider</code> will not need to contact the CAS server for validation (aside from the first request).
Once authenticated, the proxy ticket could be used for URLs other than the original target service.</p>
</div>
<div class="paragraph">
<p>This section builds upon the previous sections to accommodate proxy ticket authentication.
The first step is to specify to authenticate all artifacts as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties"&gt;
...
&lt;property name="authenticateAllArtifacts" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to specify <code>serviceProperties</code> and the <code>authenticationDetailsSource</code> for the <code>CasAuthenticationFilter</code>.
The <code>serviceProperties</code> property instructs the <code>CasAuthenticationFilter</code> to attempt to authenticate all artifacts instead of only ones present on the <code>filterProcessUrl</code>.
The <code>ServiceAuthenticationDetailsSource</code> creates a <code>ServiceAuthenticationDetails</code> that ensures the current URL, based upon the <code>HttpServletRequest</code>, is used as the service URL when validating the ticket.
The method for generating the service URL can be customized by injecting a custom <code>AuthenticationDetailsSource</code> that returns a custom <code>ServiceAuthenticationDetails</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
...
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;property name="authenticationDetailsSource"&gt;
	&lt;bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"&gt;
	&lt;constructor-arg ref="serviceProperties"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also need to update the <code>CasAuthenticationProvider</code> to handle proxy tickets.
To do this replace the <code>Cas20ServiceTicketValidator</code> with a <code>Cas20ProxyTicketValidator</code>.
You will need to configure the <code>statelessTicketCache</code> and which proxies you want to accept.
You can find an example of the updates required to accept all proxies below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
	&lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
	&lt;constructor-arg value="https://localhost:9443/cas"/&gt;
	&lt;property name="acceptAnyProxy" value="true"/&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="statelessTicketCache"&gt;
	&lt;bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache"&gt;
	&lt;property name="cache"&gt;
		&lt;bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose"&gt;
		&lt;constructor-arg value="casTickets"/&gt;
		&lt;constructor-arg value="50"/&gt;
		&lt;constructor-arg value="true"/&gt;
		&lt;constructor-arg value="false"/&gt;
		&lt;constructor-arg value="3600"/&gt;
		&lt;constructor-arg value="900"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-x509"><a class="anchor" href="#servlet-x509"></a>X.509 Authentication</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="x509-overview"><a class="anchor" href="#x509-overview"></a>Overview</h3>
<div class="paragraph">
<p>The most common use of X.509 certificate authentication is in verifying the identity of a server when using SSL, most commonly when using HTTPS from a browser.
The browser will automatically check that the certificate presented by a server has been issued (ie digitally signed) by one of a list of trusted certificate authorities which it maintains.</p>
</div>
<div class="paragraph">
<p>You can also use SSL with "mutual authentication"; the server will then request a valid certificate from the client as part of the SSL handshake.
The server will authenticate the client by checking that its certificate is signed by an acceptable authority.
If a valid certificate has been provided, it can be obtained through the servlet API in an application.
Spring Security X.509 module extracts the certificate using a filter.
It maps the certificate to an application user and loads that user&#8217;s set of granted authorities for use with the standard Spring Security infrastructure.</p>
</div>
<div class="paragraph">
<p>You should be familiar with using certificates and setting up client authentication for your servlet container before attempting to use it with Spring Security.
Most of the work is in creating and installing suitable certificates and keys.
For example, if you&#8217;re using Tomcat then read the instructions here <a href="https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html</a>.
It&#8217;s important that you get this working before trying it out with Spring Security</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_x_509_authentication_to_your_web_application"><a class="anchor" href="#_adding_x_509_authentication_to_your_web_application"></a>Adding X.509 Authentication to Your Web Application</h3>
<div class="paragraph">
<p>Enabling X.509 client authentication is very straightforward.
Just add the <code>&lt;x509/&gt;</code> element to your http security namespace configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http&gt;
...
	&lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The element has two optional attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject-principal-regex</code>.
The regular expression used to extract a username from the certificate&#8217;s subject name.
The default value is shown above.
This is the username which will be passed to the <code>UserDetailsService</code> to load the authorities for the user.</p>
</li>
<li>
<p><code>user-service-ref</code>.
This is the bean Id of the <code>UserDetailsService</code> to be used with X.509.
It isn&#8217;t needed if there is only one defined in your application context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>subject-principal-regex</code> should contain a single group.
For example the default expression "CN=(.*?)," matches the common name field.
So if the subject name in the certificate is "CN=Jimi Hendrix, OU=&#8230;&#8203;", this will give a user name of "Jimi Hendrix".
The matches are case insensitive.
So "emailAddress=(.*?)," will match "EMAILADDRESS=<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>,CN=&#8230;&#8203;" giving a user name "<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>".
If the client presents a certificate and a valid username is successfully extracted, then there should be a valid <code>Authentication</code> object in the security context.
If no certificate is found, or no corresponding user could be found then the security context will remain empty.
This means that you can easily use X.509 authentication with other options such as a form-based login.</p>
</div>
</div>
<div class="sect2">
<h3 id="x509-ssl-config"><a class="anchor" href="#x509-ssl-config"></a>Setting up SSL in Tomcat</h3>
<div class="paragraph">
<p>There are some pre-generated certificates in the <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509/server">Spring Security Samples repository</a>.
You can use these to enable SSL for testing if you don&#8217;t want to generate your own.
The file <code>server.jks</code> contains the server certificate, private key and the issuing certificate authority certificate.
There are also some client certificate files for the users from the sample applications.
You can install these in your browser to enable SSL client authentication.</p>
</div>
<div class="paragraph">
<p>To run tomcat with SSL support, drop the <code>server.jks</code> file into the tomcat <code>conf</code> directory and add the following connector to the <code>server.xml</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
			clientAuth="true" sslProtocol="TLS"
			keystoreFile="${catalina.home}/conf/server.jks"
			keystoreType="JKS" keystorePass="password"
			truststoreFile="${catalina.home}/conf/server.jks"
			truststoreType="JKS" truststorePass="password"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientAuth</code> can also be set to <code>want</code> if you still want SSL connections to succeed even if the client doesn&#8217;t provide a certificate.
Clients which don&#8217;t present a certificate won&#8217;t be able to access any objects secured by Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="runas"><a class="anchor" href="#runas"></a>Run-As Authentication Replacement</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="runas-overview"><a class="anchor" href="#runas-overview"></a>Overview</h3>
<div class="paragraph">
<p>The <code>AbstractSecurityInterceptor</code> is able to temporarily replace the <code>Authentication</code> object in the <code>SecurityContext</code> and <code>SecurityContextHolder</code> during the secure object callback phase.
This only occurs if the original <code>Authentication</code> object was successfully processed by the <code>AuthenticationManager</code> and <code>AccessDecisionManager</code>.
The <code>RunAsManager</code> will indicate the replacement <code>Authentication</code> object, if any, that should be used during the <code>SecurityInterceptorCallback</code>.</p>
</div>
<div class="paragraph">
<p>By temporarily replacing the <code>Authentication</code> object during the secure object callback phase, the secured invocation will be able to call other objects which require different authentication and authorization credentials.
It will also be able to perform any internal security checks for specific <code>GrantedAuthority</code> objects.
Because Spring Security provides a number of helper classes that automatically configure remoting protocols based on the contents of the <code>SecurityContextHolder</code>, these run-as replacements are particularly useful when calling remote web services</p>
</div>
</div>
<div class="sect2">
<h3 id="runas-config"><a class="anchor" href="#runas-config"></a>Configuration</h3>
<div class="paragraph">
<p>A <code>RunAsManager</code> interface is provided by Spring Security:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication buildRunAs(Authentication authentication, Object object,
	List&lt;ConfigAttribute&gt; config);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first method returns the <code>Authentication</code> object that should replace the existing <code>Authentication</code> object for the duration of the method invocation.
If the method returns <code>null</code>, it indicates no replacement should be made.
The second method is used by the <code>AbstractSecurityInterceptor</code> as part of its startup validation of configuration attributes.
The <code>supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code>RunAsManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
<div class="paragraph">
<p>One concrete implementation of a <code>RunAsManager</code> is provided with Spring Security.
The <code>RunAsManagerImpl</code> class returns a replacement <code>RunAsUserToken</code> if any <code>ConfigAttribute</code> starts with <code>RUN_AS_</code>.
If any such <code>ConfigAttribute</code> is found, the replacement <code>RunAsUserToken</code> will contain the same principal, credentials and granted authorities as the original <code>Authentication</code> object, along with a new <code>SimpleGrantedAuthority</code> for each <code>RUN_AS_</code> <code>ConfigAttribute</code>.
Each new <code>SimpleGrantedAuthority</code> will be prefixed with <code>ROLE_</code>, followed by the <code>RUN_AS</code> <code>ConfigAttribute</code>.
For example, a <code>RUN_AS_SERVER</code> will result in the replacement <code>RunAsUserToken</code> containing a <code>ROLE_RUN_AS_SERVER</code> granted authority.</p>
</div>
<div class="paragraph">
<p>The replacement <code>RunAsUserToken</code> is just like any other <code>Authentication</code> object.
It needs to be authenticated by the <code>AuthenticationManager</code>, probably via delegation to a suitable <code>AuthenticationProvider</code>.
The <code>RunAsImplAuthenticationProvider</code> performs such authentication.
It simply accepts as valid any <code>RunAsUserToken</code> presented.</p>
</div>
<div class="paragraph">
<p>To ensure malicious code does not create a <code>RunAsUserToken</code> and present it for guaranteed acceptance by the <code>RunAsImplAuthenticationProvider</code>, the hash of a key is stored in all generated tokens.
The <code>RunAsManagerImpl</code> and <code>RunAsImplAuthenticationProvider</code> is created in the bean context with the same key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="runAsManager"
	class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
	class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the same key, each <code>RunAsUserToken</code> can be validated it was created by an approved <code>RunAsManagerImpl</code>.
The <code>RunAsUserToken</code> is immutable after creation for security reasons</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-logout"><a class="anchor" href="#jc-logout"></a>Handling Logouts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="logout-java-configuration"><a class="anchor" href="#logout-java-configuration"></a>Logout Java/Kotlin Configuration</h3>
<div class="paragraph">
<p>When using the <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html">WebSecurityConfigurerAdapter</a></code>, logout capabilities are automatically applied.
The default is that accessing the URL <code>/logout</code> will log the user out by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invalidating the HTTP Session</p>
</li>
<li>
<p>Cleaning up any RememberMe authentication that was configured</p>
</li>
<li>
<p>Clearing the <code>SecurityContextHolder</code></p>
</li>
<li>
<p>Redirect to <code>/login?logout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similar to configuring login capabilities, however, you also have various options to further customize your logout requirements:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Logout Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        .logout(logout -&gt; logout                                                <i class="conum" data-value="1"></i><b>(1)</b>
            .logoutUrl("/my/logout")                                            <i class="conum" data-value="2"></i><b>(2)</b>
            .logoutSuccessUrl("/my/index")                                      <i class="conum" data-value="3"></i><b>(3)</b>
            .logoutSuccessHandler(logoutSuccessHandler)                         <i class="conum" data-value="4"></i><b>(4)</b>
            .invalidateHttpSession(true)                                        <i class="conum" data-value="5"></i><b>(5)</b>
            .addLogoutHandler(logoutHandler)                                    <i class="conum" data-value="6"></i><b>(6)</b>
            .deleteCookies(cookieNamesToClear)                                  <i class="conum" data-value="7"></i><b>(7)</b>
        )
        ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        logout {
            logoutUrl = "/my/logout"                              <i class="conum" data-value="1"></i><b>(1)</b>
            logoutSuccessUrl = "/my/index"                        <i class="conum" data-value="2"></i><b>(2)</b>
            logoutSuccessHandler = customLogoutSuccessHandler     <i class="conum" data-value="3"></i><b>(3)</b>
            invalidateHttpSession = true                          <i class="conum" data-value="4"></i><b>(4)</b>
            addLogoutHandler(logoutHandler)                       <i class="conum" data-value="5"></i><b>(5)</b>
            deleteCookies(cookieNamesToClear)                     <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Provides logout support.
This is automatically applied when using <code>WebSecurityConfigurerAdapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The URL that triggers log out to occur (default is <code>/logout</code>).
If CSRF protection is enabled (default), then the request must also be a POST.
For more information, please consult the <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The URL to redirect to after logout has occurred.
The default is <code>/login?logout</code>.
For more information, please consult the <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Let&#8217;s you specify a custom <code>LogoutSuccessHandler</code>.
If this is specified, <code>logoutSuccessUrl()</code> is ignored.
For more information, please consult the <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specify whether to invalidate the <code>HttpSession</code> at the time of logout.
This is <strong>true</strong> by default.
Configures the <code>SecurityContextLogoutHandler</code> under the covers.
For more information, please consult the <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Adds a <code>LogoutHandler</code>.
<code>SecurityContextLogoutHandler</code> is added as the last <code>LogoutHandler</code> by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Allows specifying the names of cookies to be removed on logout success.
This is a shortcut for adding a <code>CookieClearingLogoutHandler</code> explicitly.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Logouts can of course also be configured using the XML Namespace notation.
Please see the documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section for further details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Generally, in order to customize logout functionality, you can add
<code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code>
and/or
<code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html">LogoutSuccessHandler</a></code>
implementations.
For many common scenarios, these handlers are applied under the
covers when using the fluent API.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-logout"><a class="anchor" href="#ns-logout"></a>Logout XML Configuration</h3>
<div class="paragraph">
<p>The <code>logout</code> element adds support for logging out by navigating to a particular URL.
The default logout URL is <code>/logout</code>, but you can set it to something else using the <code>logout-url</code> attribute.
More information on other available attributes may be found in the namespace appendix.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-handler"><a class="anchor" href="#jc-logout-handler"></a>LogoutHandler</h3>
<div class="paragraph">
<p>Generally, <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code>
implementations indicate classes that are able to participate in logout handling.
They are expected to be invoked to perform necessary clean-up.
As such they should
not throw exceptions.
Various implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html">PersistentTokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html">TokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html">CookieClearingLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html">CsrfLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html">SecurityContextLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/HeaderWriterLogoutHandler.html">HeaderWriterLogoutHandler</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please see <a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a> for details.</p>
</div>
<div class="paragraph">
<p>Instead of providing <code>LogoutHandler</code> implementations directly, the fluent API also provides shortcuts that provide the respective <code>LogoutHandler</code> implementations under the covers.
E.g. <code>deleteCookies()</code> allows specifying the names of one or more cookies to be removed on logout success.
This is a shortcut compared to adding a <code>CookieClearingLogoutHandler</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-success-handler"><a class="anchor" href="#jc-logout-success-handler"></a>LogoutSuccessHandler</h3>
<div class="paragraph">
<p>The <code>LogoutSuccessHandler</code> is called after a successful logout by the <code>LogoutFilter</code>, to handle e.g.
redirection or forwarding to the appropriate destination.
Note that the interface is almost the same as the <code>LogoutHandler</code> but may raise an exception.</p>
</div>
<div class="paragraph">
<p>The following implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html">SimpleUrlLogoutSuccessHandler</a></p>
</li>
<li>
<p>HttpStatusReturningLogoutSuccessHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned above, you don&#8217;t need to specify the <code>SimpleUrlLogoutSuccessHandler</code> directly.
Instead, the fluent API provides a shortcut by setting the <code>logoutSuccessUrl()</code>.
This will setup the <code>SimpleUrlLogoutSuccessHandler</code> under the covers.
The provided URL will be redirected to after a logout has occurred.
The default is <code>/login?logout</code>.</p>
</div>
<div class="paragraph">
<p>The <code>HttpStatusReturningLogoutSuccessHandler</code> can be interesting in REST API type scenarios.
Instead of redirecting to a URL upon the successful logout, this <code>LogoutSuccessHandler</code> allows you to provide a plain HTTP status code to be returned.
If not configured a status code 200 will be returned by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout-references"><a class="anchor" href="#jc-logout-references"></a>Further Logout-Related References</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#ns-logout">Logout Handling</a></p>
</li>
<li>
<p><a href="#test-logout">Testing Logout</a></p>
</li>
<li>
<p><a href="#servletapi-logout">HttpServletRequest.logout()</a></p>
</li>
<li>
<p><a href="#remember-me-impls">Remember-Me Interfaces and Implementations</a></p>
</li>
<li>
<p><a href="#servlet-considerations-csrf-logout">Logging Out</a> in section CSRF Caveats</p>
</li>
<li>
<p>Section <a href="#cas-singlelogout">Single Logout</a> (CAS protocol)</p>
</li>
<li>
<p>Documentation for the <a href="#nsa-logout">logout element</a> in the Spring Security XML Namespace section</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-events"><a class="anchor" href="#servlet-events"></a>Authentication Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For each authentication that succeeds or fails, a <code>AuthenticationSuccessEvent</code> or <code>AbstractAuthenticationFailureEvent</code> is fired, respectively.</p>
</div>
<div class="paragraph">
<p>To listen for these events, you must first publish an <code>AuthenticationEventPublisher</code>.
Spring Security&#8217;s <code>DefaultAuthenticationEventPublisher</code> will probably do fine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    return new DefaultAuthenticationEventPublisher(applicationEventPublisher);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    return DefaultAuthenticationEventPublisher(applicationEventPublisher)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, you can use Spring&#8217;s <code>@EventListener</code> support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class AuthenticationEvents {
	@EventListener
    public void onSuccess(AuthenticationSuccessEvent success) {
		// ...
    }

    @EventListener
    public void onFailure(AbstractAuthenticationFailureEvent failures) {
		// ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class AuthenticationEvents {
    @EventListener
    fun onSuccess(success: AuthenticationSuccessEvent?) {
        // ...
    }

    @EventListener
    fun onFailure(failures: AbstractAuthenticationFailureEvent?) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While similar to <code>AuthenticationSuccessHandler</code> and <code>AuthenticationFailureHandler</code>, these are nice in that they can be used independently from the servlet API.</p>
</div>
<div class="sect2">
<h3 id="_adding_exception_mappings"><a class="anchor" href="#_adding_exception_mappings"></a>Adding Exception Mappings</h3>
<div class="paragraph">
<p><code>DefaultAuthenticationEventPublisher</code> by default will publish an <code>AbstractAuthenticationFailureEvent</code> for the following events:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadCredentialsException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernameNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AccountExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ProviderNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureProviderNotFoundEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisabledException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureDisabledEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LockedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureLockedEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationServiceException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureServiceExceptionEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CredentialsExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureCredentialsExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidBearerTokenException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The publisher does an exact <code>Exception</code> match, which means that sub-classes of these exceptions won&#8217;t also produce events.</p>
</div>
<div class="paragraph">
<p>To that end, you may want to supply additional mappings to the publisher via the <code>setAdditionalExceptionMappings</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    Map&lt;Class&lt;? extends AuthenticationException&gt;,
        Class&lt;? extends AbstractAuthenticationFailureEvent&gt;&gt; mapping =
            Collections.singletonMap(FooException.class, FooEvent.class);
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val mapping: Map&lt;Class&lt;out AuthenticationException&gt;, Class&lt;out AbstractAuthenticationFailureEvent&gt;&gt; =
            mapOf(Pair(FooException::class.java, FooEvent::class.java))
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_default_event"><a class="anchor" href="#_default_event"></a>Default Event</h3>
<div class="paragraph">
<p>And, you can supply a catch-all event to fire in the case of any <code>AuthenticationException</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent
        (GenericAuthenticationFailureEvent.class);
    return authenticationEventPublisher;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent(GenericAuthenticationFailureEvent::class.java)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Authentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by <code>SessionManagementFilter</code>, as the filter will not be invoked during the authenticating request. Session-management functionality has to be handled separately in these cases.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Essentially, the username is not included in the cookie, to prevent exposing a valid login name unecessarily. There is a discussion on this in the comments section of this article.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. The use of the <code>key</code> property should not be regarded as providing any real security here. It is merely a book-keeping exercise. If you are sharing a <code>ProviderManager</code> which contains an <code>AnonymousAuthenticationProvider</code> in a scenario where it is possible for an authenticating client to construct the <code>Authentication</code> object (such as with RMI invocations), then a malicious client could submit an <code>AnonymousAuthenticationToken</code> which it had created itself (with chosen username and authority list). If the <code>key</code> is guessable or can be found out, then the token would be accepted by the anonymous provider. This isn&#8217;t a problem with normal usage but if you are using RMI you would be best to use a customized <code>ProviderManager</code> which omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms.
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/tabs.js"></script>
<script src="../../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
