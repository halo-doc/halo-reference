<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Reactive Applications :: Spring</title>
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="security" data-version="5.6">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../overview/index.html">Spring Security</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Overview</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/prerequisites.html">Prerequisites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/community.html">Community</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/whats-new.html">What&#8217;s New</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/getting-spring-security.html">Getting Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../overview/features/index.html">Features</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../overview/features/authentication/index.html">Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../overview/features/exploits/index.html">Protection Against Exploits</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/modules.html">Project Modules &amp; Dependencies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../overview/samples.html">Samples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Servlet Applications</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/hello/index.html">Hello Spring Security</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/architecture/index.html">The Big Picture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Authentication</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/architecture/index.html">Authentication Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../servlet/authentication/unpwd/index.html">Username/Password</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reading Username/Password</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/form.html">Form</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/basic.html">Basic</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/digest.html">Digest</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="4">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Password Storage</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/in-memory.html">In Memory</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/user-details.html">UserDetails</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/user-details-service.html">UserDetailsService</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/password-encoder.html">PasswordEncoder</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/dao-authentication-provider.html">DaoAuthenticationProvider</a>
  </li>
  <li class="nav-item" data-depth="5">
    <a class="nav-link" href="../servlet/authentication/unpwd/ldap.html">LDAP</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/session-management.html">Session Management</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/rememberme.html">Remember Me</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/openid.html">OpenID</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/anonymous.html">Anonymous</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/preauth.html">Pre-Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/jaas.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/cas.html">CAS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/x509.html">X509</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/runas.html">Run-As</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/logout.html">Logout</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authentication/events.html">Authentication Events</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Authorization</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/architecture.html">Authorization Architecture</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/authorize-requests.html">Authorize HTTP Requests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/expression-based.html">Expression-Based Access Control</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/secure-objects.html">Secure Object Implementations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/method-security.html">Method Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/authorization/acls.html">Domain Object Security ACLs</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">OAuth2</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-login.html">OAuth2 Log In</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-client.html">OAuth2 Client</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/oauth2/oauth2-resourceserver.html">OAuth2 Resource Server</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/saml2/index.html">SAML2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/exploits/index.html">Protection Against Exploits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/integrations/index.html">Integrations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/java-configuration/index.html">Java Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/kotlin-configuration/index.html">Kotlin Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../servlet/namespace/index.html">Namespace Configuration</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/test/index.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/crypto/index.html">Cryptography</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlet/appendix/index.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore" style="display: none;">
  <div class="context">
    <span class="title">Spring Security</span>
    <span class="version">5.6</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../framework/5.3/index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../framework/5.3/index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../6/overview/prerequisites.html">6</a>
        </li>
        <li class="version is-current">
          <a href="../overview/index.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="" role="navigation">
<button class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Reactive Applications</h1>
<div class="sect1">
<h2 id="jc-webflux"><a class="anchor" href="#jc-webflux"></a>WebFlux Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security&#8217;s WebFlux support relies on a <code>WebFilter</code> and works the same for Spring WebFlux and Spring WebFlux.Fn.
You can find a few sample applications that demonstrate the code below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello WebFlux <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/hello-security">hellowebflux</a></p>
</li>
<li>
<p>Hello WebFlux.Fn <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux-fn/hello-security">hellowebfluxfn</a></p>
</li>
<li>
<p>Hello WebFlux Method <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/method">hellowebflux-method</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_minimal_webflux_security_configuration"><a class="anchor" href="#_minimal_webflux_security_configuration"></a>Minimal WebFlux Security Configuration</h3>
<div class="paragraph">
<p>You can find a minimal WebFlux Security configuration below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Minimal WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configuration provides form and http basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default log in page and a default log out page, sets up security related HTTP headers, CSRF protection, and more.</p>
</div>
</div>
<div class="sect2">
<h3 id="_explicit_webflux_security_configuration"><a class="anchor" href="#_explicit_webflux_security_configuration"></a>Explicit WebFlux Security Configuration</h3>
<div class="paragraph">
<p>You can find an explicit version of the minimal WebFlux Security configuration below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Explicit WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange(exchanges -&gt; exchanges
			    .anyExchange().authenticated()
			)
			.httpBasic(withDefaults())
			.formLogin(withDefaults());
		return http.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }

    @Bean
    fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            formLogin { }
            httpBasic { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configuration explicitly sets up all the same things as our minimal configuration.
From here you can easily make the changes to the defaults.</p>
</div>
<div class="paragraph">
<p>You can find more examples of explicit configuration in unit tests, by searching <a href="https://github.com/spring-projects/spring-security/search?q=path%3Aconfig%2Fsrc%2Ftest%2F+EnableWebFluxSecurity">EnableWebFluxSecurity in the <code>config/src/test/</code> directory</a>.</p>
</div>
<div class="sect3">
<h4 id="jc-webflux-multiple-filter-chains"><a class="anchor" href="#jc-webflux-multiple-filter-chains"></a>Multiple Chains Support</h4>
<div class="paragraph">
<p>You can configure multiple <code>SecurityWebFilterChain</code> instances to separate configuration by <code>RequestMatcher</code> s.</p>
</div>
<div class="paragraph">
<p>For example, you can isolate configuration for URLs that start with <code>/api</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebFluxSecurity
static class MultiSecurityHttpConfig {

    @Order(Ordered.HIGHEST_PRECEDENCE)                                                      <i class="conum" data-value="1"></i><b>(1)</b>
    @Bean
    SecurityWebFilterChain apiHttpSecurity(ServerHttpSecurity http) {
        http
            .securityMatcher(new PathPatternParserServerWebExchangeMatcher("/api/**"))      <i class="conum" data-value="2"></i><b>(2)</b>
            .authorizeExchange((exchanges) -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);                           <i class="conum" data-value="3"></i><b>(3)</b>
        return http.build();
    }

    @Bean
    SecurityWebFilterChain webHttpSecurity(ServerHttpSecurity http) {                       <i class="conum" data-value="4"></i><b>(4)</b>
        http
            .authorizeExchange((exchanges) -&gt; exchanges
                .anyExchange().authenticated()
            )
            .httpBasic(withDefaults());                                                     <i class="conum" data-value="5"></i><b>(5)</b>
        return http.build();
    }

    @Bean
    ReactiveUserDetailsService userDetailsService() {
        return new MapReactiveUserDetailsService(
                PasswordEncodedUser.user(), PasswordEncodedUser.admin());
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebFluxSecurity
open class MultiSecurityHttpConfig {
    @Order(Ordered.HIGHEST_PRECEDENCE)                                                      <i class="conum" data-value="1"></i><b>(1)</b>
    @Bean
    open fun apiHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http {
            securityMatcher(PathPatternParserServerWebExchangeMatcher("/api/**"))           <i class="conum" data-value="2"></i><b>(2)</b>
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            oauth2ResourceServer {
                jwt { }                                                                     <i class="conum" data-value="3"></i><b>(3)</b>
            }
        }
    }

    @Bean
    open fun webHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {            <i class="conum" data-value="4"></i><b>(4)</b>
        return http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            httpBasic { }                                                                   <i class="conum" data-value="5"></i><b>(5)</b>
        }
    }

    @Bean
    open fun userDetailsService(): ReactiveUserDetailsService {
        return MapReactiveUserDetailsService(
            PasswordEncodedUser.user(), PasswordEncodedUser.admin()
        )
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure a <code>SecurityWebFilterChain</code> with an <code>@Order</code> to specify which <code>SecurityWebFilterChain</code> Spring Security should consider first</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>PathPatternParserServerWebExchangeMatcher</code> to state that this <code>SecurityWebFilterChain</code> will only apply to URL paths that start with <code>/api/</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specify the authentication mechanisms that will be used for <code>/api/**</code> endpoints</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Create another instance of <code>SecurityWebFilterChain</code> with lower precedence to match all other URLs</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specify the authentication mechanisms that will be used for the rest of the application</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security will select one <code>SecurityWebFilterChain</code> <code>@Bean</code> for each request.
It will match the requests in order by the <code>securityMatcher</code> definition.</p>
</div>
<div class="paragraph">
<p>In this case, that means that if the URL path starts with <code>/api</code>, then Spring Security will use <code>apiHttpSecurity</code>.
If the URL does not start with <code>/api</code> then Spring Security will default to <code>webHttpSecurity</code>, which has an implied <code>securityMatcher</code> that matches any request.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_protection_against_exploits"><a class="anchor" href="#_protection_against_exploits"></a>Protection Against Exploits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="webflux-csrf"><a class="anchor" href="#webflux-csrf"></a>Cross Site Request Forgery (CSRF) for WebFlux Environments</h3>
<div class="paragraph">
<p>This section discusses Spring Security&#8217;s <a href="#csrf">Cross Site Request Forgery (CSRF)</a> support for WebFlux environments.</p>
</div>
<div class="sect3">
<h4 id="webflux-csrf-using"><a class="anchor" href="#webflux-csrf-using"></a>Using Spring Security CSRF Protection</h4>
<div class="paragraph">
<p>The steps to using Spring Security&#8217;s CSRF protection are outlined below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-csrf-idempotent">Use proper HTTP verbs</a></p>
</li>
<li>
<p><a href="#webflux-csrf-configure">Configure CSRF Protection</a></p>
</li>
<li>
<p><a href="#webflux-csrf-include">Include the CSRF Token</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-csrf-idempotent"><a class="anchor" href="#webflux-csrf-idempotent"></a>Use proper HTTP verbs</h5>
<div class="paragraph">
<p>The first step to protecting against CSRF attacks is to ensure your website uses proper HTTP verbs.
This is covered in detail in <a href="#csrf-protection-idempotent">Safe Methods Must be Idempotent</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-configure"><a class="anchor" href="#webflux-csrf-configure"></a>Configure CSRF Protection</h5>
<div class="paragraph">
<p>The next step is to configure Spring Security&#8217;s CSRF protection within your application.
Spring Security&#8217;s CSRF protection is enabled by default, but you may need to customize the configuration.
Below are a few common customizations.</p>
</div>
<div class="sect5">
<h6 id="webflux-csrf-configure-custom-repository"><a class="anchor" href="#webflux-csrf-configure-custom-repository"></a>Custom CsrfTokenRepository</h6>
<div class="paragraph">
<p>By default Spring Security stores the expected CSRF token in the <code>WebSession</code> using <code>WebSessionServerCsrfTokenRepository</code>.
There can be cases where users will want to configure a custom <code>ServerCsrfTokenRepository</code>.
For example, it might be desirable to persist the <code>CsrfToken</code> in a cookie to <a href="#webflux-csrf-include-ajax-auto">support a JavaScript based application</a>.</p>
</div>
<div class="paragraph">
<p>By default the <code>CookieServerCsrfTokenRepository</code> will write to a cookie named <code>XSRF-TOKEN</code> and read it from a header named <code>X-XSRF-TOKEN</code> or the HTTP parameter <code>_csrf</code>.
These defaults come from <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a></p>
</div>
<div class="paragraph">
<p>You can configure <code>CookieServerCsrfTokenRepository</code> in Java Configuration using:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Store CSRF Token in a Cookie</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The sample explicitly sets <code>cookieHttpOnly=false</code>.
This is necessary to allow JavaScript (i.e. AngularJS) to read it.
If you do not need the ability to read the cookie with JavaScript directly, it is recommended to omit <code>cookieHttpOnly=false</code> (by using <code>new CookieServerCsrfTokenRepository()</code> instead) to improve security.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-configure-disable"><a class="anchor" href="#webflux-csrf-configure-disable"></a>Disable CSRF Protection</h6>
<div class="paragraph">
<p>CSRF protection is enabled by default.
However, it is simple to disable CSRF protection if it <a href="#csrf-when">makes sense for your application</a>.</p>
</div>
<div class="paragraph">
<p>The Java configuration below will disable CSRF protection.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Disable CSRF Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -&gt; csrf.disable()))
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            disable()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-include"><a class="anchor" href="#webflux-csrf-include"></a>Include the CSRF Token</h5>
<div class="paragraph">
<p>In order for the <a href="#csrf-protection-stp">synchronizer token pattern</a> to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request.
This must be included in a part of the request (i.e. form parameter, HTTP header, etc) that is not automatically included in the HTTP request by the browser.</p>
</div>
<div class="paragraph">
<p>Spring Security&#8217;s <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html">CsrfWebFilter</a> exposes a <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html">Mono&lt;CsrfToken&gt;</a> as a <code>ServerWebExchange</code> attribute named <code>org.springframework.security.web.server.csrf.CsrfToken</code>.
This means that any view technology can access the <code>Mono&lt;CsrfToken&gt;</code> to expose the expected token as either a <a href="#webflux-csrf-include-form-attr">form</a> or <a href="#webflux-csrf-include-ajax-meta">meta tag</a>.</p>
</div>
<div id="webflux-csrf-include-subscribe" class="paragraph">
<p>If your view technology does not provide a simple way to subscribe to the <code>Mono&lt;CsrfToken&gt;</code>, a common pattern is to use Spring&#8217;s <code>@ControllerAdvice</code> to expose the <code>CsrfToken</code> directly.
For example, the following code will place the <code>CsrfToken</code> on the default attribute name (<code>_csrf</code>) used by Spring Security&#8217;s <a href="#webflux-csrf-include-form-auto">CsrfRequestDataValueProcessor</a> to automatically include the CSRF token as a hidden input.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. <code>CsrfToken</code> as <code>@ModelAttribute</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ControllerAdvice
public class SecurityControllerAdvice {
	@ModelAttribute
	Mono&lt;CsrfToken&gt; csrfToken(ServerWebExchange exchange) {
		Mono&lt;CsrfToken&gt; csrfToken = exchange.getAttribute(CsrfToken.class.getName());
		return csrfToken.doOnSuccess(token -&gt; exchange.getAttributes()
				.put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ControllerAdvice
class SecurityControllerAdvice {
    @ModelAttribute
    fun csrfToken(exchange: ServerWebExchange): Mono&lt;CsrfToken&gt; {
        val csrfToken: Mono&lt;CsrfToken&gt;? = exchange.getAttribute(CsrfToken::class.java.name)
        return csrfToken!!.doOnSuccess { token -&gt;
            exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Fortunately, Thymeleaf provides <a href="#webflux-csrf-include-form-auto">integration</a> that works without any additional work.</p>
</div>
<div class="sect5">
<h6 id="webflux-csrf-include-form"><a class="anchor" href="#webflux-csrf-include-form"></a>Form URL Encoded</h6>
<div class="paragraph">
<p>In order to post an HTML form the CSRF token must be included in the form as a hidden input.
For example, the rendered HTML might look like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. CSRF Token HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Next we will discuss various ways of including the CSRF token in a form as a hidden input.</p>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-form-auto"><a class="anchor" href="#webflux-csrf-include-form-auto"></a>Automatic CSRF Token Inclusion</h7>
<div class="paragraph">
<p>Spring Security&#8217;s CSRF support provides integration with Spring&#8217;s <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html">RequestDataValueProcessor</a> via its <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html">CsrfRequestDataValueProcessor</a>.
In order for <code>CsrfRequestDataValueProcessor</code> to work, the <code>Mono&lt;CsrfToken&gt;</code> must be subscribed to and the <code>CsrfToken</code> must be <a href="#webflux-csrf-include-subscribe">exposed as an attribute</a> that matches <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME">DEFAULT_CSRF_ATTR_NAME</a>.</p>
</div>
<div class="paragraph">
<p>Fortunately, Thymeleaf <a href="https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor">provides support</a> to take care of all the boilerplate for you by integrating with <code>RequestDataValueProcessor</code> to ensure that forms that have an unsafe HTTP method (i.e. post) will automatically include the actual CSRF token.</p>
</div>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-form-attr"><a class="anchor" href="#webflux-csrf-include-form-attr"></a>CsrfToken Request Attribute</h7>
<div class="paragraph">
<p>If the <a href="#webflux-csrf-include">other options</a> for including the actual CSRF token in the request do not work, you can take advantage of the fact that the <code>Mono&lt;CsrfToken&gt;</code> <a href="#webflux-csrf-include">is exposed</a> as a <code>ServerWebExchange</code> attribute named <code>org.springframework.security.web.server.csrf.CsrfToken</code>.</p>
</div>
<div class="paragraph">
<p>The Thymeleaf sample below assumes that you <a href="#webflux-csrf-include-subscribe">expose</a> the <code>CsrfToken</code> on an attribute named <code>_csrf</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. CSRF Token in Form with Request Attribute</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;form th:action="@{/logout}"
	method="post"&gt;
&lt;input type="submit"
	value="Log out" /&gt;
&lt;input type="hidden"
	th:name="${_csrf.parameterName}"
	th:value="${_csrf.token}"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-include-ajax"><a class="anchor" href="#webflux-csrf-include-ajax"></a>Ajax and JSON Requests</h6>
<div class="paragraph">
<p>If you are using JSON, then it is not possible to submit the CSRF token within an HTTP parameter.
Instead you can submit the token within a HTTP header.</p>
</div>
<div class="paragraph">
<p>In the following sections we will discuss various ways of including the CSRF token as an HTTP request header in JavaScript based applications.</p>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-ajax-auto"><a class="anchor" href="#webflux-csrf-include-ajax-auto"></a>Automatic Inclusion</h7>
<div class="paragraph">
<p>Spring Security can easily be <a href="#webflux-csrf-configure-custom-repository">configured</a> to store the expected CSRF token in a cookie.
By storing the expected CSRF in a cookie, JavaScript frameworks like <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a> will automatically include the actual CSRF token in the HTTP request headers.</p>
</div>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-ajax-meta"><a class="anchor" href="#webflux-csrf-include-ajax-meta"></a>Meta tags</h7>
<div class="paragraph">
<p>An alternative pattern to <a href="#webflux-csrf-include-form-auto">exposing the CSRF in a cookie</a> is to include the CSRF token within your <code>meta</code> tags.
The HTML might look something like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. CSRF meta tag HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
	&lt;meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;
	&lt;meta name="_csrf_header" content="X-CSRF-TOKEN"/&gt;
	&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once the meta tags contained the CSRF token, the JavaScript code would read the meta tags and include the CSRF token as a header.
If you were using jQuery, this could be done with the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. AJAX send CSRF Token</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The sample below assumes that you <a href="#webflux-csrf-include-subscribe">expose</a> the <code>CsrfToken</code> on an attribute named <code>_csrf</code>.
An example of doing this with Thymeleaf is shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. CSRF meta tag JSP</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
&lt;head&gt;
	&lt;meta name="_csrf" th:content="${_csrf.token}"/&gt;
	&lt;!-- default header name is X-CSRF-TOKEN --&gt;
	&lt;meta name="_csrf_header" th:content="${_csrf.headerName}"/&gt;
	&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-csrf-considerations"><a class="anchor" href="#webflux-csrf-considerations"></a>CSRF Considerations</h4>
<div class="paragraph">
<p>There are a few special considerations to consider when implementing protection against CSRF attacks.
This section discusses those considerations as it pertains to WebFlux environments.
Refer to <a href="#csrf-considerations">[csrf-considerations]</a> for a more general discussion.</p>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-login"><a class="anchor" href="#webflux-considerations-csrf-login"></a>Logging In</h5>
<div class="paragraph">
<p>It is important to <a href="#csrf-considerations-login">require CSRF for log in</a> requests to protect against forging log in attempts.
Spring Security&#8217;s WebFlux support does this out of the box.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-logout"><a class="anchor" href="#webflux-considerations-csrf-logout"></a>Logging Out</h5>
<div class="paragraph">
<p>It is important to <a href="#csrf-considerations-logout">require CSRF for log out</a> requests to protect against forging log out attempts.
By default Spring Security&#8217;s <code>LogoutWebFilter</code> only processes HTTP post requests.
This ensures that log out requires a CSRF token and that a malicious user cannot forcibly log out your users.</p>
</div>
<div class="paragraph">
<p>The easiest approach is to use a form to log out.
If you really want a link, you can use JavaScript to have the link perform a POST (i.e. maybe on a hidden form).
For browsers with JavaScript that is disabled, you can optionally have the link take the user to a log out confirmation page that will perform the POST.</p>
</div>
<div class="paragraph">
<p>If you really want to use HTTP GET with logout you can do so, but remember this is generally not recommended.
For example, the following Java Configuration will perform logout with the URL <code>/logout</code> is requested with any HTTP method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Log out with HTTP GET</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.logout(logout -&gt; logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        logout {
            requiresLogout = PathPatternParserServerWebExchangeMatcher("/logout")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-timeouts"><a class="anchor" href="#webflux-considerations-csrf-timeouts"></a>CSRF and Session Timeouts</h5>
<div class="paragraph">
<p>By default Spring Security stores the CSRF token in the <code>WebSession</code>.
This can lead to a situation where the session expires which means there is not an expected CSRF token to validate against.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve already discussed <a href="#csrf-considerations-login">general solutions</a> to session timeouts.
This section discusses the specifics of CSRF timeouts as it pertains to the WebFlux support.</p>
</div>
<div class="paragraph">
<p>It is simple to change storage of the expected CSRF token to be in a cookie.
For details, refer to the <a href="#webflux-csrf-configure-custom-repository">Custom CsrfTokenRepository</a> section.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-considerations-multipart"><a class="anchor" href="#webflux-csrf-considerations-multipart"></a>Multipart (file upload)</h5>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart">already discussed</a> how protecting multipart requests (file uploads) from CSRF attacks causes a <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">chicken and the egg</a> problem.
This section discusses how to implement placing the CSRF token in the <a href="#webflux-csrf-considerations-multipart-body">body</a> and <a href="#webflux-csrf-considerations-multipart-url">url</a> within a WebFlux application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>More information about using multipart forms with Spring can be found within the <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart">Multipart Data</a> section of the Spring reference.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="webflux-csrf-considerations-multipart-body"><a class="anchor" href="#webflux-csrf-considerations-multipart-body"></a>Place CSRF Token in the Body</h6>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart">already discussed</a> the trade-offs of placing the CSRF token in the body.</p>
</div>
<div class="paragraph">
<p>In a WebFlux application, this can be configured with the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Enable obtaining CSRF token from multipart/form-data</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -&gt; csrf.tokenFromMultipartDataEnabled(true))
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
		// ...
        csrf {
            tokenFromMultipartDataEnabled = true
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-considerations-multipart-url"><a class="anchor" href="#webflux-csrf-considerations-multipart-url"></a>Include CSRF Token in URL</h6>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-multipart">already discussed</a> the trade-offs of placing the CSRF token in the URL.
Since the <code>CsrfToken</code> is exposed as an <code>ServerHttpRequest</code> <a href="#webflux-csrf-include">request attribute</a>, we can use that to create an <code>action</code> with the CSRF token in it.
An example with Thymeleaf is shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. CSRF Token in Action</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;form method="post"
	th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
	enctype="multipart/form-data"&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-considerations-override-method"><a class="anchor" href="#webflux-csrf-considerations-override-method"></a>HiddenHttpMethodFilter</h5>
<div class="paragraph">
<p>We have <a href="#csrf-considerations-override-method">already discussed</a> overriding the HTTP method.</p>
</div>
<div class="paragraph">
<p>In a Spring WebFlux application, overriding the HTTP method is done using <a href="https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html">HiddenHttpMethodFilter</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-headers"><a class="anchor" href="#webflux-headers"></a>Security HTTP Response Headers</h3>
<div class="paragraph">
<p><a href="#headers">Security HTTP Response Headers</a> can be used to increase the security of web applications.
This section is dedicated to WebFlux based support for Security HTTP Response Headers.</p>
</div>
<div class="sect3">
<h4 id="webflux-headers-default"><a class="anchor" href="#webflux-headers-default"></a>Default Security Headers</h4>
<div class="paragraph">
<p>Spring Security provides a <a href="#headers-default">default set of Security HTTP Response Headers</a> to provide secure defaults.
While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.</p>
</div>
<div class="paragraph">
<p>You can customize specific headers.
For example, assume that you want the defaults except you wish to specify <code>SAMEORIGIN</code> for <a href="#servlet-headers-frame-options">X-Frame-Options</a>.</p>
</div>
<div class="paragraph">
<p>You can easily do this with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Customize Default Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.frameOptions(frameOptions -&gt; frameOptions
				.mode(Mode.SAMEORIGIN)
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = Mode.SAMEORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.
An example is provided below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Disable HTTP Security Response Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers.disable());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            disable()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-cache-control"><a class="anchor" href="#webflux-headers-cache-control"></a>Cache Control</h4>
<div class="paragraph">
<p>Spring Security includes <a href="#headers-cache-control">Cache Control</a> headers by default.</p>
</div>
<div class="paragraph">
<p>However, if you actually want to cache specific responses, your application can selectively add them to the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html">ServerHttpResponse</a> to override the header set by Spring Security.
This is useful to ensure things like CSS, JavaScript, and images are properly cached.</p>
</div>
<div class="paragraph">
<p>When using Spring WebFluxZz, this is typically done within your configuration.
Details on how to do this can be found in the <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-static-resources">Static Resources</a> portion of the Spring Reference documentation</p>
</div>
<div class="paragraph">
<p>If necessary, you can also disable Spring Security&#8217;s cache control HTTP response headers.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Cache Control Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.cache(cache -&gt; cache.disable())
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            cache {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-content-type-options"><a class="anchor" href="#webflux-headers-content-type-options"></a>Content Type Options</h4>
<div class="paragraph">
<p>Spring Security includes <a href="#headers-content-type-options">Content-Type</a> headers by default.
However, you can disable it with:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Content Type Options Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.contentTypeOptions(contentTypeOptions -&gt; contentTypeOptions.disable())
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentTypeOptions {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-hsts"><a class="anchor" href="#webflux-headers-hsts"></a>HTTP Strict Transport Security (HSTS)</h4>
<div class="paragraph">
<p>Spring Security provides the <a href="#headers-hsts">Strict Transport Security</a> header by default.
However, you can customize the results explicitly.
For example, the following is an example of explicitly providing HSTS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Strict Transport Security</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.hsts(hsts -&gt; hsts
				.includeSubdomains(true)
				.preload(true)
				.maxAge(Duration.ofDays(365))
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            hsts {
                includeSubdomains = true
                preload = true
                maxAge = Duration.ofDays(365)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-frame-options"><a class="anchor" href="#webflux-headers-frame-options"></a>X-Frame-Options</h4>
<div class="paragraph">
<p>By default, Spring Security disables rendering within an iframe using <a href="#headers-frame-options">X-Frame-Options</a>.</p>
</div>
<div class="paragraph">
<p>You can customize frame options to use the same origin using the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. X-Frame-Options: SAMEORIGIN</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.frameOptions(frameOptions -&gt; frameOptions
				.mode(SAMEORIGIN)
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = SAMEORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-xss-protection"><a class="anchor" href="#webflux-headers-xss-protection"></a>X-XSS-Protection</h4>
<div class="paragraph">
<p>By default, Spring Security instructs browsers to block reflected XSS attacks using the &lt;&lt;headers-xss-protection,X-XSS-Protection header&gt;.
You can disable <code>X-XSS-Protection</code> with the following Configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. X-XSS-Protection Customization</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.xssProtection(xssProtection -&gt; xssProtection.disable())
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            xssProtection {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-csp"><a class="anchor" href="#webflux-headers-csp"></a>Content Security Policy (CSP)</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-csp">Content Security Policy</a> by default, because a reasonable default is impossible to know without context of the application.
The web application author must declare the security policy(s) to enforce and/or monitor for the protected resources.</p>
</div>
<div class="paragraph">
<p>For example, given the following security policy:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. Content Security Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable the CSP header as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Content Security Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.contentSecurityPolicy(policy -&gt; policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To enable the CSP <code>report-only</code> header, provide the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Content Security Policy Report Only</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.contentSecurityPolicy(policy -&gt; policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				.reportOnly()
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                reportOnly = true
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-referrer"><a class="anchor" href="#webflux-headers-referrer"></a>Referrer Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-referrer">Referrer Policy</a> headers by default.
You can enable the Referrer Policy header using configuration as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Referrer Policy Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.referrerPolicy(referrer -&gt; referrer
				.policy(ReferrerPolicy.SAME_ORIGIN)
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            referrerPolicy {
                policy = ReferrerPolicy.SAME_ORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-feature"><a class="anchor" href="#webflux-headers-feature"></a>Feature Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-feature">Feature Policy</a> headers by default.
The following <code>Feature-Policy</code> header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Feature-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Feature-Policy: geolocation 'self'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable the Feature Policy header as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Feature-Policy Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.featurePolicy("geolocation 'self'")
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            featurePolicy("geolocation 'self'")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-permissions"><a class="anchor" href="#webflux-headers-permissions"></a>Permissions Policy</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-permissions">Permissions Policy</a> headers by default.
The following <code>Permissions-Policy</code> header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Permissions-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Permissions-Policy: geolocation=(self)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can enable the Permissions Policy header as shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Permissions-Policy Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -&gt; headers
			.permissionsPolicy(permissions -&gt; permissions
				.policy("geolocation=(self)")
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            permissionsPolicy {
                policy = "geolocation=(self)"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-clear-site-data"><a class="anchor" href="#webflux-headers-clear-site-data"></a>Clear Site Data</h4>
<div class="paragraph">
<p>Spring Security does not add <a href="#headers-clear-site-data">Clear-Site-Data</a> headers by default.
The following Clear-Site-Data header:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Clear-Site-Data Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Clear-Site-Data: "cache", "cookies"</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>can be sent on log out with the following configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. Clear-Site-Data Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
	ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);
	ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);
	DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

	http
		// ...
		.logout()
			.logoutHandler(logoutHandler);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler()
    val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES)
    val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer)
    val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData)

    return http {
        // ...
        logout {
            logoutHandler = customLogoutHandler
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http"><a class="anchor" href="#webflux-http"></a>HTTP</h3>
<div class="paragraph">
<p>All HTTP based communication should be protected <a href="#http">using TLS</a>.</p>
</div>
<div class="paragraph">
<p>Below you can find details around WebFlux specific features that assist with HTTPS usage.</p>
</div>
<div class="sect3">
<h4 id="webflux-http-redirect"><a class="anchor" href="#webflux-http-redirect"></a>Redirect to HTTPS</h4>
<div class="paragraph">
<p>If a client makes a request using HTTP rather than HTTPS, Spring Security can be configured to redirect to HTTPS.</p>
</div>
<div class="paragraph">
<p>For example, the following Java configuration will redirect any HTTP requests to HTTPS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. Redirect to HTTPS</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.redirectToHttps(withDefaults());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        redirectToHttps { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration can easily be wrapped around an if statement to only be turned on in production.
Alternatively, it can be enabled by looking for a property about the request that only happens in production.
For example, if the production environment adds a header named <code>X-Forwarded-Proto</code> the following Java Configuration could be used:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. Redirect to HTTPS when X-Forwarded</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.redirectToHttps(redirect -&gt; redirect
			.httpsRedirectWhen(e -&gt; e.getRequest().getHeaders().containsKey("X-Forwarded-Proto"))
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        redirectToHttps {
            httpsRedirectWhen {
                it.request.headers.containsKey("X-Forwarded-Proto")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-hsts"><a class="anchor" href="#webflux-hsts"></a>Strict Transport Security</h4>
<div class="paragraph">
<p>Spring Security provides support for <a href="#servlet-headers-hsts">Strict Transport Security</a> and enables it by default.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-http-proxy-server"><a class="anchor" href="#webflux-http-proxy-server"></a>Proxy Server Configuration</h4>
<div class="paragraph">
<p>Spring Security <a href="#http-proxy-server">integrates with proxy servers</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-oauth2"><a class="anchor" href="#webflux-oauth2"></a>OAuth2 WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security provides OAuth2 and WebFlux integration for reactive applications.</p>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-login"><a class="anchor" href="#webflux-oauth2-login"></a>OAuth 2.0 Login</h3>
<div class="paragraph">
<p>The OAuth 2.0 Login feature provides an application with the capability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (e.g.
GitHub) or OpenID Connect 1.0 Provider (such as Google).
OAuth 2.0 Login implements the use cases: "Login with Google" or "Login with GitHub".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OAuth 2.0 Login is implemented by using the <strong>Authorization Code Grant</strong>, as specified in the <a href="https://tools.ietf.org/html/rfc6749#section-4.1">OAuth 2.0 Authorization Framework</a> and <a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OpenID Connect Core 1.0</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-sample"><a class="anchor" href="#webflux-oauth2-login-sample"></a>Spring Boot 2.0 Sample</h4>
<div class="paragraph">
<p>Spring Boot 2.0 brings full auto-configuration capabilities for OAuth 2.0 Login.</p>
</div>
<div class="paragraph">
<p>This section shows how to configure the <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/oauth2/login"><strong>OAuth 2.0 Login WebFlux sample</strong></a> using <em>Google</em> as the <em>Authentication Provider</em> and covers the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-oauth2-login-sample-setup">Initial setup</a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-redirect">Setting the redirect URI</a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-config">Configure <code>application.yml</code></a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-start">Boot up the application</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-setup"><a class="anchor" href="#webflux-oauth2-login-sample-setup"></a>Initial setup</h5>
<div class="paragraph">
<p>To use Google&#8217;s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OAuth 2.0 implementation</a> for authentication conforms to the  <a href="https://openid.net/connect/">OpenID Connect 1.0</a> specification and is <a href="https://openid.net/certification/">OpenID Certified</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Follow the instructions on the <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a> page, starting in the section, "Setting up OAuth 2.0".</p>
</div>
<div class="paragraph">
<p>After completing the "Obtain OAuth 2.0 credentials" instructions, you should have a new OAuth Client with credentials consisting of a Client ID and a Client Secret.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-redirect"><a class="anchor" href="#webflux-oauth2-login-sample-redirect"></a>Setting the redirect URI</h5>
<div class="paragraph">
<p>The redirect URI is the path in the application that the end-user&#8217;s user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client <em>(<a href="#webflux-oauth2-login-sample-setup">created in the previous step</a>)</em> on the Consent page.</p>
</div>
<div class="paragraph">
<p>In the "Set a redirect URI" sub-section, ensure that the <strong>Authorized redirect URIs</strong> field is set to <code><a href="http://localhost:8080/login/oauth2/code/google" class="bare">http://localhost:8080/login/oauth2/code/google</a></code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The default redirect URI template is <code>{baseUrl}/login/oauth2/code/{registrationId}</code>.
The <strong><em>registrationId</em></strong> is a unique identifier for the <a href="#oauth2Client-client-registration">ClientRegistration</a>.
For our example, the <code>registrationId</code> is <code>google</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the OAuth Client is running behind a proxy server, it is recommended to check <a href="#http-proxy-server">Proxy Server Configuration</a> to ensure the application is correctly configured.
Also, see the supported <a href="#oauth2Client-auth-code-redirect-uri"><code>URI</code> template variables</a> for <code>redirect-uri</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-config"><a class="anchor" href="#webflux-oauth2-login-sample-config"></a>Configure <code>application.yml</code></h5>
<div class="paragraph">
<p>Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the <em>authentication flow</em>.
To do so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to <code>application.yml</code> and set the following configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:	<i class="conum" data-value="1"></i><b>(1)</b>
          google:	<i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 33. OAuth Client properties</div>
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring.security.oauth2.client.registration</code> is the base property prefix for OAuth Client properties.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Following the base property prefix is the ID for the <a href="#oauth2Client-client-registration">ClientRegistration</a>, such as google.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>Replace the values in the <code>client-id</code> and <code>client-secret</code> property with the OAuth 2.0 credentials you created earlier.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-start"><a class="anchor" href="#webflux-oauth2-login-sample-start"></a>Boot up the application</h5>
<div class="paragraph">
<p>Launch the Spring Boot 2.0 sample and go to <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code>.
You are then redirected to the default <em>auto-generated</em> login page, which displays a link for Google.</p>
</div>
<div class="paragraph">
<p>Click on the Google link, and you are then redirected to Google for authentication.</p>
</div>
<div class="paragraph">
<p>After authenticating with your Google account credentials, the next page presented to you is the Consent screen.
The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier.
Click <strong>Allow</strong> to authorize the OAuth Client to access your email address and basic profile information.</p>
</div>
<div class="paragraph">
<p>At this point, the OAuth Client retrieves your email address and basic profile information from the <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> and establishes an authenticated session.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-openid-provider-configuration"><a class="anchor" href="#webflux-oauth2-login-openid-provider-configuration"></a>Using OpenID Provider Configuration</h4>
<div class="paragraph">
<p>For well known providers, Spring Security provides the necessary defaults for the OAuth Authorization Provider&#8217;s configuration.
If you are working with your own Authorization Provider that supports <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">OpenID Provider Configuration</a> or <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a>, the <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse">OpenID Provider Configuration Response</a>'s <code>issuer-uri</code> can be used to configure the application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: https://idp.example.com/auth/realms/demo
        registration:
          keycloak:
            client-id: spring-security
            client-secret: 6cea952f-10d0-4d00-ac79-cc865820dc2c</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>issuer-uri</code> instructs Spring Security to query in series the endpoints <code><a href="https://idp.example.com/auth/realms/demo/.well-known/openid-configuration" class="bare">https://idp.example.com/auth/realms/demo/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/auth/realms/demo" class="bare">https://idp.example.com/.well-known/openid-configuration/auth/realms/demo</a></code>, or <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/auth/realms/demo" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/auth/realms/demo</a></code> to discover the configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security will query the endpoints one at a time, stopping at the first that gives a 200 response.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>client-id</code> and <code>client-secret</code> are linked to the provider because <code>keycloak</code> is used for both the provider and the registration.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-explicit"><a class="anchor" href="#webflux-oauth2-login-explicit"></a>Explicit OAuth2 Login Configuration</h4>
<div class="paragraph">
<p>A minimal OAuth2 Login configuration is shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Minimal OAuth2 Login</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveClientRegistrationRepository clientRegistrations() {
	ClientRegistration clientRegistration = ClientRegistrations
			.fromIssuerLocation("https://idp.example.com/auth/realms/demo")
			.clientId("spring-security")
			.clientSecret("6cea952f-10d0-4d00-ac79-cc865820dc2c")
			.build();
	return new InMemoryReactiveClientRegistrationRepository(clientRegistration);
}

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.oauth2Login(withDefaults());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun clientRegistrations(): ReactiveClientRegistrationRepository {
    val clientRegistration: ClientRegistration = ClientRegistrations
            .fromIssuerLocation("https://idp.example.com/auth/realms/demo")
            .clientId("spring-security")
            .clientSecret("6cea952f-10d0-4d00-ac79-cc865820dc2c")
            .build()
    return InMemoryReactiveClientRegistrationRepository(clientRegistration)
}

@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Additional configuration options can be seen below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Advanced OAuth2 Login</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.oauth2Login(oauth2 -&gt; oauth2
			.authenticationConverter(converter)
			.authenticationManager(manager)
			.authorizedClientRepository(authorizedClients)
			.clientRegistrationRepository(clientRegistrations)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login {
            authenticationConverter = converter
            authenticationManager = manager
            authorizedClientRepository = authorizedClients
            clientRegistrationRepository = clientRegistration
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may register a <code>GrantedAuthoritiesMapper</code> <code>@Bean</code> to have it automatically applied to the default configuration, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. GrantedAuthoritiesMapper Bean</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public GrantedAuthoritiesMapper userAuthoritiesMapper() {
    ...
}

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.oauth2Login(withDefaults());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {
   // ...
}

@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-client"><a class="anchor" href="#webflux-oauth2-client"></a>OAuth2 Client</h3>
<div class="paragraph">
<p>Spring Security&#8217;s OAuth Support allows obtaining an access token without authenticating.
A basic configuration with Spring Boot can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: replace-with-client-id
            client-secret: replace-with-client-secret
            scope: read:user,public_repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will need to replace the <code>client-id</code> and <code>client-secret</code> with values registered with GitHub.</p>
</div>
<div class="paragraph">
<p>The next step is to instruct Spring Security that you wish to act as an OAuth2 Client so that you can obtain an access token.</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. OAuth2 Client</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain configure(ServerHttpSecurity http) throws Exception {
	http
		// ...
		.oauth2Client(withDefaults());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        oauth2Client { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can now leverage Spring Security&#8217;s <a href="#webclient">[webclient]</a> or <a href="#webflux-roac">@RegisteredOAuth2AuthorizedClient</a> support to obtain and use the access token.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-resource-server"><a class="anchor" href="#webflux-oauth2-resource-server"></a>OAuth 2.0 Resource Server</h3>
<div class="paragraph">
<p>Spring Security supports protecting endpoints using two forms of OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JWT</a></p>
</li>
<li>
<p>Opaque Tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is handy in circumstances where an application has delegated its authority management to an <a href="https://tools.ietf.org/html/rfc6749">authorization server</a> (for example, Okta or Ping Identity).
This authorization server can be consulted by resource servers to authorize requests.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A complete working example for <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/oauth2/resource-server"><strong>JWTs</strong></a>  is available in the <a href="https://github.com/spring-projects/spring-security-samples/tree/main">Spring Security repository</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-minimaldependencies"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-minimaldependencies"></a>Minimal Dependencies for JWT</h4>
<div class="paragraph">
<p>Most Resource Server support is collected into <code>spring-security-oauth2-resource-server</code>.
However, the support for decoding and verifying JWTs is in <code>spring-security-oauth2-jose</code>, meaning that both are necessary in order to have a working resource server that supports JWT-encoded Bearer Tokens.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-minimalconfiguration"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-minimalconfiguration"></a>Minimal Configuration for JWTs</h4>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server consists of two basic steps.
First, include the needed dependencies and second, indicate the location of the authorization server.</p>
</div>
<div class="sect4">
<h5 id="_specifying_the_authorization_server"><a class="anchor" href="#_specifying_the_authorization_server"></a>Specifying the Authorization Server</h5>
<div class="paragraph">
<p>In a Spring Boot application, to specify which authorization server to use, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/issuer" class="bare">https://idp.example.com/issuer</a></code> is the value contained in the <code>iss</code> claim for JWT tokens that the authorization server will issue.
Resource Server will use this property to further self-configure, discover the authorization server&#8217;s public keys, and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To use the <code>issuer-uri</code> property, it must also be true that one of <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">https://idp.example.com/issuer/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">https://idp.example.com/.well-known/openid-configuration/issuer</a></code>, or <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">https://idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> is a supported endpoint for the authorization server.
This endpoint is referred to as a <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Provider Configuration</a> endpoint or a <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a> endpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect4">
<h5 id="_startup_expectations"><a class="anchor" href="#_startup_expectations"></a>Startup Expectations</h5>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate JWT-encoded Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>It achieves this through a deterministic startup process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hit the Provider Configuration or Authorization Server Metadata endpoint, processing the response for the <code>jwks_url</code> property</p>
</li>
<li>
<p>Configure the validation strategy to query <code>jwks_url</code> for valid public keys</p>
</li>
<li>
<p>Configure the validation strategy to validate each JWTs <code>iss</code> claim against <code><a href="https://idp.example.com" class="bare">https://idp.example.com</a></code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A consequence of this process is that the authorization server must be up and receiving requests in order for Resource Server to successfully start up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup will fail.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_expectations"><a class="anchor" href="#_runtime_expectations"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given a well-formed JWT, Resource Server will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate its signature against a public key obtained from the <code>jwks_url</code> endpoint during startup and matched against the JWTs header</p>
</li>
<li>
<p>Validate the JWTs <code>exp</code> and <code>nbf</code> timestamps and the JWTs <code>iss</code> claim, and</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the authorization server makes available new keys, Spring Security will automatically rotate the keys used to validate the JWT tokens.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code>Jwt</code> object, and <code>Authentication#getName</code> maps to the JWT&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, consider jumping to:</p>
</div>
<div class="paragraph">
<p><a href="#webflux-oauth2resourceserver-jwt-jwkseturi">How to Configure without Tying Resource Server startup to an authorization server&#8217;s availability</a></p>
</div>
<div class="paragraph">
<p><a href="#webflux-oauth2resourceserver-jwt-sansboot">How to Configure without Spring Boot</a></p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-jwkseturi"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-jwkseturi"></a>Specifying the Authorization Server JWK Set Uri Directly</h5>
<div class="paragraph">
<p>If the authorization server doesn&#8217;t support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, then the <code>jwk-set-uri</code> can be supplied as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The JWK Set uri is not standardized, but can typically be found in the authorization server&#8217;s documentation
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consequently, Resource Server will not ping the authorization server at startup.
We still specify the <code>issuer-uri</code> so that Resource Server still validates the <code>iss</code> claim on incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property can also be supplied directly on the <a href="#webflux-oauth2resourceserver-jwt-jwkseturi-dsl">DSL</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-sansboot"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h5>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>SecurityWebFilterChain</code> that configures the app as a resource server. When including <code>spring-security-oauth2-jose</code>, this <code>SecurityWebFilterChain</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. Resource Server SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(OAuth2ResourceServerSpec::jwt)
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>SecurityWebFilterChain</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. Replacing SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.pathMatchers("/message/**").hasAuthority("SCOPE_message:read")
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -&gt; oauth2
			.jwt(withDefaults())
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/message/**", hasAuthority("SCOPE_message:read"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is a <code>ReactiveJwtDecoder</code>, which decodes <code>String</code> tokens into validated instances of <code>Jwt</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. ReactiveJwtDecoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Calling <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/ReactiveJwtDecoders.html#fromIssuerLocation-java.lang.String-">ReactiveJwtDecoders#fromIssuerLocation</a></code> is what invokes the Provider Configuration or Authorization Server Metadata endpoint in order to derive the JWK Set Uri.
If the application doesn&#8217;t expose a <code>ReactiveJwtDecoder</code> bean, then Spring Boot will expose the above default one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>jwkSetUri()</code> or replaced using <code>decoder()</code>.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-jwkseturi-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-jwkseturi-dsl"></a>Using <code>jwkSetUri()</code></h6>
<div class="paragraph">
<p>An authorization server&#8217;s JWK Set Uri can be configured <a href="#webflux-oauth2resourceserver-jwt-jwkseturi">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -&gt; oauth2
			.jwt(jwt -&gt; jwt
				.jwkSetUri("https://idp.example.com/.well-known/jwks.json")
			)
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>jwkSetUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-dsl"></a>Using <code>decoder()</code></h6>
<div class="paragraph">
<p>More powerful than <code>jwkSetUri()</code> is <code>decoder()</code>, which will completely replace any Boot auto configuration of <code>JwtDecoder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -&gt; oauth2
			.jwt(jwt -&gt; jwt
				.decoder(myCustomDecoder())
			)
		);
    return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtDecoder = myCustomDecoder()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#webflux-oauth2resourceserver-jwt-validation">validation</a>, is necessary.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-decoder-bean"><a class="anchor" href="#webflux-oauth2resourceserver-decoder-bean"></a>Exposing a <code>ReactiveJwtDecoder</code> <code>@Bean</code></h6>
<div class="paragraph">
<p>Or, exposing a <code>ReactiveJwtDecoder</code> <code>@Bean</code> has the same effect as <code>decoder()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-decoder-algorithm"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-algorithm"></a>Configuring Trusted Algorithms</h4>
<div class="paragraph">
<p>By default, <code>NimbusReactiveJwtDecoder</code>, and hence Resource Server, will only trust and verify tokens using <code>RS256</code>.</p>
</div>
<div class="paragraph">
<p>You can customize this via <a href="#webflux-oauth2resourceserver-jwt-boot-algorithm">Spring Boot</a> or <a href="#webflux-oauth2resourceserver-jwt-decoder-builder">the NimbusJwtDecoder builder</a>.</p>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-boot-algorithm"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-boot-algorithm"></a>Via Spring Boot</h5>
<div class="paragraph">
<p>The simplest way to set the algorithm is as a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-builder"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-builder"></a>Using a Builder</h5>
<div class="paragraph">
<p>For greater power, though, we can use a builder that ships with <code>NimbusReactiveJwtDecoder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Calling <code>jwsAlgorithm</code> more than once will configure <code>NimbusReactiveJwtDecoder</code> to trust more than one algorithm, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, you can call <code>jwsAlgorithms</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -&gt; {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-public-key"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key"></a>Trusting a Single Asymmetric Key</h5>
<div class="paragraph">
<p>Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key.
The public key can be provided via <a href="#webflux-oauth2resourceserver-jwt-decoder-public-key-boot">Spring Boot</a> or by <a href="#webflux-oauth2resourceserver-jwt-decoder-public-key-builder">Using a Builder</a>.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-public-key-boot"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key-boot"></a>Via Spring Boot</h6>
<div class="paragraph">
<p>Specifying a key via Spring Boot is quite simple.
The key&#8217;s location can be specified like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to allow for a more sophisticated lookup, you can post-process the <code>RsaKeyConversionServicePostProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. BeanFactoryPostProcessor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory -&gt;
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory: ConfigurableListableBeanFactory -&gt;
        beanFactory.getBean&lt;RsaKeyConversionServicePostProcessor&gt;()
                .setResourceLoader(CustomResourceLoader())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Specify your key&#8217;s location:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">key.location: hfds://my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then autowire the value:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${key.location}")
RSAPublicKey key;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Value("\${key.location}")
val key: RSAPublicKey? = null</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-public-key-builder"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key-builder"></a>Using a Builder</h6>
<div class="paragraph">
<p>To wire an <code>RSAPublicKey</code> directly, you can simply use the appropriate <code>NimbusReactiveJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withPublicKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withPublicKey(key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-secret-key"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-secret-key"></a>Trusting a Single Symmetric Key</h5>
<div class="paragraph">
<p>Using a single symmetric key is also simple.
You can simply load in your <code>SecretKey</code> and use the appropriate <code>NimbusReactiveJwtDecoder</code> builder, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-authorization"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-authorization"></a>Configuring Authorization</h5>
<div class="paragraph">
<p>A JWT that is issued from an OAuth 2.0 Authorization Server will typically either have a <code>scope</code> or <code>scp</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
			.mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);
    return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
            authorize("/messages/**", hasAuthority("SCOPE_messages"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public Flux&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): Flux&lt;Message&gt; { }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-authorization-extraction"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-authorization-extraction"></a>Extracting Authorities Manually</h6>
<div class="paragraph">
<p>However, there are a number of circumstances where this default is insufficient.
For example, some authorization servers don&#8217;t use the <code>scope</code> attribute, but instead have their own custom attribute.
Or, at other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities.</p>
</div>
<div class="paragraph">
<p>To this end, the DSL exposes <code>jwtAuthenticationConverter()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(oauth2 -&gt; oauth2
			.jwt(jwt -&gt; jwt
				.jwtAuthenticationConverter(grantedAuthoritiesExtractor())
			)
		);
	return http.build();
}

Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; grantedAuthoritiesExtractor() {
    JwtAuthenticationConverter jwtAuthenticationConverter =
            new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter
            (new GrantedAuthoritiesExtractor());
    return new ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtAuthenticationConverter = grantedAuthoritiesExtractor()
            }
        }
    }
}

fun grantedAuthoritiesExtractor(): Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor())
    return ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>which is responsible for converting a <code>Jwt</code> into an <code>Authentication</code>.
As part of its configuration, we can supply a subsidiary converter to go from <code>Jwt</code> to a <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>That final converter might be something like <code>GrantedAuthoritiesExtractor</code> below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class GrantedAuthoritiesExtractor
        implements Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt; {

    public Collection&lt;GrantedAuthority&gt; convert(Jwt jwt) {
        Collection&lt;?&gt; authorities = (Collection&lt;?&gt;)
                jwt.getClaims().getOrDefault("mycustomclaim", Collections.emptyList());

        return authorities.stream()
                .map(Object::toString)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class GrantedAuthoritiesExtractor : Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt; {
    override fun convert(jwt: Jwt): Collection&lt;GrantedAuthority&gt; {
        val authorities: List&lt;Any&gt; = jwt.claims
                .getOrDefault("mycustomclaim", emptyList&lt;Any&gt;()) as List&lt;Any&gt;
        return authorities
                .map { it.toString() }
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more flexibility, the DSL supports entirely replacing the converter with any class that implements <code>Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class CustomAuthenticationConverter implements Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return Mono.just(jwt).map(this::doConversion);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">internal class CustomAuthenticationConverter : Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    override fun convert(jwt: Jwt): Mono&lt;AbstractAuthenticationToken&gt; {
        return Mono.just(jwt).map(this::doConversion)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-validation"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-validation"></a>Configuring Validation</h5>
<div class="paragraph">
<p>Using <a href="#webflux-oauth2resourceserver-jwt-minimalconfiguration">minimal Spring Boot configuration</a>, indicating the authorization server&#8217;s issuer uri, Resource Server will default to verifying the <code>iss</code> claim as well as the <code>exp</code> and <code>nbf</code> timestamp claims.</p>
</div>
<div class="paragraph">
<p>In circumstances where validation needs to be customized, Resource Server ships with two standard validators and also accepts custom <code>OAuth2TokenValidator</code> instances.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-validation-clockskew"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-validation-clockskew"></a>Customizing Timestamp Validation</h6>
<div class="paragraph">
<p>JWT&#8217;s typically have a window of validity, with the start of the window indicated in the <code>nbf</code> claim and the end indicated in the <code>exp</code> claim.</p>
</div>
<div class="paragraph">
<p>However, every server can experience clock drift, which can cause tokens to appear expired to one server, but not to another.
This can cause some implementation heartburn as the number of collaborating servers increases in a distributed system.</p>
</div>
<div class="paragraph">
<p>Resource Server uses <code>JwtTimestampValidator</code> to verify a token&#8217;s validity window, and it can be configured with a <code>clockSkew</code> to alleviate the above problem:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
     NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
             ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator&lt;Jwt&gt; withClockSkew = new DelegatingOAuth2TokenValidator&lt;&gt;(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new IssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val withClockSkew: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))
    jwtDecoder.setJwtValidator(withClockSkew)
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, Resource Server configures a clock skew of 60 seconds.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-validation-custom"><a class="anchor" href="#webflux-oauth2resourceserver-validation-custom"></a>Configuring a Custom Validator</h6>
<div class="paragraph">
<p>Adding a check for the <code>aud</code> claim is simple with the <code>OAuth2TokenValidator</code> API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);

    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class AudienceValidator : OAuth2TokenValidator&lt;Jwt&gt; {
    var error: OAuth2Error = OAuth2Error("invalid_token", "The required audience is missing", null)
    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, to add into a resource server, it&#8217;s a matter of specifying the <code>ReactiveJwtDecoder</code> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
            ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = new AudienceValidator();
    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val audienceValidator: OAuth2TokenValidator&lt;Jwt&gt; = AudienceValidator()
    val withIssuer: OAuth2TokenValidator&lt;Jwt&gt; = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)
    jwtDecoder.setJwtValidator(withAudience)
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-minimaldependencies"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-minimaldependencies"></a>Minimal Dependencies for Introspection</h5>
<div class="paragraph">
<p>As described in <a href="#oauth2resourceserver-jwt-minimaldependencies">Minimal Dependencies for JWT</a> most of Resource Server support is collected in <code>spring-security-oauth2-resource-server</code>.
However unless a custom <a href="#webflux-oauth2resourceserver-opaque-introspector-bean"><code>ReactiveOpaqueTokenIntrospector</code></a> is provided, the Resource Server will fallback to ReactiveOpaqueTokenIntrospector.
Meaning that both <code>spring-security-oauth2-resource-server</code> and <code>oauth2-oidc-sdk</code> are necessary in order to have a working minimal Resource Server that supports opaque Bearer Tokens.
Please refer to <code>spring-security-oauth2-resource-server</code> in order to determin the correct version for <code>oauth2-oidc-sdk</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-minimalconfiguration"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-minimalconfiguration"></a>Minimal Configuration for Introspection</h5>
<div class="paragraph">
<p>Typically, an opaque token can be verified via an <a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Introspection Endpoint</a>, hosted by the authorization server.
This can be handy when revocation is a requirement.</p>
</div>
<div class="paragraph">
<p>When using <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, configuring an application as a resource server that uses introspection consists of two basic steps.
First, include the needed dependencies and second, indicate the introspection endpoint details.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspectionuri"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspectionuri"></a>Specifying the Authorization Server</h6>
<div class="paragraph">
<p>To specify where the introspection endpoint is, simply do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code><a href="https://idp.example.com/introspect" class="bare">https://idp.example.com/introspect</a></code> is the introspection endpoint hosted by your authorization server and <code>client-id</code> and <code>client-secret</code> are the credentials needed to hit that endpoint.</p>
</div>
<div class="paragraph">
<p>Resource Server will use these properties to further self-configure and subsequently validate incoming JWTs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using introspection, the authorization server&#8217;s word is the law.
If the authorization server responses that the token is valid, then it is.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
<div class="sect5">
<h6 id="_startup_expectations_2"><a class="anchor" href="#_startup_expectations_2"></a>Startup Expectations</h6>
<div class="paragraph">
<p>When this property and these dependencies are used, Resource Server will automatically configure itself to validate Opaque Bearer Tokens.</p>
</div>
<div class="paragraph">
<p>This startup process is quite a bit simpler than for JWTs since no endpoints need to be discovered and no additional validation rules get added.</p>
</div>
</div>
<div class="sect5">
<h6 id="_runtime_expectations_2"><a class="anchor" href="#_runtime_expectations_2"></a>Runtime Expectations</h6>
<div class="paragraph">
<p>Once the application is started up, Resource Server will attempt to process any request containing an <code>Authorization: Bearer</code> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.</p>
</div>
<div class="paragraph">
<p>Given an Opaque Token, Resource Server will</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Query the provided introspection endpoint using the provided credentials and the token</p>
</li>
<li>
<p>Inspect the response for an <code>{ 'active' : true }</code> attribute</p>
</li>
<li>
<p>Map each scope to an authority with the prefix <code>SCOPE_</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting <code>Authentication#getPrincipal</code>, by default, is a Spring Security <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html">OAuth2AuthenticatedPrincipal</a></code> object, and <code>Authentication#getName</code> maps to the token&#8217;s <code>sub</code> property, if one is present.</p>
</div>
<div class="paragraph">
<p>From here, you may want to jump to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-attributes">Looking Up Attributes Post-Authentication</a></p>
</li>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-authorization-extraction">Extracting Authorities Manually</a></p>
</li>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-jwt-introspector">Using Introspection with JWTs</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-attributes"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-attributes"></a>Looking Up Attributes Post-Authentication</h5>
<div class="paragraph">
<p>Once a token is authenticated, an instance of <code>BearerTokenAuthentication</code> is set in the <code>SecurityContext</code>.</p>
</div>
<div class="paragraph">
<p>This means that it&#8217;s available in <code>@Controller</code> methods when using <code>@EnableWebFlux</code> in your configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    return Mono.just(authentication.getTokenAttributes().get("sub") + " is the subject");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): Mono&lt;String&gt; {
    return Mono.just(authentication.tokenAttributes["sub"].toString() + " is the subject")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since <code>BearerTokenAuthentication</code> holds an <code>OAuth2AuthenticatedPrincipal</code>, that also means that it&#8217;s available to controller methods, too:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/foo")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return Mono.just(principal.getAttribute("sub") + " is the subject");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): Mono&lt;String&gt; {
    return Mono.just(principal.getAttribute&lt;Any&gt;("sub").toString() + " is the subject")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_looking_up_attributes_via_spel"><a class="anchor" href="#_looking_up_attributes_via_spel"></a>Looking Up Attributes Via SpEL</h6>
<div class="paragraph">
<p>Of course, this also means that attributes can be accessed via SpEL.</p>
</div>
<div class="paragraph">
<p>For example, if using <code>@EnableReactiveMethodSecurity</code> so that you can use <code>@PreAuthorize</code> annotations, you can do:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public Mono&lt;String&gt; forFoosEyesOnly() {
    return Mono.just("foo");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("principal.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): Mono&lt;String&gt; {
    return Mono.just("foo")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-sansboot"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-sansboot"></a>Overriding or Replacing Boot Auto Configuration</h5>
<div class="paragraph">
<p>There are two <code>@Bean</code> s that Spring Boot generates on Resource Server&#8217;s behalf.</p>
</div>
<div class="paragraph">
<p>The first is a <code>SecurityWebFilterChain</code> that configures the app as a resource server.
When use Opaque Token, this <code>SecurityWebFilterChain</code> looks like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		.authorizeExchange(exchanges -&gt; exchanges
			.anyExchange().authenticated()
		)
		.oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken)
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>SecurityWebFilterChain</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>Replacing this is as simple as exposing the bean within the application:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. Replacing SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class MyCustomSecurityConfiguration {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myIntrospector())
                )
            );
        return http.build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/messages/**", hasAuthority("SCOPE_message:read"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspector = myIntrospector()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above requires the scope of <code>message:read</code> for any URL that starts with <code>/messages/</code>.</p>
</div>
<div class="paragraph">
<p>Methods on the <code>oauth2ResourceServer</code> DSL will also override or replace auto configuration.</p>
</div>
<div class="paragraph">
<p>For example, the second <code>@Bean</code> Spring Boot creates is a <code>ReactiveOpaqueTokenIntrospector</code>, which decodes <code>String</code> tokens into validated instances of <code>OAuth2AuthenticatedPrincipal</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the application doesn&#8217;t expose a <code>ReactiveOpaqueTokenIntrospector</code> bean, then Spring Boot will expose the above default one.</p>
</div>
<div class="paragraph">
<p>And its configuration can be overridden using <code>introspectionUri()</code> and <code>introspectionClientCredentials()</code> or replaced using <code>introspector()</code>.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspectionuri-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspectionuri-dsl"></a>Using <code>introspectionUri()</code></h6>
<div class="paragraph">
<p>An authorization server&#8217;s Introspection Uri can be configured <a href="#webflux-oauth2resourceserver-opaque-introspectionuri">as a configuration property</a> or it can be supplied in the DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class DirectlyConfiguredIntrospectionUri {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
        return http.build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspectionUri = "https://idp.example.com/introspect"
                introspectionClientCredentials("client", "secret")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>introspectionUri()</code> takes precedence over any configuration property.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspector-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspector-dsl"></a>Using <code>introspector()</code></h6>
<div class="paragraph">
<p>More powerful than <code>introspectionUri()</code> is <code>introspector()</code>, which will completely replace any Boot auto configuration of <code>ReactiveOpaqueTokenIntrospector</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class DirectlyConfiguredIntrospector {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
        return http.build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspector = myCustomIntrospector()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is handy when deeper configuration, like <a href="#webflux-oauth2resourceserver-opaque-authorization-extraction">authority mapping</a>or <a href="#webflux-oauth2resourceserver-opaque-jwt-introspector">JWT revocation</a> is necessary.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspector-bean"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspector-bean"></a>Exposing a <code>ReactiveOpaqueTokenIntrospector</code> <code>@Bean</code></h6>
<div class="paragraph">
<p>Or, exposing a <code>ReactiveOpaqueTokenIntrospector</code> <code>@Bean</code> has the same effect as <code>introspector()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-authorization"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-authorization"></a>Configuring Authorization</h5>
<div class="paragraph">
<p>An OAuth 2.0 Introspection endpoint will typically return a <code>scope</code> attribute, indicating the scopes (or authorities) it&#8217;s been granted, for example:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string "SCOPE_".</p>
</div>
<div class="paragraph">
<p>This means that to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
public class MappedAuthorities {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchange -&gt; exchange
                .pathMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .pathMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken);
        return http.build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
            authorize("/messages/**", hasAuthority("SCOPE_messages"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or similarly with method security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public Flux&lt;Message&gt; getMessages(...) {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): Flux&lt;Message&gt; { }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-authorization-extraction"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-authorization-extraction"></a>Extracting Authorities Manually</h6>
<div class="paragraph">
<p>By default, Opaque Token support will extract the scope claim from an introspection response and parse it into individual <code>GrantedAuthority</code> instances.</p>
</div>
<div class="paragraph">
<p>For example, if the introspection response were:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "active" : true,
    "scope" : "message:read message:write"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then Resource Server would generate an <code>Authentication</code> with two authorities, one for <code>message:read</code> and the other for <code>message:write</code>.</p>
</div>
<div class="paragraph">
<p>This can, of course, be customized using a custom <code>ReactiveOpaqueTokenIntrospector</code> that takes a look at the attribute set and converts in its own way:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomAuthoritiesOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return this.delegate.introspect(token)
                .map(principal -&gt; new DefaultOAuth2AuthenticatedPrincipal(
                        principal.getName(), principal.getAttributes(), extractAuthorities(principal)));
    }

    private Collection&lt;GrantedAuthority&gt; extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List&lt;String&gt; scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CustomAuthoritiesOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .map { principal: OAuth2AuthenticatedPrincipal -&gt;
                    DefaultOAuth2AuthenticatedPrincipal(
                            principal.name, principal.attributes, extractAuthorities(principal))
                }
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection&lt;GrantedAuthority&gt; {
        val scopes = principal.getAttribute&lt;List&lt;String&gt;&gt;(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-jwt-introspector"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-jwt-introspector"></a>Using Introspection with JWTs</h5>
<div class="paragraph">
<p>A common question is whether or not introspection is compatible with JWTs.
Spring Security&#8217;s Opaque Token support has been designed to not care about the format of the token&#8201;&#8212;&#8201;it will gladly pass any token to the introspection endpoint provided.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s say that you&#8217;ve got a requirement that requires you to check with the authorization server on each request, in case the JWT has been revoked.</p>
</div>
<div class="paragraph">
<p>Even though you are using the JWT format for the token, your validation method is introspection, meaning you&#8217;d want to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the resulting <code>Authentication</code> would be <code>BearerTokenAuthentication</code>.
Any attributes in the corresponding <code>OAuth2AuthenticatedPrincipal</code> would be whatever was returned by the introspection endpoint.</p>
</div>
<div class="paragraph">
<p>But, let&#8217;s say that, oddly enough, the introspection endpoint only returns whether or not the token is active.
Now what?</p>
</div>
<div class="paragraph">
<p>In this case, you can create a custom <code>ReactiveOpaqueTokenIntrospector</code> that still hits the endpoint, but then updates the returned principal to have the JWTs claims as the attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class JwtOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
	private ReactiveOpaqueTokenIntrospector delegate =
			new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
	private ReactiveJwtDecoder jwtDecoder = new NimbusReactiveJwtDecoder(new ParseOnlyJWTProcessor());

	public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
		return this.delegate.introspect(token)
				.flatMap(principal -&gt; this.jwtDecoder.decode(token))
				.map(jwt -&gt; new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES));
	}

	private static class ParseOnlyJWTProcessor implements Converter&lt;JWT, Mono&lt;JWTClaimsSet&gt;&gt; {
		public Mono&lt;JWTClaimsSet&gt; convert(JWT jwt) {
			try {
				return Mono.just(jwt.getJWTClaimsSet());
			} catch (Exception ex) {
				return Mono.error(ex);
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class JwtOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: ReactiveJwtDecoder = NimbusReactiveJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .flatMap { jwtDecoder.decode(token) }
                .map { jwt: Jwt -&gt; DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES) }
    }

    private class ParseOnlyJWTProcessor : Converter&lt;JWT, Mono&lt;JWTClaimsSet&gt;&gt; {
        override fun convert(jwt: JWT): Mono&lt;JWTClaimsSet&gt; {
            return try {
                Mono.just(jwt.jwtClaimsSet)
            } catch (e: Exception) {
                Mono.error(e)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Thereafter, this custom introspector can be configured simply by exposing it as a <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntropsector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-userinfo"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-userinfo"></a>Calling a <code>/userinfo</code> Endpoint</h5>
<div class="paragraph">
<p>Generally speaking, a Resource Server doesn&#8217;t care about the underlying user, but instead about the authorities that have been granted.</p>
</div>
<div class="paragraph">
<p>That said, at times it can be valuable to tie the authorization statement back to a user.</p>
</div>
<div class="paragraph">
<p>If an application is also using <code>spring-security-oauth2-client</code>, having set up the appropriate <code>ClientRegistrationRepository</code>, then this is quite simple with a custom <code>OpaqueTokenIntrospector</code>.
This implementation below does three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Delegates to the introspection endpoint, to affirm the token&#8217;s validity</p>
</li>
<li>
<p>Looks up the appropriate client registration associated with the <code>/userinfo</code> endpoint</p>
</li>
<li>
<p>Invokes and returns the response from the <code>/userinfo</code> endpoint</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
	private final ReactiveOpaqueTokenIntrospector delegate =
			new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
	private final ReactiveOAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oauth2UserService =
			new DefaultReactiveOAuth2UserService();

	private final ReactiveClientRegistrationRepository repository;

	// ... constructor

	@Override
	public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
		return Mono.zip(this.delegate.introspect(token), this.repository.findByRegistrationId("registration-id"))
				.map(t -&gt; {
					OAuth2AuthenticatedPrincipal authorized = t.getT1();
					ClientRegistration clientRegistration = t.getT2();
					Instant issuedAt = authorized.getAttribute(ISSUED_AT);
					Instant expiresAt = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT);
					OAuth2AccessToken accessToken = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
					return new OAuth2UserRequest(clientRegistration, accessToken);
				})
				.flatMap(this.oauth2UserService::loadUser);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService: ReactiveOAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; = DefaultReactiveOAuth2UserService()
    private val repository: ReactiveClientRegistrationRepository? = null

    // ... constructor
    override fun introspect(token: String?): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return Mono.zip&lt;OAuth2AuthenticatedPrincipal, ClientRegistration&gt;(delegate.introspect(token), repository!!.findByRegistrationId("registration-id"))
                .map&lt;OAuth2UserRequest&gt; { t: Tuple2&lt;OAuth2AuthenticatedPrincipal, ClientRegistration&gt; -&gt;
                    val authorized = t.t1
                    val clientRegistration = t.t2
                    val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
                    val expiresAt: Instant? = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT)
                    val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
                    OAuth2UserRequest(clientRegistration, accessToken)
                }
                .flatMap { userRequest: OAuth2UserRequest -&gt; oauth2UserService.loadUser(userRequest) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you aren&#8217;t using <code>spring-security-oauth2-client</code>, it&#8217;s still quite simple.
You will simply need to invoke the <code>/userinfo</code> with your own instance of <code>WebClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private final ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return this.delegate.introspect(token)
		        .map(this::makeUserInfoRequest);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .map(this::makeUserInfoRequest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Either way, having created your <code>ReactiveOpaqueTokenIntrospector</code>, you should publish it as a <code>@Bean</code> to override the defaults:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveOpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-multitenancy"><a class="anchor" href="#webflux-oauth2resourceserver-multitenancy"></a>Multi-tenancy</h4>
<div class="paragraph">
<p>A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.</p>
</div>
<div class="paragraph">
<p>For example, your resource server may accept bearer tokens from two different authorization servers.
Or, your authorization server may represent a multiplicity of issuers.</p>
</div>
<div class="paragraph">
<p>In each case, there are two things that need to be done and trade-offs associated with how you choose to do them:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Resolve the tenant</p>
</li>
<li>
<p>Propagate the tenant</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_resolving_the_tenant_by_claim"><a class="anchor" href="#_resolving_the_tenant_by_claim"></a>Resolving the Tenant By Claim</h5>
<div class="paragraph">
<p>One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the <code>JwtIssuerReactiveAuthenticationManagerResolver</code>, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerReactiveAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeExchange(exchanges -&gt; exchanges
        .anyExchange().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")

return http {
    authorizeExchange {
        authorize(anyExchange, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is nice because the issuer endpoints are loaded lazily.
In fact, the corresponding <code>JwtReactiveAuthenticationManager</code> is instantiated only when the first request with the corresponding issuer is sent.
This allows for an application startup that is independent from those authorization servers being up and available.</p>
</div>
<div class="sect5">
<h6 id="_dynamic_tenants"><a class="anchor" href="#_dynamic_tenants"></a>Dynamic Tenants</h6>
<div class="paragraph">
<p>Of course, you may not want to restart the application each time a new tenant is added.
In this case, you can configure the <code>JwtIssuerReactiveAuthenticationManagerResolver</code> with a repository of <code>ReactiveAuthenticationManager</code> instances, which you can edit at runtime, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Mono&lt;ReactiveAuthenticationManager&gt; addManager(
		Map&lt;String, ReactiveAuthenticationManager&gt; authenticationManagers, String issuer) {

	return Mono.fromCallable(() -&gt; ReactiveJwtDecoders.fromIssuerLocation(issuer))
            .subscribeOn(Schedulers.boundedElastic())
            .map(JwtReactiveAuthenticationManager::new)
            .doOnNext(authenticationManager -&gt; authenticationManagers.put(issuer, authenticationManager));
}

// ...

JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeExchange(exchanges -&gt; exchanges
        .anyExchange().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">private fun addManager(
        authenticationManagers: MutableMap&lt;String, ReactiveAuthenticationManager&gt;, issuer: String): Mono&lt;JwtReactiveAuthenticationManager&gt; {
    return Mono.fromCallable { ReactiveJwtDecoders.fromIssuerLocation(issuer) }
            .subscribeOn(Schedulers.boundedElastic())
            .map { jwtDecoder: ReactiveJwtDecoder -&gt; JwtReactiveAuthenticationManager(jwtDecoder) }
            .doOnNext { authenticationManager: JwtReactiveAuthenticationManager -&gt; authenticationManagers[issuer] = authenticationManager }
}

// ...

var customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get)
return http {
    authorizeExchange {
        authorize(anyExchange, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, you construct <code>JwtIssuerReactiveAuthenticationManagerResolver</code> with a strategy for obtaining the <code>ReactiveAuthenticationManager</code> given the issuer.
This approach allows us to add and remove elements from the repository (shown as a <code>Map</code> in the snippet) at runtime.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It would be unsafe to simply take any issuer and construct an <code>ReactiveAuthenticationManager</code> from it.
The issuer should be one that the code can verify from a trusted source like an allowed list of issuers.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-bearertoken-resolver"><a class="anchor" href="#webflux-oauth2resourceserver-bearertoken-resolver"></a>Bearer Token Resolution</h4>
<div class="paragraph">
<p>By default, Resource Server looks for a bearer token in the <code>Authorization</code> header.
This, however, can be customized.</p>
</div>
<div class="paragraph">
<p>For example, you may have a need to read the bearer token from a custom header.
To achieve this, you can wire an instance of <code>ServerBearerTokenAuthenticationConverter</code> into the DSL, as you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Custom Bearer Token Header</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ServerBearerTokenAuthenticationConverter converter = new ServerBearerTokenAuthenticationConverter();
converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
http
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .bearerTokenConverter(converter)
    );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val converter = ServerBearerTokenAuthenticationConverter()
converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
return http {
    oauth2ResourceServer {
        bearerTokenConverter = converter
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bearer_token_propagation"><a class="anchor" href="#_bearer_token_propagation"></a>Bearer Token Propagation</h4>
<div class="paragraph">
<p>Now that you&#8217;re in possession of a bearer token, it might be handy to pass that to downstream services.
This is quite simple with <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServerBearerExchangeFilterFunction.html">ServerBearerExchangeFilterFunction</a></code>, which you can see in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServerBearerExchangeFilterFunction())
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServerBearerExchangeFilterFunction())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the above <code>WebClient</code> is used to perform requests, Spring Security will look up the current <code>Authentication</code> and extract any <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/AbstractOAuth2Token.html">AbstractOAuth2Token</a></code> credential.
Then, it will propagate that token in the <code>Authorization</code> header.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono&lt;String&gt;()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Will invoke the <code><a href="https://other-service.example.com/endpoint" class="bare">https://other-service.example.com/endpoint</a></code>, adding the bearer token <code>Authorization</code> header for you.</p>
</div>
<div class="paragraph">
<p>In places where you need to override this behavior, it&#8217;s a simple matter of supplying the header yourself, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -&gt; headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers { it.setBearerAuth(overridingToken) }
        .retrieve()
        .bodyToMono&lt;String&gt;()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the filter will fall back and simply forward the request onto the rest of the web filter chain.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the <a href="https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServerOAuth2AuthorizedClientExchangeFilterFunction.html">OAuth 2.0 Client filter function</a>, this filter function makes no attempt to renew the token, should it be expired.
To obtain this level of support, please use the OAuth 2.0 Client filter.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-roac"><a class="anchor" href="#webflux-roac"></a>@RegisteredOAuth2AuthorizedClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security allows resolving an access token using <code>@RegisteredOAuth2AuthorizedClient</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A working example can be found in <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/oauth2/webclient"><strong>OAuth 2.0 WebClient WebFlux sample</strong></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After configuring Spring Security for <a href="#webflux-oauth2-login">OAuth2 Login</a> or as an <a href="#webflux-oauth2-client">OAuth2 Client</a>, an <code>OAuth2AuthorizedClient</code> can be resolved using the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This integrates into Spring Security to provide the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security will automatically refresh expired tokens (if a refresh token is present)</p>
</li>
<li>
<p>If an access token is requested and not present, Spring Security will automatically request the access token.</p>
<div class="ulist">
<ul>
<li>
<p>For <code>authorization_code</code> this involves performing the redirect and then replaying the original request</p>
</li>
<li>
<p>For <code>client_credentials</code> the token is simply requested and saved</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the user authenticated using <code>oauth2Login()</code>, then the <code>client-id</code> is optional.
For example, the following would work:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/implicit")
Mono&lt;String&gt; implicit(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/implicit")
fun implicit(@RegisteredOAuth2AuthorizedClient authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is convenient if the user always authenticates with OAuth2 Login and an access token from the same authorization server is needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-x509"><a class="anchor" href="#reactive-x509"></a>Reactive X.509 Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Similar to <a href="#servlet-x509">Servlet X.509 authentication</a>, reactive x509 authentication filter allows extracting an authentication token from a certificate provided by a client.</p>
</div>
<div class="paragraph">
<p>Below is an example of a reactive x509 security configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
	http
		.x509(withDefaults())
		.authorizeExchange(exchanges -&gt; exchanges
		    .anyExchange().permitAll()
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        x509 { }
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the configuration above, when neither <code>principalExtractor</code> nor <code>authenticationManager</code> is provided defaults will be used. The default principal extractor is <code>SubjectDnX509PrincipalExtractor</code> which extracts the CN (common name) field from a certificate provided by a client. The default authentication manager is <code>ReactivePreAuthenticatedAuthenticationManager</code> which performs user account validation, checking that user account with a name extracted by <code>principalExtractor</code> exists and it is not locked, disabled, or expired.</p>
</div>
<div class="paragraph">
<p>The next example demonstrates how these defaults can be overridden.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
	SubjectDnX509PrincipalExtractor principalExtractor =
	        new SubjectDnX509PrincipalExtractor();

	principalExtractor.setSubjectDnRegex("OU=(.*?)(?:,|$)");

	ReactiveAuthenticationManager authenticationManager = authentication -&gt; {
		authentication.setAuthenticated("Trusted Org Unit".equals(authentication.getName()));
		return Mono.just(authentication);
	};

	http
		.x509(x509 -&gt; x509
		    .principalExtractor(principalExtractor)
		    .authenticationManager(authenticationManager)
		)
		.authorizeExchange(exchanges -&gt; exchanges
		    .anyExchange().authenticated()
		);
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain? {
    val customPrincipalExtractor = SubjectDnX509PrincipalExtractor()
    customPrincipalExtractor.setSubjectDnRegex("OU=(.*?)(?:,|$)")
    val customAuthenticationManager = ReactiveAuthenticationManager { authentication: Authentication -&gt;
        authentication.isAuthenticated = "Trusted Org Unit" == authentication.name
        Mono.just(authentication)
    }
    return http {
        x509 {
            principalExtractor = customPrincipalExtractor
            authenticationManager = customAuthenticationManager
        }
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, a username is extracted from the OU field of a client certificate instead of CN, and account lookup using <code>ReactiveUserDetailsService</code> is not performed at all. Instead, if the provided certificate issued to an OU named "Trusted Org Unit", a request will be authenticated.</p>
</div>
<div class="paragraph">
<p>For an example of configuring Netty and <code>WebClient</code> or <code>curl</code> command-line tool to use mutual TLS and enable X.509 authentication, please refer to <a href="https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509" class="bare">https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_webclient"><a class="anchor" href="#_webclient"></a>WebClient</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following documentation is for use within Reactive environments.
For Servlet environments, refer to <a href="#oauth2Client-webclient-servlet">WebClient for Servlet</a> environments.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Framework has built in support for setting a Bearer token.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">webClient.get()
    .headers(h -&gt; h.setBearerAuth(token))
    ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">webClient.get()
    .headers { it.setBearerAuth(token) }
    ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security builds on this support to provide additional benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security will automatically refresh expired tokens (if a refresh token is present)</p>
</li>
<li>
<p>If an access token is requested and not present, Spring Security will automatically request the access token.</p>
<div class="ulist">
<ul>
<li>
<p>For authorization_code this involves performing the redirect and then replaying the original request</p>
</li>
<li>
<p>For client_credentials the token is simply requested and saved</p>
</li>
</ul>
</div>
</li>
<li>
<p>Support for the ability to transparently include the current OAuth token or explicitly select which token should be used.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="webclient-setup"><a class="anchor" href="#webclient-setup"></a>WebClient OAuth2 Setup</h3>
<div class="paragraph">
<p>The first step is ensuring to setup the <code>WebClient</code> correctly.
An example of setting up <code>WebClient</code> in a fully reactive environment can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
WebClient webClient(ReactiveClientRegistrationRepository clientRegistrations,
		ServerOAuth2AuthorizedClientRepository authorizedClients) {
	ServerOAuth2AuthorizedClientExchangeFilterFunction oauth =
			new ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients);
	// (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
	// oauth.setDefaultOAuth2AuthorizedClient(true);
	// (optional) set a default ClientRegistration.registrationId
	// oauth.setDefaultClientRegistrationId("client-registration-id");
	return WebClient.builder()
			.filter(oauth)
			.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun webClient(clientRegistrations: ReactiveClientRegistrationRepository,
              authorizedClients: ServerOAuth2AuthorizedClientRepository): WebClient {
    val oauth = ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients)
    // (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
    // oauth.setDefaultOAuth2AuthorizedClient(true)
    // (optional) set a default ClientRegistration.registrationId
    // oauth.setDefaultClientRegistrationId("client-registration-id")
    return WebClient.builder()
            .filter(oauth)
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-implicit"><a class="anchor" href="#webclient-implicit"></a>Implicit OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>If we set <code>defaultOAuth2AuthorizedClient</code> to <code>true</code> in our setup and the user authenticated with oauth2Login (i.e. OIDC), then the current authentication is used to automatically provide the access token.
Alternatively,  if we set <code>defaultClientRegistrationId</code> to a valid <code>ClientRegistration</code> id, that registration is used to provide the access token.
This is convenient, but in environments where not all endpoints should get the access token, it is dangerous (you might provide the wrong access token to an endpoint).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; body = this.webClient
		.get()
		.uri(this.uri)
		.retrieve()
		.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val body: Mono&lt;String&gt; = webClient
        .get()
        .uri(this.uri)
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-explicit"><a class="anchor" href="#webclient-explicit"></a>Explicit OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>The <code>OAuth2AuthorizedClient</code> can be explicitly provided by setting it on the requests attributes.
In the example below we resolve the <code>OAuth2AuthorizedClient</code> using Spring WebFlux or Spring MVC argument resolver support.
However, it does not matter how the <code>OAuth2AuthorizedClient</code> is resolved.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
	return this.webClient
			.get()
			.uri(this.uri)
			.attributes(oauth2AuthorizedClient(authorizedClient))
			.retrieve()
			.bodyToMono(String.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    return this.webClient
            .get()
            .uri(uri)
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-clientregistrationid"><a class="anchor" href="#webclient-clientregistrationid"></a>clientRegistrationId</h3>
<div class="paragraph">
<p>Alternatively, it is possible to specify the <code>clientRegistrationId</code> on the request attributes and the <code>WebClient</code> will attempt to lookup the <code>OAuth2AuthorizedClient</code>.
If it is not found, one will automatically be acquired.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; body = this.webClient
		.get()
		.uri(this.uri)
		.attributes(clientRegistrationId("client-id"))
		.retrieve()
		.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val body: Mono&lt;String&gt; = this.webClient
        .get()
        .uri(uri)
        .attributes(clientRegistrationId("client-id"))
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-erms"><a class="anchor" href="#jc-erms"></a>EnableReactiveMethodSecurity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security supports method security using <a href="https://projectreactor.io/docs/core/release/reference/#context">Reactor&#8217;s Context</a> which is setup using <code>ReactiveSecurityContextHolder</code>.
For example, this demonstrates how to retrieve the currently logged in user&#8217;s message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For this to work the return type of the method must be a <code>org.reactivestreams.Publisher</code> (i.e. <code>Mono</code>/<code>Flux</code>) or the function must be a Kotlin coroutine function.
This is necessary to integrate with Reactor&#8217;s <code>Context</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Authentication authentication = new TestingAuthenticationToken("user", "password", "ROLE_USER");

Mono&lt;String&gt; messageByUsername = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername)
	// In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication));

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val authentication: Authentication = TestingAuthenticationToken("user", "password", "ROLE_USER")

val messageByUsername: Mono&lt;String&gt; = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername) // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication))

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>with <code>this::findMessageByUsername</code> defined as:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; findMessageByUsername(String username) {
	return Mono.just("Hi " + username);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun findMessageByUsername(username: String): Mono&lt;String&gt; {
	return Mono.just("Hi $username")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Below is a minimal method security configuration when using method security in reactive applications.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableReactiveMethodSecurity
public class SecurityConfig {
	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build();
		UserDetails admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER","ADMIN")
			.build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableReactiveMethodSecurity
class SecurityConfig {
	@Bean
	fun userDetailsService(): MapReactiveUserDetailsService {
		val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()
		val rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build()
		val admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER", "ADMIN")
			.build()
		return MapReactiveUserDetailsService(rob, admin)
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Consider the following class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	public Mono&lt;String&gt; findMessage() {
		return Mono.just("Hello World!");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	fun findMessage(): Mono&lt;String&gt; {
		return Mono.just("Hello World!")
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, the following class using Kotlin coroutines:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class HelloWorldMessageService {
    @PreAuthorize("hasRole('ADMIN')")
    suspend fun findMessage(): String {
        delay(10)
        return "Hello World!"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Combined with our configuration above, <code>@PreAuthorize("hasRole('ADMIN')")</code> will ensure that <code>findByMessage</code> is only invoked by a user with the role <code>ADMIN</code>.
It is important to note that any of the expressions in standard method security work for <code>@EnableReactiveMethodSecurity</code>.
However, at this time we only support return type of <code>Boolean</code> or <code>boolean</code> of the expression.
This means that the expression must not block.</p>
</div>
<div class="paragraph">
<p>When integrating with <a href="#jc-webflux">WebFlux Security</a>, the Reactor Context is automatically established by Spring Security according to the authenticated user.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {

	@Bean
	SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {
		return http
			// Demonstrate that method security works
			// Best practice to use both for defense in depth
			.authorizeExchange(exchanges -&gt; exchanges
				.anyExchange().permitAll()
			)
			.httpBasic(withDefaults())
			.build();
	}

	@Bean
	MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build();
		UserDetails admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER","ADMIN")
			.build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
class SecurityConfig {
	@Bean
	open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
		return http {
			authorizeExchange {
				authorize(anyExchange, permitAll)
			}
			httpBasic { }
		}
	}

	@Bean
	fun userDetailsService(): MapReactiveUserDetailsService {
		val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()
		val rob = userBuilder.username("rob")
			.password("rob")
			.roles("USER")
			.build()
		val admin = userBuilder.username("admin")
			.password("admin")
			.roles("USER", "ADMIN")
			.build()
		return MapReactiveUserDetailsService(rob, admin)
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find a complete sample in <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/webflux/java/method">hellowebflux-method</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a>CORS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework provides <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-cors-intro">first class support for CORS</a>.
CORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the <code>JSESSIONID</code>).
If the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it.</p>
</div>
<div class="paragraph">
<p>The easiest way to ensure that CORS is handled first is to use the <code>CorsWebFilter</code>.
Users can integrate the <code>CorsWebFilter</code> with Spring Security by providing a <code>CorsConfigurationSource</code>.
For example, the following will integrate CORS support within Spring Security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
CorsConfigurationSource corsConfigurationSource() {
	CorsConfiguration configuration = new CorsConfiguration();
	configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
	configuration.setAllowedMethods(Arrays.asList("GET","POST"));
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	source.registerCorsConfiguration("/**", configuration);
	return source;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun corsConfigurationSource(): CorsConfigurationSource {
    val configuration = CorsConfiguration()
    configuration.allowedOrigins = listOf("https://example.com")
    configuration.allowedMethods = listOf("GET", "POST")
    val source = UrlBasedCorsConfigurationSource()
    source.registerCorsConfiguration("/**", configuration)
    return source
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following will disable the CORS integration within Spring Security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.cors(cors -&gt; cors.disable());
	return http.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        cors {
            disable()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-webflux"><a class="anchor" href="#test-webflux"></a>Reactive Test Support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="test-erms"><a class="anchor" href="#test-erms"></a>Testing Reactive Method Security</h3>
<div class="paragraph">
<p>For example, we can test our example from <a href="#jc-erms">EnableReactiveMethodSecurity</a> using the same setup and annotations we did in <a href="#test-method">[test-method]</a>.
Here is a minimal sample of what we can do:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWorldMessageServiceTests {
	@Autowired
	HelloWorldMessageService messages;

	@Test
	public void messagesWhenNotAuthenticatedThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser
	public void messagesWhenUserThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser(roles = "ADMIN")
	public void messagesWhenAdminThenOk() {
		StepVerifier.create(this.messages.findMessage())
			.expectNext("Hello World!")
			.verifyComplete();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RunWith(SpringRunner::class)
@ContextConfiguration(classes = [HelloWebfluxMethodApplication::class])
class HelloWorldMessageServiceTests {
    @Autowired
    lateinit var messages: HelloWorldMessageService

    @Test
    fun messagesWhenNotAuthenticatedThenDenied() {
        StepVerifier.create(messages.findMessage())
            .expectError(AccessDeniedException::class.java)
            .verify()
    }

    @Test
    @WithMockUser
    fun messagesWhenUserThenDenied() {
        StepVerifier.create(messages.findMessage())
            .expectError(AccessDeniedException::class.java)
            .verify()
    }

    @Test
    @WithMockUser(roles = ["ADMIN"])
    fun messagesWhenAdminThenOk() {
        StepVerifier.create(messages.findMessage())
            .expectNext("Hello World!")
            .verifyComplete()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-webtestclient"><a class="anchor" href="#test-webtestclient"></a>WebTestClientSupport</h3>
<div class="paragraph">
<p>Spring Security provides integration with <code>WebTestClient</code>.
The basic setup looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWebfluxMethodApplicationTests {
	@Autowired
	ApplicationContext context;

	WebTestClient rest;

	@Before
	public void setup() {
		this.rest = WebTestClient
			.bindToApplicationContext(this.context)
			// add Spring Security test Support
			.apply(springSecurity())
			.configureClient()
			.filter(basicAuthentication())
			.build();
	}
	// ...
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_authentication"><a class="anchor" href="#_authentication"></a>Authentication</h4>
<div class="paragraph">
<p>After applying the Spring Security support to <code>WebTestClient</code> we can use either annotations or <code>mutateWith</code> support.
For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void messageWhenNotAuthenticated() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isUnauthorized();
}

// --- WithMockUser ---

@Test
@WithMockUser
public void messageWhenWithMockUserThenForbidden() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
@WithMockUser(roles = "ADMIN")
public void messageWhenWithMockAdminThenOk() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}

// --- mutateWith mockUser ---

@Test
public void messageWhenMutateWithMockUserThenForbidden() throws Exception {
	this.rest
		.mutateWith(mockUser())
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
public void messageWhenMutateWithMockAdminThenOk() throws Exception {
	this.rest
		.mutateWith(mockUser().roles("ADMIN"))
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.reactive.server.expectBody

//...

@Test
@WithMockUser
fun messageWhenWithMockUserThenForbidden() {
    this.rest.get().uri("/message")
        .exchange()
        .expectStatus().isEqualTo(HttpStatus.FORBIDDEN)
}

@Test
@WithMockUser(roles = ["ADMIN"])
fun messageWhenWithMockAdminThenOk() {
    this.rest.get().uri("/message")
        .exchange()
        .expectStatus().isOk
        .expectBody&lt;String&gt;().isEqualTo("Hello World!")

}

// --- mutateWith mockUser ---

@Test
fun messageWhenMutateWithMockUserThenForbidden() {
    this.rest
        .mutateWith(mockUser())
        .get().uri("/message")
        .exchange()
        .expectStatus().isEqualTo(HttpStatus.FORBIDDEN)
}

@Test
fun messageWhenMutateWithMockAdminThenOk() {
    this.rest
        .mutateWith(mockUser().roles("ADMIN"))
        .get().uri("/message")
        .exchange()
        .expectStatus().isOk
        .expectBody&lt;String&gt;().isEqualTo("Hello World!")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_csrf_support"><a class="anchor" href="#_csrf_support"></a>CSRF Support</h4>
<div class="paragraph">
<p>Spring Security also provides support for CSRF testing with <code>WebTestClient</code>.
For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.rest
	// provide a valid CSRF token
	.mutateWith(csrf())
	.post()
	.uri("/login")
	...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">this.rest
    // provide a valid CSRF token
    .mutateWith(csrf())
    .post()
    .uri("/login")
    ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2"><a class="anchor" href="#webflux-testing-oauth2"></a>Testing OAuth 2.0</h4>
<div class="paragraph">
<p>When it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the <code>SecurityContextHolder</code>.</p>
</div>
<div class="paragraph">
<p>For example, for a controller that looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(Principal user) {
    return Mono.just(user.getName());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(user: Principal): Mono&lt;String&gt; {
    return Mono.just(user.name)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s nothing OAuth2-specific about it, so you will likely be able to simply <a href="#test-erms">use <code>@WithMockUser</code></a> and be fine.</p>
</div>
<div class="paragraph">
<p>But, in cases where your controllers are bound to some aspect of Spring Security&#8217;s OAuth 2.0 support, like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser user) {
    return Mono.just(user.getIdToken().getSubject());
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal user: OidcUser): Mono&lt;String&gt; {
    return Mono.just(user.idToken.subject)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>then Spring Security&#8217;s test support can come in handy.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oidc-login"><a class="anchor" href="#webflux-testing-oidc-login"></a>Testing OIDC Login</h4>
<div class="paragraph">
<p>Testing the method above with <code>WebTestClient</code> would require simulating some kind of grant flow with an authorization server.
Certainly this would be a daunting task, which is why Spring Security ships with support for removing this boilerplate.</p>
</div>
<div class="paragraph">
<p>For example, we can tell Spring Security to include a default <code>OidcUser</code> using the <code>SecurityMockServerConfigurers#oidcLogin</code> method, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()).get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOidcLogin())
    .get().uri("/endpoint")
    .exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockServerRequest</code> with an <code>OidcUser</code> that includes a simple <code>OidcIdToken</code>, <code>OidcUserInfo</code>, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include an <code>OidcIdToken</code> with a <code>sub</code> claim set to <code>user</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(user.idToken.getClaim&lt;String&gt;("sub")).isEqualTo("user")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>an <code>OidcUserInfo</code> with no claims set:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(user.getUserInfo().getClaims()).isEmpty();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(user.userInfo.claims).isEmpty()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(user.authorities).hasSize(1)
assertThat(user.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OidcUser</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OidcUser</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits into a mock <code>ServerOAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#webflux-testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>..</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-authorities"><a class="anchor" href="#webflux-testing-oidc-login-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOidcLogin()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-claims"><a class="anchor" href="#webflux-testing-oidc-login-claims"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> claim that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oidcUser: OidcUser): Mono&lt;String&gt; {
    val userId = oidcUser.idToken.getClaim&lt;String&gt;("user_id")
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that claim with the <code>idToken()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .idToken(token -&gt; token.claim("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOidcLogin()
        .idToken { token -&gt; token.claim("user_id", "1234") }
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>since <code>OidcUser</code> collects its claims from <code>OidcIdToken</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-user"><a class="anchor" href="#webflux-testing-oidc-login-user"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>userInfo(OidcUserInfo.Builder)</code> - For configuring the <code>OidcUserInfo</code> instance</p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oidcUser(OidcUser)</code> - For configuring the complete <code>OidcUser</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OidcUser</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OidcUser</code> by hand:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        OidcIdToken.withTokenValue("id-token").claim("user_name", "foo_user").build(),
        "user_name");

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val oidcUser: OidcUser = DefaultOidcUser(
    AuthorityUtils.createAuthorityList("SCOPE_message:read"),
    OidcIdToken.withTokenValue("id-token").claim("user_name", "foo_user").build(),
    "user_name"
)

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-login"><a class="anchor" href="#webflux-testing-oauth2-login"></a>Testing OAuth 2.0 Login</h4>
<div class="paragraph">
<p>As with <a href="#webflux-testing-oidc-login">testing OIDC login</a>, testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow.
And because of that, Spring Security also has test support for non-OIDC use cases.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that gets the logged-in user as an <code>OAuth2User</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return Mono.just(oauth2User.getAttribute("sub"));
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono&lt;String&gt; {
    return Mono.just(oauth2User.getAttribute("sub"))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>OAuth2User</code> using the <code>SecurityMockServerConfigurers#oauth2User</code> method, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockServerRequest</code> with an <code>OAuth2User</code> that includes a simple <code>Map</code> of attributes and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat((String) user.getAttribute("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(user.getAttribute&lt;String&gt;("sub")).isEqualTo("user")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(user.authorities).hasSize(1)
assertThat(user.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>OAuth2User</code> instance is available for <a href="#mvc-authentication-principal">the <code>@AuthenticationPrincipal</code> annotation</a>.</p>
</div>
<div class="paragraph">
<p>Further, it also links that <code>OAuth2User</code> to a simple instance of <code>OAuth2AuthorizedClient</code> that it deposits in a mock <code>ServerOAuth2AuthorizedClientRepository</code>.
This can be handy if your tests <a href="#webflux-testing-oauth2-client">use the <code>@RegisteredOAuth2AuthorizedClient</code> annotation</a>.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-authorities"><a class="anchor" href="#webflux-testing-oauth2-login-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOAuth2Login()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-claims"><a class="anchor" href="#webflux-testing-oauth2-login-claims"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono&lt;String&gt; {
    val userId = oauth2User.getAttribute&lt;String&gt;("user_id")
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOAuth2Login()
        .attributes { attrs -&gt; attrs["user_id"] = "1234" }
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-user"><a class="anchor" href="#webflux-testing-oauth2-login-user"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the associated <code>OAuth2AuthorizedClient</code> with a given <code>ClientRegistration</code></p>
</li>
<li>
<p><code>oauth2User(OAuth2User)</code> - For configuring the complete <code>OAuth2User</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you:
1. Have your own implementation of <code>OAuth2User</code>, or
2. Need to change the name attribute</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> claim instead of the <code>sub</code> claim.
In that case, you can configure an <code>OAuth2User</code> by hand:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val oauth2User: OAuth2User = DefaultOAuth2User(
    AuthorityUtils.createAuthorityList("SCOPE_message:read"),
    mapOf(Pair("user_name", "foo_user")),
    "user_name"
)

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-client"><a class="anchor" href="#webflux-testing-oauth2-client"></a>Testing OAuth 2.0 Clients</h4>
<div class="paragraph">
<p>Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.
For example, your controller may be relying on the client credentials grant to get a token that isn&#8217;t associated with the user at all:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.reactive.function.client.bodyToMono

// ...

@GetMapping("/endpoint")
fun foo(@RegisteredOAuth2AuthorizedClient("my-app") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Simulating this handshake with the authorization server could be cumbersome.
Instead, you can use <code>SecurityMockServerConfigurers#oauth2Client</code> to add a <code>OAuth2AuthorizedClient</code> into a mock <code>ServerOAuth2AuthorizedClientRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>What this will do is create an <code>OAuth2AuthorizedClient</code> that has a simple <code>ClientRegistration</code>, <code>OAuth2AccessToken</code>, and resource owner name.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>ClientRegistration</code> with a client id of "test-client" and client secret of "test-secret":</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(authorizedClient.clientRegistration.clientId).isEqualTo("test-client")
assertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo("test-secret")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>a resource owner name of "user":</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(authorizedClient.principalName).isEqualTo("user")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and an <code>OAuth2AccessToken</code> with just one scope, <code>read</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(authorizedClient.accessToken.scopes).hasSize(1)
assertThat(authorizedClient.accessToken.scopes).containsExactly("read")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The client can then be retrieved as normal using <code>@RegisteredOAuth2AuthorizedClient</code> in a controller method.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-scopes"><a class="anchor" href="#webflux-testing-oauth2-client-scopes"></a>Configuring Scopes</h5>
<div class="paragraph">
<p>In many circumstances, the OAuth 2.0 access token comes with a set of scopes.
If your controller inspects these, say like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set&lt;String&gt; scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class);
    }
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.reactive.function.client.bodyToMono

// ...

@GetMapping("/endpoint")
fun foo(@RegisteredOAuth2AuthorizedClient("my-app") authorizedClient: OAuth2AuthorizedClient): Mono&lt;String&gt; {
    val scopes = authorizedClient.accessToken.scopes
    if (scopes.contains("message:read")) {
        return webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono()
    }
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>then you can configure the scope using the <code>accessToken()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read")))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(OAuth2AccessToken(BEARER, "token", null, null, setOf("message:read")))
)
.get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-registration"><a class="anchor" href="#webflux-testing-oauth2-client-registration"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principalName(String)</code> - For configuring the resource owner name</p>
</li>
<li>
<p><code>clientRegistration(Consumer&lt;ClientRegistration.Builder&gt;)</code> - For configuring the associated <code>ClientRegistration</code></p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - For configuring the complete <code>ClientRegistration</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That last one is handy if you want to use a real <code>ClientRegistration</code></p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that you are wanting to use one of your app&#8217;s <code>ClientRegistration</code> definitions, as specified in your <code>application.yml</code>.</p>
</div>
<div class="paragraph">
<p>In that case, your test can autowire the <code>ReactiveClientRegistrationRepository</code> and look up the one your test needs:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
ReactiveClientRegistrationRepository clientRegistrationRepository;

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook").block())
    )
    .get().uri("/exchange").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Autowired
lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook").block())
    )
    .get().uri("/exchange").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-jwt"><a class="anchor" href="#webflux-testing-jwt"></a>Testing JWT Authentication</h4>
<div class="paragraph">
<p>In order to make an authorized request on a resource server, you need a bearer token.
If your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification.
All of this can be quite daunting, especially when this isn&#8217;t the focus of your test.</p>
</div>
<div class="paragraph">
<p>Fortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.
We&#8217;ll look at two of them now:</p>
</div>
<div class="sect4">
<h5 id="_mockjwt_webtestclientconfigurer"><a class="anchor" href="#_mockjwt_webtestclientconfigurer"></a><code>mockJwt() WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>The first way is via a <code>WebTestClientConfigurer</code>.
The simplest of these would look something like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>What this will do is create a mock <code>Jwt</code>, passing it correctly through any authentication APIs so that it&#8217;s available for your authorization mechanisms to verify.</p>
</div>
<div class="paragraph">
<p>By default, the <code>JWT</code> that it creates has the following characteristics:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the resulting <code>Jwt</code>, were it tested, would pass in the following way:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(jwt.tokenValue).isEqualTo("token")
assertThat(jwt.headers["alg"]).isEqualTo("none")
assertThat(jwt.subject).isEqualTo("sub")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These values can, of course be configured.</p>
</div>
<div class="paragraph">
<p>Any headers or claims can be configured with their corresponding methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().jwt(jwt -&gt; jwt.header("kid", "one")
		.claim("iss", "https://idp.example.org")))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockJwt().jwt { jwt -&gt; jwt.header("kid", "one")
        .claim("iss", "https://idp.example.org")
    })
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().jwt(jwt -&gt; jwt.claims(claims -&gt; claims.remove("scope"))))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockJwt().jwt { jwt -&gt;
        jwt.claims { claims -&gt; claims.remove("scope") }
    })
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>scope</code> and <code>scp</code> claims are processed the same way here as they are in a normal bearer token request.
However, this can be overridden simply by providing the list of <code>GrantedAuthority</code> instances that you need for your test:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().authorities(new SimpleGrantedAuthority("SCOPE_messages")))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockJwt().authorities(SimpleGrantedAuthority("SCOPE_messages")))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, if you have a custom <code>Jwt</code> to <code>Collection&lt;GrantedAuthority&gt;</code> converter, you can also use that to derive the authorities:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
	.mutateWith(mockJwt().authorities(new MyConverter()))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockJwt().authorities(MyConverter()))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also specify a complete <code>Jwt</code>, for which <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/Jwt.Builder.html">Jwt.Builder</a></code> comes quite handy:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read")
    .build();

client
	.mutateWith(mockJwt().jwt(jwt))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwt: Jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read")
    .build()

client
    .mutateWith(mockJwt().jwt(jwt))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_authentication_webtestclientconfigurer"><a class="anchor" href="#_authentication_webtestclientconfigurer"></a><code>authentication()</code> <code>WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>The second way is by using the <code>authentication()</code> <code>Mutator</code>.
Essentially, you can instantiate your own <code>JwtAuthenticationToken</code> and provide it in your test, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

client
	.mutateWith(mockAuthentication(token))
	.get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build()
val authorities: Collection&lt;GrantedAuthority&gt; = AuthorityUtils.createAuthorityList("SCOPE_read")
val token = JwtAuthenticationToken(jwt, authorities)

client
    .mutateWith(mockAuthentication&lt;JwtMutator&gt;(token))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to these, you can also mock the <code>ReactiveJwtDecoder</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-opaque-token"><a class="anchor" href="#webflux-testing-opaque-token"></a>Testing Opaque Token Authentication</h4>
<div class="paragraph">
<p>Similar to <a href="#webflux-testing-jwt">JWTs</a>, opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult.
To help with that, Spring Security has test support for opaque tokens.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that we&#8217;ve got a controller that retrieves the authentication as a <code>BearerTokenAuthentication</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    return Mono.just((String) authentication.getTokenAttributes().get("sub"));
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(authentication: BearerTokenAuthentication): Mono&lt;String?&gt; {
    return Mono.just(authentication.tokenAttributes["sub"] as String?)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In that case, we can tell Spring Security to include a default <code>BearerTokenAuthentication</code> using the <code>SecurityMockServerConfigurers#opaqueToken</code> method, like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>What this will do is configure the associated <code>MockHttpServletRequest</code> with a <code>BearerTokenAuthentication</code> that includes a simple <code>OAuth2AuthenticatedPrincipal</code>, <code>Map</code> of attributes, and <code>Collection</code> of granted authorities.</p>
</div>
<div class="paragraph">
<p>Specifically, it will include a <code>Map</code> with a key/value pair of <code>sub</code>/<code>user</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(token.tokenAttributes["sub"] as String?).isEqualTo("user")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>and a <code>Collection</code> of authorities with just one authority, <code>SCOPE_read</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(token.authorities).hasSize(1)
assertThat(token.authorities).containsExactly(SimpleGrantedAuthority("SCOPE_read"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security does the necessary work to make sure that the <code>BearerTokenAuthentication</code> instance is available for your controller methods.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-authorities"><a class="anchor" href="#webflux-testing-opaque-token-authorities"></a>Configuring Authorities</h5>
<div class="paragraph">
<p>In many circumstances, your method is protected by filter or method security and needs your <code>Authentication</code> to have certain granted authorities to allow the request.</p>
</div>
<div class="paragraph">
<p>In this case, you can supply what granted authorities you need using the <code>authorities()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOpaqueToken()
        .authorities(SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-attributes"><a class="anchor" href="#webflux-testing-opaque-token-attributes"></a>Configuring Claims</h5>
<div class="paragraph">
<p>And while granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say, for example, that you&#8217;ve got a <code>user_id</code> attribute that indicates the user&#8217;s id in your system.
You might access it like so in a controller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/endpoint")
fun foo(authentication: BearerTokenAuthentication): Mono&lt;String?&gt; {
    val userId = authentication.tokenAttributes["user_id"] as String?
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In that case, you&#8217;d want to specify that attribute with the <code>attributes()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client
    .mutateWith(mockOpaqueToken()
        .attributes { attrs -&gt; attrs["user_id"] = "1234" }
    )
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-principal"><a class="anchor" href="#webflux-testing-opaque-token-principal"></a>Additional Configurations</h5>
<div class="paragraph">
<p>There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects.</p>
</div>
<div class="paragraph">
<p>One such is <code>principal(OAuth2AuthenticatedPrincipal)</code>, which you can use to configure the complete <code>OAuth2AuthenticatedPrincipal</code> instance that underlies the <code>BearerTokenAuthentication</code></p>
</div>
<div class="paragraph">
<p>It&#8217;s handy if you:
1. Have your own implementation of <code>OAuth2AuthenticatedPrincipal</code>, or
2. Want to specify a different principal name</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say that your authorization server sends the principal name in the <code>user_name</code> attribute instead of the <code>sub</code> attribute.
In that case, you can configure an <code>OAuth2AuthenticatedPrincipal</code> by hand:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val attributes: Map&lt;String, Any&gt; = mapOf(Pair("user_name", "foo_user"))
val principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal(
    attributes["user_name"] as String?,
    attributes,
    AuthorityUtils.createAuthorityList("SCOPE_message:read")
)

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that as an alternative to using <code>mockOpaqueToken()</code> test support, you can also mock the <code>OpaqueTokenIntrospector</code> bean itself with a <code>@MockBean</code> annotation.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket"><a class="anchor" href="#rsocket"></a>RSocket Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security&#8217;s RSocket support relies on a <code>SocketAcceptorInterceptor</code>.
The main entry point into security is found in the <code>PayloadSocketAcceptorInterceptor</code> which adapts the RSocket APIs to allow intercepting a <code>PayloadExchange</code> with <code>PayloadInterceptor</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can find a few sample applications that demonstrate the code below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello RSocket <a href="https://github.com/spring-projects/spring-security-samples/tree/main/reactive/rsocket/hello-security">hellorsocket</a></p>
</li>
<li>
<p><a href="https://github.com/rwinch/spring-flights/tree/security">Spring Flights</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_minimal_rsocket_security_configuration"><a class="anchor" href="#_minimal_rsocket_security_configuration"></a>Minimal RSocket Security Configuration</h3>
<div class="paragraph">
<p>You can find a minimal RSocket Security configuration below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRSocketSecurity
public class HelloRSocketSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableRSocketSecurity
open class HelloRSocketSecurityConfig {
    @Bean
    open fun userDetailsService(): MapReactiveUserDetailsService {
        val user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("user")
            .roles("USER")
            .build()
        return MapReactiveUserDetailsService(user)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configuration enables <a href="#rsocket-authentication-simple">simple authentication</a> and sets up <a href="#rsocket-authorization">rsocket-authorization</a> to require an authenticated user for any request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_securitysocketacceptorinterceptor"><a class="anchor" href="#_adding_securitysocketacceptorinterceptor"></a>Adding SecuritySocketAcceptorInterceptor</h3>
<div class="paragraph">
<p>For Spring Security to work we need to apply <code>SecuritySocketAcceptorInterceptor</code> to the <code>ServerRSocketFactory</code>.
This is what connects our <code>PayloadSocketAcceptorInterceptor</code> we created with the RSocket infrastructure.
In a Spring Boot application this is done automatically using <code>RSocketSecurityAutoConfiguration</code> with the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
RSocketServerCustomizer springSecurityRSocketSecurity(SecuritySocketAcceptorInterceptor interceptor) {
    return (server) -&gt; server.interceptors((registry) -&gt; registry.forSocketAcceptor(interceptor));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authentication"><a class="anchor" href="#rsocket-authentication"></a>RSocket Authentication</h3>
<div class="paragraph">
<p>RSocket authentication is performed with <code>AuthenticationPayloadInterceptor</code> which acts as a controller to invoke a <code>ReactiveAuthenticationManager</code> instance.</p>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-setup-vs-request"><a class="anchor" href="#rsocket-authentication-setup-vs-request"></a>Authentication at Setup vs Request Time</h4>
<div class="paragraph">
<p>Generally, authentication can occur at setup time and/or request time.</p>
</div>
<div class="paragraph">
<p>Authentication at setup time makes sense in a few scenarios.
A common scenarios is when a single user (i.e. mobile connection) is leveraging an RSocket connection.
In this case only a single user is leveraging the connection, so authentication can be done once at connection time.</p>
</div>
<div class="paragraph">
<p>In a scenario where the RSocket connection is shared it makes sense to send credentials on each request.
For example, a web application that connects to an RSocket server as a downstream service would make a single connection that all users leverage.
In this case, if the RSocket server needs to perform authorization based on the web application&#8217;s users credentials per request makes sense.</p>
</div>
<div class="paragraph">
<p>In some scenarios authentication at setup and per request makes sense.
Consider a web application as described previously.
If we need to restrict the connection to the web application itself, we can provide a credential with a <code>SETUP</code> authority at connection time.
Then each user would have different authorities but not the <code>SETUP</code> authority.
This means that individual users can make requests but not make additional connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-simple"><a class="anchor" href="#rsocket-authentication-simple"></a>Simple Authentication</h4>
<div class="paragraph">
<p>Spring Security has support for <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Simple.md">Simple Authentication Metadata Extension</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Basic Authentication drafts evolved into Simple Authentication and is only supported for backward compatibility.
See <code>RSocketSecurity.basicAuthentication(Customizer)</code> for setting it up.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The RSocket receiver can decode the credentials using <code>AuthenticationPayloadExchangeConverter</code> which is automatically setup using the <code>simpleAuthentication</code> portion of the DSL.
An explicit configuration can be found below.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize -&gt;
			authorize
					.anyRequest().authenticated()
					.anyExchange().permitAll()
		)
		.simpleAuthentication(Customizer.withDefaults());
	return rsocket.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
open fun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor {
    rsocket
        .authorizePayload { authorize -&gt; authorize
                .anyRequest().authenticated()
                .anyExchange().permitAll()
        }
        .simpleAuthentication(withDefaults())
    return rsocket.build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The RSocket sender can send credentials using <code>SimpleAuthenticationEncoder</code> which can be added to Spring&#8217;s <code>RSocketStrategies</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RSocketStrategies.Builder strategies = ...;
strategies.encoder(new SimpleAuthenticationEncoder());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">var strategies: RSocketStrategies.Builder = ...
strategies.encoder(SimpleAuthenticationEncoder())</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It can then be used to send a username and password to the receiver in the setup:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
	.setupMetadata(credentials, authenticationMimeType)
	.rsocketStrategies(strategies.build())
	.connectTcp(host, port);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val authenticationMimeType: MimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)
val credentials = UsernamePasswordMetadata("user", "password")
val requester: Mono&lt;RSocketRequester&gt; = RSocketRequester.builder()
    .setupMetadata(credentials, authenticationMimeType)
    .rsocketStrategies(strategies.build())
    .connectTcp(host, port)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively or additionally, a username and password can be sent in a request.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;RSocketRequester&gt; requester;
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");

public Mono&lt;AirportLocation&gt; findRadar(String code) {
	return this.requester.flatMap(req -&gt;
		req.route("find.radar.{code}", code)
			.metadata(credentials, authenticationMimeType)
			.retrieveMono(AirportLocation.class)
	);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.messaging.rsocket.retrieveMono

// ...

var requester: Mono&lt;RSocketRequester&gt;? = null
var credentials = UsernamePasswordMetadata("user", "password")

open fun findRadar(code: String): Mono&lt;AirportLocation&gt; {
    return requester!!.flatMap { req -&gt;
        req.route("find.radar.{code}", code)
            .metadata(credentials, authenticationMimeType)
            .retrieveMono&lt;AirportLocation&gt;()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-jwt"><a class="anchor" href="#rsocket-authentication-jwt"></a>JWT</h4>
<div class="paragraph">
<p>Spring Security has support for <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Bearer.md">Bearer Token Authentication Metadata Extension</a>.
The support comes in the form of authenticating a JWT (determining the JWT is valid) and then using the JWT to make authorization decisions.</p>
</div>
<div class="paragraph">
<p>The RSocket receiver can decode the credentials using <code>BearerPayloadExchangeConverter</code> which is automatically setup using the <code>jwt</code> portion of the DSL.
An example configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize -&gt;
			authorize
				.anyRequest().authenticated()
				.anyExchange().permitAll()
		)
		.jwt(Customizer.withDefaults());
	return rsocket.build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor {
    rsocket
        .authorizePayload { authorize -&gt; authorize
            .anyRequest().authenticated()
            .anyExchange().permitAll()
        }
        .jwt(withDefaults())
    return rsocket.build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration above relies on the existence of a <code>ReactiveJwtDecoder</code> <code>@Bean</code> being present.
An example of creating one from the issuer can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
	return ReactiveJwtDecoders
		.fromIssuerLocation("https://example.com/auth/realms/demo");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders
        .fromIssuerLocation("https://example.com/auth/realms/demo")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The RSocket sender does not need to do anything special to send the token because the value is just a simple String.
For example, the token can be sent at setup time:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
BearerTokenMetadata token = ...;
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
	.setupMetadata(token, authenticationMimeType)
	.connectTcp(host, port);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val authenticationMimeType: MimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)
val token: BearerTokenMetadata = ...

val requester = RSocketRequester.builder()
    .setupMetadata(token, authenticationMimeType)
    .connectTcp(host, port)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively or additionally, the token can be sent in a request.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MimeType authenticationMimeType =
	MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
Mono&lt;RSocketRequester&gt; requester;
BearerTokenMetadata token = ...;

public Mono&lt;AirportLocation&gt; findRadar(String code) {
	return this.requester.flatMap(req -&gt;
		req.route("find.radar.{code}", code)
	        .metadata(token, authenticationMimeType)
			.retrieveMono(AirportLocation.class)
	);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val authenticationMimeType: MimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)
var requester: Mono&lt;RSocketRequester&gt;? = null
val token: BearerTokenMetadata = ...

open fun findRadar(code: String): Mono&lt;AirportLocation&gt; {
    return this.requester!!.flatMap { req -&gt;
        req.route("find.radar.{code}", code)
            .metadata(token, authenticationMimeType)
            .retrieveMono&lt;AirportLocation&gt;()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authorization"><a class="anchor" href="#rsocket-authorization"></a>RSocket Authorization</h3>
<div class="paragraph">
<p>RSocket authorization is performed with <code>AuthorizationPayloadInterceptor</code> which acts as a controller to invoke a <code>ReactiveAuthorizationManager</code> instance.
The DSL can be used to setup authorization rules based upon the <code>PayloadExchange</code>.
An example configuration can be found below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">rsocket
	.authorizePayload(authz -&gt;
		authz
			.setup().hasRole("SETUP") <i class="conum" data-value="1"></i><b>(1)</b>
			.route("fetch.profile.me").authenticated() <i class="conum" data-value="2"></i><b>(2)</b>
			.matcher(payloadExchange -&gt; isMatch(payloadExchange)) <i class="conum" data-value="3"></i><b>(3)</b>
				.hasRole("CUSTOM")
			.route("fetch.profile.{username}") <i class="conum" data-value="4"></i><b>(4)</b>
				.access((authentication, context) -&gt; checkFriends(authentication, context))
			.anyRequest().authenticated() <i class="conum" data-value="5"></i><b>(5)</b>
			.anyExchange().permitAll() <i class="conum" data-value="6"></i><b>(6)</b>
	);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">rsocket
    .authorizePayload { authz -&gt;
        authz
            .setup().hasRole("SETUP") <i class="conum" data-value="1"></i><b>(1)</b>
            .route("fetch.profile.me").authenticated() <i class="conum" data-value="2"></i><b>(2)</b>
            .matcher { payloadExchange -&gt; isMatch(payloadExchange) } <i class="conum" data-value="3"></i><b>(3)</b>
            .hasRole("CUSTOM")
            .route("fetch.profile.{username}") <i class="conum" data-value="4"></i><b>(4)</b>
            .access { authentication, context -&gt; checkFriends(authentication, context) }
            .anyRequest().authenticated() <i class="conum" data-value="5"></i><b>(5)</b>
            .anyExchange().permitAll()
    } <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting up a connection requires the authority <code>ROLE_SETUP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the route is <code>fetch.profile.me</code> authorization only requires the user be authenticated</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In this rule we setup a custom matcher where authorization requires the user to have the authority <code>ROLE_CUSTOM</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This rule leverages custom authorization.
The matcher expresses a variable with the name <code>username</code> that is made available in the <code>context</code>.
A custom authorization rule is exposed in the <code>checkFriends</code> method.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This rule ensures that request that does not already have a rule will require the user to be authenticated.
A request is where the metadata is included.
It would not include additional payloads.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This rule ensures that any exchange that does not already have a rule is allowed for anyone.
In this example, it means that payloads that have no metadata have no authorization rules.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is important to understand that authorization rules are performed in order.
Only the first authorization rule that matches will be invoked.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
