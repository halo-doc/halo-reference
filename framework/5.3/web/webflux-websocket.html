<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WebSockets :: Spring</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <div class="navbar-item">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core/beans/index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../core/beans/beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../core/appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/6/overview/prerequisites.html">6</a>
        </li>
        <li class="version">
          <a href="../../../security/5.6/overview/prerequisites.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="webflux-websocket.html">WebSockets</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/web/webflux-websocket.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">WebSockets</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation covers support for reactive-stack WebSocket
messaging.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a>Introduction to WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The WebSocket protocol, <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>, provides a standardized
way to establish a full-duplex, two-way communication channel between client and server
over a single TCP connection. It is a different TCP protocol from HTTP but is designed to
work over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.</p>
</div>
<div class="paragraph">
<p>A WebSocket interaction begins with an HTTP request that uses the HTTP <code>Upgrade</code> header
to upgrade or, in this case, to switch to the WebSocket protocol. The following example
shows such an interaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket <i class="conum" data-value="1"></i><b>(1)</b>
Connection: Upgrade <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Upgrade</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the <code>Upgrade</code> connection.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Instead of the usual 200 status code, a server with WebSocket support returns output
similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Protocol switch</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After a successful handshake, the TCP socket underlying the HTTP upgrade request remains
open for both the client and the server to continue to send and receive messages.</p>
</div>
<div class="paragraph">
<p>A complete introduction of how WebSockets work is beyond the scope of this document.
See RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and
tutorials on the Web.</p>
</div>
<div class="paragraph">
<p>Note that, if a WebSocket server is running behind a web server (e.g. nginx), you
likely need to configure it to pass WebSocket upgrade requests on to the WebSocket
server. Likewise, if the application runs in a cloud environment, check the
instructions of the cloud provider related to WebSocket support.</p>
</div>
<div class="sect2">
<h3 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a>HTTP Versus WebSocket</h3>
<div class="paragraph">
<p>Even though WebSocket is designed to be HTTP-compatible and starts with an HTTP request,
it is important to understand that the two protocols lead to very different
architectures and application programming models.</p>
</div>
<div class="paragraph">
<p>In HTTP and REST, an application is modeled as many URLs. To interact with the application,
clients access those URLs, request-response style. Servers route requests to the
appropriate handler based on the HTTP URL, method, and headers.</p>
</div>
<div class="paragraph">
<p>By contrast, in WebSockets, there is usually only one URL for the initial connect.
Subsequently, all application messages flow on that same TCP connection. This points to
an entirely different asynchronous, event-driven, messaging architecture.</p>
</div>
<div class="paragraph">
<p>WebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe
any semantics to the content of messages. That means that there is no way to route or process
a message unless the client and the server agree on message semantics.</p>
</div>
<div class="paragraph">
<p>WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol
(for example, STOMP), through the <code>Sec-WebSocket-Protocol</code> header on the HTTP handshake request.
In the absence of that, they need to come up with their own conventions.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a>When to Use WebSockets</h3>
<div class="paragraph">
<p>WebSockets can make a web page be dynamic and interactive. However, in many cases,
a combination of Ajax and HTTP streaming or long polling can provide a simple and
effective solution.</p>
</div>
<div class="paragraph">
<p>For example, news, mail, and social feeds need to update dynamically, but it may be
perfectly okay to do so every few minutes. Collaboration, games, and financial apps, on
the other hand, need to be much closer to real-time.</p>
</div>
<div class="paragraph">
<p>Latency alone is not a deciding factor. If the volume of messages is relatively low (for example,
monitoring network failures) HTTP streaming or polling can provide an effective solution.
It is the combination of low latency, high frequency, and high volume that make the best
case for the use of WebSocket.</p>
</div>
<div class="paragraph">
<p>Keep in mind also that over the Internet, restrictive proxies that are outside of your control
may preclude WebSocket interactions, either because they are not configured to pass on the
<code>Upgrade</code> header or because they close long-lived connections that appear idle. This
means that the use of WebSocket for internal applications within the firewall is a more
straightforward decision than it is for public facing applications.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-websocket-server"><a class="anchor" href="#webflux-websocket-server"></a>WebSocket API</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web.html#websocket-server" class="page">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework provides a WebSocket API that you can use to write client- and
server-side applications that handle WebSocket messages.</p>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server-handler"><a class="anchor" href="#webflux-websocket-server-handler"></a>Server</h3>
<div class="paragraph">
<p><span class="small"><a href="../web.html#websocket-server-handler" class="page">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>To create a WebSocket server, you can first create a <code>WebSocketHandler</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

	@Override
	public Mono&lt;Void&gt; handle(WebSocketSession session) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.reactive.socket.WebSocketHandler
import org.springframework.web.reactive.socket.WebSocketSession

class MyWebSocketHandler : WebSocketHandler {

	override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can map it to a URL:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class WebConfig {

	@Bean
	public HandlerMapping handlerMapping() {
		Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;();
		map.put("/path", new MyWebSocketHandler());
		int order = -1; // before annotated controllers

		return new SimpleUrlHandlerMapping(map, order);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class WebConfig {

	@Bean
	fun handlerMapping(): HandlerMapping {
		val map = mapOf("/path" to MyWebSocketHandler())
		val order = -1 // before annotated controllers

		return SimpleUrlHandlerMapping(map, order)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If using the <a href="../web-reactive.html#webflux-config" class="page">WebFlux Config</a> there is nothing
further to do, or otherwise if not using the WebFlux config you&#8217;ll need to declare a
<code>WebSocketHandlerAdapter</code> as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class WebConfig {

	// ...

	@Bean
	public WebSocketHandlerAdapter handlerAdapter() {
		return new WebSocketHandlerAdapter();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class WebConfig {

	// ...

	@Bean
	fun handlerAdapter() =  WebSocketHandlerAdapter()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websockethandler"><a class="anchor" href="#webflux-websockethandler"></a><code>WebSocketHandler</code></h3>
<div class="paragraph">
<p>The <code>handle</code> method of <code>WebSocketHandler</code> takes <code>WebSocketSession</code> and returns <code>Mono&lt;Void&gt;</code>
to indicate when application handling of the session is complete. The session is handled
through two streams, one for inbound and one for outbound messages. The following table
describes the two methods that handle the streams:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>WebSocketSession</code> method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;WebSocketMessage&gt; receive()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides access to the inbound message stream and completes when the connection is closed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono&lt;Void&gt; send(Publisher&lt;WebSocketMessage&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Takes a source for outgoing messages, writes the messages, and returns a <code>Mono&lt;Void&gt;</code> that
  completes when the source completes and writing is done.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A <code>WebSocketHandler</code> must compose the inbound and outbound streams into a unified flow and
return a <code>Mono&lt;Void&gt;</code> that reflects the completion of that flow. Depending on application
requirements, the unified flow completes when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Either the inbound or the outbound message stream completes.</p>
</li>
<li>
<p>The inbound stream completes (that is, the connection closed), while the outbound stream is infinite.</p>
</li>
<li>
<p>At a chosen point, through the <code>close</code> method of <code>WebSocketSession</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When inbound and outbound message streams are composed together, there is no need to
check if the connection is open, since Reactive Streams signals end activity.
The inbound stream receives a completion or error signal, and the outbound stream
receives a cancellation signal.</p>
</div>
<div class="paragraph">
<p>The most basic implementation of a handler is one that handles the inbound stream. The
following example shows such an implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ExampleHandler implements WebSocketHandler {

	@Override
	public Mono&lt;Void&gt; handle(WebSocketSession session) {
		return session.receive()			<i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext(message -&gt; {
					// ...					<i class="conum" data-value="2"></i><b>(2)</b>
				})
				.concatMap(message -&gt; {
					// ...					<i class="conum" data-value="3"></i><b>(3)</b>
				})
				.then();					<i class="conum" data-value="4"></i><b>(4)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Access the stream of inbound messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Do something with each message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Perform nested asynchronous operations that use the message content.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that completes when receiving completes.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

	override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {
		return session.receive()            <i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext {
					// ...					<i class="conum" data-value="2"></i><b>(2)</b>
				}
				.concatMap {
					// ...					<i class="conum" data-value="3"></i><b>(3)</b>
				}
				.then()                     <i class="conum" data-value="4"></i><b>(4)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Access the stream of inbound messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Do something with each message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Perform nested asynchronous operations that use the message content.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that completes when receiving completes.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For nested, asynchronous operations, you may need to call <code>message.retain()</code> on underlying
servers that use pooled data buffers (for example, Netty). Otherwise, the data buffer may be
released before you have had a chance to read the data. For more background, see
<a href="../core.html#databuffers" class="page">Data Buffers and Codecs</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following implementation combines the inbound and outbound streams:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ExampleHandler implements WebSocketHandler {

	@Override
	public Mono&lt;Void&gt; handle(WebSocketSession session) {

		Flux&lt;WebSocketMessage&gt; output = session.receive()				<i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext(message -&gt; {
					// ...
				})
				.concatMap(message -&gt; {
					// ...
				})
				.map(value -&gt; session.textMessage("Echo " + value));	<i class="conum" data-value="2"></i><b>(2)</b>

		return session.send(output);									<i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle the inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create the outbound message, producing a combined flow.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that does not complete while we continue to receive.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

	override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {

		val output = session.receive()                      <i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext {
					// ...
				}
				.concatMap {
					// ...
				}
				.map { session.textMessage("Echo $it") }    <i class="conum" data-value="2"></i><b>(2)</b>

		return session.send(output)                         <i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle the inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create the outbound message, producing a combined flow.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that does not complete while we continue to receive.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Inbound and outbound streams can be independent and be joined only for completion,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ExampleHandler implements WebSocketHandler {

	@Override
	public Mono&lt;Void&gt; handle(WebSocketSession session) {

		Mono&lt;Void&gt; input = session.receive()								<i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext(message -&gt; {
					// ...
				})
				.concatMap(message -&gt; {
					// ...
				})
				.then();

		Flux&lt;String&gt; source = ... ;
		Mono&lt;Void&gt; output = session.send(source.map(session::textMessage));	<i class="conum" data-value="2"></i><b>(2)</b>

		return Mono.zip(input, output).then();								<i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Send outgoing messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Join the streams and return a <code>Mono&lt;Void&gt;</code> that completes when either stream ends.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

	override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {

		val input = session.receive()									<i class="conum" data-value="1"></i><b>(1)</b>
				.doOnNext {
					// ...
				}
				.concatMap {
					// ...
				}
				.then()

		val source: Flux&lt;String&gt; = ...
		val output = session.send(source.map(session::textMessage))		<i class="conum" data-value="2"></i><b>(2)</b>

		return Mono.zip(input, output).then()							<i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Send outgoing messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Join the streams and return a <code>Mono&lt;Void&gt;</code> that completes when either stream ends.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-databuffer"><a class="anchor" href="#webflux-websocket-databuffer"></a><code>DataBuffer</code></h3>
<div class="paragraph">
<p><code>DataBuffer</code> is the representation for a byte buffer in WebFlux. The Spring Core part of
the reference has more on that in the section on
<a href="../core.html#databuffers" class="page">Data Buffers and Codecs</a>. The key point to understand is that on some
servers like Netty, byte buffers are pooled and reference counted, and must be released
when consumed to avoid memory leaks.</p>
</div>
<div class="paragraph">
<p>When running on Netty, applications must use <code>DataBufferUtils.retain(dataBuffer)</code> if they
wish to hold on input data buffers in order to ensure they are not released, and
subsequently use <code>DataBufferUtils.release(dataBuffer)</code> when the buffers are consumed.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server-handshake"><a class="anchor" href="#webflux-websocket-server-handshake"></a>Handshake</h3>
<div class="paragraph">
<p><span class="small"><a href="../web.html#websocket-server-handshake" class="page">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p><code>WebSocketHandlerAdapter</code> delegates to a <code>WebSocketService</code>. By default, that is an instance
of <code>HandshakeWebSocketService</code>, which performs basic checks on the WebSocket request and
then uses <code>RequestUpgradeStrategy</code> for the server in use. Currently, there is built-in
support for Reactor Netty, Tomcat, Jetty, and Undertow.</p>
</div>
<div class="paragraph">
<p><code>HandshakeWebSocketService</code> exposes a <code>sessionAttributePredicate</code> property that allows
setting a <code>Predicate&lt;String&gt;</code> to extract attributes from the <code>WebSession</code> and insert them
into the attributes of the <code>WebSocketSession</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server-config"><a class="anchor" href="#webflux-websocket-server-config"></a>Server Configation</h3>
<div class="paragraph">
<p><span class="small"><a href="../web.html#websocket-server-runtime-configuration" class="page">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The <code>RequestUpgradeStrategy</code> for each server exposes configuration specific to the
underlying WebSocket server engine. When using the WebFlux Java config you can customize
such properties as shown in the corresponding section of the
<a href="../web-reactive.html#webflux-config-websocket-service" class="page">WebFlux Config</a>, or otherwise if
not using the WebFlux config, use the below:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class WebConfig {

	@Bean
	public WebSocketHandlerAdapter handlerAdapter() {
		return new WebSocketHandlerAdapter(webSocketService());
	}

	@Bean
	public WebSocketService webSocketService() {
		TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
		strategy.setMaxSessionIdleTimeout(0L);
		return new HandshakeWebSocketService(strategy);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class WebConfig {

	@Bean
	fun handlerAdapter() =
			WebSocketHandlerAdapter(webSocketService())

	@Bean
	fun webSocketService(): WebSocketService {
		val strategy = TomcatRequestUpgradeStrategy().apply {
			setMaxSessionIdleTimeout(0L)
		}
		return HandshakeWebSocketService(strategy)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the upgrade strategy for your server to see what options are available. Currently,
only Tomcat and Jetty expose such options.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server-cors"><a class="anchor" href="#webflux-websocket-server-cors"></a>CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="../web.html#websocket-server-allowed-origins" class="page">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The easiest way to configure CORS and restrict access to a WebSocket endpoint is to
have your <code>WebSocketHandler</code> implement <code>CorsConfigurationSource</code> and return a
<code>CorsConfiguration</code> with allowed origins, headers, and other details. If you cannot do
that, you can also set the <code>corsConfigurations</code> property on the <code>SimpleUrlHandler</code> to
specify CORS settings by URL pattern. If both are specified, they are combined by using the
<code>combine</code> method on <code>CorsConfiguration</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-client"><a class="anchor" href="#webflux-websocket-client"></a>Client</h3>
<div class="paragraph">
<p>Spring WebFlux provides a <code>WebSocketClient</code> abstraction with implementations for
Reactor Netty, Tomcat, Jetty, Undertow, and standard Java (that is, JSR-356).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Tomcat client is effectively an extension of the standard Java one with some extra
functionality in the <code>WebSocketSession</code> handling to take advantage of the Tomcat-specific
API to suspend receiving messages for back pressure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To start a WebSocket session, you can create an instance of the client and use its <code>execute</code>
methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebSocketClient client = new ReactorNettyWebSocketClient();

URI url = new URI("ws://localhost:8080/path");
client.execute(url, session -&gt;
		session.receive()
				.doOnNext(System.out::println)
				.then());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val client = ReactorNettyWebSocketClient()

		val url = URI("ws://localhost:8080/path")
		client.execute(url) { session -&gt;
			session.receive()
					.doOnNext(::println)
			.then()
		}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some clients, such as Jetty, implement <code>Lifecycle</code> and need to be stopped and started
before you can use them. All clients have constructor options related to configuration
of the underlying WebSocket client.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  appId: 'L0TI0XV6RD',
  apiKey: '278da59d0706716556405ce7a28ba297',
  indexName: 'dev_spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>  </body>
</html>
