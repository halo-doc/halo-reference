<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Classpath Scanning and Managed Components :: Spring</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Spring</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">5.3</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Spring Framework</a></li>
    <li><a href="../../core.html">Core</a></li>
    <li><a href="index.html">The IoC Container</a></li>
    <li><a href="scanning.html">Classpath Scanning and Managed Components</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/beans/scanning.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Classpath Scanning and Managed Components</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Most examples in this chapter use XML to specify the configuration metadata that produces
each <code>BeanDefinition</code> within the Spring container. The previous section
(<a href="#beans-annotation-config">[beans-annotation-config]</a>) demonstrates how to provide a lot of the configuration
metadata through source-level annotations. Even in those examples, however, the &#8220;base&#8221;
bean definitions are explicitly defined in the XML file, while the annotations drive only
the dependency injection. This section describes an option for implicitly detecting the
candidate components by scanning the classpath. Candidate components are classes that
match against a filter criteria and have a corresponding bean definition registered with
the container. This removes the need to use XML to perform bean registration. Instead, you
can use annotations (for example, <code>@Component</code>), AspectJ type expressions, or your own
custom filter criteria to select which classes have bean definitions registered with
the container.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with Spring 3.0, many features provided by the Spring JavaConfig project are
part of the core Spring Framework. This allows you to define beans using Java rather
than using the traditional XML files. Take a look at the <code>@Configuration</code>, <code>@Bean</code>,
<code>@Import</code>, and <code>@DependsOn</code> annotations for examples of how to use these new features.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a><code>@Component</code> and Further Stereotype Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>@Repository</code> annotation is a marker for any class that fulfills the role or
stereotype of a repository (also known as Data Access Object or DAO). Among the uses
of this marker is the automatic translation of exceptions, as described in
<a href="../../data-access.html#orm-exception-translation" class="page">Exception Translation</a>.</p>
</div>
<div class="paragraph">
<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>, and
<code>@Controller</code>. <code>@Component</code> is a generic stereotype for any Spring-managed component.
<code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for
more specific use cases (in the persistence, service, and presentation
layers, respectively). Therefore, you can annotate your component classes with
<code>@Component</code>, but, by annotating them with <code>@Repository</code>, <code>@Service</code>, or <code>@Controller</code>
instead, your classes are more properly suited for processing by tools or associating
with aspects. For example, these stereotype annotations make ideal targets for
pointcuts. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> can also
carry additional semantics in future releases of the Spring Framework. Thus, if you are
choosing between using <code>@Component</code> or <code>@Service</code> for your service layer, <code>@Service</code> is
clearly the better choice. Similarly, as stated earlier, <code>@Repository</code> is already
supported as a marker for automatic exception translation in your persistence layer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a>Using Meta-annotations and Composed Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many of the annotations provided by Spring can be used as meta-annotations in your
own code. A meta-annotation is an annotation that can be applied to another annotation.
For example, the <code>@Service</code> annotation mentioned <a href="#beans-stereotype-annotations">earlier</a>
is meta-annotated with <code>@Component</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
public @interface Service {

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Component</code> causes <code>@Service</code> to be treated in the same way as <code>@Component</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
annotation class Service {

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Component</code> causes <code>@Service</code> to be treated in the same way as <code>@Component</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also combine meta-annotations to create &#8220;composed annotations&#8221;. For example,
the <code>@RestController</code> annotation from Spring MVC is composed of <code>@Controller</code> and
<code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p>In addition, composed annotations can optionally redeclare attributes from
meta-annotations to allow customization. This can be particularly useful when you
want to only expose a subset of the meta-annotation&#8217;s attributes. For example, Spring&#8217;s
<code>@SessionScope</code> annotation hardcodes the scope name to <code>session</code> but still allows
customization of the <code>proxyMode</code>. The following listing shows the definition of the
<code>SessionScope</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

	/**
	 * Alias for {@link Scope#proxyMode}.
	 * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
	 */
	@AliasFor(annotation = Scope.class)
	ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Scope(WebApplicationContext.SCOPE_SESSION)
annotation class SessionScope(
		@get:AliasFor(annotation = Scope::class)
		val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use <code>@SessionScope</code> without declaring the <code>proxyMode</code> as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
@SessionScope
public class SessionScopedService {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Service
@SessionScope
class SessionScopedService {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also override the value for the <code>proxyMode</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
class SessionScopedUserService : UserService {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details, see the
<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a>
wiki page.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a>Automatically Detecting Classes and Registering Bean Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring can automatically detect stereotyped classes and register corresponding
<code>BeanDefinition</code> instances with the <code>ApplicationContext</code>. For example, the following two classes
are eligible for such autodetection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class SimpleMovieLister {

	private MovieFinder movieFinder;

	public SimpleMovieLister(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Service
class SimpleMovieLister(private val movieFinder: MovieFinder)</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Repository
public class JpaMovieFinder implements MovieFinder {
	// implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Repository
class JpaMovieFinder : MovieFinder {
	// implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To autodetect these classes and register the corresponding beans, you need to add
<code>@ComponentScan</code> to your <code>@Configuration</code> class, where the <code>basePackages</code> attribute
is a common parent package for the two classes. (Alternatively, you can specify a
comma- or semicolon- or space-separated list that includes the parent package of each class.)</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"])
class AppConfig  {
	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For brevity, the preceding example could have used the <code>value</code> attribute of the
annotation (that is, <code>@ComponentScan("org.example")</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following alternative uses XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:component-scan base-package="org.example"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The use of <code>&lt;context:component-scan&gt;</code> implicitly enables the functionality of
<code>&lt;context:annotation-config&gt;</code>. There is usually no need to include the
<code>&lt;context:annotation-config&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The scanning of classpath packages requires the presence of corresponding directory
entries in the classpath. When you build JARs with Ant, make sure that you do not
activate the files-only switch of the JAR task. Also, classpath directories may not be
exposed based on security policies in some environments&#8201;&#8212;&#8201;for example, standalone apps on
JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests&#8201;&#8212;&#8201;see
<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>).</p>
</div>
<div class="paragraph">
<p>On JDK 9&#8217;s module path (Jigsaw), Spring&#8217;s classpath scanning generally works as expected.
However, make sure that your component classes are exported in your <code>module-info</code>
descriptors. If you expect Spring to invoke non-public members of your classes, make
sure that they are 'opened' (that is, that they use an <code>opens</code> declaration instead of an
<code>exports</code> declaration in your <code>module-info</code> descriptor).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, the <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> are both implicitly included when you use the
component-scan element. That means that the two components are autodetected and
wired together&#8201;&#8212;&#8201;all without any bean configuration metadata provided in XML.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can disable the registration of <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> by including the <code>annotation-config</code> attribute
with a value of <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a>Using Filters to Customize Scanning</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, classes annotated with <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>,
<code>@Configuration</code>, or a custom annotation that itself is annotated with <code>@Component</code> are
the only detected candidate components. However, you can modify and extend this behavior
by applying custom filters. Add them as <code>includeFilters</code> or <code>excludeFilters</code> attributes of
the <code>@ComponentScan</code> annotation (or as <code>&lt;context:include-filter /&gt;</code> or
<code>&lt;context:exclude-filter /&gt;</code> child elements of the <code>&lt;context:component-scan&gt;</code> element in
XML configuration). Each filter element requires the <code>type</code> and <code>expression</code> attributes.
The following table describes the filtering options:</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Filter Types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Filter Type</th>
<th class="tableblock halign-left valign-top">Example Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">annotation (default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An annotation to be <em>present</em> or <em>meta-present</em> at the type level in target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A class (or interface) that the target components are assignable to (extend or implement).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectj</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An AspectJ type expression to be matched by the target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A regex expression to be matched by the target components' class names.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A custom implementation of the <code>org.springframework.core.type.TypeFilter</code> interface.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following example shows the configuration ignoring all <code>@Repository</code> annotations
and using &#8220;stub&#8221; repositories instead:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example",
		includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
		excludeFilters = @Filter(Repository.class))
public class AppConfig {
	...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = "org.example",
		includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
		excludeFilters = [Filter(Repository::class)])
class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the equivalent XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
	&lt;context:component-scan base-package="org.example"&gt;
		&lt;context:include-filter type="regex"
				expression=".*Stub.*Repository"/&gt;
		&lt;context:exclude-filter type="annotation"
				expression="org.springframework.stereotype.Repository"/&gt;
	&lt;/context:component-scan&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also disable the default filters by setting <code>useDefaultFilters=false</code> on the
annotation or by providing <code>use-default-filters="false"</code> as an attribute of the
<code>&lt;component-scan/&gt;</code> element. This effectively disables automatic detection of classes
annotated or meta-annotated with <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>,
<code>@RestController</code>, or <code>@Configuration</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a>Defining Bean Metadata within Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring components can also contribute bean definition metadata to the container. You can do
this with the same <code>@Bean</code> annotation used to define bean metadata within <code>@Configuration</code>
annotated classes. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class FactoryMethodComponent {

	@Bean
	@Qualifier("public")
	public TestBean publicInstance() {
		return new TestBean("publicInstance");
	}

	public void doWork() {
		// Component method implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class FactoryMethodComponent {

	@Bean
	@Qualifier("public")
	fun publicInstance() = TestBean("publicInstance")

	fun doWork() {
		// Component method implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding class is a Spring component that has application-specific code in its
<code>doWork()</code> method. However, it also contributes a bean definition that has a factory
method referring to the method <code>publicInstance()</code>. The <code>@Bean</code> annotation identifies the
factory method and other bean definition properties, such as a qualifier value through
the <code>@Qualifier</code> annotation. Other method-level annotations that can be specified are
<code>@Scope</code>, <code>@Lazy</code>, and custom qualifier annotations.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In addition to its role for component initialization, you can also place the <code>@Lazy</code> annotation
on injection points marked with <code>@Autowired</code> or <code>@Inject</code>. In this context, it
leads to the injection of a lazy-resolution proxy.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Autowired fields and methods are supported, as previously discussed, with additional
support for autowiring of <code>@Bean</code> methods. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class FactoryMethodComponent {

	private static int i;

	@Bean
	@Qualifier("public")
	public TestBean publicInstance() {
		return new TestBean("publicInstance");
	}

	// use of a custom qualifier and autowiring of method parameters
	@Bean
	protected TestBean protectedInstance(
			@Qualifier("public") TestBean spouse,
			@Value("#{privateInstance.age}") String country) {
		TestBean tb = new TestBean("protectedInstance", 1);
		tb.setSpouse(spouse);
		tb.setCountry(country);
		return tb;
	}

	@Bean
	private TestBean privateInstance() {
		return new TestBean("privateInstance", i++);
	}

	@Bean
	@RequestScope
	public TestBean requestScopedInstance() {
		return new TestBean("requestScopedInstance", 3);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class FactoryMethodComponent {

	companion object {
		private var i: Int = 0
	}

	@Bean
	@Qualifier("public")
	fun publicInstance() = TestBean("publicInstance")

	// use of a custom qualifier and autowiring of method parameters
	@Bean
	protected fun protectedInstance(
			@Qualifier("public") spouse: TestBean,
			@Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
		this.spouse = spouse
		this.country = country
	}

	@Bean
	private fun privateInstance() = TestBean("privateInstance", i++)

	@Bean
	@RequestScope
	fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example autowires the <code>String</code> method parameter <code>country</code> to the value of the <code>age</code>
property on another bean named <code>privateInstance</code>. A Spring Expression Language element
defines the value of the property through the notation <code>#{ &lt;expression&gt; }</code>. For <code>@Value</code>
annotations, an expression resolver is preconfigured to look for bean names when
resolving expression text.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 4.3, you may also declare a factory method parameter of type
<code>InjectionPoint</code> (or its more specific subclass: <code>DependencyDescriptor</code>) to
access the requesting injection point that triggers the creation of the current bean.
Note that this applies only to the actual creation of bean instances, not to the
injection of existing instances. As a consequence, this feature makes most sense for
beans of prototype scope. For other scopes, the factory method only ever sees the
injection point that triggered the creation of a new bean instance in the given scope
(for example, the dependency that triggered the creation of a lazy singleton bean).
You can use the provided injection point metadata with semantic care in such scenarios.
The following example shows how to use <code>InjectionPoint</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class FactoryMethodComponent {

	@Bean @Scope("prototype")
	public TestBean prototypeInstance(InjectionPoint injectionPoint) {
		return new TestBean("prototypeInstance for " + injectionPoint.getMember());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class FactoryMethodComponent {

	@Bean
	@Scope("prototype")
	fun prototypeInstance(injectionPoint: InjectionPoint) =
			TestBean("prototypeInstance for ${injectionPoint.member}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> methods in a regular Spring component are processed differently than their
counterparts inside a Spring <code>@Configuration</code> class. The difference is that <code>@Component</code>
classes are not enhanced with CGLIB to intercept the invocation of methods and fields.
CGLIB proxying is the means by which invoking methods or fields within <code>@Bean</code> methods
in <code>@Configuration</code> classes creates bean metadata references to collaborating objects.
Such methods are not invoked with normal Java semantics but rather go through the
container in order to provide the usual lifecycle management and proxying of Spring
beans, even when referring to other beans through programmatic calls to <code>@Bean</code> methods.
In contrast, invoking a method or field in a <code>@Bean</code> method within a plain <code>@Component</code>
class has standard Java semantics, with no special CGLIB processing or other
constraints applying.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may declare <code>@Bean</code> methods as <code>static</code>, allowing for them to be called without
creating their containing configuration class as an instance. This makes particular
sense when defining post-processor beans (for example, of type <code>BeanFactoryPostProcessor</code>
or <code>BeanPostProcessor</code>), since such beans get initialized early in the container
lifecycle and should avoid triggering other parts of the configuration at that point.</p>
</div>
<div class="paragraph">
<p>Calls to static <code>@Bean</code> methods never get intercepted by the container, not even within
<code>@Configuration</code> classes (as described earlier in this section), due to technical
limitations: CGLIB subclassing can override only non-static methods. As a consequence,
a direct call to another <code>@Bean</code> method has standard Java semantics, resulting
in an independent instance being returned straight from the factory method itself.</p>
</div>
<div class="paragraph">
<p>The Java language visibility of <code>@Bean</code> methods does not have an immediate impact on
the resulting bean definition in Spring&#8217;s container. You can freely declare your
factory methods as you see fit in non-<code>@Configuration</code> classes and also for static
methods anywhere. However, regular <code>@Bean</code> methods in <code>@Configuration</code> classes need
to be overridable&#8201;&#8212;&#8201;that is, they must not be declared as <code>private</code> or <code>final</code>.</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> methods are also discovered on base classes of a given component or
configuration class, as well as on Java 8 default methods declared in interfaces
implemented by the component or configuration class. This allows for a lot of
flexibility in composing complex configuration arrangements, with even multiple
inheritance being possible through Java 8 default methods as of Spring 4.2.</p>
</div>
<div class="paragraph">
<p>Finally, a single class may hold multiple <code>@Bean</code> methods for the same
bean, as an arrangement of multiple factory methods to use depending on available
dependencies at runtime. This is the same algorithm as for choosing the &#8220;greediest&#8221;
constructor or factory method in other configuration scenarios: The variant with
the largest number of satisfiable dependencies is picked at construction time,
analogous to how the container selects between multiple <code>@Autowired</code> constructors.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a>Naming Autodetected Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a component is autodetected as part of the scanning process, its bean name is
generated by the <code>BeanNameGenerator</code> strategy known to that scanner. By default, any
Spring stereotype annotation (<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, and
<code>@Controller</code>) that contains a name <code>value</code> thereby provides that name to the
corresponding bean definition.</p>
</div>
<div class="paragraph">
<p>If such an annotation contains no name <code>value</code> or for any other detected component
(such as those discovered by custom filters), the default bean name generator returns
the uncapitalized non-qualified class name. For example, if the following component
classes were detected, the names would be <code>myMovieLister</code> and <code>movieFinderImpl</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service("myMovieLister")
public class SimpleMovieLister {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Service("myMovieLister")
class SimpleMovieLister {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Repository
public class MovieFinderImpl implements MovieFinder {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Repository
class MovieFinderImpl : MovieFinder {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom
bean-naming strategy. First, implement the
{api-spring-framework}/beans/factory/support/BeanNameGenerator.html[<code>BeanNameGenerator</code>]
interface, and be sure to include a default no-arg constructor. Then, provide the fully
qualified class name when configuring the scanner, as the following example annotation
and bean definition show.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you run into naming conflicts due to multiple autodetected components having the
same non-qualified class name (i.e., classes with identical names but residing in
different packages), you may need to configure a <code>BeanNameGenerator</code> that defaults to the
fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the
<code>FullyQualifiedAnnotationBeanNameGenerator</code> located in package
<code>org.springframework.context.annotation</code> can be used for such purposes.
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
	&lt;context:component-scan base-package="org.example"
		name-generator="org.example.MyNameGenerator" /&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a general rule, consider specifying the name with the annotation whenever other
components may be making explicit references to it. On the other hand, the
auto-generated names are adequate whenever the container is responsible for wiring.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a>Providing a Scope for Autodetected Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As with Spring-managed components in general, the default and most common scope for
autodetected components is <code>singleton</code>. However, sometimes you need a different scope
that can be specified by the <code>@Scope</code> annotation. You can provide the name of the
scope within the annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Scope("prototype")
@Repository
class MovieFinderImpl : MovieFinder {
	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@Scope</code> annotations are only introspected on the concrete bean class (for annotated
components) or the factory method (for <code>@Bean</code> methods). In contrast to XML bean
definitions, there is no notion of bean definition inheritance, and inheritance
hierarchies at the class level are irrelevant for metadata purposes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For details on web-specific scopes such as &#8220;request&#8221; or &#8220;session&#8221; in a Spring context,
see <a href="#beans-factory-scopes-other">[beans-factory-scopes-other]</a>. As with the pre-built annotations for those scopes,
you may also compose your own scoping annotations by using Spring&#8217;s meta-annotation
approach: for example, a custom annotation meta-annotated with <code>@Scope("prototype")</code>,
possibly also declaring a custom scoped-proxy mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To provide a custom strategy for scope resolution rather than relying on the
annotation-based approach, you can implement the
{api-spring-framework}/context/annotation/ScopeMetadataResolver.html[<code>ScopeMetadataResolver</code>]
interface. Be sure to include a default no-arg constructor. Then you can provide the
fully qualified class name when configuring the scanner, as the following example of both
an annotation and a bean definition shows:
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
	&lt;context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using certain non-singleton scopes, it may be necessary to generate proxies for the
scoped objects. The reasoning is described in <a href="#beans-factory-scopes-other-injection">[beans-factory-scopes-other-injection]</a>.
For this purpose, a scoped-proxy attribute is available on the component-scan
element. The three possible values are: <code>no</code>, <code>interfaces</code>, and <code>targetClass</code>. For example,
the following configuration results in standard JDK dynamic proxies:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
class AppConfig {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
	&lt;context:component-scan base-package="org.example" scoped-proxy="interfaces"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a>Providing Qualifier Metadata with Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>@Qualifier</code> annotation is discussed in <a href="#beans-autowired-annotation-qualifiers">[beans-autowired-annotation-qualifiers]</a>.
The examples in that section demonstrate the use of the <code>@Qualifier</code> annotation and
custom qualifier annotations to provide fine-grained control when you resolve autowire
candidates. Because those examples were based on XML bean definitions, the qualifier
metadata was provided on the candidate bean definitions by using the <code>qualifier</code> or <code>meta</code>
child elements of the <code>bean</code> element in the XML. When relying upon classpath scanning for
auto-detection of components, you can provide the qualifier metadata with type-level
annotations on the candidate class. The following three examples demonstrate this
technique:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
@Qualifier("Action")
class ActionMovieCatalog : MovieCatalog</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
@Genre("Action")
class ActionMovieCatalog : MovieCatalog {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with most annotation-based alternatives, keep in mind that the annotation metadata is
bound to the class definition itself, while the use of XML allows for multiple beans
of the same type to provide variations in their qualifier metadata, because that
metadata is provided per-instance rather than per-class.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a>Generating an Index of Candidate Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While classpath scanning is very fast, it is possible to improve the startup performance
of large applications by creating a static list of candidates at compilation time. In this
mode, all modules that are targets of component scanning must use this mechanism.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Your existing <code>@ComponentScan</code> or <code>&lt;context:component-scan/&gt;</code> directives must remain
unchanged to request the context to scan candidates in certain packages. When the
<code>ApplicationContext</code> detects such an index, it automatically uses it rather than scanning
the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To generate the index, add an additional dependency to each module that contains
components that are targets for component scan directives. The following example shows
how to do so with Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
		&lt;version&gt;{spring-version}&lt;/version&gt;
		&lt;optional&gt;true&lt;/optional&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Gradle 4.5 and earlier, the dependency should be declared in the <code>compileOnly</code>
configuration, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
	compileOnly "org.springframework:spring-context-indexer:{spring-version}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Gradle 4.6 and later, the dependency should be declared in the <code>annotationProcessor</code>
configuration, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
	annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-context-indexer</code> artifact generates a <code>META-INF/spring.components</code> file that
is included in the jar file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When working with this mode in your IDE, the <code>spring-context-indexer</code> must be
registered as an annotation processor to make sure the index is up-to-date when
candidate components are updated.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The index is enabled automatically when a <code>META-INF/spring.components</code> file is found
on the classpath. If an index is partially available for some libraries (or use cases)
but could not be built for the whole application, you can fall back to a regular classpath
arrangement (as though no index were present at all) by setting <code>spring.index.ignore</code> to
<code>true</code>, either as a JVM system property or via the
<a href="../../appendix.html#appendix-spring-properties" class="page"><code>SpringProperties</code></a> mechanism.
</td>
</tr>
</table>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/tabs.js"></script>  </body>
</html>
