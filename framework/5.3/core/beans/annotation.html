<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Annotation-based Container Configuration :: Spring</title>
    <link rel="prev" href="extension.html">
    <link rel="next" href="scanning.html">
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../../_/css/site.css">

<link href="../../../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">
        <img id="springlogo" class="block" src="../../../../_/img/spring-logo.svg" alt="Spring" width="140px">
      </a>
        <span class="title-divider">/</span>
        <div class="navbar-project">
          <span class="title">Spring Framework</span>
        </div>
      <div>
          <span class="title-divider">/</span>
                </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://spring.io/">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item" class="blue mb-2 inline-block" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore" style="display: none;">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../security/6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../security/6/overview/prerequisites.html">6</a>
        </li>
        <li class="version">
          <a href="../../../../security/5.6/overview/index.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Spring Framework</a></li>
    <li><a href="../../core.html">Core</a></li>
    <li><a href="index.html">The IoC Container</a></li>
    <li><a href="annotation.html">Annotation-based Container Configuration</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/beans/annotation.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Annotation-based Container Configuration</h1>
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">Are annotations better than XML for configuring Spring?</div>
<div class="paragraph">
<p>The introduction of annotation-based configuration raised the question of whether this
approach is &#8220;better&#8221; than XML. The short answer is &#8220;it depends.&#8221; The long answer is
that each approach has its pros and cons, and, usually, it is up to the developer to
decide which strategy suits them better. Due to the way they are defined, annotations
provide a lot of context in their declaration, leading to shorter and more concise
configuration. However, XML excels at wiring up components without touching their source
code or recompiling them. Some developers prefer having the wiring close to the source
while others argue that annotated classes are no longer POJOs and, furthermore, that the
configuration becomes decentralized and harder to control.</p>
</div>
<div class="paragraph">
<p>No matter the choice, Spring can accommodate both styles and even mix them together.
It is worth pointing out that through its <a href="#beans-java">JavaConfig</a> option, Spring lets
annotations be used in a non-invasive way, without touching the target components
source code and that, in terms of tooling, all configuration styles are supported by the
<a href="https://spring.io/tools">Spring Tools for Eclipse</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>An alternative to XML setup is provided by annotation-based configuration, which relies on
the bytecode metadata for wiring up components instead of angle-bracket declarations.
Instead of using XML to describe a bean wiring, the developer moves the configuration
into the component class itself by using annotations on the relevant class, method, or
field declaration. As mentioned in <a href="#beans-factory-extension-bpp-examples-aabpp">[beans-factory-extension-bpp-examples-aabpp]</a>, using
a <code>BeanPostProcessor</code> in conjunction with annotations is a common means of extending the
Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing
required properties with the <a href="#beans-required-annotation"><code>@Required</code></a> annotation. Spring
2.5 made it possible to follow that same general approach to drive Spring&#8217;s dependency
injection. Essentially, the <code>@Autowired</code> annotation provides the same capabilities as
described in <a href="#beans-factory-autowire">[beans-factory-autowire]</a> but with more fine-grained control and wider
applicability. Spring 2.5 also added support for JSR-250 annotations, such as
<code>@PostConstruct</code> and <code>@PreDestroy</code>. Spring 3.0 added support for JSR-330 (Dependency
Injection for Java) annotations contained in the <code>javax.inject</code> package such as <code>@Inject</code>
and <code>@Named</code>. Details about those annotations can be found in the
<a href="#beans-standard-annotations">relevant section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Annotation injection is performed before XML injection. Thus, the XML configuration
overrides the annotations for properties wired through both approaches.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As always, you can register the post-processors as individual bean definitions, but they
can also be implicitly registered by including the following tag in an XML-based Spring
configuration (notice the inclusion of the <code>context</code> namespace):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:annotation-config/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;context:annotation-config/&gt;</code> element implicitly registers the following post-processors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html"><code>ConfigurationClassPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html"><code>EventListenerMethodProcessor</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same
application context in which it is defined. This means that, if you put
<code>&lt;context:annotation-config/&gt;</code> in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>,
it only checks for <code>@Autowired</code> beans in your controllers, and not your services. See
<a href="../../web.html#mvc-servlet" class="page">The DispatcherServlet</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a>@Required</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>@Required</code> annotation applies to bean property setter methods, as in the following
example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	private MovieFinder movieFinder;

	@Required
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">	class SimpleMovieLister {

	@Required
	lateinit var movieFinder: MovieFinder

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This annotation indicates that the affected bean property must be populated at
configuration time, through an explicit property value in a bean definition or through
autowiring. The container throws an exception if the affected bean property has not been
populated. This allows for eager and explicit failure, avoiding <code>NullPointerException</code>
instances or the like later on. We still recommend that you put assertions into the
bean class itself (for example, into an init method). Doing so enforces those required
references and values even when you use the class outside of a container.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>
must be registered as a bean to enable support for the <code>@Required</code> annotation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@Required</code> annotation and <code>RequiredAnnotationBeanPostProcessor</code> are formally
deprecated as of Spring Framework 5.1, in favor of using constructor injection for
required settings (or a custom implementation of <code>InitializingBean.afterPropertiesSet()</code>
or a custom <code>@PostConstruct</code> method along with bean property setter methods).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a>Using <code>@Autowired</code></h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR 330&#8217;s <code>@Inject</code> annotation can be used in place of Spring&#8217;s <code>@Autowired</code> annotation in the
examples included in this section. See <a href="#beans-standard-annotations">here</a> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can apply the <code>@Autowired</code> annotation to constructors, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private final CustomerPreferenceDao customerPreferenceDao;

	@Autowired
	public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
		this.customerPreferenceDao = customerPreferenceDao;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender @Autowired constructor(
	private val customerPreferenceDao: CustomerPreferenceDao)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 4.3, an <code>@Autowired</code> annotation on such a constructor is no longer
necessary if the target bean defines only one constructor to begin with. However, if
several constructors are available and there is no primary/default constructor, at least
one of the constructors must be annotated with <code>@Autowired</code> in order to instruct the
container which one to use. See the discussion on
<a href="#beans-autowired-annotation-constructor-resolution">constructor resolution</a> for details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also apply the <code>@Autowired</code> annotation to <em>traditional</em> setter methods,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	private MovieFinder movieFinder;

	@Autowired
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimpleMovieLister {

	@Autowired
	lateinit var movieFinder: MovieFinder

	// ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also apply the annotation to methods with arbitrary names and multiple
arguments, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private MovieCatalog movieCatalog;

	private CustomerPreferenceDao customerPreferenceDao;

	@Autowired
	public void prepare(MovieCatalog movieCatalog,
			CustomerPreferenceDao customerPreferenceDao) {
		this.movieCatalog = movieCatalog;
		this.customerPreferenceDao = customerPreferenceDao;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	private lateinit var movieCatalog: MovieCatalog

	private lateinit var customerPreferenceDao: CustomerPreferenceDao

	@Autowired
	fun prepare(movieCatalog: MovieCatalog,
				customerPreferenceDao: CustomerPreferenceDao) {
		this.movieCatalog = movieCatalog
		this.customerPreferenceDao = customerPreferenceDao
	}

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can apply <code>@Autowired</code> to fields as well and even mix it with constructors, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private final CustomerPreferenceDao customerPreferenceDao;

	@Autowired
	private MovieCatalog movieCatalog;

	@Autowired
	public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
		this.customerPreferenceDao = customerPreferenceDao;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender @Autowired constructor(
	private val customerPreferenceDao: CustomerPreferenceDao) {

	@Autowired
	private lateinit var movieCatalog: MovieCatalog

	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that your target components (for example, <code>MovieCatalog</code> or <code>CustomerPreferenceDao</code>)
are consistently declared by the type that you use for your <code>@Autowired</code>-annotated
injection points. Otherwise, injection may fail due to a "no type match found" error at runtime.</p>
</div>
<div class="paragraph">
<p>For XML-defined beans or component classes found via classpath scanning, the container
usually knows the concrete type up front. However, for <code>@Bean</code> factory methods, you need
to make sure that the declared return type is sufficiently expressive. For components
that implement several interfaces or for components potentially referred to by their
implementation type, consider declaring the most specific return type on your factory
method (at least as specific as required by the injection points referring to your bean).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also instruct Spring to provide all beans of a particular type from the
<code>ApplicationContext</code> by adding the <code>@Autowired</code> annotation to a field or method that
expects an array of that type, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	private MovieCatalog[] movieCatalogs;

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	private lateinit var movieCatalogs: Array&lt;MovieCatalog&gt;

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies for typed collections, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private Set&lt;MovieCatalog&gt; movieCatalogs;

	@Autowired
	public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
		this.movieCatalogs = movieCatalogs;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	lateinit var movieCatalogs: Set&lt;MovieCatalog&gt;

	// ...
}</code></pre>
</div>
</div>
<div id="beans-factory-ordered" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Your target beans can implement the <code>org.springframework.core.Ordered</code> interface or use
the <code>@Order</code> or standard <code>@Priority</code> annotation if you want items in the array or list
to be sorted in a specific order. Otherwise, their order follows the registration
order of the corresponding target bean definitions in the container.</p>
</div>
<div class="paragraph">
<p>You can declare the <code>@Order</code> annotation at the target class level and on <code>@Bean</code> methods,
potentially for individual bean definitions (in case of multiple definitions that
use the same bean class). <code>@Order</code> values may influence priorities at injection points,
but be aware that they do not influence singleton startup order, which is an
orthogonal concern determined by dependency relationships and <code>@DependsOn</code> declarations.</p>
</div>
<div class="paragraph">
<p>Note that the standard <code>javax.annotation.Priority</code> annotation is not available at the
<code>@Bean</code> level, since it cannot be declared on methods. Its semantics can be modeled
through <code>@Order</code> values in combination with <code>@Primary</code> on a single bean for each type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even typed <code>Map</code> instances can be autowired as long as the expected key type is <code>String</code>.
The map values contain all beans of the expected type, and the keys contain the
corresponding bean names, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private Map&lt;String, MovieCatalog&gt; movieCatalogs;

	@Autowired
	public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
		this.movieCatalogs = movieCatalogs;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	lateinit var movieCatalogs: Map&lt;String, MovieCatalog&gt;

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, autowiring fails when no matching candidate beans are available for a given
injection point. In the case of a declared array, collection, or map, at least one
matching element is expected.</p>
</div>
<div class="paragraph">
<p>The default behavior is to treat annotated methods and fields as indicating required
dependencies. You can change this behavior as demonstrated in the following example,
enabling the framework to skip a non-satisfiable injection point through marking it as
non-required (i.e., by setting the <code>required</code> attribute in <code>@Autowired</code> to <code>false</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	private MovieFinder movieFinder;

	@Autowired(required = false)
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimpleMovieLister {

	@Autowired(required = false)
	var movieFinder: MovieFinder? = null

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A non-required method will not be called at all if its dependency (or one of its
dependencies, in case of multiple arguments) is not available. A non-required field will
not get populated at all in such cases, leaving its default value in place.</p>
</div>
<div id="beans-autowired-annotation-constructor-resolution" class="paragraph">
<p>Injected constructor and factory method arguments are a special case since the <code>required</code>
attribute in <code>@Autowired</code> has a somewhat different meaning due to Spring&#8217;s constructor
resolution algorithm that may potentially deal with multiple constructors. Constructor
and factory method arguments are effectively required by default but with a few special
rules in a single-constructor scenario, such as multi-element injection points (arrays,
collections, maps) resolving to empty instances if no matching beans are available. This
allows for a common implementation pattern where all dependencies can be declared in a
unique multi-argument constructor — for example, declared as a single public constructor
without an <code>@Autowired</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only one constructor of any given bean class may declare <code>@Autowired</code> with the <code>required</code>
attribute set to <code>true</code>, indicating <em>the</em> constructor to autowire when used as a Spring
bean. As a consequence, if the <code>required</code> attribute is left at its default value <code>true</code>,
only a single constructor may be annotated with <code>@Autowired</code>. If multiple constructors
declare the annotation, they will all have to declare <code>required=false</code> in order to be
considered as candidates for autowiring (analogous to <code>autowire=constructor</code> in XML).
The constructor with the greatest number of dependencies that can be satisfied by matching
beans in the Spring container will be chosen. If none of the candidates can be satisfied,
then a primary/default constructor (if present) will be used. Similarly, if a class
declares multiple constructors but none of them is annotated with <code>@Autowired</code>, then a
primary/default constructor (if present) will be used. If a class only declares a single
constructor to begin with, it will always be used, even if not annotated. Note that an
annotated constructor does not have to be public.</p>
</div>
<div class="paragraph">
<p>The <code>required</code> attribute of <code>@Autowired</code> is recommended over the deprecated <code>@Required</code>
annotation on setter methods. Setting the <code>required</code> attribute to <code>false</code> indicates that
the property is not required for autowiring purposes, and the property is ignored if it
cannot be autowired. <code>@Required</code>, on the other hand, is stronger in that it enforces the
property to be set by any means supported by the container, and if no value is defined,
a corresponding exception is raised.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can express the non-required nature of a particular dependency
through Java 8&#8217;s <code>java.util.Optional</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	@Autowired
	public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
		...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.0, you can also use a <code>@Nullable</code> annotation (of any kind
in any package&#8201;&#8212;&#8201;for example, <code>javax.annotation.Nullable</code> from JSR-305) or just leverage
Kotlin builtin null-safety support:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	@Autowired
	public void setMovieFinder(@Nullable MovieFinder movieFinder) {
		...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimpleMovieLister {

	@Autowired
	var movieFinder: MovieFinder? = null

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <code>@Autowired</code> for interfaces that are well-known resolvable
dependencies: <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>,
<code>ApplicationEventPublisher</code>, and <code>MessageSource</code>. These interfaces and their extended
interfaces, such as <code>ConfigurableApplicationContext</code> or <code>ResourcePatternResolver</code>, are
automatically resolved, with no special setup necessary. The following example autowires
an <code>ApplicationContext</code> object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	private ApplicationContext context;

	public MovieRecommender() {
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	lateinit var context: ApplicationContext

	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@Autowired</code>, <code>@Inject</code>, <code>@Value</code>, and <code>@Resource</code> annotations are handled by Spring
<code>BeanPostProcessor</code> implementations. This means that you cannot apply these annotations
within your own <code>BeanPostProcessor</code> or <code>BeanFactoryPostProcessor</code> types (if any).
These types must be 'wired up' explicitly by using XML or a Spring <code>@Bean</code> method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a>Fine-tuning Annotation-based Autowiring with <code>@Primary</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because autowiring by type may lead to multiple candidates, it is often necessary to have
more control over the selection process. One way to accomplish this is with Spring&#8217;s
<code>@Primary</code> annotation. <code>@Primary</code> indicates that a particular bean should be given
preference when multiple beans are candidates to be autowired to a single-valued
dependency. If exactly one primary bean exists among the candidates, it becomes the
autowired value.</p>
</div>
<div class="paragraph">
<p>Consider the following configuration that defines <code>firstMovieCatalog</code> as the
primary <code>MovieCatalog</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MovieConfiguration {

	@Bean
	@Primary
	public MovieCatalog firstMovieCatalog() { ... }

	@Bean
	public MovieCatalog secondMovieCatalog() { ... }

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class MovieConfiguration {

	@Bean
	@Primary
	fun firstMovieCatalog(): MovieCatalog { ... }

	@Bean
	fun secondMovieCatalog(): MovieCatalog { ... }

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the preceding configuration, the following <code>MovieRecommender</code> is autowired with the
<code>firstMovieCatalog</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	private MovieCatalog movieCatalog;

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	private lateinit var movieCatalog: MovieCatalog

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding bean definitions follow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:annotation-config/&gt;

	&lt;bean class="example.SimpleMovieCatalog" primary="true"&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a>Fine-tuning Annotation-based Autowiring with Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one
primary candidate can be determined. When you need more control over the selection process,
you can use Spring&#8217;s <code>@Qualifier</code> annotation. You can associate qualifier values
with specific arguments, narrowing the set of type matches so that a specific bean is
chosen for each argument. In the simplest case, this can be a plain descriptive value, as
shown in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	@Qualifier("main")
	private MovieCatalog movieCatalog;

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	@Qualifier("main")
	private lateinit var movieCatalog: MovieCatalog

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify the <code>@Qualifier</code> annotation on individual constructor arguments or
method parameters, as shown in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	private MovieCatalog movieCatalog;

	private CustomerPreferenceDao customerPreferenceDao;

	@Autowired
	public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
			CustomerPreferenceDao customerPreferenceDao) {
		this.movieCatalog = movieCatalog;
		this.customerPreferenceDao = customerPreferenceDao;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	private lateinit var movieCatalog: MovieCatalog

	private lateinit var customerPreferenceDao: CustomerPreferenceDao

	@Autowired
	fun prepare(@Qualifier("main") movieCatalog: MovieCatalog,
				customerPreferenceDao: CustomerPreferenceDao) {
		this.movieCatalog = movieCatalog
		this.customerPreferenceDao = customerPreferenceDao
	}

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows corresponding bean definitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:annotation-config/&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier value="main"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier value="action"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>

		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The bean with the <code>main</code> qualifier value is wired with the constructor argument that
is qualified with the same value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The bean with the <code>action</code> qualifier value is wired with the constructor argument that
is qualified with the same value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For a fallback match, the bean name is considered a default qualifier value. Thus, you
can define the bean with an <code>id</code> of <code>main</code> instead of the nested qualifier element, leading
to the same matching result. However, although you can use this convention to refer to
specific beans by name, <code>@Autowired</code> is fundamentally about type-driven injection with
optional semantic qualifiers. This means that qualifier values, even with the bean name
fallback, always have narrowing semantics within the set of type matches. They do not
semantically express a reference to a unique bean <code>id</code>. Good qualifier values are <code>main</code>
or <code>EMEA</code> or <code>persistent</code>, expressing characteristics of a specific component that are
independent from the bean <code>id</code>, which may be auto-generated in case of an anonymous bean
definition such as the one in the preceding example.</p>
</div>
<div class="paragraph">
<p>Qualifiers also apply to typed collections, as discussed earlier&#8201;&#8212;&#8201;for example, to
<code>Set&lt;MovieCatalog&gt;</code>. In this case, all matching beans, according to the declared
qualifiers, are injected as a collection. This implies that qualifiers do not have to be
unique. Rather, they constitute filtering criteria. For example, you can define
multiple <code>MovieCatalog</code> beans with the same qualifier value &#8220;action&#8221;, all of which are
injected into a <code>Set&lt;MovieCatalog&gt;</code> annotated with <code>@Qualifier("action")</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Letting qualifier values select against target bean names, within the type-matching
candidates, does not require a <code>@Qualifier</code> annotation at the injection point.
If there is no other resolution indicator (such as a qualifier or a primary marker),
for a non-unique dependency situation, Spring matches the injection point name
(that is, the field name or parameter name) against the target bean names and choose the
same-named candidate, if any.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That said, if you intend to express annotation-driven injection by name, do not
primarily use <code>@Autowired</code>, even if it is capable of selecting by bean name among
type-matching candidates. Instead, use the JSR-250 <code>@Resource</code> annotation, which is
semantically defined to identify a specific target component by its unique name, with
the declared type being irrelevant for the matching process. <code>@Autowired</code> has rather
different semantics: After selecting candidate beans by type, the specified <code>String</code>
qualifier value is considered within those type-selected candidates only (for example,
matching an <code>account</code> qualifier against beans marked with the same qualifier label).</p>
</div>
<div class="paragraph">
<p>For beans that are themselves defined as a collection, <code>Map</code>, or array type, <code>@Resource</code>
is a fine solution, referring to the specific collection or array bean by unique name.
That said, as of 4.3, collection, you can match <code>Map</code>, and array types through Spring&#8217;s
<code>@Autowired</code> type matching algorithm as well, as long as the element type information
is preserved in <code>@Bean</code> return type signatures or collection inheritance hierarchies.
In this case, you can use qualifier values to select among same-typed collections,
as outlined in the previous paragraph.</p>
</div>
<div class="paragraph">
<p>As of 4.3, <code>@Autowired</code> also considers self references for injection (that is, references
back to the bean that is currently injected). Note that self injection is a fallback.
Regular dependencies on other components always have precedence. In that sense, self
references do not participate in regular candidate selection and are therefore in
particular never primary. On the contrary, they always end up as lowest precedence.
In practice, you should use self references as a last resort only (for example, for
calling other methods on the same instance through the bean&#8217;s transactional proxy).
Consider factoring out the affected methods to a separate delegate bean in such a scenario.
Alternatively, you can use <code>@Resource</code>, which may obtain a proxy back to the current bean
by its unique name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Trying to inject the results from <code>@Bean</code> methods on the same configuration class is
effectively a self-reference scenario as well. Either lazily resolve such references
in the method signature where it is actually needed (as opposed to an autowired field
in the configuration class) or declare the affected <code>@Bean</code> methods as <code>static</code>,
decoupling them from the containing configuration class instance and its lifecycle.
Otherwise, such beans are only considered in the fallback phase, with matching beans
on other configuration classes selected as primary candidates instead (if available).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Autowired</code> applies to fields, constructors, and multi-argument methods, allowing for
narrowing through qualifier annotations at the parameter level. In contrast, <code>@Resource</code>
is supported only for fields and bean property setter methods with a single argument.
As a consequence, you should stick with qualifiers if your injection target is a
constructor or a multi-argument method.</p>
</div>
<div class="paragraph">
<p>You can create your own custom qualifier annotations. To do so, define an annotation and
provide the <code>@Qualifier</code> annotation within your definition, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

	String value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Genre(val value: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can provide the custom qualifier on autowired fields and parameters, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	@Genre("Action")
	private MovieCatalog actionCatalog;

	private MovieCatalog comedyCatalog;

	@Autowired
	public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
		this.comedyCatalog = comedyCatalog;
	}

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	@Genre("Action")
	private lateinit var actionCatalog: MovieCatalog

	private lateinit var comedyCatalog: MovieCatalog

	@Autowired
	fun setComedyCatalog(@Genre("Comedy") comedyCatalog: MovieCatalog) {
		this.comedyCatalog = comedyCatalog
	}

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, you can provide the information for the candidate bean definitions. You can add
<code>&lt;qualifier/&gt;</code> tags as sub-elements of the <code>&lt;bean/&gt;</code> tag and then specify the <code>type</code> and
<code>value</code> to match your custom qualifier annotations. The type is matched against the
fully-qualified class name of the annotation. Alternately, as a convenience if no risk of
conflicting names exists, you can use the short class name. The following example
demonstrates both approaches:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:annotation-config/&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier type="Genre" value="Action"/&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier type="example.Genre" value="Comedy"/&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#beans-classpath-scanning">[beans-classpath-scanning]</a>, you can see an annotation-based alternative to
providing the qualifier metadata in XML. Specifically, see <a href="#beans-scanning-qualifiers">[beans-scanning-qualifiers]</a>.</p>
</div>
<div class="paragraph">
<p>In some cases, using an annotation without a value may suffice. This can be
useful when the annotation serves a more generic purpose and can be applied across
several different types of dependencies. For example, you may provide an offline
catalog that can be searched when no Internet connection is available. First, define
the simple annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Offline</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the annotation to the field or property to be autowired, as shown in the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	@Offline <i class="conum" data-value="1"></i><b>(1)</b>
	private MovieCatalog offlineCatalog;

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line adds the <code>@Offline</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	@Offline <i class="conum" data-value="1"></i><b>(1)</b>
	private lateinit var offlineCatalog: MovieCatalog

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line adds the <code>@Offline</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now the bean definition only needs a qualifier <code>type</code>, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="example.SimpleMovieCatalog"&gt;
	&lt;qualifier type="Offline"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
	&lt;!-- inject any dependencies required by this bean --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This element specifies the qualifier.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also define custom qualifier annotations that accept named attributes in
addition to or instead of the simple <code>value</code> attribute. If multiple attribute values are
then specified on a field or parameter to be autowired, a bean definition must match
all such attribute values to be considered an autowire candidate. As an example,
consider the following annotation definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

	String genre();

	Format format();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class MovieQualifier(val genre: String, val format: Format)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case <code>Format</code> is an enum, defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public enum Format {
	VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">enum class Format {
	VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fields to be autowired are annotated with the custom qualifier and include values
for both attributes: <code>genre</code> and <code>format</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Autowired
	@MovieQualifier(format=Format.VHS, genre="Action")
	private MovieCatalog actionVhsCatalog;

	@Autowired
	@MovieQualifier(format=Format.VHS, genre="Comedy")
	private MovieCatalog comedyVhsCatalog;

	@Autowired
	@MovieQualifier(format=Format.DVD, genre="Action")
	private MovieCatalog actionDvdCatalog;

	@Autowired
	@MovieQualifier(format=Format.BLURAY, genre="Comedy")
	private MovieCatalog comedyBluRayCatalog;

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Autowired
	@MovieQualifier(format = Format.VHS, genre = "Action")
	private lateinit var actionVhsCatalog: MovieCatalog

	@Autowired
	@MovieQualifier(format = Format.VHS, genre = "Comedy")
	private lateinit var comedyVhsCatalog: MovieCatalog

	@Autowired
	@MovieQualifier(format = Format.DVD, genre = "Action")
	private lateinit var actionDvdCatalog: MovieCatalog

	@Autowired
	@MovieQualifier(format = Format.BLURAY, genre = "Comedy")
	private lateinit var comedyBluRayCatalog: MovieCatalog

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the bean definitions should contain matching qualifier values. This example
also demonstrates that you can use bean meta attributes instead of the
<code>&lt;qualifier/&gt;</code> elements. If available, the <code>&lt;qualifier/&gt;</code> element and its attributes take
precedence, but the autowiring mechanism falls back on the values provided within the
<code>&lt;meta/&gt;</code> tags if no such qualifier is present, as in the last two bean definitions in
the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:annotation-config/&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier type="MovieQualifier"&gt;
			&lt;attribute key="format" value="VHS"/&gt;
			&lt;attribute key="genre" value="Action"/&gt;
		&lt;/qualifier&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;qualifier type="MovieQualifier"&gt;
			&lt;attribute key="format" value="VHS"/&gt;
			&lt;attribute key="genre" value="Comedy"/&gt;
		&lt;/qualifier&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;meta key="format" value="DVD"/&gt;
		&lt;meta key="genre" value="Action"/&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

	&lt;bean class="example.SimpleMovieCatalog"&gt;
		&lt;meta key="format" value="BLURAY"/&gt;
		&lt;meta key="genre" value="Comedy"/&gt;
		&lt;!-- inject any dependencies required by this bean --&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a>Using Generics as Autowiring Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to the <code>@Qualifier</code> annotation, you can use Java generic types
as an implicit form of qualification. For example, suppose you have the following
configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {

	@Bean
	public StringStore stringStore() {
		return new StringStore();
	}

	@Bean
	public IntegerStore integerStore() {
		return new IntegerStore();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class MyConfiguration {

	@Bean
	fun stringStore() = StringStore()

	@Bean
	fun integerStore() = IntegerStore()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that the preceding beans implement a generic interface, (that is, <code>Store&lt;String&gt;</code> and
<code>Store&lt;Integer&gt;</code>), you can <code>@Autowire</code> the <code>Store</code> interface and the generic is
used as a qualifier, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Autowired
private lateinit var s1: Store&lt;String&gt; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private lateinit var s2: Store&lt;Integer&gt; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generic qualifiers also apply when autowiring lists, <code>Map</code> instances and arrays. The
following example autowires a generic <code>List</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private lateinit var s: List&lt;Store&lt;Integer&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a>Using <code>CustomAutowireConfigurer</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>
is a <code>BeanFactoryPostProcessor</code> that lets you register your own custom qualifier
annotation types, even if they are not annotated with Spring&#8217;s <code>@Qualifier</code> annotation.
The following example shows how to use <code>CustomAutowireConfigurer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="customAutowireConfigurer"
		class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
	&lt;property name="customQualifierTypes"&gt;
		&lt;set&gt;
			&lt;value&gt;example.CustomQualifier&lt;/value&gt;
		&lt;/set&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AutowireCandidateResolver</code> determines autowire candidates by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>autowire-candidate</code> value of each bean definition</p>
</li>
<li>
<p>Any <code>default-autowire-candidates</code> patterns available on the <code>&lt;beans/&gt;</code> element</p>
</li>
<li>
<p>The presence of <code>@Qualifier</code> annotations and any custom annotations registered
with the <code>CustomAutowireConfigurer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When multiple beans qualify as autowire candidates, the determination of a &#8220;primary&#8221; is
as follows: If exactly one bean definition among the candidates has a <code>primary</code>
attribute set to <code>true</code>, it is selected.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a>Injection with <code>@Resource</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring also supports injection by using the JSR-250 <code>@Resource</code> annotation
(<code>javax.annotation.Resource</code>) on fields or bean property setter methods.
This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS
endpoints. Spring supports this pattern for Spring-managed objects as well.</p>
</div>
<div class="paragraph">
<p><code>@Resource</code> takes a name attribute. By default, Spring interprets that value as
the bean name to be injected. In other words, it follows by-name semantics,
as demonstrated in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	private MovieFinder movieFinder;

	@Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line injects a <code>@Resource</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimpleMovieLister {

	@Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
	private lateinit var movieFinder:MovieFinder
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line injects a <code>@Resource</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If no name is explicitly specified, the default name is derived from the field name or
setter method. In case of a field, it takes the field name. In case of a setter method,
it takes the bean property name. The following example is going to have the bean
named <code>movieFinder</code> injected into its setter method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleMovieLister {

	private MovieFinder movieFinder;

	@Resource
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimpleMovieLister {

	@Resource
	private lateinit var movieFinder: MovieFinder

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The name provided with the annotation is resolved as a bean name by the
<code>ApplicationContext</code> of which the <code>CommonAnnotationBeanPostProcessor</code> is aware.
The names can be resolved through JNDI if you configure Spring&#8217;s
<a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>
explicitly. However, we recommend that you rely on the default behavior and
use Spring&#8217;s JNDI lookup capabilities to preserve the level of indirection.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the exclusive case of <code>@Resource</code> usage with no explicit name specified, and similar
to <code>@Autowired</code>, <code>@Resource</code> finds a primary type match instead of a specific named bean
and resolves well known resolvable dependencies: the <code>BeanFactory</code>,
<code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code>
interfaces.</p>
</div>
<div class="paragraph">
<p>Thus, in the following example, the <code>customerPreferenceDao</code> field first looks for a bean
named "customerPreferenceDao" and then falls back to a primary type match for the type
<code>CustomerPreferenceDao</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MovieRecommender {

	@Resource
	private CustomerPreferenceDao customerPreferenceDao;

	@Resource
	private ApplicationContext context; <i class="conum" data-value="1"></i><b>(1)</b>

	public MovieRecommender() {
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>context</code> field is injected based on the known resolvable dependency type:
<code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MovieRecommender {

	@Resource
	private lateinit var customerPreferenceDao: CustomerPreferenceDao


	@Resource
	private lateinit var context: ApplicationContext <i class="conum" data-value="1"></i><b>(1)</b>

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>context</code> field is injected based on the known resolvable dependency type:
<code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-value-annotations"><a class="anchor" href="#beans-value-annotations"></a>Using <code>@Value</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>@Value</code> is typically used to inject externalized properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class MovieRecommender(@Value("\${catalog.name}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the following configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@PropertySource("classpath:application.properties")
class AppConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following <code>application.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">catalog.name=MovieCatalog</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, the <code>catalog</code> parameter and field will be equal to the <code>MovieCatalog</code> value.</p>
</div>
<div class="paragraph">
<p>A default lenient embedded value resolver is provided by Spring. It will try to resolve the
property value and if it cannot be resolved, the property name (for example <code>${catalog.name}</code>)
will be injected as the value. If you want to maintain strict control over nonexistent
values, you should declare a <code>PropertySourcesPlaceholderConfigurer</code> bean, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class AppConfig {

	@Bean
	fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When configuring a <code>PropertySourcesPlaceholderConfigurer</code> using JavaConfig, the
<code>@Bean</code> method must be <code>static</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the above configuration ensures Spring initialization failure if any <code>${}</code>
placeholder could not be resolved. It is also possible to use methods like
<code>setPlaceholderPrefix</code>, <code>setPlaceholderSuffix</code>, or <code>setValueSeparator</code> to customize
placeholders.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot configures by default a <code>PropertySourcesPlaceholderConfigurer</code> bean that
will get properties from <code>application.properties</code> and <code>application.yml</code> files.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Built-in converter support provided by Spring allows simple type conversion (to <code>Integer</code>
or <code>int</code> for example) to be automatically handled. Multiple comma-separated values can be
automatically converted to String array without extra effort.</p>
</div>
<div class="paragraph">
<p>It is possible to provide a default value as following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class MovieRecommender(@Value("\${catalog.name:defaultCatalog}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Spring <code>BeanPostProcessor</code> uses a <code>ConversionService</code> behind the scene to handle the
process for converting the String value in <code>@Value</code> to the target type. If you want to
provide conversion support for your own custom type, you can provide your own
<code>ConversionService</code> bean instance as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class AppConfig {

	@Bean
	fun conversionService(): ConversionService {
			return DefaultFormattingConversionService().apply {
			addConverter(MyCustomConverter())
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>@Value</code> contains a <a href="#expressions"><code>SpEL</code> expression</a> the value will be dynamically
computed at runtime as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class MovieRecommender(
	@Value("#{systemProperties['user.catalog'] + 'Catalog' }") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>SpEL also enables the use of more complex data structures:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MovieRecommender {

    private final Map&lt;String, Integer&gt; countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map&lt;String, Integer&gt; countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class MovieRecommender(
	@Value("#{{'Thriller': 100, 'Comedy': 300}}") private val countOfMoviesPerCatalog: Map&lt;String, Int&gt;)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a>Using <code>@PostConstruct</code> and <code>@PreDestroy</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation
but also the JSR-250 lifecycle annotations: <code>javax.annotation.PostConstruct</code> and
<code>javax.annotation.PreDestroy</code>. Introduced in Spring 2.5, the support for these
annotations offers an alternative to the lifecycle callback mechanism described in
<a href="#beans-factory-lifecycle-initializingbean">initialization callbacks</a> and
<a href="#beans-factory-lifecycle-disposablebean">destruction callbacks</a>. Provided that the
<code>CommonAnnotationBeanPostProcessor</code> is registered within the Spring <code>ApplicationContext</code>,
a method carrying one of these annotations is invoked at the same point in the lifecycle
as the corresponding Spring lifecycle interface method or explicitly declared callback
method. In the following example, the cache is pre-populated upon initialization and
cleared upon destruction:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CachingMovieLister {

	@PostConstruct
	public void populateMovieCache() {
		// populates the movie cache upon initialization...
	}

	@PreDestroy
	public void clearMovieCache() {
		// clears the movie cache upon destruction...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CachingMovieLister {

	@PostConstruct
	fun populateMovieCache() {
		// populates the movie cache upon initialization...
	}

	@PreDestroy
	fun clearMovieCache() {
		// clears the movie cache upon destruction...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the effects of combining various lifecycle mechanisms, see
<a href="#beans-factory-lifecycle-combined-effects">[beans-factory-lifecycle-combined-effects]</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Like <code>@Resource</code>, the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotation types were a part
of the standard Java libraries from JDK 6 to 8. However, the entire <code>javax.annotation</code>
package got separated from the core Java modules in JDK 9 and eventually removed in
JDK 11. If needed, the <code>javax.annotation-api</code> artifact needs to be obtained via Maven
Central now, simply to be added to the application&#8217;s classpath like any other library.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="extension.html">Container Extension Points</a></span>
  <span class="next"><a href="scanning.html">Classpath Scanning and Managed Components</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/vendor/tabs.js"></script>
  </body>
</html>
