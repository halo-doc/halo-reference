<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring AOP APIs :: Spring</title>
    <link rel="prev" href="aop.html">
    <link rel="next" href="null-safety.html">
    <meta name="generator" content="Antora 3.0.0-alpha.6">
    <link rel="stylesheet" href="../../../_/css/site.css">

<link href="../../../_/img/favicon.ico" rel='shortcut icon' type='image/vnd.microsoft.icon'>
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">
        <img id="springlogo" class="block" src="../../../_/img/spring-logo.svg" alt="Spring">
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://spring.io/">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/why-spring">Overview</a>
            <a class="navbar-item" href="https://spring.io/microservices">Microservices</a>
            <a class="navbar-item" href="https://spring.io/reactive">Reactive</a>
            <a class="navbar-item" href="https://spring.io/event-driven">Event Driven</a>
            <a class="navbar-item" href="https://spring.io/cloud">Cloud</a>
            <a class="navbar-item" href="https://spring.io/web-applications">Web Applications</a>
            <a class="navbar-item" href="https://spring.io/serverless">Serverless</a>
            <a class="navbar-item" href="https://spring.io/batch">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/learn">Overview</a>
            <a class="navbar-item" href="https://spring.io/quickstart">Quickstart</a>
            <a class="navbar-item" href="https://spring.io/guides">Guides</a>
            <a class="navbar-item" href="https://spring.io/blog">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/projects">Overview</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-boot">Spring Boot</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-framework">Spring Framework</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud">Spring Cloud</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-cloud-dataflow">Spring Cloud Data Flow</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-data">Spring Data</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-integration">Spring Integration</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-batch">Spring Batch</a>
            <a class="navbar-item" href="https://spring.io/projects/spring-security">Spring Security</a>
            <a class="navbar-item" class="blue mb-2 inline-block" href="https://spring.io/projects">View all projects</a>
            <a class="navbar-item" href="https://spring.io/tools">Spring Tools 4</a>
          </div>
        </div>

        <a class="navbar-item" href="https://spring.io/training">Training</a>
        <a class="navbar-item" href="https://spring.io/support">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://spring.io/community">Overview</a>
            <a class="navbar-item" href="https://spring.io/events">Events</a>
            <a class="navbar-item" href="https://spring.io/team">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="beans/index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="resources.html">Resources</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/6/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/6/overview/prerequisites.html">6</a>
        </li>
        <li class="version">
          <a href="../../../security/5.6/overview/index.html">5.6</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="../core.html">Core</a></li>
    <li><a href="aop-api.html">Spring AOP APIs</a></li>
  </ul>
</nav>
<div>
  <input id="search-input" type="text" placeholder="Search docs">
</div>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/aop-api.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Spring AOP APIs</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The previous chapter described the Spring&#8217;s support for AOP with @AspectJ and schema-based
aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common
applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the
previous chapter.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a>Pointcut API in Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how Spring handles the crucial pointcut concept.</p>
</div>
<div class="sect2">
<h3 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a>Concepts</h3>
<div class="paragraph">
<p>Spring&#8217;s pointcut model enables pointcut reuse independent of advice types. You can
target different advice with the same pointcut.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.Pointcut</code> interface is the central interface, used to
target advices to particular classes and methods. The complete interface follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Pointcut {

	ClassFilter getClassFilter();

	MethodMatcher getMethodMatcher();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Splitting the <code>Pointcut</code> interface into two parts allows reuse of class and method
matching parts and fine-grained composition operations (such as performing a &#8220;union&#8221;
with another method matcher).</p>
</div>
<div class="paragraph">
<p>The <code>ClassFilter</code> interface is used to restrict the pointcut to a given set of target
classes. If the <code>matches()</code> method always returns true, all target classes are
matched. The following listing shows the <code>ClassFilter</code> interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ClassFilter {

	boolean matches(Class clazz);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodMatcher</code> interface is normally more important. The complete interface follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MethodMatcher {

	boolean matches(Method m, Class&lt;?&gt; targetClass);

	boolean isRuntime();

	boolean matches(Method m, Class&lt;?&gt; targetClass, Object... args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>matches(Method, Class)</code> method is used to test whether this pointcut ever
matches a given method on a target class. This evaluation can be performed when an AOP
proxy is created to avoid the need for a test on every method invocation. If the
two-argument <code>matches</code> method returns <code>true</code> for a given method, and the <code>isRuntime()</code>
method for the MethodMatcher returns <code>true</code>, the three-argument matches method is
invoked on every method invocation. This lets a pointcut look at the arguments passed
to the method invocation immediately before the target advice starts.</p>
</div>
<div class="paragraph">
<p>Most <code>MethodMatcher</code> implementations are static, meaning that their <code>isRuntime()</code> method
returns <code>false</code>. In this case, the three-argument <code>matches</code> method is never invoked.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If possible, try to make pointcuts static, allowing the AOP framework to cache the
results of pointcut evaluation when an AOP proxy is created.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a>Operations on Pointcuts</h3>
<div class="paragraph">
<p>Spring supports operations (notably, union and intersection) on pointcuts.</p>
</div>
<div class="paragraph">
<p>Union means the methods that either pointcut matches.
Intersection means the methods that both pointcuts match.
Union is usually more useful.
You can compose pointcuts by using the static methods in the
<code>org.springframework.aop.support.Pointcuts</code> class or by using the
<code>ComposablePointcut</code> class in the same package. However, using AspectJ pointcut
expressions is usually a simpler approach.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a>AspectJ Expression Pointcuts</h3>
<div class="paragraph">
<p>Since 2.0, the most important type of pointcut used by Spring is
<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>. This is a pointcut that
uses an AspectJ-supplied library to parse an AspectJ pointcut expression string.</p>
</div>
<div class="paragraph">
<p>See the <a href="#aop">previous chapter</a> for a discussion of supported AspectJ pointcut primitives.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a>Convenience Pointcut Implementations</h3>
<div class="paragraph">
<p>Spring provides several convenient pointcut implementations. You can use some of them
directly; others are intended to be subclassed in application-specific pointcuts.</p>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>Static Pointcuts</h4>
<div class="paragraph">
<p>Static pointcuts are based on the method and the target class and cannot take into account
the method&#8217;s arguments. Static pointcuts suffice&#8201;&#8212;&#8201;and are best&#8201;&#8212;&#8201;for most usages.
Spring can evaluate a static pointcut only once, when a method is first invoked.
After that, there is no need to evaluate the pointcut again with each method invocation.</p>
</div>
<div class="paragraph">
<p>The rest of this section describes some of the static pointcut implementations that are
included with Spring.</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>Regular Expression Pointcuts</h5>
<div class="paragraph">
<p>One obvious way to specify static pointcuts is regular expressions. Several AOP
frameworks besides Spring make this possible.
<code>org.springframework.aop.support.JdkRegexpMethodPointcut</code> is a generic regular
expression pointcut that uses the regular expression support in the JDK.</p>
</div>
<div class="paragraph">
<p>With the <code>JdkRegexpMethodPointcut</code> class, you can provide a list of pattern strings.
If any of these is a match, the pointcut evaluates to <code>true</code>. (As a consequence,
the resulting pointcut is effectively the union of the specified patterns.)</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>JdkRegexpMethodPointcut</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="settersAndAbsquatulatePointcut"
		class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
	&lt;property name="patterns"&gt;
		&lt;list&gt;
			&lt;value&gt;.*set.*&lt;/value&gt;
			&lt;value&gt;.*absquatulate&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring provides a convenience class named <code>RegexpMethodPointcutAdvisor</code>, which lets us
also reference an <code>Advice</code> (remember that an <code>Advice</code> can be an interceptor, before advice,
throws advice, and others). Behind the scenes, Spring uses a <code>JdkRegexpMethodPointcut</code>.
Using <code>RegexpMethodPointcutAdvisor</code> simplifies wiring, as the one bean encapsulates both
pointcut and advice, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="settersAndAbsquatulateAdvisor"
		class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
	&lt;property name="advice"&gt;
		&lt;ref bean="beanNameOfAopAllianceInterceptor"/&gt;
	&lt;/property&gt;
	&lt;property name="patterns"&gt;
		&lt;list&gt;
			&lt;value&gt;.*set.*&lt;/value&gt;
			&lt;value&gt;.*absquatulate&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>RegexpMethodPointcutAdvisor</code> with any <code>Advice</code> type.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>Attribute-driven Pointcuts</h5>
<div class="paragraph">
<p>An important type of static pointcut is a metadata-driven pointcut. This uses the
values of metadata attributes (typically, source-level metadata).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>Dynamic pointcuts</h4>
<div class="paragraph">
<p>Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account
method arguments as well as static information. This means that they must be
evaluated with every method invocation and that the result cannot be cached, as arguments will
vary.</p>
</div>
<div class="paragraph">
<p>The main example is the <code>control flow</code> pointcut.</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>Control Flow Pointcuts</h5>
<div class="paragraph">
<p>Spring control flow pointcuts are conceptually similar to AspectJ <code>cflow</code> pointcuts,
although less powerful. (There is currently no way to specify that a pointcut runs
below a join point matched by another pointcut.) A control flow pointcut matches the
current call stack. For example, it might fire if the join point was invoked by a method
in the <code>com.mycompany.web</code> package or by the <code>SomeCaller</code> class. Control flow pointcuts
are specified by using the <code>org.springframework.aop.support.ControlFlowPointcut</code> class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Control flow pointcuts are significantly more expensive to evaluate at runtime than even
other dynamic pointcuts. In Java 1.4, the cost is about five times that of other dynamic
pointcuts.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a>Pointcut Superclasses</h3>
<div class="paragraph">
<p>Spring provides useful pointcut superclasses to help you to implement your own pointcuts.</p>
</div>
<div class="paragraph">
<p>Because static pointcuts are most useful, you should probably subclass
<code>StaticMethodMatcherPointcut</code>. This requires implementing only one
abstract method (although you can override other methods to customize behavior). The
following example shows how to subclass <code>StaticMethodMatcherPointcut</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class TestStaticPointcut extends StaticMethodMatcherPointcut {

	public boolean matches(Method m, Class targetClass) {
		// return true if custom criteria match
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class TestStaticPointcut : StaticMethodMatcherPointcut() {

	override fun matches(method: Method, targetClass: Class&lt;*&gt;): Boolean {
		// return true if custom criteria match
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are also superclasses for dynamic pointcuts.
You can use custom pointcuts with any advice type.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a>Custom Pointcuts</h3>
<div class="paragraph">
<p>Because pointcuts in Spring AOP are Java classes rather than language features (as in
AspectJ), you can declare custom pointcuts, whether static or dynamic. Custom
pointcuts in Spring can be arbitrarily complex. However, we recommend using the AspectJ pointcut
expression language, if you can.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Later versions of Spring may offer support for &#8220;semantic pointcuts&#8221; as offered by JAC&#8201;&#8212;&#8201;for example, &#8220;all methods that change instance variables in the target object.&#8221;
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a>Advice API in Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now we can examine how Spring AOP handles advice.</p>
</div>
<div class="sect2">
<h3 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a>Advice Lifecycles</h3>
<div class="paragraph">
<p>Each advice is a Spring bean. An advice instance can be shared across all advised
objects or be unique to each advised object. This corresponds to per-class or
per-instance advice.</p>
</div>
<div class="paragraph">
<p>Per-class advice is used most often. It is appropriate for generic advice, such as
transaction advisors. These do not depend on the state of the proxied object or add new
state. They merely act on the method and arguments.</p>
</div>
<div class="paragraph">
<p>Per-instance advice is appropriate for introductions, to support mixins. In this case,
the advice adds state to the proxied object.</p>
</div>
<div class="paragraph">
<p>You can use a mix of shared and per-instance advice in the same AOP proxy.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a>Advice Types in Spring</h3>
<div class="paragraph">
<p>Spring provides several advice types and is extensible to support
arbitrary advice types. This section describes the basic concepts and standard advice types.</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>Interception Around Advice</h4>
<div class="paragraph">
<p>The most fundamental advice type in Spring is interception around advice.</p>
</div>
<div class="paragraph">
<p>Spring is compliant with the AOP <code>Alliance</code> interface for around advice that uses method
interception. Classes that implement <code>MethodInterceptor</code> and that implement around advice should also implement the
following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MethodInterceptor extends Interceptor {

	Object invoke(MethodInvocation invocation) throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodInvocation</code> argument to the <code>invoke()</code> method exposes the method being
invoked, the target join point, the AOP proxy, and the arguments to the method. The
<code>invoke()</code> method should return the invocation&#8217;s result: the return value of the join
point.</p>
</div>
<div class="paragraph">
<p>The following example shows a simple <code>MethodInterceptor</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DebugInterceptor implements MethodInterceptor {

	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("Before: invocation=[" + invocation + "]");
		Object rval = invocation.proceed();
		System.out.println("Invocation returned");
		return rval;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class DebugInterceptor : MethodInterceptor {

	override fun invoke(invocation: MethodInvocation): Any {
		println("Before: invocation=[$invocation]")
		val rval = invocation.proceed()
		println("Invocation returned")
		return rval
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the call to the <code>proceed()</code> method of <code>MethodInvocation</code>. This proceeds down the
interceptor chain towards the join point. Most interceptors invoke this method and
return its return value. However, a <code>MethodInterceptor</code>, like any around advice, can
return a different value or throw an exception rather than invoke the proceed method.
However, you do not want to do this without good reason.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MethodInterceptor</code> implementations offer interoperability with other AOP Alliance-compliant AOP
implementations. The other advice types discussed in the remainder of this section
implement common AOP concepts but in a Spring-specific way. While there is an advantage
in using the most specific advice type, stick with <code>MethodInterceptor</code> around advice if
you are likely to want to run the aspect in another AOP framework. Note that pointcuts
are not currently interoperable between frameworks, and the AOP Alliance does not
currently define pointcut interfaces.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>Before Advice</h4>
<div class="paragraph">
<p>A simpler advice type is a before advice. This does not need a <code>MethodInvocation</code>
object, since it is called only before entering the method.</p>
</div>
<div class="paragraph">
<p>The main advantage of a before advice is that there is no need to invoke the <code>proceed()</code>
method and, therefore, no possibility of inadvertently failing to proceed down the
interceptor chain.</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>MethodBeforeAdvice</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MethodBeforeAdvice extends BeforeAdvice {

	void before(Method m, Object[] args, Object target) throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Spring&#8217;s API design would allow for
field before advice, although the usual objects apply to field interception and it is
unlikely for Spring to ever implement it.)</p>
</div>
<div class="paragraph">
<p>Note that the return type is <code>void</code>. Before advice can insert custom behavior before the join
point runs but cannot change the return value. If a before advice throws an
exception, it stops further execution of the interceptor chain. The exception
propagates back up the interceptor chain. If it is unchecked or on the signature of
the invoked method, it is passed directly to the client. Otherwise, it is
wrapped in an unchecked exception by the AOP proxy.</p>
</div>
<div class="paragraph">
<p>The following example shows a before advice in Spring, which counts all method invocations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CountingBeforeAdvice implements MethodBeforeAdvice {

	private int count;

	public void before(Method m, Object[] args, Object target) throws Throwable {
		++count;
	}

	public int getCount() {
		return count;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CountingBeforeAdvice : MethodBeforeAdvice {

	var count: Int = 0

	override fun before(m: Method, args: Array&lt;Any&gt;, target: Any?) {
		++count
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Before advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>Throws Advice</h4>
<div class="paragraph">
<p>Throws advice is invoked after the return of the join point if the join point threw
an exception. Spring offers typed throws advice. Note that this means that the
<code>org.springframework.aop.ThrowsAdvice</code> interface does not contain any methods. It is a
tag interface identifying that the given object implements one or more typed throws
advice methods. These should be in the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">afterThrowing([Method, args, target], subclassOfThrowable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only the last argument is required. The method signatures may have either one or four
arguments, depending on whether the advice method is interested in the method and
arguments. The next two listing show classes that are examples of throws advice.</p>
</div>
<div class="paragraph">
<p>The following advice is invoked if a <code>RemoteException</code> is thrown (including from subclasses):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class RemoteThrowsAdvice implements ThrowsAdvice {

	public void afterThrowing(RemoteException ex) throws Throwable {
		// Do something with remote exception
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class RemoteThrowsAdvice : ThrowsAdvice {

	fun afterThrowing(ex: RemoteException) {
		// Do something with remote exception
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the preceding
advice, the next example declares four arguments, so that it has access to the invoked method, method
arguments, and target object. The following advice is invoked if a <code>ServletException</code> is thrown:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

	public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
		// Do something with all arguments
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class ServletThrowsAdviceWithArguments : ThrowsAdvice {

	fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
		// Do something with all arguments
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final example illustrates how these two methods could be used in a single class
that handles both <code>RemoteException</code> and <code>ServletException</code>. Any number of throws advice
methods can be combined in a single class. The following listing shows the final example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class CombinedThrowsAdvice implements ThrowsAdvice {

	public void afterThrowing(RemoteException ex) throws Throwable {
		// Do something with remote exception
	}

	public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
		// Do something with all arguments
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CombinedThrowsAdvice : ThrowsAdvice {

	fun afterThrowing(ex: RemoteException) {
		// Do something with remote exception
	}

	fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
		// Do something with all arguments
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a throws-advice method throws an exception itself, it overrides the
original exception (that is, it changes the exception thrown to the user). The overriding
exception is typically a RuntimeException, which is compatible with any method
signature. However, if a throws-advice method throws a checked exception, it must
match the declared exceptions of the target method and is, hence, to some degree
coupled to specific target method signatures. <em>Do not throw an undeclared checked
exception that is incompatible with the target method&#8217;s signature!</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Throws advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>After Returning Advice</h4>
<div class="paragraph">
<p>An after returning advice in Spring must implement the
<code>org.springframework.aop.AfterReturningAdvice</code> interface, which the following listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface AfterReturningAdvice extends Advice {

	void afterReturning(Object returnValue, Method m, Object[] args, Object target)
			throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An after returning advice has access to the return value (which it cannot modify),
the invoked method, the method&#8217;s arguments, and the target.</p>
</div>
<div class="paragraph">
<p>The following after returning advice counts all successful method invocations that have
not thrown exceptions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

	private int count;

	public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
			throws Throwable {
		++count;
	}

	public int getCount() {
		return count;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CountingAfterReturningAdvice : AfterReturningAdvice {

	var count: Int = 0
		private set

	override fun afterReturning(returnValue: Any?, m: Method, args: Array&lt;Any&gt;, target: Any?) {
		++count
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advice does not change the execution path. If it throws an exception, it is
thrown up the interceptor chain instead of the return value.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
After returning advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>Introduction Advice</h4>
<div class="paragraph">
<p>Spring treats introduction advice as a special kind of interception advice.</p>
</div>
<div class="paragraph">
<p>Introduction requires an <code>IntroductionAdvisor</code> and an <code>IntroductionInterceptor</code> that
implement the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface IntroductionInterceptor extends MethodInterceptor {

	boolean implementsInterface(Class intf);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>invoke()</code> method inherited from the AOP Alliance <code>MethodInterceptor</code> interface must
implement the introduction. That is, if the invoked method is on an introduced
interface, the introduction interceptor is responsible for handling the method call&#8201;&#8212;&#8201;it
cannot invoke <code>proceed()</code>.</p>
</div>
<div class="paragraph">
<p>Introduction advice cannot be used with any pointcut, as it applies only at the class,
rather than the method, level. You can only use introduction advice with the
<code>IntroductionAdvisor</code>, which has the following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

	ClassFilter getClassFilter();

	void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

	Class&lt;?&gt;[] getInterfaces();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no <code>MethodMatcher</code> and, hence, no <code>Pointcut</code> associated with introduction
advice. Only class filtering is logical.</p>
</div>
<div class="paragraph">
<p>The <code>getInterfaces()</code> method returns the interfaces introduced by this advisor.</p>
</div>
<div class="paragraph">
<p>The <code>validateInterfaces()</code> method is used internally to see whether or not the
introduced interfaces can be implemented by the configured <code>IntroductionInterceptor</code>.</p>
</div>
<div class="paragraph">
<p>Consider an example from the Spring test suite and suppose we want to
introduce the following interface to one or more objects:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Lockable {
	void lock();
	void unlock();
	boolean locked();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface Lockable {
	fun lock()
	fun unlock()
	fun locked(): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This illustrates a mixin. We want to be able to cast advised objects to <code>Lockable</code>,
whatever their type and call lock and unlock methods. If we call the <code>lock()</code> method, we
want all setter methods to throw a <code>LockedException</code>. Thus, we can add an aspect that
provides the ability to make objects immutable without them having any knowledge of it:
a good example of AOP.</p>
</div>
<div class="paragraph">
<p>First, we need an <code>IntroductionInterceptor</code> that does the heavy lifting. In this
case, we extend the <code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>
convenience class. We could implement <code>IntroductionInterceptor</code> directly, but using
<code>DelegatingIntroductionInterceptor</code> is best for most cases.</p>
</div>
<div class="paragraph">
<p>The <code>DelegatingIntroductionInterceptor</code> is designed to delegate an introduction to an
actual implementation of the introduced interfaces, concealing the use of interception
to do so. You can set the delegate to any object using a constructor argument. The
default delegate (when the no-argument constructor is used) is <code>this</code>. Thus, in the next example,
the delegate is the <code>LockMixin</code> subclass of <code>DelegatingIntroductionInterceptor</code>.
Given a delegate (by default, itself), a <code>DelegatingIntroductionInterceptor</code> instance
looks for all interfaces implemented by the delegate (other than
<code>IntroductionInterceptor</code>) and supports introductions against any of them.
Subclasses such as <code>LockMixin</code> can call the <code>suppressInterface(Class intf)</code>
method to suppress interfaces that should not be exposed. However, no matter how many
interfaces an <code>IntroductionInterceptor</code> is prepared to support, the
<code>IntroductionAdvisor</code> used controls which interfaces are actually exposed. An
introduced interface conceals any implementation of the same interface by the target.</p>
</div>
<div class="paragraph">
<p>Thus, <code>LockMixin</code> extends <code>DelegatingIntroductionInterceptor</code> and implements <code>Lockable</code>
itself. The superclass automatically picks up that <code>Lockable</code> can be supported for
introduction, so we do not need to specify that. We could introduce any number of
interfaces in this way.</p>
</div>
<div class="paragraph">
<p>Note the use of the <code>locked</code> instance variable. This effectively adds additional state
to that held in the target object.</p>
</div>
<div class="paragraph">
<p>The following example shows the example <code>LockMixin</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {

	private boolean locked;

	public void lock() {
		this.locked = true;
	}

	public void unlock() {
		this.locked = false;
	}

	public boolean locked() {
		return this.locked;
	}

	public Object invoke(MethodInvocation invocation) throws Throwable {
		if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) {
			throw new LockedException();
		}
		return super.invoke(invocation);
	}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class LockMixin : DelegatingIntroductionInterceptor(), Lockable {

	private var locked: Boolean = false

	fun lock() {
		this.locked = true
	}

	fun unlock() {
		this.locked = false
	}

	fun locked(): Boolean {
		return this.locked
	}

	override fun invoke(invocation: MethodInvocation): Any? {
		if (locked() &amp;&amp; invocation.method.name.indexOf("set") == 0) {
			throw LockedException()
		}
		return super.invoke(invocation)
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often, you need not override the <code>invoke()</code> method. The
<code>DelegatingIntroductionInterceptor</code> implementation (which calls the <code>delegate</code> method if
the method is introduced, otherwise proceeds towards the join point) usually
suffices. In the present case, we need to add a check: no setter method can be invoked
if in locked mode.</p>
</div>
<div class="paragraph">
<p>The required introduction only needs to hold a distinct
<code>LockMixin</code> instance and specify the introduced interfaces (in this case, only
<code>Lockable</code>). A more complex example might take a reference to the introduction
interceptor (which would be defined as a prototype). In this case, there is no
configuration relevant for a <code>LockMixin</code>, so we create it by using <code>new</code>.
The following example shows our <code>LockMixinAdvisor</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

	public LockMixinAdvisor() {
		super(new LockMixin(), Lockable.class);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class LockMixinAdvisor : DefaultIntroductionAdvisor(LockMixin(), Lockable::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can apply this advisor very simply, because it requires no configuration. (However, it
is impossible to use an <code>IntroductionInterceptor</code> without an
<code>IntroductionAdvisor</code>.) As usual with introductions, the advisor must be per-instance,
as it is stateful. We need a different instance of <code>LockMixinAdvisor</code>, and hence
<code>LockMixin</code>, for each advised object. The advisor comprises part of the advised object&#8217;s
state.</p>
</div>
<div class="paragraph">
<p>We can apply this advisor programmatically by using the <code>Advised.addAdvisor()</code> method or
(the recommended way) in XML configuration, as any other advisor. All proxy creation
choices discussed below, including &#8220;auto proxy creators,&#8221; correctly handle introductions
and stateful mixins.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a>The Advisor API in Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Spring, an Advisor is an aspect that contains only a single advice object associated
with a pointcut expression.</p>
</div>
<div class="paragraph">
<p>Apart from the special case of introductions, any advisor can be used with any advice.
<code>org.springframework.aop.support.DefaultPointcutAdvisor</code> is the most commonly used
advisor class. It can be used with a <code>MethodInterceptor</code>, <code>BeforeAdvice</code>, or
<code>ThrowsAdvice</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to mix advisor and advice types in Spring in the same AOP proxy. For
example, you could use an interception around advice, throws advice, and before advice in
one proxy configuration. Spring automatically creates the necessary interceptor
chain.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a>Using the <code>ProxyFactoryBean</code> to Create AOP Proxies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you use the Spring IoC container (an <code>ApplicationContext</code> or <code>BeanFactory</code>) for your
business objects (and you should be!), you want to use one of Spring&#8217;s AOP
<code>FactoryBean</code> implementations. (Remember that a factory bean introduces a layer of indirection, letting
it create objects of a different type.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Spring AOP support also uses factory beans under the covers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The basic way to create an AOP proxy in Spring is to use the
<code>org.springframework.aop.framework.ProxyFactoryBean</code>. This gives complete control over
the pointcuts, any advice that applies, and their ordering. However, there are simpler
options that are preferable if you do not need such control.</p>
</div>
<div class="sect2">
<h3 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a>Basics</h3>
<div class="paragraph">
<p>The <code>ProxyFactoryBean</code>, like other Spring <code>FactoryBean</code> implementations, introduces a
level of indirection. If you define a <code>ProxyFactoryBean</code> named <code>foo</code>, objects that
reference <code>foo</code> do not see the <code>ProxyFactoryBean</code> instance itself but an object
created by the implementation of the <code>getObject()</code> method in the <code>ProxyFactoryBean</code> . This
method creates an AOP proxy that wraps a target object.</p>
</div>
<div class="paragraph">
<p>One of the most important benefits of using a <code>ProxyFactoryBean</code> or another IoC-aware
class to create AOP proxies is that advices and pointcuts can also be
managed by IoC. This is a powerful feature, enabling certain approaches that are hard to
achieve with other AOP frameworks. For example, an advice may itself reference
application objects (besides the target, which should be available in any AOP
framework), benefiting from all the pluggability provided by Dependency Injection.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a>JavaBean Properties</h3>
<div class="paragraph">
<p>In common with most <code>FactoryBean</code> implementations provided with Spring, the
<code>ProxyFactoryBean</code> class is itself a JavaBean. Its properties are used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the target you want to proxy.</p>
</li>
<li>
<p>Specify whether to use CGLIB (described later and see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some key properties are inherited from <code>org.springframework.aop.framework.ProxyConfig</code>
(the superclass for all AOP proxy factories in Spring). These key properties include
the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code>: <code>true</code> if the target class is to be proxied, rather than the
target class&#8217;s interfaces. If this property value is set to <code>true</code>, then CGLIB proxies
are created (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>optimize</code>: Controls whether or not aggressive optimizations are applied to proxies
created through CGLIB. You should not blithely use this setting unless you fully
understand how the relevant AOP proxy handles optimization. This is currently used
only for CGLIB proxies. It has no effect with JDK dynamic proxies.</p>
</li>
<li>
<p><code>frozen</code>: If a proxy configuration is <code>frozen</code>, changes to the configuration are
no longer allowed. This is useful both as a slight optimization and for those cases
when you do not want callers to be able to manipulate the proxy (through the <code>Advised</code>
interface) after the proxy has been created. The default value of this property is
<code>false</code>, so changes (such as adding additional advice) are allowed.</p>
</li>
<li>
<p><code>exposeProxy</code>: Determines whether or not the current proxy should be exposed in a
<code>ThreadLocal</code> so that it can be accessed by the target. If a target needs to obtain
the proxy and the <code>exposeProxy</code> property is set to <code>true</code>, the target can use the
<code>AopContext.currentProxy()</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other properties specific to <code>ProxyFactoryBean</code> include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code>: An array of <code>String</code> interface names. If this is not supplied, a CGLIB
proxy for the target class is used (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>interceptorNames</code>: A <code>String</code> array of <code>Advisor</code>, interceptor, or other advice names to
apply. Ordering is significant, on a first come-first served basis. That is to say
that the first interceptor in the list is the first to be able to intercept the
invocation.</p>
<div class="paragraph">
<p>The names are bean names in the current factory, including bean names from ancestor
factories. You cannot mention bean references here, since doing so results in the
<code>ProxyFactoryBean</code> ignoring the singleton setting of the advice.</p>
</div>
<div class="paragraph">
<p>You can append an interceptor name with an asterisk (<code>*</code>). Doing so results in the
application of all advisor beans with names that start with the part before the asterisk
to be applied. You can find an example of using this feature in <a href="#aop-global-advisors">Using &#8220;Global&#8221; Advisors</a>.</p>
</div>
</li>
<li>
<p>singleton: Whether or not the factory should return a single object, no matter how
often the <code>getObject()</code> method is called. Several <code>FactoryBean</code> implementations offer
such a method. The default value is <code>true</code>. If you want to use stateful advice - for
example, for stateful mixins - use prototype advices along with a singleton value of
<code>false</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a>JDK- and CGLIB-based proxies</h3>
<div class="paragraph">
<p>This section serves as the definitive documentation on how the <code>ProxyFactoryBean</code>
chooses to create either a JDK-based proxy or a CGLIB-based proxy for a particular target
object (which is to be proxied).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The behavior of the <code>ProxyFactoryBean</code> with regard to creating JDK- or CGLIB-based
proxies changed between versions 1.2.x and 2.0 of Spring. The <code>ProxyFactoryBean</code> now
exhibits similar semantics with regard to auto-detecting interfaces as those of the
<code>TransactionProxyFactoryBean</code> class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the class of a target object that is to be proxied (hereafter simply referred to as
the target class) does not implement any interfaces, a CGLIB-based proxy is
created. This is the easiest scenario, because JDK proxies are interface-based, and no
interfaces means JDK proxying is not even possible. You can plug in the target bean
and specify the list of interceptors by setting the <code>interceptorNames</code> property. Note that a
CGLIB-based proxy is created even if the <code>proxyTargetClass</code> property of the
<code>ProxyFactoryBean</code> has been set to <code>false</code>. (Doing so makes no sense and is best
removed from the bean definition, because it is, at best, redundant, and, at worst
confusing.)</p>
</div>
<div class="paragraph">
<p>If the target class implements one (or more) interfaces, the type of proxy that is
created depends on the configuration of the <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyTargetClass</code> property of the <code>ProxyFactoryBean</code> has been set to <code>true</code>,
a CGLIB-based proxy is created. This makes sense and is in keeping with the
principle of least surprise. Even if the <code>proxyInterfaces</code> property of the
<code>ProxyFactoryBean</code> has been set to one or more fully qualified interface names, the fact
that the <code>proxyTargetClass</code> property is set to <code>true</code> causes CGLIB-based
proxying to be in effect.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has been set to one or more
fully qualified interface names, a JDK-based proxy is created. The created
proxy implements all of the interfaces that were specified in the <code>proxyInterfaces</code>
property. If the target class happens to implement a whole lot more interfaces than
those specified in the <code>proxyInterfaces</code> property, that is all well and good, but those
additional interfaces are not implemented by the returned proxy.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has not been set, but
the target class does implement one (or more) interfaces, the
<code>ProxyFactoryBean</code> auto-detects the fact that the target class does actually
implement at least one interface, and a JDK-based proxy is created. The interfaces
that are actually proxied are all of the interfaces that the target class
implements. In effect, this is the same as supplying a list of each and every
interface that the target class implements to the <code>proxyInterfaces</code> property. However,
it is significantly less work and less prone to typographical errors.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a>Proxying Interfaces</h3>
<div class="paragraph">
<p>Consider a simple example of <code>ProxyFactoryBean</code> in action. This example involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A target bean that is proxied. This is the <code>personTarget</code> bean definition in
the example.</p>
</li>
<li>
<p>An <code>Advisor</code> and an <code>Interceptor</code> used to provide advice.</p>
</li>
<li>
<p>An AOP proxy bean definition to specify the target object (the <code>personTarget</code> bean),
the interfaces to proxy, and the advices to apply.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following listing shows the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
	&lt;property name="name" value="Tony"/&gt;
	&lt;property name="age" value="51"/&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
	&lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person"
	class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
	&lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;

	&lt;property name="target" ref="personTarget"/&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
			&lt;value&gt;myAdvisor&lt;/value&gt;
			&lt;value&gt;debugInterceptor&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>interceptorNames</code> property takes a list of <code>String</code>, which holds the bean names of the
interceptors or advisors in the current factory. You can use advisors, interceptors, before, after
returning, and throws advice objects. The ordering of advisors is significant.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You might be wondering why the list does not hold bean references. The reason for this is
that, if the singleton property of the <code>ProxyFactoryBean</code> is set to <code>false</code>, it must be able to
return independent proxy instances. If any of the advisors is itself a prototype, an
independent instance would need to be returned, so it is necessary to be able to obtain
an instance of the prototype from the factory. Holding a reference is not sufficient.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>person</code> bean definition shown earlier can be used in place of a <code>Person</code> implementation, as
follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Person person = (Person) factory.getBean("person");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val person = factory.getBean("person") as Person;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other beans in the same IoC context can express a strongly typed dependency on it, as
with an ordinary Java object. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
	&lt;property name="person"&gt;&lt;ref bean="person"/&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PersonUser</code> class in this example exposes a property of type <code>Person</code>. As far as
it is concerned, the AOP proxy can be used transparently in place of a &#8220;real&#8221; person
implementation. However, its class would be a dynamic proxy class. It would be possible
to cast it to the <code>Advised</code> interface (discussed later).</p>
</div>
<div class="paragraph">
<p>You can conceal the distinction between target and proxy by using an anonymous
inner bean. Only the <code>ProxyFactoryBean</code> definition is different. The
advice is included only for completeness. The following example shows how to use an
anonymous inner bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
	&lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
	&lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;
	&lt;!-- Use inner bean, not local reference to target --&gt;
	&lt;property name="target"&gt;
		&lt;bean class="com.mycompany.PersonImpl"&gt;
			&lt;property name="name" value="Tony"/&gt;
			&lt;property name="age" value="51"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
			&lt;value&gt;myAdvisor&lt;/value&gt;
			&lt;value&gt;debugInterceptor&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using an anonymous inner bean has the advantage that there is only one object of type <code>Person</code>. This is useful if we want
to prevent users of the application context from obtaining a reference to the un-advised
object or need to avoid any ambiguity with Spring IoC autowiring. There is also,
arguably, an advantage in that the <code>ProxyFactoryBean</code> definition is self-contained.
However, there are times when being able to obtain the un-advised target from the
factory might actually be an advantage (for example, in certain test scenarios).</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a>Proxying Classes</h3>
<div class="paragraph">
<p>What if you need to proxy a class, rather than one or more interfaces?</p>
</div>
<div class="paragraph">
<p>Imagine that in our earlier example, there was no <code>Person</code> interface. We needed to advise
a class called <code>Person</code> that did not implement any business interface. In this case, you
can configure Spring to use CGLIB proxying rather than dynamic proxies. To do so, set the
<code>proxyTargetClass</code> property on the <code>ProxyFactoryBean</code> shown earlier to <code>true</code>. While it is best to
program to interfaces rather than classes, the ability to advise classes that do not
implement interfaces can be useful when working with legacy code. (In general, Spring
is not prescriptive. While it makes it easy to apply good practices, it avoids forcing a
particular approach.)</p>
</div>
<div class="paragraph">
<p>If you want to, you can force the use of CGLIB in any case, even if you do have
interfaces.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying works by generating a subclass of the target class at runtime. Spring
configures this generated subclass to delegate method calls to the original target. The
subclass is used to implement the Decorator pattern, weaving in the advice.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying should generally be transparent to users. However, there are some issues
to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Final</code> methods cannot be advised, as they cannot be overridden.</p>
</li>
<li>
<p>There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged
and included in the spring-core JAR. In other words, CGLIB-based AOP works &#8220;out of
the box&#8221;, as do JDK dynamic proxies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is little performance difference between CGLIB proxying and dynamic proxies.
Performance should not be a decisive consideration in this case.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a>Using &#8220;Global&#8221; Advisors</h3>
<div class="paragraph">
<p>By appending an asterisk to an interceptor name, all advisors with bean names that match
the part before the asterisk are added to the advisor chain. This can come in handy
if you need to add a standard set of &#8220;global&#8221; advisors. The following example defines
two global advisors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
	&lt;property name="target" ref="service"/&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
			&lt;value&gt;global*&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a>Concise Proxy Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Especially when defining transactional proxies, you may end up with many similar proxy
definitions. The use of parent and child bean definitions, along with inner bean
definitions, can result in much cleaner and more concise proxy definitions.</p>
</div>
<div class="paragraph">
<p>First, we create a parent, template, bean definition for the proxy, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="txProxyTemplate" abstract="true"
		class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
	&lt;property name="transactionManager" ref="transactionManager"/&gt;
	&lt;property name="transactionAttributes"&gt;
		&lt;props&gt;
			&lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
		&lt;/props&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is never instantiated itself, so it can actually be incomplete. Then, each proxy
that needs to be created is a child bean definition, which wraps the target of the
proxy as an inner bean definition, since the target is never used on its own anyway.
The following example shows such a child bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myService" parent="txProxyTemplate"&gt;
	&lt;property name="target"&gt;
		&lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can override properties from the parent template. In the following example,
we override the transaction propagation settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
	&lt;property name="target"&gt;
		&lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;property name="transactionAttributes"&gt;
		&lt;props&gt;
			&lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
			&lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
			&lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
			&lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
		&lt;/props&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the parent bean example, we explicitly marked the parent bean definition as
being abstract by setting the <code>abstract</code> attribute to <code>true</code>, as described
<a href="#beans-child-bean-definitions">previously</a>, so that it may not actually ever be
instantiated. Application contexts (but not simple bean factories), by default,
pre-instantiate all singletons. Therefore, it is important (at least for singleton beans)
that, if you have a (parent) bean definition that you intend to use only as a template,
and this definition specifies a class, you must make sure to set the <code>abstract</code>
attribute to <code>true</code>. Otherwise, the application context actually tries to
pre-instantiate it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-prog"><a class="anchor" href="#aop-prog"></a>Creating AOP Proxies Programmatically with the <code>ProxyFactory</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is easy to create AOP proxies programmatically with Spring. This lets you use
Spring AOP without dependency on Spring IoC.</p>
</div>
<div class="paragraph">
<p>The interfaces implemented by the target object are
automatically proxied. The following listing shows creation of a proxy for a target object, with one
interceptor and one advisor:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val factory = ProxyFactory(myBusinessInterfaceImpl)
factory.addAdvice(myMethodInterceptor)
factory.addAdvisor(myAdvisor)
val tb = factory.proxy as MyBusinessInterface</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step is to construct an object of type
<code>org.springframework.aop.framework.ProxyFactory</code>. You can create this with a target
object, as in the preceding example, or specify the interfaces to be proxied in an alternate
constructor.</p>
</div>
<div class="paragraph">
<p>You can add advices (with interceptors as a specialized kind of advice), advisors, or both
and manipulate them for the life of the <code>ProxyFactory</code>. If you add an
<code>IntroductionInterceptionAroundAdvisor</code>, you can cause the proxy to implement additional
interfaces.</p>
</div>
<div class="paragraph">
<p>There are also convenience methods on <code>ProxyFactory</code> (inherited from <code>AdvisedSupport</code>)
that let you add other advice types, such as before and throws advice.
<code>AdvisedSupport</code> is the superclass of both <code>ProxyFactory</code> and <code>ProxyFactoryBean</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Integrating AOP proxy creation with the IoC framework is best practice in most
applications. We recommend that you externalize configuration from Java code with AOP,
as you should in general.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a>Manipulating Advised Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>However you create AOP proxies, you can manipulate them BY using the
<code>org.springframework.aop.framework.Advised</code> interface. Any AOP proxy can be cast to this
interface, no matter which other interfaces it implements. This interface includes the
following methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun getAdvisors(): Array&lt;Advisor&gt;

@Throws(AopConfigException::class)
fun addAdvice(advice: Advice)

@Throws(AopConfigException::class)
fun addAdvice(pos: Int, advice: Advice)

@Throws(AopConfigException::class)
fun addAdvisor(advisor: Advisor)

@Throws(AopConfigException::class)
fun addAdvisor(pos: Int, advisor: Advisor)

fun indexOf(advisor: Advisor): Int

@Throws(AopConfigException::class)
fun removeAdvisor(advisor: Advisor): Boolean

@Throws(AopConfigException::class)
fun removeAdvisor(index: Int)

@Throws(AopConfigException::class)
fun replaceAdvisor(a: Advisor, b: Advisor): Boolean

fun isFrozen(): Boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getAdvisors()</code> method returns an <code>Advisor</code> for every advisor, interceptor, or
other advice type that has been added to the factory. If you added an <code>Advisor</code>, the
returned advisor at this index is the object that you added. If you added an
interceptor or other advice type, Spring wrapped this in an advisor with a
pointcut that always returns <code>true</code>. Thus, if you added a <code>MethodInterceptor</code>, the advisor
returned for this index is a <code>DefaultPointcutAdvisor</code> that returns your
<code>MethodInterceptor</code> and a pointcut that matches all classes and methods.</p>
</div>
<div class="paragraph">
<p>The <code>addAdvisor()</code> methods can be used to add any <code>Advisor</code>. Usually, the advisor holding
pointcut and advice is the generic <code>DefaultPointcutAdvisor</code>, which you can use with
any advice or pointcut (but not for introductions).</p>
</div>
<div class="paragraph">
<p>By default, it is possible to add or remove advisors or interceptors even once a proxy
has been created. The only restriction is that it is impossible to add or remove an
introduction advisor, as existing proxies from the factory do not show the interface
change. (You can obtain a new proxy from the factory to avoid this problem.)</p>
</div>
<div class="paragraph">
<p>The following example shows casting an AOP proxy to the <code>Advised</code> interface and examining and
manipulating its advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.getAdvisors().length);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val advised = myObject as Advised
val advisors = advised.advisors
val oldAdvisorCount = advisors.size
println("$oldAdvisorCount advisors")

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(DebugInterceptor())

// Add selective advice using a pointcut
advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.advisors.size)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is questionable whether it is advisable (no pun intended) to modify advice on a
business object in production, although there are, no doubt, legitimate usage cases.
However, it can be very useful in development (for example, in tests). We have sometimes
found it very useful to be able to add test code in the form of an interceptor or other
advice, getting inside a method invocation that we want to test. (For example, the advice can
get inside a transaction created for that method, perhaps to run SQL to check that
a database was correctly updated, before marking the transaction for roll back.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on how you created the proxy, you can usually set a <code>frozen</code> flag. In that
case, the <code>Advised</code> <code>isFrozen()</code> method returns <code>true</code>, and any attempts to modify
advice through addition or removal results in an <code>AopConfigException</code>. The ability
to freeze the state of an advised object is useful in some cases (for example, to
prevent calling code removing a security interceptor).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a>Using the "auto-proxy" facility</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far, we have considered explicit creation of AOP proxies by using a <code>ProxyFactoryBean</code> or
similar factory bean.</p>
</div>
<div class="paragraph">
<p>Spring also lets us use &#8220;auto-proxy&#8221; bean definitions, which can automatically
proxy selected bean definitions. This is built on Spring&#8217;s &#8220;bean post processor&#8221;
infrastructure, which enables modification of any bean definition as the container loads.</p>
</div>
<div class="paragraph">
<p>In this model, you set up some special bean definitions in your XML bean definition file
to configure the auto-proxy infrastructure. This lets you declare the targets
eligible for auto-proxying. You need not use <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By using an auto-proxy creator that refers to specific beans in the current context.</p>
</li>
<li>
<p>A special case of auto-proxy creation that deserves to be considered separately:
auto-proxy creation driven by source-level metadata attributes.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a>Auto-proxy Bean Definitions</h3>
<div class="paragraph">
<p>This section covers the  auto-proxy creators provided by the
<code>org.springframework.aop.framework.autoproxy</code> package.</p>
</div>
<div class="sect3">
<h4 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a><code>BeanNameAutoProxyCreator</code></h4>
<div class="paragraph">
<p>The <code>BeanNameAutoProxyCreator</code> class is a <code>BeanPostProcessor</code> that automatically creates
AOP proxies for beans with names that match literal values or wildcards. The following
example shows how to create a <code>BeanNameAutoProxyCreator</code> bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
	&lt;property name="beanNames" value="jdk*,onlyJdk"/&gt;
	&lt;property name="interceptorNames"&gt;
		&lt;list&gt;
			&lt;value&gt;myInterceptor&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>ProxyFactoryBean</code>, there is an <code>interceptorNames</code> property rather than a list
of interceptors, to allow correct behavior for prototype advisors. Named &#8220;interceptors&#8221;
can be advisors or any advice type.</p>
</div>
<div class="paragraph">
<p>As with auto-proxying in general, the main point of using <code>BeanNameAutoProxyCreator</code> is
to apply the same configuration consistently to multiple objects, with minimal volume of
configuration. It is a popular choice for applying declarative transactions to multiple
objects.</p>
</div>
<div class="paragraph">
<p>Bean definitions whose names match, such as <code>jdkMyBean</code> and <code>onlyJdk</code> in the preceding
example, are plain old bean definitions with the target class. An AOP proxy is
automatically created by the <code>BeanNameAutoProxyCreator</code>. The same advice is applied
to all matching beans. Note that, if advisors are used (rather than the interceptor in
the preceding example), the pointcuts may apply differently to different beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a><code>DefaultAdvisorAutoProxyCreator</code></h4>
<div class="paragraph">
<p>A more general and extremely powerful auto-proxy creator is
<code>DefaultAdvisorAutoProxyCreator</code>. This automagically applies eligible advisors in the
current context, without the need to include specific bean names in the auto-proxy
advisor&#8217;s bean definition. It offers the same merit of consistent configuration and
avoidance of duplication as <code>BeanNameAutoProxyCreator</code>.</p>
</div>
<div class="paragraph">
<p>Using this mechanism involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specifying a <code>DefaultAdvisorAutoProxyCreator</code> bean definition.</p>
</li>
<li>
<p>Specifying any number of advisors in the same or related contexts. Note that these
must be advisors, not interceptors or other advices. This is necessary,
because there must be a pointcut to evaluate, to check the eligibility of each advice
to candidate bean definitions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> automatically evaluates the pointcut contained
in each advisor, to see what (if any) advice it should apply to each business object
(such as <code>businessObject1</code> and <code>businessObject2</code> in the example).</p>
</div>
<div class="paragraph">
<p>This means that any number of advisors can be applied automatically to each business
object. If no pointcut in any of the advisors matches any method in a business object,
the object is not proxied. As bean definitions are added for new business objects,
they are automatically proxied if necessary.</p>
</div>
<div class="paragraph">
<p>Auto-proxying in general has the advantage of making it impossible for callers or
dependencies to obtain an un-advised object. Calling <code>getBean("businessObject1")</code> on this
<code>ApplicationContext</code> returns an AOP proxy, not the target business object. (The &#8220;inner
bean&#8221; idiom shown earlier also offers this benefit.)</p>
</div>
<div class="paragraph">
<p>The following example creates a <code>DefaultAdvisorAutoProxyCreator</code> bean and the other
elements discussed in this section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
	&lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
	&lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> is very useful if you want to apply the same advice
consistently to many business objects. Once the infrastructure definitions are in place,
you can add new business objects without including specific proxy configuration.
You can also easily drop in additional aspects (for example, tracing or
performance monitoring aspects) with minimal change to configuration.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> offers support for filtering (by using a naming
convention so that only certain advisors are evaluated, which allows the use of multiple,
differently configured, AdvisorAutoProxyCreators in the same factory) and ordering.
Advisors can implement the <code>org.springframework.core.Ordered</code> interface to ensure
correct ordering if this is an issue. The <code>TransactionAttributeSourceAdvisor</code> used in the
preceding example has a configurable order value. The default setting is unordered.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a>Using <code>TargetSource</code> Implementations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring offers the concept of a <code>TargetSource</code>, expressed in the
<code>org.springframework.aop.TargetSource</code> interface. This interface is responsible for
returning the &#8220;target object&#8221; that implements the join point. The <code>TargetSource</code>
implementation is asked for a target instance each time the AOP proxy handles a method
invocation.</p>
</div>
<div class="paragraph">
<p>Developers who use Spring AOP do not normally need to work directly with <code>TargetSource</code> implementations, but
this provides a powerful means of supporting pooling, hot swappable, and other
sophisticated targets. For example, a pooling <code>TargetSource</code> can return a different target
instance for each invocation, by using a pool to manage instances.</p>
</div>
<div class="paragraph">
<p>If you do not specify a <code>TargetSource</code>, a default implementation is used to wrap a
local object. The same target is returned for each invocation (as you would expect).</p>
</div>
<div class="paragraph">
<p>The rest of this section describes the standard target sources provided with Spring and how you can use them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When using a custom target source, your target will usually need to be a prototype
rather than a singleton bean definition. This allows Spring to create a new target
instance when required.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a>Hot-swappable Target Sources</h3>
<div class="paragraph">
<p>The <code>org.springframework.aop.target.HotSwappableTargetSource</code> exists to let the target
of an AOP proxy be switched while letting callers keep their references to it.</p>
</div>
<div class="paragraph">
<p>Changing the target source&#8217;s target takes effect immediately. The
<code>HotSwappableTargetSource</code> is thread-safe.</p>
</div>
<div class="paragraph">
<p>You can change the target by using the <code>swap()</code> method on HotSwappableTargetSource, as the follow example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val swapper = beanFactory.getBean("swapper") as HotSwappableTargetSource
val oldTarget = swapper.swap(newTarget)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the required XML definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
	&lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
	&lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding <code>swap()</code> call changes the target of the swappable bean. Clients that hold a
reference to that bean are unaware of the change but immediately start hitting
the new target.</p>
</div>
<div class="paragraph">
<p>Although this example does not add any advice (it is not necessary to add advice to
use a <code>TargetSource</code>), any <code>TargetSource</code> can be used in conjunction with
arbitrary advice.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a>Pooling Target Sources</h3>
<div class="paragraph">
<p>Using a pooling target source provides a similar programming model to stateless session
EJBs, in which a pool of identical instances is maintained, with method invocations
going to free objects in the pool.</p>
</div>
<div class="paragraph">
<p>A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can
be applied to any POJO. As with Spring in general, this service can be applied in a
non-invasive way.</p>
</div>
<div class="paragraph">
<p>Spring provides support for Commons Pool 2.2, which provides a
fairly efficient pooling implementation. You need the <code>commons-pool</code> Jar on your
application&#8217;s classpath to use this feature. You can also subclass
<code>org.springframework.aop.target.AbstractPoolingTargetSource</code> to support any other
pooling API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Commons Pool 1.5+ is also supported but is deprecated as of Spring Framework 4.2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following listing shows an example configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject"
		scope="prototype"&gt;
	... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPool2TargetSource"&gt;
	&lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
	&lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
	&lt;property name="targetSource" ref="poolTargetSource"/&gt;
	&lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the target object (<code>businessObjectTarget</code> in the preceding example) must be a
prototype. This lets the <code>PoolingTargetSource</code> implementation create new instances
of the target to grow the pool as necessary. See the <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">javadoc of
<code>AbstractPoolingTargetSource</code></a> and the concrete subclass you wish to use for information
about its properties. <code>maxSize</code> is the most basic and is always guaranteed to be present.</p>
</div>
<div class="paragraph">
<p>In this case, <code>myInterceptor</code> is the name of an interceptor that would need to be
defined in the same IoC context. However, you need not specify interceptors to
use pooling. If you want only pooling and no other advice, do not set the
<code>interceptorNames</code> property at all.</p>
</div>
<div class="paragraph">
<p>You can configure Spring to be able to cast any pooled object to the
<code>org.springframework.aop.target.PoolingConfig</code> interface, which exposes information
about the configuration and current size of the pool through an introduction. You
need to define an advisor similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
	&lt;property name="targetObject" ref="poolTargetSource"/&gt;
	&lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advisor is obtained by calling a convenience method on the
<code>AbstractPoolingTargetSource</code> class, hence the use of <code>MethodInvokingFactoryBean</code>. This
advisor&#8217;s name (<code>poolConfigAdvisor</code>, here) must be in the list of interceptors names in
the <code>ProxyFactoryBean</code> that exposes the pooled object.</p>
</div>
<div class="paragraph">
<p>The cast is defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val conf = beanFactory.getBean("businessObject") as PoolingConfig
println("Max pool size is " + conf.maxSize)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pooling stateless service objects is not usually necessary. We do not believe it should
be the default choice, as most stateless objects are naturally thread safe, and instance
pooling is problematic if resources are cached.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simpler pooling is available by using auto-proxying. You can set the <code>TargetSource</code> implementations
used by any auto-proxy creator.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a>Prototype Target Sources</h3>
<div class="paragraph">
<p>Setting up a &#8220;prototype&#8221; target source is similar to setting up a pooling <code>TargetSource</code>. In this
case, a new instance of the target is created on every method invocation. Although
the cost of creating a new object is not high in a modern JVM, the cost of wiring up the
new object (satisfying its IoC dependencies) may be more expensive. Thus, you should not
use this approach without very good reason.</p>
</div>
<div class="paragraph">
<p>To do this, you could modify the <code>poolTargetSource</code> definition shown earlier as follows
(we also changed the name, for clarity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
	&lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only property is the name of the target bean. Inheritance is used in the
<code>TargetSource</code> implementations to ensure consistent naming. As with the pooling target
source, the target bean must be a prototype bean definition.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a><code>ThreadLocal</code> Target Sources</h3>
<div class="paragraph">
<p><code>ThreadLocal</code> target sources are useful if you need an object to be created for each
incoming request (per thread that is). The concept of a <code>ThreadLocal</code> provides a JDK-wide
facility to transparently store a resource alongside a thread. Setting up a
<code>ThreadLocalTargetSource</code> is pretty much the same as was explained for the other types
of target source, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
	&lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ThreadLocal</code> instances come with serious issues (potentially resulting in memory leaks) when
incorrectly using them in multi-threaded and multi-classloader environments. You
should always consider wrapping a threadlocal in some other class and never directly use
the <code>ThreadLocal</code> itself (except in the wrapper class). Also, you should
always remember to correctly set and unset (where the latter simply involves a call to
<code>ThreadLocal.set(null)</code>) the resource local to the thread. Unsetting should be done in
any case, since not unsetting it might result in problematic behavior. Spring&#8217;s
<code>ThreadLocal</code> support does this for you and should always be considered in favor of using
<code>ThreadLocal</code> instances without other proper handling code.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a>Defining New Advice Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring AOP is designed to be extensible. While the interception implementation strategy
is presently used internally, it is possible to support arbitrary advice types in
addition to the interception around advice, before, throws advice, and
after returning advice.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.adapter</code> package is an SPI package that lets
support for new custom advice types be added without changing the core framework.
The only constraint on a custom <code>Advice</code> type is that it must implement the
<code>org.aopalliance.aop.Advice</code> marker interface.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code></a>
javadoc for further information.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="aop.html">Aspect Oriented Programming with Spring</a></span>
  <span class="next"><a href="null-safety.html">Null-safety</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer flex">
    <div id="spring-links flex">
        <img id="springlogo" src="../../../_/img/spring-logo.svg" alt="Spring">
        <p class="smallest antialiased">© <script>var d = new Date();
        document.write(d.getFullYear());</script> <a href="https://www.vmware.com/">VMware</a>, Inc. or its affiliates. <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> • <a href="https://www.vmware.com/help/privacy.html" rel="noopener noreferrer">Privacy</a> • <a href="https://spring.io/trademarks">Trademark Guidelines</a> <span id="thank-you-mobile">• <a href="https://spring.io/thank-you">Thank you</a></span> • <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> • <a class="ot-sdk-show-settings">Cookie Settings</a> <span id="teconsent"></span></p>
        <p class="smallest antialiased">Apache®, Apache Tomcat®, Apache Kafka®, Apache Cassandra&trade;, and Apache Geode&trade; are trademarks or registered trademarks of the Apache Software Foundation in the United States and/or other countries. Java&trade;, Java&trade; SE, Java&trade; EE, and OpenJDK&trade; are trademarks of Oracle and/or its affiliates. Kubernetes® is a registered trademark of the Linux Foundation in the United States and other countries. Linux® is the registered trademark of Linus Torvalds in the United States and other countries. Windows® and Microsoft® Azure are registered trademarks of Microsoft Corporation. “AWS” and “Amazon Web Services” are trademarks or registered trademarks of Amazon.com Inc. or its affiliates. All other trademarks and copyrights are property of their respective owners and are only mentioned for informative purposes. Other names may be trademarks of their respective owners.</p>
    </div>
    <div id="social-icons" class="flex jc-between">
        <a href="https://www.youtube.com/user/SpringSourceDev" title="Youtube"><svg id="youtube-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><circle class="cls-1" cx="20" cy="20" r="20"/><path class="cls-2" d="M30.91,14.53a2.89,2.89,0,0,0-2-2C27.12,12,20,12,20,12s-7.12,0-8.9.47a2.9,2.9,0,0,0-2,2A30.56,30.56,0,0,0,8.63,20a30.44,30.44,0,0,0,.46,5.47,2.89,2.89,0,0,0,2,2C12.9,28,20,28,20,28s7.12,0,8.9-.47a2.87,2.87,0,0,0,2-2A30.56,30.56,0,0,0,31.37,20,28.88,28.88,0,0,0,30.91,14.53ZM17.73,23.41V16.59L23.65,20Z"/></svg></a>
        <a href="https://github.com/spring-projects" title="Github"><svg id="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><path class="cls-1" d="M38,0a38,38,0,1,0,38,38A38,38,0,0,0,38,0Z"/></g><path class="cls-2" d="M38,15.59A22.95,22.95,0,0,0,30.71,60.3c1.15.21,1.57-.5,1.57-1.11s0-2,0-3.9c-6.38,1.39-7.73-3.07-7.73-3.07A6.09,6.09,0,0,0,22,48.86c-2.09-1.42.15-1.39.15-1.39a4.81,4.81,0,0,1,3.52,2.36c2,3.5,5.37,2.49,6.67,1.91a4.87,4.87,0,0,1,1.46-3.07c-5.09-.58-10.45-2.55-10.45-11.34a8.84,8.84,0,0,1,2.36-6.15,8.29,8.29,0,0,1,.23-6.07s1.92-.62,6.3,2.35a21.82,21.82,0,0,1,11.49,0c4.38-3,6.3-2.35,6.3-2.35a8.29,8.29,0,0,1,.23,6.07,8.84,8.84,0,0,1,2.36,6.15c0,8.81-5.37,10.75-10.48,11.32a5.46,5.46,0,0,1,1.56,4.25c0,3.07,0,5.54,0,6.29s.42,1.33,1.58,1.1A22.94,22.94,0,0,0,38,15.59Z"/></svg></a>
        <a href="https://twitter.com/springcentral" title="Twitter"><svg id="twitter-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 75.93 75.93"><circle class="cls-1" cx="37.97" cy="37.97" r="37.97"/><path id="Twitter-2" data-name="Twitter" class="cls-2" d="M55.2,22.73a15.43,15.43,0,0,1-4.88,1.91,7.56,7.56,0,0,0-5.61-2.49A7.78,7.78,0,0,0,37,30a7.56,7.56,0,0,0,.2,1.79,21.63,21.63,0,0,1-15.84-8.23,8,8,0,0,0,2.37,10.52,7.66,7.66,0,0,1-3.48-1v.09A7.84,7.84,0,0,0,26.45,41a7.54,7.54,0,0,1-2,.28A7.64,7.64,0,0,1,23,41.09a7.71,7.71,0,0,0,7.18,5.47,15.21,15.21,0,0,1-9.55,3.37,15.78,15.78,0,0,1-1.83-.11,21.41,21.41,0,0,0,11.78,3.54c14.13,0,21.86-12,21.86-22.42,0-.34,0-.68,0-1a15.67,15.67,0,0,0,3.83-4.08,14.9,14.9,0,0,1-4.41,1.24A7.8,7.8,0,0,0,55.2,22.73Z"/></svg></a>
    </div>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/vendor/tabs.js"></script>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
docsearch({
  apiKey: '6098173f7ca8a2fc7db296538ae8a6cc',
  indexName: 'spring',
  inputSelector: '#search-input',
  algoliaOptions: { hitsPerPage: 10 }
})
</script>
  </body>
</html>
