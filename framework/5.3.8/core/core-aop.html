<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Aspect Oriented Programming with Spring :: Spring</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../core.html">Core</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3.8</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3.8</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/5.6.0/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/5.6.0/overview/prerequisites.html">5.6.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="core-aop.html">Aspect Oriented Programming with Spring</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/core-aop.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Aspect Oriented Programming with Spring</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by
providing another way of thinking about program structure. The key unit of modularity
in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects
enable the modularization of concerns (such as transaction management) that cut across
multiple types and objects. (Such concerns are often termed &#8220;crosscutting&#8221; concerns
in AOP literature.)</p>
</div>
<div class="paragraph">
<p>One of the key components of Spring is the AOP framework. While the Spring IoC
container does not depend on AOP (meaning you do not need to use AOP if you don&#8217;t want
to), AOP complements Spring IoC to provide a very capable middleware solution.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Spring AOP with AspectJ pointcuts</div>
<div class="paragraph">
<p>Spring provides simple and powerful ways of writing custom aspects by using either a
<a href="#aop-schema">schema-based approach</a> or the <a href="#aop-ataspectj">@AspectJ annotation style</a>.
Both of these styles offer fully typed advice and use of the AspectJ pointcut language
while still using Spring AOP for weaving.</p>
</div>
<div class="paragraph">
<p>This chapter discusses the schema- and @AspectJ-based AOP support.
The lower-level AOP support is discussed in <a href="#aop-api">the following chapter</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP is used in the Spring Framework to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide declarative enterprise services. The most important such service is
<a href="../data-access.html#transaction-declarative" class="page">declarative transaction management</a>.</p>
</li>
<li>
<p>Let users implement custom aspects, complementing their use of OOP with AOP.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are interested only in generic declarative services or other pre-packaged
declarative middleware services such as pooling, you do not need to work directly with
Spring AOP, and can skip most of this chapter.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a>AOP Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us begin by defining some central AOP concepts and terminology. These terms are not
Spring-specific. Unfortunately, AOP terminology is not particularly intuitive.
However, it would be even more confusing if Spring used its own terminology.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aspect: A modularization of a concern that cuts across multiple classes.
Transaction management is a good example of a crosscutting concern in enterprise Java
applications. In Spring AOP, aspects are implemented by using regular classes
(the <a href="#aop-schema">schema-based approach</a>) or regular classes annotated with the
<code>@Aspect</code> annotation (the <a href="#aop-ataspectj">@AspectJ style</a>).</p>
</li>
<li>
<p>Join point: A point during the execution of a program, such as the execution of a
method or the handling of an exception. In Spring AOP, a join point always
represents a method execution.</p>
</li>
<li>
<p>Advice: Action taken by an aspect at a particular join point. Different types of
advice include &#8220;around&#8221;, &#8220;before&#8221; and &#8220;after&#8221; advice. (Advice types are discussed
later.) Many AOP frameworks, including Spring, model an advice as an interceptor and
maintain a chain of interceptors around the join point.</p>
</li>
<li>
<p>Pointcut: A predicate that matches join points. Advice is associated with a
pointcut expression and runs at any join point matched by the pointcut (for example,
the execution of a method with a certain name). The concept of join points as matched
by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut
expression language by default.</p>
</li>
<li>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring
AOP lets you introduce new interfaces (and a corresponding implementation) to any
advised object. For example, you could use an introduction to make a bean implement an
<code>IsModified</code> interface, to simplify caching. (An introduction is known as an
inter-type declaration in the AspectJ community.)</p>
</li>
<li>
<p>Target object: An object being advised by one or more aspects. Also referred to as
the &#8220;advised object&#8221;. Since Spring AOP is implemented by using runtime proxies, this
object is always a proxied object.</p>
</li>
<li>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect
contracts (advise method executions and so on). In the Spring Framework, an AOP proxy
is a JDK dynamic proxy or a CGLIB proxy.</p>
</li>
<li>
<p>Weaving: linking aspects with other application types or objects to create an
advised object. This can be done at compile time (using the AspectJ compiler, for
example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks,
performs weaving at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring AOP includes the following types of advice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before advice: Advice that runs before a join point but that does not have
the ability to prevent execution flow proceeding to the join point (unless it throws
an exception).</p>
</li>
<li>
<p>After returning advice: Advice to be run after a join point completes
normally (for example, if a method returns without throwing an exception).</p>
</li>
<li>
<p>After throwing advice: Advice to be run if a method exits by throwing an
exception.</p>
</li>
<li>
<p>After (finally) advice: Advice to be run regardless of the means by which a
join point exits (normal or exceptional return).</p>
</li>
<li>
<p>Around advice: Advice that surrounds a join point such as a method invocation.
This is the most powerful kind of advice. Around advice can perform custom behavior
before and after the method invocation. It is also responsible for choosing whether to
proceed to the join point or to shortcut the advised method execution by returning its
own return value or throwing an exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Around advice is the most general kind of advice. Since Spring AOP, like AspectJ,
provides a full range of advice types, we recommend that you use the least powerful
advice type that can implement the required behavior. For example, if you need only to
update a cache with the return value of a method, you are better off implementing an
after returning advice than an around advice, although an around advice can accomplish
the same thing. Using the most specific advice type provides a simpler programming model
with less potential for errors. For example, you do not need to invoke the <code>proceed()</code>
method on the <code>JoinPoint</code> used for around advice, and, hence, you cannot fail to invoke it.</p>
</div>
<div class="paragraph">
<p>All advice parameters are statically typed so that you work with advice parameters of
the appropriate type (e.g. the type of the return value from a method execution) rather
than <code>Object</code> arrays.</p>
</div>
<div class="paragraph">
<p>The concept of join points matched by pointcuts is the key to AOP, which distinguishes
it from older technologies offering only interception. Pointcuts enable advice to be
targeted independently of the object-oriented hierarchy. For example, you can apply an
around advice providing declarative transaction management to a set of methods that span
multiple objects (such as all business operations in the service layer).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a>Spring AOP Capabilities and Goals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring AOP is implemented in pure Java. There is no need for a special compilation
process. Spring AOP does not need to control the class loader hierarchy and is thus
suitable for use in a servlet container or application server.</p>
</div>
<div class="paragraph">
<p>Spring AOP currently supports only method execution join points (advising the execution
of methods on Spring beans). Field interception is not implemented, although support for
field interception could be added without breaking the core Spring AOP APIs. If you need
to advise field access and update join points, consider a language such as AspectJ.</p>
</div>
<div class="paragraph">
<p>Spring AOP&#8217;s approach to AOP differs from that of most other AOP frameworks. The aim is
not to provide the most complete AOP implementation (although Spring AOP is quite
capable). Rather, the aim is to provide a close integration between AOP implementation and
Spring IoC, to help solve common problems in enterprise applications.</p>
</div>
<div class="paragraph">
<p>Thus, for example, the Spring Framework&#8217;s AOP functionality is normally used in
conjunction with the Spring IoC container. Aspects are configured by using normal bean
definition syntax (although this allows powerful &#8220;auto-proxying&#8221; capabilities). This is a
crucial difference from other AOP implementations. You cannot do some things
easily or efficiently with Spring AOP, such as advise very fine-grained objects (typically,
domain objects). AspectJ is the best choice in such cases. However, our
experience is that Spring AOP provides an excellent solution to most problems in
enterprise Java applications that are amenable to AOP.</p>
</div>
<div class="paragraph">
<p>Spring AOP never strives to compete with AspectJ to provide a comprehensive AOP
solution. We believe that both proxy-based frameworks such as Spring AOP and full-blown
frameworks such as AspectJ are valuable and that they are complementary, rather than in
competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable
all uses of AOP within a consistent Spring-based application
architecture. This integration does not affect the Spring AOP API or the AOP Alliance
API. Spring AOP remains backward-compatible. See <a href="#aop-api">the following chapter</a>
for a discussion of the Spring AOP APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the central tenets of the Spring Framework is that of non-invasiveness. This
is the idea that you should not be forced to introduce framework-specific classes and
interfaces into your business or domain model. However, in some places, the Spring Framework
does give you the option to introduce Spring Framework-specific dependencies into your
codebase. The rationale in giving you such options is because, in certain scenarios, it
might be just plain easier to read or code some specific piece of functionality in such
a way. However, the Spring Framework (almost) always offers you the choice: You have the
freedom to make an informed decision as to which option best suits your particular use
case or scenario.</p>
</div>
<div class="paragraph">
<p>One such choice that is relevant to this chapter is that of which AOP framework (and
which AOP style) to choose. You have the choice of AspectJ, Spring AOP, or both. You
also have the choice of either the @AspectJ annotation-style approach or the Spring XML
configuration-style approach. The fact that this chapter chooses to introduce the
@AspectJ-style approach first should not be taken as an indication that the Spring team
favors the @AspectJ annotation-style approach over the Spring XML configuration-style.</p>
</div>
<div class="paragraph">
<p>See <a href="#aop-choosing">Choosing which AOP Declaration Style to Use</a> for a more complete discussion of the &#8220;whys and wherefores&#8221; of
each style.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a>AOP Proxies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This
enables any interface (or set of interfaces) to be proxied.</p>
</div>
<div class="paragraph">
<p>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than
interfaces. By default, CGLIB is used if a business object does not implement an
interface. As it is good practice to program to interfaces rather than classes, business
classes normally implement one or more business interfaces. It is possible to
<a href="#aop-proxying">force the use of CGLIB</a>, in those (hopefully rare) cases where you
need to advise a method that is not declared on an interface or where you need to
pass a proxied object to a method as a concrete type.</p>
</div>
<div class="paragraph">
<p>It is important to grasp the fact that Spring AOP is proxy-based. See
<a href="#aop-understanding-aop-proxies">Understanding AOP Proxies</a> for a thorough examination of exactly what this
implementation detail actually means.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a>@AspectJ support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@AspectJ refers to a style of declaring aspects as regular Java classes annotated with
annotations. The @AspectJ style was introduced by the
<a href="https://www.eclipse.org/aspectj">AspectJ project</a> as part of the AspectJ 5 release. Spring
interprets the same annotations as AspectJ 5, using a library supplied by AspectJ
for pointcut parsing and matching. The AOP runtime is still pure Spring AOP, though, and
there is no dependency on the AspectJ compiler or weaver.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the AspectJ compiler and weaver enables use of the full AspectJ language and
is discussed in <a href="#aop-using-aspectj">Using AspectJ with Spring Applications</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a>Enabling @AspectJ Support</h3>
<div class="paragraph">
<p>To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for
configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on
whether or not they are advised by those aspects. By auto-proxying, we mean that, if Spring
determines that a bean is advised by one or more aspects, it automatically generates
a proxy for that bean to intercept method invocations and ensures that advice is run
as needed.</p>
</div>
<div class="paragraph">
<p>The @AspectJ support can be enabled with XML- or Java-style configuration. In either
case, you also need to ensure that AspectJ&#8217;s <code>aspectjweaver.jar</code> library is on the
classpath of your application (version 1.8 or later). This library is available in the
<code>lib</code> directory of an AspectJ distribution or from the Maven Central repository.</p>
</div>
<div class="sect3">
<h4 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>Enabling @AspectJ Support with Java Configuration</h4>
<div class="paragraph">
<p>To enable @AspectJ support with Java <code>@Configuration</code>, add the <code>@EnableAspectJAutoProxy</code>
annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableAspectJAutoProxy
class AppConfig</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>Enabling @AspectJ Support with XML Configuration</h4>
<div class="paragraph">
<p>To enable @AspectJ support with XML-based configuration, use the <code>aop:aspectj-autoproxy</code>
element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspectj-autoproxy/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This assumes that you use schema support as described in
<a href="../core.html#xsd-schemas" class="page">XML Schema-based configuration</a>.
See <a href="../core.html#xsd-schemas-aop" class="page">the AOP schema</a> for how to
import the tags in the <code>aop</code> namespace.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a>Declaring an Aspect</h3>
<div class="paragraph">
<p>With @AspectJ support enabled, any bean defined in your application context with a
class that is an @AspectJ aspect (has the <code>@Aspect</code> annotation) is automatically
detected by Spring and used to configure Spring AOP. The next two examples show the
minimal definition required for a not-very-useful aspect.</p>
</div>
<div class="paragraph">
<p>The first of the two example shows a regular bean definition in the application
context that points to a bean class that has the <code>@Aspect</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt;
	&lt;!-- configure properties of the aspect here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two examples shows the <code>NotVeryUsefulAspect</code> class definition,
which is annotated with the <code>org.aspectj.lang.annotation.Aspect</code> annotation;</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package org.xyz

import org.aspectj.lang.annotation.Aspect;

@Aspect
class NotVeryUsefulAspect</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aspects (classes annotated with <code>@Aspect</code>) can have methods and fields, the same as any
other class. They can also contain pointcut, advice, and introduction (inter-type)
declarations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Autodetecting aspects through component scanning</div>
You can register aspect classes as regular beans in your Spring XML configuration,
via <code>@Bean</code> methods in <code>@Configuration</code> classes, or have Spring autodetect them through
classpath scanning&#8201;&#8212;&#8201;the same as any other Spring-managed bean. However, note that the
<code>@Aspect</code> annotation is not sufficient for autodetection in the classpath. For that
purpose, you need to add a separate <code>@Component</code> annotation (or, alternatively, a custom
stereotype annotation that qualifies, as per the rules of Spring&#8217;s component scanner).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Advising aspects with other aspects?</div>
In Spring AOP, aspects themselves cannot be the targets of advice from other
aspects. The <code>@Aspect</code> annotation on a class marks it as an aspect and, hence, excludes
it from auto-proxying.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a>Declaring a Pointcut</h3>
<div class="paragraph">
<p>Pointcuts determine join points of interest and thus enable us to control
when advice runs. Spring AOP only supports method execution join points for Spring
beans, so you can think of a pointcut as matching the execution of methods on Spring
beans. A pointcut declaration has two parts: a signature comprising a name and any
parameters and a pointcut expression that determines exactly which method
executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut
signature is provided by a regular method definition, and the pointcut expression is
indicated by using the <code>@Pointcut</code> annotation (the method serving as the pointcut signature
must have a <code>void</code> return type).</p>
</div>
<div class="paragraph">
<p>An example may help make this distinction between a pointcut signature and a pointcut
expression clear. The following example defines a pointcut named <code>anyOldTransfer</code> that
matches the execution of any method named <code>transfer</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Pointcut("execution(* transfer(..))") // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Pointcut("execution(* transfer(..))") // the pointcut expression
private fun anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut expression that forms the value of the <code>@Pointcut</code> annotation is a regular
AspectJ pointcut expression. For a full discussion of AspectJ&#8217;s pointcut language, see
the <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ
Programming Guide</a> (and, for extensions, the
<a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5
Developer&#8217;s Notebook</a>) or one of the books on AspectJ (such as <em>Eclipse AspectJ</em>, by Colyer
et. al., or <em>AspectJ in Action</em>, by Ramnivas Laddad).</p>
</div>
<div class="sect3">
<h4 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>Supported Pointcut Designators</h4>
<div class="paragraph">
<p>Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>execution</code>: For matching method execution join points. This is the primary
pointcut designator to use when working with Spring AOP.</p>
</li>
<li>
<p><code>within</code>: Limits matching to join points within certain types (the execution
of a method declared within a matching type when using Spring AOP).</p>
</li>
<li>
<p><code>this</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p>
</li>
<li>
<p><code>target</code>: Limits matching to join points (the execution of methods when using
Spring AOP) where the target object (application object being proxied) is an instance
of the given type.</p>
</li>
<li>
<p><code>args</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the arguments are instances of the given types.</p>
</li>
<li>
<p><code>@target</code>: Limits matching to join points (the execution of methods when using
Spring AOP) where the class of the executing object has an annotation of the given type.</p>
</li>
<li>
<p><code>@args</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the runtime type of the actual arguments passed have annotations of the
given types.</p>
</li>
<li>
<p><code>@within</code>: Limits matching to join points within types that have the given
annotation (the execution of methods declared in types with the given annotation when
using Spring AOP).</p>
</li>
<li>
<p><code>@annotation</code>: Limits matching to join points where the subject of the join point
(the method being run in Spring AOP) has the given annotation.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Other pointcut types</div>
<div class="paragraph">
<p>The full AspectJ pointcut language supports additional pointcut designators that are not
supported in Spring: <code>call</code>, <code>get</code>, <code>set</code>, <code>preinitialization</code>,
<code>staticinitialization</code>, <code>initialization</code>, <code>handler</code>, <code>adviceexecution</code>, <code>withincode</code>, <code>cflow</code>,
<code>cflowbelow</code>, <code>if</code>, <code>@this</code>, and <code>@withincode</code>. Use of these pointcut designators in pointcut
expressions interpreted by Spring AOP results in an <code>IllegalArgumentException</code> being
thrown.</p>
</div>
<div class="paragraph">
<p>The set of pointcut designators supported by Spring AOP may be extended in future
releases to support more of the AspectJ pointcut designators.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Because Spring AOP limits matching to only method execution join points, the preceding discussion
of the pointcut designators gives a narrower definition than you can find in the
AspectJ programming guide. In addition, AspectJ itself has type-based semantics and, at
an execution join point, both <code>this</code> and <code>target</code> refer to the same object: the
object executing the method. Spring AOP is a proxy-based system and differentiates
between the proxy object itself (which is bound to <code>this</code>) and the target object behind the
proxy (which is bound to <code>target</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Due to the proxy-based nature of Spring&#8217;s AOP framework, calls within the target object
are, by definition, not intercepted. For JDK proxies, only public interface method
calls on the proxy can be intercepted. With CGLIB, public and protected method calls on
the proxy are intercepted (and even package-visible methods, if necessary). However,
common interactions through proxies should always be designed through public signatures.</p>
</div>
<div class="paragraph">
<p>Note that pointcut definitions are generally matched against any intercepted method.
If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with
potential non-public interactions through proxies, it needs to be defined accordingly.</p>
</div>
<div class="paragraph">
<p>If your interception needs include method calls or even constructors within the target
class, consider the use of Spring-driven <a href="#aop-aj-ltw">native AspectJ weaving</a> instead
of Spring&#8217;s proxy-based AOP framework. This constitutes a different mode of AOP usage
with different characteristics, so be sure to make yourself familiar with weaving
before making a decision.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring AOP also supports an additional PCD named <code>bean</code>. This PCD lets you limit
the matching of join points to a particular named Spring bean or to a set of named
Spring beans (when using wildcards). The <code>bean</code> PCD has the following form:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>idOrNameOfBean</code> token can be the name of any Spring bean. Limited wildcard
support that uses the <code>*</code> character is provided, so, if you establish some naming
conventions for your Spring beans, you can write a <code>bean</code> PCD expression
to select them. As is the case with other pointcut designators, the <code>bean</code> PCD can
be used with the <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (negation) operators, too.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>bean</code> PCD is supported only in Spring AOP and not in
native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that
AspectJ defines and is, therefore, not available for aspects declared in the <code>@Aspect</code> model.</p>
</div>
<div class="paragraph">
<p>The <code>bean</code> PCD operates at the instance level (building on the Spring bean name
concept) rather than at the type level only (to which weaving-based AOP is limited).
Instance-based pointcut designators are a special capability of Spring&#8217;s
proxy-based AOP framework and its close integration with the Spring bean factory, where
it is natural and straightforward to identify specific beans by name.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>Combining Pointcut Expressions</h4>
<div class="paragraph">
<p>You can combine pointcut expressions by using <code>&amp;&amp;,</code> <code>||</code> and <code>!</code>. You can also refer to
pointcut expressions by name. The following example shows three pointcut expressions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.myapp.trading..*)")
private void inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private void tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>anyPublicOperation</code> matches if a method execution join point represents the execution
of any public method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>inTrading</code> matches if a method execution is in the trading module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tradingOperation</code> matches if a method execution represents any public method in the
trading module.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Pointcut("execution(public * *(..))")
private fun anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.myapp.trading..*)")
private fun inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private fun tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>anyPublicOperation</code> matches if a method execution join point represents the execution
of any public method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>inTrading</code> matches if a method execution is in the trading module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tradingOperation</code> matches if a method execution represents any public method in the
trading module.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is a best practice to build more complex pointcut expressions out of smaller named
components, as shown earlier. When referring to pointcuts by name, normal Java visibility
rules apply (you can see private pointcuts in the same type, protected pointcuts in the
hierarchy, public pointcuts anywhere, and so on). Visibility does not affect pointcut
matching.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>Sharing Common Pointcut Definitions</h4>
<div class="paragraph">
<p>When working with enterprise applications, developers often want to refer to modules of
the application and particular sets of operations from within several aspects. We
recommend defining a <code>CommonPointcuts</code> aspect that captures common pointcut expressions
for this purpose. Such an aspect typically resembles the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.xyz.myapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class CommonPointcuts {

	/**
	 * A join point is in the web layer if the method is defined
	 * in a type in the com.xyz.myapp.web package or any sub-package
	 * under that.
	 */
	@Pointcut("within(com.xyz.myapp.web..*)")
	public void inWebLayer() {}

	/**
	 * A join point is in the service layer if the method is defined
	 * in a type in the com.xyz.myapp.service package or any sub-package
	 * under that.
	 */
	@Pointcut("within(com.xyz.myapp.service..*)")
	public void inServiceLayer() {}

	/**
	 * A join point is in the data access layer if the method is defined
	 * in a type in the com.xyz.myapp.dao package or any sub-package
	 * under that.
	 */
	@Pointcut("within(com.xyz.myapp.dao..*)")
	public void inDataAccessLayer() {}

	/**
	 * A business service is the execution of any method defined on a service
	 * interface. This definition assumes that interfaces are placed in the
	 * "service" package, and that implementation types are in sub-packages.
	 *
	 * If you group service interfaces by functional area (for example,
	 * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
	 * the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
	 * could be used instead.
	 *
	 * Alternatively, you can write the expression using the 'bean'
	 * PCD, like so "bean(*Service)". (This assumes that you have
	 * named your Spring service beans in a consistent fashion.)
	 */
	@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
	public void businessService() {}

	/**
	 * A data access operation is the execution of any method defined on a
	 * dao interface. This definition assumes that interfaces are placed in the
	 * "dao" package, and that implementation types are in sub-packages.
	 */
	@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
	public void dataAccessOperation() {}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.xyz.myapp

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Pointcut

@Aspect
class CommonPointcuts {

	/**
	* A join point is in the web layer if the method is defined
	* in a type in the com.xyz.myapp.web package or any sub-package
	* under that.
	*/
	@Pointcut("within(com.xyz.myapp.web..*)")
	fun inWebLayer() {
	}

	/**
	* A join point is in the service layer if the method is defined
	* in a type in the com.xyz.myapp.service package or any sub-package
	* under that.
	*/
	@Pointcut("within(com.xyz.myapp.service..*)")
	fun inServiceLayer() {
	}

	/**
	* A join point is in the data access layer if the method is defined
	* in a type in the com.xyz.myapp.dao package or any sub-package
	* under that.
	*/
	@Pointcut("within(com.xyz.myapp.dao..*)")
	fun inDataAccessLayer() {
	}

	/**
	* A business service is the execution of any method defined on a service
	* interface. This definition assumes that interfaces are placed in the
	* "service" package, and that implementation types are in sub-packages.
	*
	* If you group service interfaces by functional area (for example,
	* in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
	* the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
	* could be used instead.
	*
	* Alternatively, you can write the expression using the 'bean'
	* PCD, like so "bean(*Service)". (This assumes that you have
	* named your Spring service beans in a consistent fashion.)
	*/
	@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
	fun businessService() {
	}

	/**
	* A data access operation is the execution of any method defined on a
	* dao interface. This definition assumes that interfaces are placed in the
	* "dao" package, and that implementation types are in sub-packages.
	*/
	@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
	fun dataAccessOperation() {
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can refer to the pointcuts defined in such an aspect anywhere you need a
pointcut expression. For example, to make the service layer transactional, you could
write the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;
	&lt;aop:advisor
		pointcut="com.xyz.myapp.CommonPointcuts.businessService()"
		advice-ref="tx-advice"/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
	&lt;tx:attributes&gt;
		&lt;tx:method name="*" propagation="REQUIRED"/&gt;
	&lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;aop:config&gt;</code> and <code>&lt;aop:advisor&gt;</code> elements are discussed in <a href="#aop-schema">Schema-based AOP Support</a>. The
transaction elements are discussed in <a href="../data-access.html#transaction" class="page">Transaction Management</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>Examples</h4>
<div class="paragraph">
<p>Spring AOP users are likely to use the <code>execution</code> pointcut designator the most often.
The format of an execution expression follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>	execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
				throws-pattern?)</pre>
</div>
</div>
<div class="paragraph">
<p>All parts except the returning type pattern (<code>ret-type-pattern</code> in the preceding snippet),
the name pattern, and the parameters pattern are optional. The returning type pattern determines
what the return type of the method must be in order for a join point to be matched.
<code>*</code> is most frequently used as the returning type pattern. It matches any return
type. A fully-qualified type name matches only when the method returns the given
type. The name pattern matches the method name. You can use the <code>*</code> wildcard as all or
part of a name pattern. If you specify a declaring type pattern,
include a trailing <code>.</code> to join it to the name pattern component.
The parameters pattern is slightly more complex: <code>()</code> matches a
method that takes no parameters, whereas <code>(..)</code> matches any number (zero or more) of parameters.
The <code>(*)</code> pattern matches a method that takes one parameter of any type.
<code>(*,String)</code> matches a method that takes two parameters. The first can be of any type, while the
second must be a <code>String</code>. Consult the
<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">Language
Semantics</a> section of the AspectJ Programming Guide for more information.</p>
</div>
<div class="paragraph">
<p>The following examples show some common pointcut expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The execution of any public method:</p>
<div class="literalblock">
<div class="content">
<pre>	execution(public * *(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method with a name that begins with <code>set</code>:</p>
<div class="literalblock">
<div class="content">
<pre>	execution(* set*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined by the <code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>	execution(* com.xyz.service.AccountService.*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined in the <code>service</code> package:</p>
<div class="literalblock">
<div class="content">
<pre>	execution(* com.xyz.service.*.*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined in the service package or one of its sub-packages:</p>
<div class="literalblock">
<div class="content">
<pre>	execution(* com.xyz.service..*.*(..))</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) within the service package:</p>
<div class="literalblock">
<div class="content">
<pre>	within(com.xyz.service.*)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) within the service package or one of its
sub-packages:</p>
<div class="literalblock">
<div class="content">
<pre>	within(com.xyz.service..*)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the proxy implements the
<code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>	this(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'this' is more commonly used in a binding form. See the section on <a href="#aop-advice">Declaring Advice</a>
for how to make the proxy object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the target object
implements the <code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>	target(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'target' is more commonly used in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the target object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) that takes a single parameter
and where the argument passed at runtime is <code>Serializable</code>:</p>
<div class="literalblock">
<div class="content">
<pre>	args(java.io.Serializable)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'args' is more commonly used in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the method arguments available in the advice body.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that the pointcut given in this example is different from <code>execution(*
*(java.io.Serializable))</code>. The args version matches if the argument passed at runtime is
<code>Serializable</code>, and the execution version matches if the method signature declares a single
parameter of type <code>Serializable</code>.</p>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the target object has a
<code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>	@target(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@target' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section for
how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the declared type of the
target object has an <code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>	@within(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@within' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section for
how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the executing method has an
<code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>	@annotation(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@annotation' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) which takes a single parameter,
and where the runtime type of the argument passed has the <code>@Classified</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>	@args(com.xyz.security.Classified)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@args' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
how to make the annotation object(s) available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) on a Spring bean named
<code>tradeService</code>:</p>
<div class="literalblock">
<div class="content">
<pre>	bean(tradeService)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) on Spring beans having names that
match the wildcard expression <code>*Service</code>:</p>
<div class="literalblock">
<div class="content">
<pre>	bean(*Service)</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>Writing Good Pointcuts</h4>
<div class="paragraph">
<p>During compilation, AspectJ processes pointcuts in order to optimize matching
performance. Examining code and determining if each join point matches (statically or
dynamically) a given pointcut is a costly process. (A dynamic match means the match
cannot be fully determined from static analysis and that a test is placed in the code to
determine if there is an actual match when the code is running). On first encountering a
pointcut declaration, AspectJ rewrites it into an optimal form for the matching
process. What does this mean? Basically, pointcuts are rewritten in DNF (Disjunctive
Normal Form) and the components of the pointcut are sorted such that those components
that are cheaper to evaluate are checked first. This means you do not have to worry
about understanding the performance of various pointcut designators and may supply them
in any order in a pointcut declaration.</p>
</div>
<div class="paragraph">
<p>However, AspectJ can work only with what it is told. For optimal performance of
matching, you should think about what they are trying to achieve and narrow the search
space for matches as much as possible in the definition. The existing designators
naturally fall into one of three groups: kinded, scoping, and contextual:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded designators select a particular kind of join point:
<code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, and <code>handler</code>.</p>
</li>
<li>
<p>Scoping designators select a group of join points of interest
(probably of many kinds): <code>within</code> and <code>withincode</code></p>
</li>
<li>
<p>Contextual designators match (and optionally bind) based on context:
<code>this</code>, <code>target</code>, and <code>@annotation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well written pointcut should include at least the first two types (kinded and
scoping). You can include the contextual designators to match based on
join point context or bind that context for use in the advice. Supplying only a
kinded designator or only a contextual designator works but could affect weaving
performance (time and memory used), due to extra processing and analysis. Scoping
designators are very fast to match, and using them usage means AspectJ can very quickly
dismiss groups of join points that should not be further processed. A good
pointcut should always include one if possible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-advice"><a class="anchor" href="#aop-advice"></a>Declaring Advice</h3>
<div class="paragraph">
<p>Advice is associated with a pointcut expression and runs before, after, or around
method executions matched by the pointcut. The pointcut expression may be either a
simple reference to a named pointcut or a pointcut expression declared in place.</p>
</div>
<div class="sect3">
<h4 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>Before Advice</h4>
<div class="paragraph">
<p>You can declare before advice in an aspect by using the <code>@Before</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

	@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	public void doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

	@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	fun doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we use an in-place pointcut expression, we could rewrite the preceding example as the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

	@Before("execution(* com.xyz.myapp.dao.*.*(..))")
	public void doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

	@Before("execution(* com.xyz.myapp.dao.*.*(..))")
	fun doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>After Returning Advice</h4>
<div class="paragraph">
<p>After returning advice runs when a matched method execution returns normally.
You can declare it by using the <code>@AfterReturning</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

	@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	public void doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

	@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	fun doAccessCheck() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can have multiple advice declarations (and other members as well),
all inside the same aspect. We show only a single advice declaration in these
examples to focus the effect of each one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes, you need access in the advice body to the actual value that was returned.
You can use the form of <code>@AfterReturning</code> that binds the return value to get that
access, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

	@AfterReturning(
		pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
		returning="retVal")
	public void doAccessCheck(Object retVal) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

	@AfterReturning(
		pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
		returning = "retVal")
	fun doAccessCheck(retVal: Any) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>returning</code> attribute must correspond to the name of a parameter
in the advice method. When a method execution returns, the return value is passed to
the advice method as the corresponding argument value. A <code>returning</code> clause also
restricts matching to only those method executions that return a value of the
specified type (in this case, <code>Object</code>, which matches any return value).</p>
</div>
<div class="paragraph">
<p>Please note that it is not possible to return a totally different reference when
using after returning advice.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>After Throwing Advice</h4>
<div class="paragraph">
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. You can declare it by using the <code>@AfterThrowing</code> annotation, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

	@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	public void doRecoveryActions() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

	@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	fun doRecoveryActions() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often, you want the advice to run only when exceptions of a given type are thrown,
and you also often need access to the thrown exception in the advice body. You can
use the <code>throwing</code> attribute to both restrict matching (if desired&#8201;&#8212;&#8201;use <code>Throwable</code>
as the exception type otherwise) and bind the thrown exception to an advice parameter.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

	@AfterThrowing(
		pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
		throwing="ex")
	public void doRecoveryActions(DataAccessException ex) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

	@AfterThrowing(
		pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
		throwing = "ex")
	fun doRecoveryActions(ex: DataAccessException) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>throwing</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution exits by throwing an exception, the exception
is passed to the advice method as the corresponding argument value. A <code>throwing</code> clause
also restricts matching to only those method executions that throw an exception of the
specified type (<code>DataAccessException</code>, in this case).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that <code>@AfterThrowing</code> does not indicate a general exception handling callback.
Specifically, an <code>@AfterThrowing</code> advice method is only supposed to receive exceptions
from the join point (user-declared target method) itself but not from an accompanying
<code>@After</code>/<code>@AfterReturning</code> method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>After (Finally) Advice</h4>
<div class="paragraph">
<p>After (finally) advice runs when a matched method execution exits. It is declared by
using the <code>@After</code> annotation. After advice must be prepared to handle both normal and
exception return conditions. It is typically used for releasing resources and similar
purposes. The following example shows how to use after finally advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample {

	@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	public void doReleaseLock() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.After

@Aspect
class AfterFinallyExample {

	@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
	fun doReleaseLock() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that <code>@After</code> advice in AspectJ is defined as "after finally advice", analogous
to a finally block in a try-catch statement. It will be invoked for any outcome,
normal return or exception thrown from the join point (user-declared target method),
in contrast to <code>@AfterReturning</code> which only applies to successful normal returns.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>Around Advice</h4>
<div class="paragraph">
<p>The last kind of advice is around advice. Around advice runs &#8220;around&#8221; a matched
method&#8217;s execution. It has the opportunity to do work both before and after the method
runs and to determine when, how, and even if the method actually gets to run at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer, for example).
Always use the least powerful form of advice that meets your requirements (that is,
do not use around advice if before advice would do).</p>
</div>
<div class="paragraph">
<p>Around advice is declared by using the <code>@Around</code> annotation. The first parameter of the
advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to run.
The <code>proceed</code> method can also pass in an <code>Object[]</code>. The values in the array are used
as the arguments to the method execution when it proceeds.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The behavior of <code>proceed</code> when called with an <code>Object[]</code> is a little different than
the behavior of <code>proceed</code> for around advice compiled by the AspectJ compiler. For around
advice written using the traditional AspectJ language, the number of arguments passed to
<code>proceed</code> must match the number of arguments passed to the around advice (not the number
of arguments taken by the underlying join point), and the value passed to proceed in a
given argument position supplants the original value at the join point for the entity
the value was bound to (do not worry if this does not make sense right now). The approach
taken by Spring is simpler and a better match to its proxy-based, execution-only
semantics. You only need to be aware of this difference if you compile @AspectJ
aspects written for Spring and use <code>proceed</code> with arguments with the AspectJ compiler
and weaver. There is a way to write such aspects that is 100% compatible across both
Spring AOP and AspectJ, and this is discussed in the
<a href="#aop-ataspectj-advice-params">following section on advice parameters</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use around advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample {

	@Around("com.xyz.myapp.CommonPointcuts.businessService()")
	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
		// start stopwatch
		Object retVal = pjp.proceed();
		// stop stopwatch
		return retVal;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.ProceedingJoinPoint

@Aspect
class AroundExample {

	@Around("com.xyz.myapp.CommonPointcuts.businessService()")
	fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
		// start stopwatch
		val retVal = pjp.proceed()
		// stop stopwatch
		return retVal
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value returned by the around advice is the return value seen by the caller of the
method. For example, a simple caching aspect could return a value from a cache if it
has one and invoke <code>proceed()</code> if it does not. Note that <code>proceed</code> may be invoked once,
many times, or not at all within the body of the around advice. All of these are legal.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>Advice Parameters</h4>
<div class="paragraph">
<p>Spring offers fully typed advice, meaning that you declare the parameters you need in the
advice signature (as we saw earlier for the returning and throwing examples) rather than
work with <code>Object[]</code> arrays all the time. We see how to make argument and other contextual
values available to the advice body later in this section. First, we take a look at how to
write generic advice that can find out about the method the advice is currently advising.</p>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>Access to the Current <code>JoinPoint</code></h5>
<div class="paragraph">
<p>Any advice method may declare, as its first parameter, a parameter of type
<code>org.aspectj.lang.JoinPoint</code> (note that around advice is required to declare a first
parameter of type <code>ProceedingJoinPoint</code>, which is a subclass of <code>JoinPoint</code>.
The <code>JoinPoint</code> interface provides a number of useful methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getArgs()</code>: Returns the method arguments.</p>
</li>
<li>
<p><code>getThis()</code>: Returns the proxy object.</p>
</li>
<li>
<p><code>getTarget()</code>: Returns the target object.</p>
</li>
<li>
<p><code>getSignature()</code>: Returns a description of the method that is being advised.</p>
</li>
<li>
<p><code>toString()</code>: Prints a useful description of the method being advised.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">javadoc</a> for more detail.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>Passing Parameters to Advice</h5>
<div class="paragraph">
<p>We have already seen how to bind the returned value or exception value (using after
returning and after throwing advice). To make argument values available to the advice
body, you can use the binding form of <code>args</code>. If you use a parameter name in place of a
type name in an args expression, the value of the corresponding argument is passed as
the parameter value when the advice is invoked. An example should make this clearer.
Suppose you want to advise the execution of DAO operations that take an <code>Account</code>
object as the first parameter, and you need access to the account in the advice body.
You could write the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
public void validateAccount(Account account) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
fun validateAccount(account: Account) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>args(account,..)</code> part of the pointcut expression serves two purposes. First, it
restricts matching to only those method executions where the method takes at least one
parameter, and the argument passed to that parameter is an instance of <code>Account</code>.
Second, it makes the actual <code>Account</code> object available to the advice through the <code>account</code>
parameter.</p>
</div>
<div class="paragraph">
<p>Another way of writing this is to declare a pointcut that &#8220;provides&#8221; the <code>Account</code>
object value when it matches a join point, and then refer to the named pointcut
from the advice. This would look as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
private fun accountDataAccessOperation(account: Account) {
}

@Before("accountDataAccessOperation(account)")
fun validateAccount(account: Account) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the AspectJ programming guide for more
details.</p>
</div>
<div class="paragraph">
<p>The proxy object ( <code>this</code>), target object ( <code>target</code>), and annotations ( <code>@within</code>,
<code>@target</code>, <code>@annotation</code>, and <code>@args</code>) can all be bound in a similar fashion. The next two
examples show how to match the execution of methods annotated with an
<code>@Auditable</code> annotation and extract the audit code:</p>
</div>
<div class="paragraph">
<p>The first of the two examples shows the definition of the <code>@Auditable</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable {
	AuditCode value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Auditable(val value: AuditCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two examples shows the advice that matches the execution of <code>@Auditable</code> methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
public void audit(Auditable auditable) {
	AuditCode code = auditable.value();
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
fun audit(auditable: Auditable) {
	val code = auditable.value()
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>Advice Parameters and Generics</h5>
<div class="paragraph">
<p>Spring AOP can handle generics used in class declarations and method parameters. Suppose
you have a generic type like the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Sample&lt;T&gt; {
	void sampleGenericMethod(T param);
	void sampleGenericCollectionMethod(Collection&lt;T&gt; param);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">interface Sample&lt;T&gt; {
	fun sampleGenericMethod(param: T)
	fun sampleGenericCollectionMethod(param: Collection&lt;T&gt;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can restrict interception of method types to certain parameter types by
typing the advice parameter to the parameter type for which you want to intercept the method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(MyType param) {
	// Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: MyType) {
	// Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach does not work for generic collections. So you cannot define a
pointcut as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(Collection&lt;MyType&gt; param) {
	// Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: Collection&lt;MyType&gt;) {
	// Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work, we would have to inspect every element of the collection, which is not
reasonable, as we also cannot decide how to treat <code>null</code> values in general. To achieve
something similar to this, you have to type the parameter to <code>Collection&lt;?&gt;</code> and manually
check the type of the elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>Determining Argument Names</h5>
<div class="paragraph">
<p>The parameter binding in advice invocations relies on matching names used in pointcut
expressions to declared parameter names in advice and pointcut method signatures.
Parameter names are not available through Java reflection, so Spring AOP uses the
following strategy to determine parameter names:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the parameter names have been explicitly specified by the user, the specified
parameter names are used. Both the advice and the pointcut annotations have
an optional <code>argNames</code> attribute that you can use to specify the argument names of
the annotated method. These argument names are available at runtime. The following example
shows how to use the <code>argNames</code> attribute:</p>
</li>
</ul>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
		argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) {
	AuditCode code = auditable.value();
	// ... use code and bean
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(bean: Any, auditable: Auditable) {
	val code = auditable.value()
	// ... use code and bean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the first parameter is of the <code>JoinPoint</code>, <code>ProceedingJoinPoint</code>, or
<code>JoinPoint.StaticPart</code> type, you can leave out the name of the parameter from the value
of the <code>argNames</code> attribute. For example, if you modify the preceding advice to receive
the join point object, the <code>argNames</code> attribute need not include it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
		argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) {
	AuditCode code = auditable.value();
	// ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
	val code = auditable.value()
	// ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The special treatment given to the first parameter of the <code>JoinPoint</code>,
<code>ProceedingJoinPoint</code>, and <code>JoinPoint.StaticPart</code> types is particularly convenient for
advice instances that do not collect any other join point context. In such situations, you may
omit the <code>argNames</code> attribute. For example, the following advice need not declare
the <code>argNames</code> attribute:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
public void audit(JoinPoint jp) {
	// ... use jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
fun audit(jp: JoinPoint) {
	// ... use jp
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the <code>'argNames'</code> attribute is a little clumsy, so if the <code>'argNames'</code> attribute
has not been specified,  Spring AOP looks at the debug information for the
class and tries to determine the parameter names from the local variable table. This
information is present as long as the classes have been compiled with debug
information ( <code>'-g:vars'</code> at a minimum). The consequences of compiling with this flag
on are: (1) your code is slightly easier to understand (reverse engineer), (2)
the class file sizes are very slightly bigger (typically inconsequential), (3) the
optimization to remove unused local variables is not  applied by your compiler. In
other words, you should encounter no difficulties by building with this flag on.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the
debug information, you need not add the <code>argNames</code> attribute, as the compiler
retain the needed information.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>If the code has been compiled without the necessary debug information, Spring AOP
tries to deduce the pairing of binding variables to parameters (for example, if
only one variable is bound in the pointcut expression, and the advice method
takes only one parameter, the pairing is obvious). If the binding of variables is
ambiguous given the available information, an <code>AmbiguousBindingException</code> is
thrown.</p>
</li>
<li>
<p>If all of the above strategies fail, an <code>IllegalArgumentException</code> is thrown.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-proceeding-with-the-call"><a class="anchor" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>Proceeding with Arguments</h5>
<div class="paragraph">
<p>We remarked earlier that we would describe how to write a <code>proceed</code> call with
arguments that works consistently across Spring AOP and AspectJ. The solution is
to ensure that the advice signature binds each of the method parameters in order.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
		"com.xyz.myapp.CommonPointcuts.inDataAccessLayer() &amp;&amp; " +
		"args(accountHolderNamePattern)")
public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
		String accountHolderNamePattern) throws Throwable {
	String newPattern = preProcess(accountHolderNamePattern);
	return pjp.proceed(new Object[] {newPattern});
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
		"com.xyz.myapp.CommonPointcuts.inDataAccessLayer() &amp;&amp; " +
		"args(accountHolderNamePattern)")
fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
						accountHolderNamePattern: String): Any {
	val newPattern = preProcess(accountHolderNamePattern)
	return pjp.proceed(arrayOf&lt;Any&gt;(newPattern))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In many cases, you do this binding anyway (as in the preceding example).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-advice-ordering"><a class="anchor" href="#aop-ataspectj-advice-ordering"></a>Advice Ordering</h4>
<div class="paragraph">
<p>What happens when multiple pieces of advice all want to run at the same join point?
Spring AOP follows the same precedence rules as AspectJ to determine the order of advice
execution. The highest precedence advice runs first "on the way in" (so, given two pieces
of before advice, the one with highest precedence runs first). "On the way out" from a
join point, the highest precedence advice runs last (so, given two pieces of after
advice, the one with the highest precedence will run second).</p>
</div>
<div class="paragraph">
<p>When two pieces of advice defined in different aspects both need to run at the same
join point, unless you specify otherwise, the order of execution is undefined. You can
control the order of execution by specifying precedence. This is done in the normal
Spring way by either implementing the <code>org.springframework.core.Ordered</code> interface in
the aspect class or annotating it with the <code>@Order</code> annotation. Given two aspects, the
aspect returning the lower value from <code>Ordered.getOrder()</code> (or the annotation value) has
the higher precedence.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Each of the distinct advice types of a particular aspect is conceptually meant to apply
to the join point directly. As a consequence, an <code>@AfterThrowing</code> advice method is not
supposed to receive an exception from an accompanying <code>@After</code>/<code>@AfterReturning</code> method.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.2.7, advice methods defined in the same <code>@Aspect</code> class that
need to run at the same join point are assigned precedence based on their advice type in
the following order, from highest to lowest precedence: <code>@Around</code>, <code>@Before</code>, <code>@After</code>,
<code>@AfterReturning</code>, <code>@AfterThrowing</code>. Note, however, that an <code>@After</code> advice method will
effectively be invoked after any <code>@AfterReturning</code> or <code>@AfterThrowing</code> advice methods
in the same aspect, following AspectJ&#8217;s "after finally advice" semantics for <code>@After</code>.</p>
</div>
<div class="paragraph">
<p>When two pieces of the same type of advice (for example, two <code>@After</code> advice methods)
defined in the same <code>@Aspect</code> class both need to run at the same join point, the ordering
is undefined (since there is no way to retrieve the source code declaration order through
reflection for javac-compiled classes). Consider collapsing such advice methods into one
advice method per join point in each <code>@Aspect</code> class or refactor the pieces of advice into
separate <code>@Aspect</code> classes that you can order at the aspect level via <code>Ordered</code> or <code>@Order</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-introductions"><a class="anchor" href="#aop-introductions"></a>Introductions</h3>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>You can make an introduction by using the <code>@DeclareParents</code> annotation. This annotation
is used to declare that matching types have a new parent (hence the name). For example,
given an interface named <code>UsageTracked</code> and an implementation of that interface named
<code>DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code>UsageTracked</code> interface (e.g. for statistics via JMX):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Aspect
public class UsageTracking {

	@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
	public static UsageTracked mixin;

	@Before("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)")
	public void recordUsage(UsageTracked usageTracked) {
		usageTracked.incrementUseCount();
	}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Aspect
class UsageTracking {

	companion object {
		@DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
		lateinit var mixin: UsageTracked
	}

	@Before("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)")
	fun recordUsage(usageTracked: UsageTracked) {
		usageTracked.incrementUseCount()
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by the type of the annotated field. The
<code>value</code> attribute of the <code>@DeclareParents</code> annotation is an AspectJ type pattern. Any
bean of a matching type implements the <code>UsageTracked</code> interface. Note that, in the
before advice of the preceding example, service beans can be directly used as
implementations of the <code>UsageTracked</code> interface. If accessing a bean programmatically,
you would write the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-instantiation-models"><a class="anchor" href="#aop-instantiation-models"></a>Aspect Instantiation Models</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is an advanced topic. If you are just starting out with AOP, you can safely skip
it until later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, there is a single instance of each aspect within the application
context. AspectJ calls this the singleton instantiation model. It is possible to define
aspects with alternate lifecycles. Spring supports AspectJ&#8217;s <code>perthis</code> and <code>pertarget</code>
instantiation models; <code>percflow</code>, <code>percflowbelow</code>, and <code>pertypewithin</code> are not currently
supported.</p>
</div>
<div class="paragraph">
<p>You can declare a <code>perthis</code> aspect by specifying a <code>perthis</code> clause in the <code>@Aspect</code>
annotation. Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
public class MyAspect {

	private int someState;

	@Before("com.xyz.myapp.CommonPointcuts.businessService()")
	public void recordServiceUsage() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
class MyAspect {

	private val someState: Int = 0

	@Before("com.xyz.myapp.CommonPointcuts.businessService()")
	fun recordServiceUsage() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the effect of the <code>perthis</code> clause is that one aspect instance
is created for each unique service object that performs a business service (each unique
object bound to <code>this</code> at join points matched by the pointcut expression). The aspect
instance is created the first time that a method is invoked on the service object. The
aspect goes out of scope when the service object goes out of scope. Before the aspect
instance is created, none of the advice within it runs. As soon as the aspect instance
has been created, the advice declared within it runs at matched join points, but only
when the service object is the one with which this aspect is associated. See the AspectJ
Programming Guide for more information on <code>per</code> clauses.</p>
</div>
<div class="paragraph">
<p>The <code>pertarget</code> instantiation model works in exactly the same way as <code>perthis</code>, but it
creates one aspect instance for each unique target object at matched join points.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj-example"><a class="anchor" href="#aop-ataspectj-example"></a>An AOP Example</h3>
<div class="paragraph">
<p>Now that you have seen how all the constituent parts work, we can put them together to do
something useful.</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we need to use around advice so that we can
call <code>proceed</code> multiple times. The following listing shows the basic aspect implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Aspect
public class ConcurrentOperationExecutor implements Ordered {

	private static final int DEFAULT_MAX_RETRIES = 2;

	private int maxRetries = DEFAULT_MAX_RETRIES;
	private int order = 1;

	public void setMaxRetries(int maxRetries) {
		this.maxRetries = maxRetries;
	}

	public int getOrder() {
		return this.order;
	}

	public void setOrder(int order) {
		this.order = order;
	}

	@Around("com.xyz.myapp.CommonPointcuts.businessService()")
	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		int numAttempts = 0;
		PessimisticLockingFailureException lockFailureException;
		do {
			numAttempts++;
			try {
				return pjp.proceed();
			}
			catch(PessimisticLockingFailureException ex) {
				lockFailureException = ex;
			}
		} while(numAttempts &lt;= this.maxRetries);
		throw lockFailureException;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Aspect
class ConcurrentOperationExecutor : Ordered {

	private val DEFAULT_MAX_RETRIES = 2
	private var maxRetries = DEFAULT_MAX_RETRIES
	private var order = 1

	fun setMaxRetries(maxRetries: Int) {
		this.maxRetries = maxRetries
	}

	override fun getOrder(): Int {
		return this.order
	}

	fun setOrder(order: Int) {
		this.order = order
	}

	@Around("com.xyz.myapp.CommonPointcuts.businessService()")
	fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
		var numAttempts = 0
		var lockFailureException: PessimisticLockingFailureException
		do {
			numAttempts++
			try {
				return pjp.proceed()
			} catch (ex: PessimisticLockingFailureException) {
				lockFailureException = ex
			}

		} while (numAttempts &lt;= this.maxRetries)
		throw lockFailureException
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties are both configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice. Notice that, for the
moment, we apply the retry logic to each <code>businessService()</code>. We try to proceed,
and if we fail with a <code>PessimisticLockingFailureException</code>, we try again, unless
we have exhausted all of our retry attempts.</p>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
	&lt;property name="maxRetries" value="3"/&gt;
	&lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To refine the aspect so that it retries only idempotent operations, we might define the following
<code>Idempotent</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
	// marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent// marker annotation</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then use the annotation to annotate the implementation of service operations. The change
to the aspect to retry only idempotent operations involves refining the pointcut
expression so that only <code>@Idempotent</code> operations match, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Around("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; " +
		"@annotation(com.xyz.myapp.service.Idempotent)")
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Around("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; " +
		"@annotation(com.xyz.myapp.service.Idempotent)")
fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
	// ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-schema"><a class="anchor" href="#aop-schema"></a>Schema-based AOP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you prefer an XML-based format, Spring also offers support for defining aspects
using the <code>aop</code> namespace tags. The exact same pointcut expressions and advice kinds
as when using the @AspectJ style are supported. Hence, in this section we focus on
that syntax and refer the reader to the discussion in the previous section
(<a href="#aop-ataspectj">@AspectJ support</a>) for an understanding of writing pointcut expressions and the binding
of advice parameters.</p>
</div>
<div class="paragraph">
<p>To use the aop namespace tags described in this section, you need to import the
<code>spring-aop</code> schema, as described in <a href="../core.html#xsd-schemas" class="page">XML Schema-based configuration</a>. See <a href="../core.html#xsd-schemas-aop" class="page">the AOP schema</a>
for how to import the tags in the <code>aop</code> namespace.</p>
</div>
<div class="paragraph">
<p>Within your Spring configurations, all aspect and advisor elements must be placed within
an <code>&lt;aop:config&gt;</code> element (you can have more than one <code>&lt;aop:config&gt;</code> element in an
application context configuration). An <code>&lt;aop:config&gt;</code> element can contain pointcut,
advisor, and aspect elements (note that these must be declared in that order).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The <code>&lt;aop:config&gt;</code> style of configuration makes heavy use of Spring&#8217;s
<a href="#aop-autoproxy">auto-proxying</a> mechanism. This can cause issues (such as advice
not being woven) if you already use explicit auto-proxying through the use of
<code>BeanNameAutoProxyCreator</code> or something similar. The recommended usage pattern is to
use either only the <code>&lt;aop:config&gt;</code> style or only the <code>AutoProxyCreator</code> style and
never mix them.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-schema-declaring-an-aspect"><a class="anchor" href="#aop-schema-declaring-an-aspect"></a>Declaring an Aspect</h3>
<div class="paragraph">
<p>When you use the schema support, an aspect is a regular Java object defined as a bean in
your Spring application context. The state and behavior are captured in the fields and
methods of the object, and the pointcut and advice information are captured in the XML.</p>
</div>
<div class="paragraph">
<p>You can declare an aspect by using the <code>&lt;aop:aspect&gt;</code> element, and reference the backing bean
by using the <code>ref</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;
	&lt;aop:aspect id="myAspect" ref="aBean"&gt;
		...
	&lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
	...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean that backs the aspect (<code>aBean</code> in this case) can of course be configured and
dependency injected just like any other Spring bean.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-pointcuts"><a class="anchor" href="#aop-schema-pointcuts"></a>Declaring a Pointcut</h3>
<div class="paragraph">
<p>You can declare a named pointcut inside an <code>&lt;aop:config&gt;</code> element, letting the pointcut
definition be shared across several aspects and advisors.</p>
</div>
<div class="paragraph">
<p>A pointcut that represents the execution of any business service in the service layer can
be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:pointcut id="businessService"
		expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the pointcut expression itself is using the same AspectJ pointcut expression
language as described in <a href="#aop-ataspectj">@AspectJ support</a>. If you use the schema based declaration
style, you can refer to named pointcuts defined in types (@Aspects) within the
pointcut expression. Another way of defining the above pointcut would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:pointcut id="businessService"
		expression="com.xyz.myapp.CommonPointcuts.businessService()"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that you have a <code>CommonPointcuts</code> aspect as described in <a href="#aop-common-pointcuts">Sharing Common Pointcut Definitions</a>.</p>
</div>
<div class="paragraph">
<p>Then declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:aspect id="myAspect" ref="aBean"&gt;

		&lt;aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

		...
	&lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In much the same way as an @AspectJ aspect, pointcuts declared by using the schema based
definition style can collect join point context. For example, the following pointcut
collects the <code>this</code> object as the join point context and passes it to the advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:aspect id="myAspect" ref="aBean"&gt;

		&lt;aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt;

		&lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

		...
	&lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice must be declared to receive the collected join point context by including
parameters of the matching names, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void monitor(Object service) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun monitor(service: Any) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When combining pointcut sub-expressions, <code>&amp;amp;&amp;amp;</code> is awkward within an XML
document, so you can use the <code>and</code>, <code>or</code>, and <code>not</code> keywords in place of <code>&amp;amp;&amp;amp;</code>,
<code>||</code>, and <code>!</code>, respectively. For example, the previous pointcut can be better written as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:aspect id="myAspect" ref="aBean"&gt;

		&lt;aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..)) and this(service)"/&gt;

		&lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

		...
	&lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that pointcuts defined in this way are referred to by their XML <code>id</code> and cannot be
used as named pointcuts to form composite pointcuts. The named pointcut support in the
schema-based definition style is thus more limited than that offered by the @AspectJ
style.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a>Declaring Advice</h3>
<div class="paragraph">
<p>The schema-based AOP support uses the same five kinds of advice as the @AspectJ style, and they have
exactly the same semantics.</p>
</div>
<div class="sect3">
<h4 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>Before Advice</h4>
<div class="paragraph">
<p>Before advice runs before a matched method execution. It is declared inside an
<code>&lt;aop:aspect&gt;</code> by using the <code>&lt;aop:before&gt;</code> element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

	&lt;aop:before
		pointcut-ref="dataAccessOperation"
		method="doAccessCheck"/&gt;

	...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>dataAccessOperation</code> is the <code>id</code> of a pointcut defined at the top (<code>&lt;aop:config&gt;</code>)
level. To define the pointcut inline instead, replace the <code>pointcut-ref</code> attribute with
a <code>pointcut</code> attribute, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

	&lt;aop:before
		pointcut="execution(* com.xyz.myapp.dao.*.*(..))"
		method="doAccessCheck"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we noted in the discussion of the @AspectJ style, using named pointcuts can
significantly improve the readability of your code.</p>
</div>
<div class="paragraph">
<p>The <code>method</code> attribute identifies a method (<code>doAccessCheck</code>) that provides the body of
the advice. This method must be defined for the bean referenced by the aspect element
that contains the advice. Before a data access operation is performed (a method execution
join point matched by the pointcut expression), the <code>doAccessCheck</code> method on the aspect
bean is invoked.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>After Returning Advice</h4>
<div class="paragraph">
<p>After returning advice runs when a matched method execution completes normally. It is
declared inside an <code>&lt;aop:aspect&gt;</code> in the same way as before advice. The following example
shows how to declare it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

	&lt;aop:after-returning
		pointcut-ref="dataAccessOperation"
		method="doAccessCheck"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in the @AspectJ style, you can get the return value within the advice body.
To do so, use the <code>returning</code> attribute to specify the name of the parameter to which
the return value should be passed, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

	&lt;aop:after-returning
		pointcut-ref="dataAccessOperation"
		returning="retVal"
		method="doAccessCheck"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doAccessCheck</code> method must declare a parameter named <code>retVal</code>. The type of this
parameter constrains matching in the same way as described for <code>@AfterReturning</code>. For
example, you can declare the method signature as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void doAccessCheck(Object retVal) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun doAccessCheck(retVal: Any) {...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>After Throwing Advice</h4>
<div class="paragraph">
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. It is declared inside an <code>&lt;aop:aspect&gt;</code> by using the <code>after-throwing</code> element,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

	&lt;aop:after-throwing
		pointcut-ref="dataAccessOperation"
		method="doRecoveryActions"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in the @AspectJ style, you can get the thrown exception within the advice body.
To do so, use the <code>throwing</code> attribute to specify the name of the parameter to
which the exception should be passed as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

	&lt;aop:after-throwing
		pointcut-ref="dataAccessOperation"
		throwing="dataAccessEx"
		method="doRecoveryActions"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doRecoveryActions</code> method must declare a parameter named <code>dataAccessEx</code>.
The type of this parameter constrains matching in the same way as described for
<code>@AfterThrowing</code>. For example, the method signature may be declared as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void doRecoveryActions(DataAccessException dataAccessEx) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun doRecoveryActions(dataAccessEx: DataAccessException) {...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>After (Finally) Advice</h4>
<div class="paragraph">
<p>After (finally) advice runs no matter how a matched method execution exits.
You can declare it by using the <code>after</code> element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt;

	&lt;aop:after
		pointcut-ref="dataAccessOperation"
		method="doReleaseLock"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>Around Advice</h4>
<div class="paragraph">
<p>The last kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method runs
and to determine when, how, and even if the method actually gets to run at all.
Around advice is often used to share state before and after a method execution in a
thread-safe manner (starting and stopping a timer, for example). Always use the least
powerful form of advice that meets your requirements. Do not use around advice if
before advice can do the job.</p>
</div>
<div class="paragraph">
<p>You can declare around advice by using the <code>aop:around</code> element. The first parameter of
the advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to run.
The <code>proceed</code> method may also be called with an <code>Object[]</code>. The values in the array
are used as the arguments to the method execution when it proceeds.
See <a href="#aop-ataspectj-around-advice">Around Advice</a> for notes on calling <code>proceed</code> with an <code>Object[]</code>.
The following example shows how to declare around advice in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="aroundExample" ref="aBean"&gt;

	&lt;aop:around
		pointcut-ref="businessService"
		method="doBasicProfiling"/&gt;

	...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the <code>doBasicProfiling</code> advice can be exactly the same as in the
@AspectJ example (minus the annotation, of course), as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
	// start stopwatch
	Object retVal = pjp.proceed();
	// stop stopwatch
	return retVal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
	// start stopwatch
	val retVal = pjp.proceed()
	// stop stopwatch
	return pjp.proceed()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>Advice Parameters</h4>
<div class="paragraph">
<p>The schema-based declaration style supports fully typed advice in the same way as
described for the @AspectJ support&#8201;&#8212;&#8201;by matching pointcut parameters by name against
advice method parameters. See <a href="#aop-ataspectj-advice-params">Advice Parameters</a> for details. If you wish
to explicitly specify argument names for the advice methods (not relying on the
detection strategies previously described), you can do so by using the <code>arg-names</code>
attribute of the advice element, which is treated in the same manner as the <code>argNames</code>
attribute in an advice annotation (as described in <a href="#aop-ataspectj-advice-params-names">Determining Argument Names</a>).
The following example shows how to specify an argument name in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:before
	pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
	method="audit"
	arg-names="auditable"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>arg-names</code> attribute accepts a comma-delimited list of parameter names.</p>
</div>
<div class="paragraph">
<p>The following slightly more involved example of the XSD-based approach shows
some around advice used in conjunction with a number of strongly typed parameters:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package x.y.service;

public interface PersonService {

	Person getPerson(String personName, int age);
}

public class DefaultPersonService implements PersonService {

	public Person getPerson(String name, int age) {
		return new Person(name, age);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package x.y.service

interface PersonService {

	fun getPerson(personName: String, age: Int): Person
}

class DefaultPersonService : PersonService {

	fun getPerson(name: String, age: Int): Person {
		return Person(name, age)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is the aspect. Notice the fact that the <code>profile(..)</code> method accepts a number of
strongly-typed parameters, the first of which happens to be the join point used to
proceed with the method call. The presence of this parameter is an indication that the
<code>profile(..)</code> is to be used as <code>around</code> advice, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler {

	public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
		StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
		try {
			clock.start(call.toShortString());
			return call.proceed();
		} finally {
			clock.stop();
			System.out.println(clock.prettyPrint());
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.aspectj.lang.ProceedingJoinPoint
import org.springframework.util.StopWatch

class SimpleProfiler {

	fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any {
		val clock = StopWatch("Profiling for '$name' and '$age'")
		try {
			clock.start(call.toShortString())
			return call.proceed()
		} finally {
			clock.stop()
			println(clock.prettyPrint())
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following example XML configuration effects the execution of the
preceding advice for a particular join point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

	&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;
	&lt;bean id="personService" class="x.y.service.DefaultPersonService"/&gt;

	&lt;!-- this is the actual advice itself --&gt;
	&lt;bean id="profiler" class="x.y.SimpleProfiler"/&gt;

	&lt;aop:config&gt;
		&lt;aop:aspect ref="profiler"&gt;

			&lt;aop:pointcut id="theExecutionOfSomePersonServiceMethod"
				expression="execution(* x.y.service.PersonService.getPerson(String,int))
				and args(name, age)"/&gt;

			&lt;aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
				method="profile"/&gt;

		&lt;/aop:aspect&gt;
	&lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider the following driver script:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.PersonService;

public final class Boot {

	public static void main(final String[] args) throws Exception {
		BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
		PersonService person = (PersonService) ctx.getBean("personService");
		person.getPerson("Pengo", 12);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main() {
	val ctx = ClassPathXmlApplicationContext("x/y/plain.xml")
	val person = ctx.getBean("personService") as PersonService
	person.getPerson("Pengo", 12)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a Boot class, we would get output similar to the following on standard output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>Advice Ordering</h4>
<div class="paragraph">
<p>When multiple pieces of advice need to run at the same join point (executing method)
the ordering rules are as described in <a href="#aop-ataspectj-advice-ordering">Advice Ordering</a>. The precedence
between aspects is determined via the <code>order</code> attribute in the <code>&lt;aop:aspect&gt;</code> element or
by either adding the <code>@Order</code> annotation to the bean that backs the aspect or by having
the bean implement the <code>Ordered</code> interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In contrast to the precedence rules for advice methods defined in the same <code>@Aspect</code>
class, when two pieces of advice defined in the same <code>&lt;aop:aspect&gt;</code> element both need to
run at the same join point, the precedence is determined by the order in which the advice
elements are declared within the enclosing <code>&lt;aop:aspect&gt;</code> element, from highest to lowest
precedence.</p>
</div>
<div class="paragraph">
<p>For example, given an <code>around</code> advice and a <code>before</code> advice defined in the same
<code>&lt;aop:aspect&gt;</code> element that apply to the same join point, to ensure that the <code>around</code>
advice has higher precedence than the <code>before</code> advice, the <code>&lt;aop:around&gt;</code> element must be
declared before the <code>&lt;aop:before&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>As a general rule of thumb, if you find that you have multiple pieces of advice defined
in the same <code>&lt;aop:aspect&gt;</code> element that apply to the same join point, consider collapsing
such advice methods into one advice method per join point in each <code>&lt;aop:aspect&gt;</code> element
or refactor the pieces of advice into separate <code>&lt;aop:aspect&gt;</code> elements that you can order
at the aspect level.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a>Introductions</h3>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) let an aspect declare
that advised objects implement a given interface and provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>You can make an introduction by using the <code>aop:declare-parents</code> element inside an <code>aop:aspect</code>.
You can use the <code>aop:declare-parents</code> element to declare that matching types have a new parent (hence the name).
For example, given an interface named <code>UsageTracked</code> and an implementation of that interface named
<code>DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code>UsageTracked</code> interface. (In order to expose statistics
through JMX for example.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt;

	&lt;aop:declare-parents
		types-matching="com.xzy.myapp.service.*+"
		implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
		default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt;

	&lt;aop:before
		pointcut="com.xyz.myapp.CommonPointcuts.businessService()
			and this(usageTracked)"
			method="recordUsage"/&gt;

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class that backs the <code>usageTracking</code> bean would then contain the following method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void recordUsage(UsageTracked usageTracked) {
	usageTracked.incrementUseCount();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun recordUsage(usageTracked: UsageTracked) {
	usageTracked.incrementUseCount()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by the <code>implement-interface</code> attribute. The
value of the <code>types-matching</code> attribute is an AspectJ type pattern. Any bean of a
matching type implements the <code>UsageTracked</code> interface. Note that, in the before
advice of the preceding example, service beans can be directly used as implementations of
the <code>UsageTracked</code> interface. To access a bean programmatically, you could write the
following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a>Aspect Instantiation Models</h3>
<div class="paragraph">
<p>The only supported instantiation model for schema-defined aspects is the singleton
model. Other instantiation models may be supported in future releases.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a>Advisors</h3>
<div class="paragraph">
<p>The concept of &#8220;advisors&#8221; comes from the AOP support defined in Spring
and does not have a direct equivalent in AspectJ. An advisor is like a small
self-contained aspect that has a single piece of advice. The advice itself is
represented by a bean and must implement one of the advice interfaces described in
<a href="#aop-api-advice-types">[aop-api-advice-types]</a>. Advisors can take advantage of AspectJ pointcut expressions.</p>
</div>
<div class="paragraph">
<p>Spring supports the advisor concept with the <code>&lt;aop:advisor&gt;</code> element. You most
commonly see it used in conjunction with transactional advice, which also has its own
namespace support in Spring. The following example shows an advisor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:pointcut id="businessService"
		expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

	&lt;aop:advisor
		pointcut-ref="businessService"
		advice-ref="tx-advice"/&gt;

&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
	&lt;tx:attributes&gt;
		&lt;tx:method name="*" propagation="REQUIRED"/&gt;
	&lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as the <code>pointcut-ref</code> attribute used in the preceding example, you can also use the
<code>pointcut</code> attribute to define a pointcut expression inline.</p>
</div>
<div class="paragraph">
<p>To define the precedence of an advisor so that the advice can participate in ordering,
use the <code>order</code> attribute to define the <code>Ordered</code> value of the advisor.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a>An AOP Schema Example</h3>
<div class="paragraph">
<p>This section shows how the concurrent locking failure retry example from
<a href="#aop-ataspectj-example">An AOP Example</a> looks when rewritten with the schema support.</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we need to use around advice so that we can
call <code>proceed</code> multiple times. The following listing shows the basic aspect implementation
(which is a regular Java class that uses the schema support):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ConcurrentOperationExecutor implements Ordered {

	private static final int DEFAULT_MAX_RETRIES = 2;

	private int maxRetries = DEFAULT_MAX_RETRIES;
	private int order = 1;

	public void setMaxRetries(int maxRetries) {
		this.maxRetries = maxRetries;
	}

	public int getOrder() {
		return this.order;
	}

	public void setOrder(int order) {
		this.order = order;
	}

	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		int numAttempts = 0;
		PessimisticLockingFailureException lockFailureException;
		do {
			numAttempts++;
			try {
				return pjp.proceed();
			}
			catch(PessimisticLockingFailureException ex) {
				lockFailureException = ex;
			}
		} while(numAttempts &lt;= this.maxRetries);
		throw lockFailureException;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class ConcurrentOperationExecutor : Ordered {

	private val DEFAULT_MAX_RETRIES = 2

	private var maxRetries = DEFAULT_MAX_RETRIES
	private var order = 1

	fun setMaxRetries(maxRetries: Int) {
		this.maxRetries = maxRetries
	}

	override fun getOrder(): Int {
		return this.order
	}

	fun setOrder(order: Int) {
		this.order = order
	}

	fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
		var numAttempts = 0
		var lockFailureException: PessimisticLockingFailureException
		do {
			numAttempts++
			try {
				return pjp.proceed()
			} catch (ex: PessimisticLockingFailureException) {
				lockFailureException = ex
			}

		} while (numAttempts &lt;= this.maxRetries)
		throw lockFailureException
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties are both configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice method. We try to
proceed. If we fail with a <code>PessimisticLockingFailureException</code>, we try again,
unless we have exhausted all of our retry attempts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This class is identical to the one used in the @AspectJ example, but with the
annotations removed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;

	&lt;aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor"&gt;

		&lt;aop:pointcut id="idempotentOperation"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

		&lt;aop:around
			pointcut-ref="idempotentOperation"
			method="doConcurrentOperation"/&gt;

	&lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id="concurrentOperationExecutor"
	class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
		&lt;property name="maxRetries" value="3"/&gt;
		&lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, for the time, being we assume that all business services are idempotent. If
this is not the case, we can refine the aspect so that it retries only genuinely
idempotent operations, by introducing an <code>Idempotent</code> annotation and using the annotation
to annotate the implementation of service operations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
	// marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent {
	// marker annotation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The
change to the aspect to retry only idempotent operations involves refining the
pointcut expression so that only <code>@Idempotent</code> operations match, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:pointcut id="idempotentOperation"
		expression="execution(* com.xyz.myapp.service.*.*(..)) and
		@annotation(com.xyz.myapp.service.Idempotent)"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a>Choosing which AOP Declaration Style to Use</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you have decided that an aspect is the best approach for implementing a given
requirement, how do you decide between using Spring AOP or AspectJ and between the
Aspect language (code) style, the @AspectJ annotation style, or the Spring XML style? These
decisions are influenced by a number of factors including application requirements,
development tools, and team familiarity with AOP.</p>
</div>
<div class="sect2">
<h3 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a>Spring AOP or Full AspectJ?</h3>
<div class="paragraph">
<p>Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as
there is no requirement to introduce the AspectJ compiler / weaver into your development
and build processes. If you only need to advise the execution of operations on Spring
beans, Spring AOP is the right choice. If you need to advise objects not managed by
the Spring container (such as domain objects, typically), you need to use
AspectJ. You also need to use AspectJ if you wish to advise join points other than
simple method executions (for example, field get or set join points and so on).</p>
</div>
<div class="paragraph">
<p>When you use AspectJ, you have the choice of the AspectJ language syntax (also known as
the &#8220;code style&#8221;) or the @AspectJ annotation style. Clearly, if you do not use Java
5+, the choice has been made for you: Use the code style. If aspects play a large
role in your design, and you are able to use the <a href="https://www.eclipse.org/ajdt/">AspectJ
Development Tools (AJDT)</a> plugin for Eclipse, the AspectJ language syntax is the
preferred option. It is cleaner and simpler because the language was purposefully
designed for writing aspects. If you do not use Eclipse or have only a few aspects
that do not play a major role in your application, you may want to consider using
the @AspectJ style, sticking with regular Java compilation in your IDE, and adding
an aspect weaving phase to your build script.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a>@AspectJ or XML for Spring AOP?</h3>
<div class="paragraph">
<p>If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style.
There are various tradeoffs to consider.</p>
</div>
<div class="paragraph">
<p>The XML style may be most familiar to existing Spring users, and it is backed by genuine
POJOs. When using AOP as a tool to configure enterprise services, XML can be a good
choice (a good test is whether you consider the pointcut expression to be a part of your
configuration that you might want to change independently). With the XML style, it is
arguably clearer from your configuration which aspects are present in the system.</p>
</div>
<div class="paragraph">
<p>The XML style has two disadvantages. First, it does not fully encapsulate the
implementation of the requirement it addresses in a single place. The DRY principle says
that there should be a single, unambiguous, authoritative representation of any piece of
knowledge within a system. When using the XML style, the knowledge of how a requirement
is implemented is split across the declaration of the backing bean class and the XML in
the configuration file. When you use the @AspectJ style, this information is encapsulated
in a single module: the aspect. Secondly, the XML style is slightly more limited in what
it can express than the @AspectJ style: Only the &#8220;singleton&#8221; aspect instantiation model
is supported, and it is not possible to combine named pointcuts declared in XML.
For example, in the @AspectJ style you can write something like the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Pointcut("execution(* get*())")
public void propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
public void operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
public void accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Pointcut("execution(* get*())")
fun propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
fun operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
fun accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the XML style you can declare the first two pointcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:pointcut id="propertyAccess"
		expression="execution(* get*())"/&gt;

&lt;aop:pointcut id="operationReturningAnAccount"
		expression="execution(org.xyz.Account+ *(..))"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The downside of the XML approach is that you cannot define the
<code>accountPropertyAccess</code> pointcut by combining these definitions.</p>
</div>
<div class="paragraph">
<p>The @AspectJ style supports additional instantiation models and richer pointcut
composition. It has the advantage of keeping the aspect as a modular unit. It also has
the advantage that the @AspectJ aspects can be understood (and thus consumed) both by
Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ
to implement additional requirements, you can easily migrate to a classic AspectJ setup.
On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple
configuration of enterprise services.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a>Mixing Aspect Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support,
schema-defined <code>&lt;aop:aspect&gt;</code> aspects, <code>&lt;aop:advisor&gt;</code> declared advisors, and even proxies
and interceptors in other styles in the same configuration. All of these are implemented
by using the same underlying support mechanism and can co-exist without any difficulty.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a>Proxying Mechanisms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given
target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common
open-source class definition library (repackaged into <code>spring-core</code>).</p>
</div>
<div class="paragraph">
<p>If the target object to be proxied implements at least one interface, a JDK dynamic
proxy is used. All of the interfaces implemented by the target type are proxied.
If the target object does not implement any interfaces, a CGLIB proxy is created.</p>
</div>
<div class="paragraph">
<p>If you want to force the use of CGLIB proxying (for example, to proxy every method
defined for the target object, not only those implemented by its interfaces),
you can do so. However, you should consider the following issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With CGLIB, <code>final</code> methods cannot be advised, as they cannot be overridden in
runtime-generated subclasses.</p>
</li>
<li>
<p>As of Spring 4.0, the constructor of your proxied object is NOT called twice anymore,
since the CGLIB proxy instance is created through Objenesis. Only if your JVM does
not allow for constructor bypassing, you might see double invocations and
corresponding debug log entries from Spring&#8217;s AOP support.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To force the use of CGLIB proxies, set the value of the <code>proxy-target-class</code> attribute
of the <code>&lt;aop:config&gt;</code> element to true, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config proxy-target-class="true"&gt;
	&lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the
<code>proxy-target-class</code> attribute of the <code>&lt;aop:aspectj-autoproxy&gt;</code> element to <code>true</code>,
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Multiple <code>&lt;aop:config/&gt;</code> sections are collapsed into a single unified auto-proxy creator
at runtime, which applies the <em>strongest</em> proxy settings that any of the
<code>&lt;aop:config/&gt;</code> sections (typically from different XML bean definition files) specified.
This also applies to the <code>&lt;tx:annotation-driven/&gt;</code> and <code>&lt;aop:aspectj-autoproxy/&gt;</code>
elements.</p>
</div>
<div class="paragraph">
<p>To be clear, using <code>proxy-target-class="true"</code> on <code>&lt;tx:annotation-driven/&gt;</code>,
<code>&lt;aop:aspectj-autoproxy/&gt;</code>, or <code>&lt;aop:config/&gt;</code> elements forces the use of CGLIB
proxies <em>for all three of them</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a>Understanding AOP Proxies</h3>
<div class="paragraph">
<p>Spring AOP is proxy-based. It is vitally important that you grasp the semantics of
what that last statement actually means before you write your own aspects or use any of
the Spring AOP-based aspects supplied with the Spring Framework.</p>
</div>
<div class="paragraph">
<p>Consider first the scenario where you have a plain-vanilla, un-proxied,
nothing-special-about-it, straight object reference, as the following
code snippet shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimplePojo implements Pojo {

	public void foo() {
		// this next method invocation is a direct call on the 'this' reference
		this.bar();
	}

	public void bar() {
		// some logic...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimplePojo : Pojo {

	fun foo() {
		// this next method invocation is a direct call on the 'this' reference
		this.bar()
	}

	fun bar() {
		// some logic...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you invoke a method on an object reference, the method is invoked directly on
that object reference, as the following image and listing show:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/images/aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Main {

	public static void main(String[] args) {
		Pojo pojo = new SimplePojo();
		// this is a direct method call on the 'pojo' reference
		pojo.foo();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main() {
	val pojo = SimplePojo()
	// this is a direct method call on the 'pojo' reference
	pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Things change slightly when the reference that client code has is a proxy. Consider the
following diagram and code snippet:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/images/aop-proxy-call.png" alt="aop proxy call">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Main {

	public static void main(String[] args) {
		ProxyFactory factory = new ProxyFactory(new SimplePojo());
		factory.addInterface(Pojo.class);
		factory.addAdvice(new RetryAdvice());

		Pojo pojo = (Pojo) factory.getProxy();
		// this is a method call on the proxy!
		pojo.foo();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main() {
	val factory = ProxyFactory(SimplePojo())
	factory.addInterface(Pojo::class.java)
	factory.addAdvice(RetryAdvice())

	val pojo = factory.proxy as Pojo
	// this is a method call on the proxy!
	pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key thing to understand here is that the client code inside the <code>main(..)</code> method
of the <code>Main</code> class has a reference to the proxy. This means that method calls on that
object reference are calls on the proxy. As a result, the proxy can delegate to all of
the interceptors (advice) that are relevant to that particular method call. However,
once the call has finally reached the target object (the <code>SimplePojo</code> reference in
this case), any method calls that it may make on itself, such as <code>this.bar()</code> or
<code>this.foo()</code>, are going to be invoked against the <code>this</code> reference, and not the proxy.
This has important implications. It means that self-invocation is not going to result
in the advice associated with a method invocation getting a chance to run.</p>
</div>
<div class="paragraph">
<p>Okay, so what is to be done about this? The best approach (the term "best" is used
loosely here) is to refactor your code such that the self-invocation does not happen.
This does entail some work on your part, but it is the best, least-invasive approach.
The next approach is absolutely horrendous, and we hesitate to point it out, precisely
because it is so horrendous. You can (painful as it is to us) totally tie the logic
within your class to Spring AOP, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimplePojo implements Pojo {

	public void foo() {
		// this works, but... gah!
		((Pojo) AopContext.currentProxy()).bar();
	}

	public void bar() {
		// some logic...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SimplePojo : Pojo {

	fun foo() {
		// this works, but... gah!
		(AopContext.currentProxy() as Pojo).bar()
	}

	fun bar() {
		// some logic...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This totally couples your code to Spring AOP, and it makes the class itself aware of
the fact that it is being used in an AOP context, which flies in the face of AOP. It
also requires some additional configuration when the proxy is being created, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Main {

	public static void main(String[] args) {
		ProxyFactory factory = new ProxyFactory(new SimplePojo());
		factory.addInterface(Pojo.class);
		factory.addAdvice(new RetryAdvice());
		factory.setExposeProxy(true);

		Pojo pojo = (Pojo) factory.getProxy();
		// this is a method call on the proxy!
		pojo.foo();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main() {
	val factory = ProxyFactory(SimplePojo())
	factory.addInterface(Pojo::class.java)
	factory.addAdvice(RetryAdvice())
	factory.isExposeProxy = true

	val pojo = factory.proxy as Pojo
	// this is a method call on the proxy!
	pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it must be noted that AspectJ does not have this self-invocation issue because
it is not a proxy-based AOP framework.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a>Programmatic Creation of @AspectJ Proxies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to declaring aspects in your configuration by using either <code>&lt;aop:config&gt;</code>
or <code>&lt;aop:aspectj-autoproxy&gt;</code>, it is also possible to programmatically create proxies
that advise target objects. For the full details of Spring&#8217;s AOP API, see the
<a href="#aop-api">next chapter</a>. Here, we want to focus on the ability to automatically
create proxies by using @AspectJ aspects.</p>
</div>
<div class="paragraph">
<p>You can use the <code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> class
to create a proxy for a target object that is advised by one or more @AspectJ aspects.
The basic usage for this class is very simple, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create a factory that can generate a proxy for the given target object
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager.class);

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker);

// now get the proxy object...
MyInterfaceType proxy = factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// create a factory that can generate a proxy for the given target object
val factory = AspectJProxyFactory(targetObject)

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager::class.java)

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker)

// now get the proxy object...
val proxy = factory.getProxy&lt;Any&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the {api-spring-framework}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc] for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a>Using AspectJ with Spring Applications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Everything we have covered so far in this chapter is pure Spring AOP. In this section,
we look at how you can use the AspectJ compiler or weaver instead of or in
addition to Spring AOP if your needs go beyond the facilities offered by Spring AOP
alone.</p>
</div>
<div class="paragraph">
<p>Spring ships with a small AspectJ aspect library, which is available stand-alone in your
distribution as <code>spring-aspects.jar</code>. You need to add this to your classpath in order
to use the aspects in it. <a href="#aop-atconfigurable">Using AspectJ to Dependency Inject Domain Objects with Spring</a> and <a href="#aop-ajlib-other">Other Spring aspects for AspectJ</a> discuss the
content of this library and how you can use it. <a href="#aop-aj-configure">Configuring AspectJ Aspects by Using Spring IoC</a> discusses how to
dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,
<a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a> provides an introduction to load-time weaving for Spring applications
that use AspectJ.</p>
</div>
<div class="sect2">
<h3 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a>Using AspectJ to Dependency Inject Domain Objects with Spring</h3>
<div class="paragraph">
<p>The Spring container instantiates and configures beans defined in your application
context. It is also possible to ask a bean factory to configure a pre-existing
object, given the name of a bean definition that contains the configuration to be applied.
<code>spring-aspects.jar</code> contains an annotation-driven aspect that exploits this
capability to allow dependency injection of any object. The support is intended to
be used for objects created outside of the control of any container. Domain objects
often fall into this category because they are often created programmatically with the
<code>new</code> operator or by an ORM tool as a result of a database query.</p>
</div>
<div class="paragraph">
<p>The <code>@Configurable</code> annotation marks a class as being eligible for Spring-driven
configuration. In the simplest case, you can use purely it as a marker annotation, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable
class Account {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used as a marker interface in this way, Spring configures new instances of the
annotated type (<code>Account</code>, in this case) by using a bean definition (typically
prototype-scoped) with the same name as the fully-qualified type name
(<code>com.xyz.myapp.domain.Account</code>). Since the default name for a bean is the
fully-qualified name of its type, a convenient way to declare the prototype definition
is to omit the <code>id</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="com.xyz.myapp.domain.Account" scope="prototype"&gt;
	&lt;property name="fundsTransferService" ref="fundsTransferService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to explicitly specify the name of the prototype bean definition to use, you
can do so directly in the annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable("account")
public class Account {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable("account")
class Account {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring now looks for a bean definition named <code>account</code> and uses that as the
definition to configure new <code>Account</code> instances.</p>
</div>
<div class="paragraph">
<p>You can also use autowiring to avoid having to specify a dedicated bean definition at
all. To have Spring apply autowiring, use the <code>autowire</code> property of the <code>@Configurable</code>
annotation. You can specify either <code>@Configurable(autowire=Autowire.BY_TYPE)</code> or
<code>@Configurable(autowire=Autowire.BY_NAME)</code> for autowiring by type or by name,
respectively. As an alternative, it is preferable to specify explicit, annotation-driven
dependency injection for your <code>@Configurable</code> beans through <code>@Autowired</code> or <code>@Inject</code>
at the field or method level (see <a href="#beans-annotation-config">[beans-annotation-config]</a> for further details).</p>
</div>
<div class="paragraph">
<p>Finally, you can enable Spring dependency checking for the object references in the newly
created and configured object by using the <code>dependencyCheck</code> attribute (for example,
<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>). If this attribute is
set to <code>true</code>, Spring validates after configuration that all properties (which
are not primitives or collections) have been set.</p>
</div>
<div class="paragraph">
<p>Note that using the annotation on its own does nothing. It is the
<code>AnnotationBeanConfigurerAspect</code> in <code>spring-aspects.jar</code> that acts on the presence of
the annotation. In essence, the aspect says, &#8220;after returning from the initialization of
a new object of a type annotated with <code>@Configurable</code>, configure the newly created object
using Spring in accordance with the properties of the annotation&#8221;. In this context,
&#8220;initialization&#8221; refers to newly instantiated objects (for example, objects instantiated
with the <code>new</code> operator) as well as to <code>Serializable</code> objects that are undergoing
deserialization (for example, through
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">readResolve()</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the key phrases in the above paragraph is &#8220;in essence&#8221;. For most cases, the
exact semantics of &#8220;after returning from the initialization of a new object&#8221; are
fine. In this context, &#8220;after initialization&#8221; means that the dependencies are
injected after the object has been constructed. This means that the dependencies
are not available for use in the constructor bodies of the class. If you want the
dependencies to be injected before the constructor bodies run and thus be
available for use in the body of the constructors, you need to define this on the
<code>@Configurable</code> declaration, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find more information about the language semantics of the various pointcut
types in AspectJ
<a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">in this
appendix</a> of the <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ
Programming Guide</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this to work, the annotated types must be woven with the AspectJ weaver. You can
either use a build-time Ant or Maven task to do this (see, for example, the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ Development
Environment Guide</a>) or load-time weaving (see <a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a>). The
<code>AnnotationBeanConfigurerAspect</code> itself needs to be configured by Spring (in order to obtain
a reference to the bean factory that is to be used to configure new objects). If you
use Java-based configuration, you can add <code>@EnableSpringConfigured</code> to any
<code>@Configuration</code> class, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableSpringConfigured
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableSpringConfigured
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML based configuration, the Spring
<a href="../core.html#xsd-schemas-context" class="page"><code>context</code> namespace</a>
defines a convenient <code>context:spring-configured</code> element, which you can use as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;context:spring-configured/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <code>@Configurable</code> objects created before the aspect has been configured
result in a message being issued to the debug log and no configuration of the
object taking place. An example might be a bean in the Spring configuration that creates
domain objects when it is initialized by Spring. In this case, you can use the
<code>depends-on</code> bean attribute to manually specify that the bean depends on the
configuration aspect. The following example shows how to use the <code>depends-on</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myService"
		class="com.xzy.myapp.service.MyService"
		depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"&gt;

	&lt;!-- ... --&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not activate <code>@Configurable</code> processing through the bean configurer aspect unless you
really mean to rely on its semantics at runtime. In particular, make sure that you do
not use <code>@Configurable</code> on bean classes that are registered as regular Spring beans
with the container. Doing so results in double initialization, once through the
container and once through the aspect.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a>Unit Testing <code>@Configurable</code> Objects</h4>
<div class="paragraph">
<p>One of the goals of the <code>@Configurable</code> support is to enable independent unit testing
of domain objects without the difficulties associated with hard-coded lookups.
If <code>@Configurable</code> types have not been woven by AspectJ, the annotation has no affect
during unit testing. You can set mock or stub property references in the object under
test and proceed as normal. If <code>@Configurable</code> types have been woven by AspectJ,
you can still unit test outside of the container as normal, but you see a warning
message each time that you construct a <code>@Configurable</code> object indicating that it has
not been configured by Spring.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>Working with Multiple Application Contexts</h4>
<div class="paragraph">
<p>The <code>AnnotationBeanConfigurerAspect</code> that is used to implement the <code>@Configurable</code> support
is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope
of <code>static</code> members: There is one aspect instance per classloader that defines the type.
This means that, if you define multiple application contexts within the same classloader
hierarchy, you need to consider where to define the <code>@EnableSpringConfigured</code> bean and
where to place <code>spring-aspects.jar</code> on the classpath.</p>
</div>
<div class="paragraph">
<p>Consider a typical Spring web application configuration that has a shared parent application
context that defines common business services, everything needed to support those services,
and one child application context for each servlet (which contains definitions particular
to that servlet). All of these contexts co-exist within the same classloader hierarchy,
and so the <code>AnnotationBeanConfigurerAspect</code> can hold a reference to only one of them.
In this case, we recommend defining the <code>@EnableSpringConfigured</code> bean in the shared
(parent) application context. This defines the services that you are likely to want to
inject into domain objects. A consequence is that you cannot configure domain objects
with references to beans defined in the child (servlet-specific) contexts by using the
@Configurable mechanism (which is probably not something you want to do anyway).</p>
</div>
<div class="paragraph">
<p>When deploying multiple web applications within the same container, ensure that each
web application loads the types in <code>spring-aspects.jar</code> by using its own classloader
(for example, by placing <code>spring-aspects.jar</code> in <code>'WEB-INF/lib'</code>). If <code>spring-aspects.jar</code>
is added only to the container-wide classpath (and hence loaded by the shared parent
classloader), all web applications share the same aspect instance (which is probably
not what you want).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a>Other Spring aspects for AspectJ</h3>
<div class="paragraph">
<p>In addition to the <code>@Configurable</code> aspect, <code>spring-aspects.jar</code> contains an AspectJ
aspect that you can use to drive Spring&#8217;s transaction management for types and methods
annotated with the <code>@Transactional</code> annotation. This is primarily intended for users who
want to use the Spring Framework&#8217;s transaction support outside of the Spring container.</p>
</div>
<div class="paragraph">
<p>The aspect that interprets <code>@Transactional</code> annotations is the
<code>AnnotationTransactionAspect</code>. When you use this aspect, you must annotate the
implementation class (or methods within that class or both), not the interface (if
any) that the class implements. AspectJ follows Java&#8217;s rule that annotations on
interfaces are not inherited.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a class specifies the default transaction semantics for
the execution of any public operation in the class.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). Methods of any
visibility may be annotated, including private methods. Annotating non-public methods
directly is the only way to get transaction demarcation for the execution of such methods.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since Spring Framework 4.2, <code>spring-aspects</code> provides a similar aspect that offers the
exact same features for the standard <code>javax.transaction.Transactional</code> annotation. Check
<code>JtaAnnotationTransactionAspect</code> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For AspectJ programmers who want to use the Spring configuration and transaction
management support but do not want to (or cannot) use annotations, <code>spring-aspects.jar</code>
also contains <code>abstract</code> aspects you can extend to provide your own pointcut
definitions. See the sources for the <code>AbstractBeanConfigurerAspect</code> and
<code>AbstractTransactionAspect</code> aspects for more information. As an example, the following
excerpt shows how you could write an aspect to configure all instances of objects
defined in the domain model by using prototype bean definitions that match the
fully qualified class names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

	public DomainObjectConfiguration() {
		setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
	}

	// the creation of a new bean (any object in the domain model)
	protected pointcut beanCreation(Object beanInstance) :
		initialization(new(..)) &amp;&amp;
		CommonPointcuts.inDomainModel() &amp;&amp;
		this(beanInstance);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a>Configuring AspectJ Aspects by Using Spring IoC</h3>
<div class="paragraph">
<p>When you use AspectJ aspects with Spring applications, it is natural to both want and
expect to be able to configure such aspects with Spring. The AspectJ runtime itself is
responsible for aspect creation, and the means of configuring the AspectJ-created
aspects through Spring depends on the AspectJ instantiation model (the <code>per-xxx</code> clause)
used by the aspect.</p>
</div>
<div class="paragraph">
<p>The majority of AspectJ aspects are singleton aspects. Configuration of these
aspects is easy. You can create a bean definition that references the aspect type as
normal and include the <code>factory-method="aspectOf"</code> bean attribute. This ensures that
Spring obtains the aspect instance by asking AspectJ for it rather than trying to create
an instance itself. The following example shows how to use the <code>factory-method="aspectOf"</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="profiler" class="com.xyz.profiler.Profiler"
		factory-method="aspectOf"&gt; <i class="conum" data-value="1"></i><b>(1)</b>

	&lt;property name="profilingStrategy" ref="jamonProfilingStrategy"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the <code>factory-method="aspectOf"</code> attribute</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Non-singleton aspects are harder to configure. However, it is possible to do so by
creating prototype bean definitions and using the <code>@Configurable</code> support from
<code>spring-aspects.jar</code> to configure the aspect instances once they have bean created by
the AspectJ runtime.</p>
</div>
<div class="paragraph">
<p>If you have some @AspectJ aspects that you want to weave with AspectJ (for example,
using load-time weaving for domain model types) and other @AspectJ aspects that you want
to use with Spring AOP, and these aspects are all configured in Spring, you
need to tell the Spring AOP @AspectJ auto-proxying support which exact subset of the
@AspectJ aspects defined in the configuration should be used for auto-proxying. You can
do this by using one or more <code>&lt;include/&gt;</code> elements inside the <code>&lt;aop:aspectj-autoproxy/&gt;</code>
declaration. Each <code>&lt;include/&gt;</code> element specifies a name pattern, and only beans with
names matched by at least one of the patterns are used for Spring AOP auto-proxy
configuration. The following example shows how to use <code>&lt;include/&gt;</code> elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:aspectj-autoproxy&gt;
	&lt;aop:include name="thisBean"/&gt;
	&lt;aop:include name="thatBean"/&gt;
&lt;/aop:aspectj-autoproxy&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not be misled by the name of the <code>&lt;aop:aspectj-autoproxy/&gt;</code> element. Using it
results in the creation of Spring AOP proxies. The @AspectJ style of aspect
declaration is being used here, but the AspectJ runtime is not involved.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a>Load-time Weaving with AspectJ in the Spring Framework</h3>
<div class="paragraph">
<p>Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an
application&#8217;s class files as they are being loaded into the Java virtual machine (JVM).
The focus of this section is on configuring and using LTW in the specific context of the
Spring Framework. This section is not a general introduction to LTW. For full details on
the specifics of LTW and configuring LTW with only AspectJ (with Spring not being
involved at all), see the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW section of the AspectJ
Development Environment Guide</a>.</p>
</div>
<div class="paragraph">
<p>The value that the Spring Framework brings to AspectJ LTW is in enabling much
finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected by using
a Java (5+) agent, which is switched on by specifying a VM argument when starting up a
JVM. It is, thus, a JVM-wide setting, which may be fine in some situations but is often a
little too coarse. Spring-enabled LTW lets you switch on LTW on a
per-<code>ClassLoader</code> basis, which is more fine-grained and which can make more
sense in a 'single-JVM-multiple-application' environment (such as is found in a typical
application server environment).</p>
</div>
<div class="paragraph">
<p>Further, <a href="#aop-aj-ltw-environments">in certain environments</a>, this support enables
load-time weaving without making any modifications to the application server&#8217;s launch
script that is needed to add <code>-javaagent:path/to/aspectjweaver.jar</code> or (as we describe
later in this section) <code>-javaagent:path/to/spring-instrument.jar</code>. Developers configure
the application context to enable load-time weaving instead of relying on administrators
who typically are in charge of the deployment configuration, such as the launch script.</p>
</div>
<div class="paragraph">
<p>Now that the sales pitch is over, let us first walk through a quick example of AspectJ
LTW that uses Spring, followed by detailed specifics about elements introduced in the
example. For a complete example, see the
<a href="https://github.com/spring-projects/spring-petclinic">Petclinic sample application</a>.</p>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>A First Example</h4>
<div class="paragraph">
<p>Assume that you are an application developer who has been tasked with diagnosing
the cause of some performance problems in a system. Rather than break out a
profiling tool, we are going to switch on a simple profiling aspect that lets us
quickly get some performance metrics. We can then apply a finer-grained profiling
tool to that specific area immediately afterwards.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The example presented here uses XML configuration. You can also configure and
use @AspectJ with <a href="#beans-java">Java configuration</a>. Specifically, you can use the
<code>@EnableLoadTimeWeaving</code> annotation as an alternative to <code>&lt;context:load-time-weaver/&gt;</code>
(see <a href="#aop-aj-ltw-spring">below</a> for details).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the profiling aspect, which is not fancy.
It is a time-based profiler that uses the @AspectJ-style of aspect declaration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect {

	@Around("methodsToBeProfiled()")
	public Object profile(ProceedingJoinPoint pjp) throws Throwable {
		StopWatch sw = new StopWatch(getClass().getSimpleName());
		try {
			sw.start(pjp.getSignature().getName());
			return pjp.proceed();
		} finally {
			sw.stop();
			System.out.println(sw.prettyPrint());
		}
	}

	@Pointcut("execution(public * foo..*.*(..))")
	public void methodsToBeProfiled(){}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package foo

import org.aspectj.lang.ProceedingJoinPoint
import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.annotation.Pointcut
import org.springframework.util.StopWatch
import org.springframework.core.annotation.Order

@Aspect
class ProfilingAspect {

	@Around("methodsToBeProfiled()")
	fun profile(pjp: ProceedingJoinPoint): Any {
		val sw = StopWatch(javaClass.simpleName)
		try {
			sw.start(pjp.getSignature().getName())
			return pjp.proceed()
		} finally {
			sw.stop()
			println(sw.prettyPrint())
		}
	}

	@Pointcut("execution(public * foo..*.*(..))")
	fun methodsToBeProfiled() {
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to create an <code>META-INF/aop.xml</code> file, to inform the AspectJ weaver that
we want to weave our <code>ProfilingAspect</code> into our classes. This file convention, namely
the presence of a file (or files) on the Java classpath called <code>META-INF/aop.xml</code> is
standard AspectJ. The following example shows the <code>aop.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;
&lt;aspectj&gt;

	&lt;weaver&gt;
		&lt;!-- only weave classes in our application-specific packages --&gt;
		&lt;include within="foo.*"/&gt;
	&lt;/weaver&gt;

	&lt;aspects&gt;
		&lt;!-- weave in just this aspect --&gt;
		&lt;aspect name="foo.ProfilingAspect"/&gt;
	&lt;/aspects&gt;

&lt;/aspectj&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can move on to the Spring-specific portion of the configuration. We need
to configure a <code>LoadTimeWeaver</code> (explained later). This load-time weaver is the
essential component responsible for weaving the aspect configuration in one or
more <code>META-INF/aop.xml</code> files into the classes in your application. The good
thing is that it does not require a lot of configuration (there are some more
options that you can specify, but these are detailed later), as can be seen in
the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;!-- a service object; we will be profiling its methods --&gt;
	&lt;bean id="entitlementCalculationService"
			class="foo.StubEntitlementCalculationService"/&gt;

	&lt;!-- this switches on the load-time weaving --&gt;
	&lt;context:load-time-weaver/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that all the required artifacts (the aspect, the <code>META-INF/aop.xml</code>
file, and the Spring configuration) are in place, we can create the following
driver class with a <code>main(..)</code> method to demonstrate the LTW in action:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

		EntitlementCalculationService entitlementCalculationService =
				(EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

		// the profiling aspect is 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main() {
	val ctx = ClassPathXmlApplicationContext("beans.xml")

	val entitlementCalculationService = ctx.getBean("entitlementCalculationService") as EntitlementCalculationService

	// the profiling aspect is 'woven' around this method execution
	entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have one last thing to do. The introduction to this section did say that one could
switch on LTW selectively on a per-<code>ClassLoader</code> basis with Spring, and this is true.
However, for this example, we use a Java agent (supplied with Spring) to switch on LTW.
We use the following command to run the <code>Main</code> class shown earlier:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-javaagent</code> is a flag for specifying and enabling
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">agents
to instrument programs that run on the JVM</a>. The Spring Framework ships with such an
agent, the <code>InstrumentationSavingAgent</code>, which is packaged in the
<code>spring-instrument.jar</code> that was supplied as the value of the <code>-javaagent</code> argument in
the preceding example.</p>
</div>
<div class="paragraph">
<p>The output from the execution of the <code>Main</code> program looks something like the next example.
(I have introduced a <code>Thread.sleep(..)</code> statement into the <code>calculateEntitlement()</code>
implementation so that the profiler actually captures something other than 0
milliseconds (the <code>01234</code> milliseconds is not an overhead introduced by the AOP).
The following listing shows the output we got when we ran our profiler:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
</div>
</div>
<div class="paragraph">
<p>Since this LTW is effected by using full-blown AspectJ, we are not limited only to advising
Spring beans. The following slight variation on the <code>Main</code> program yields the same
result:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

	public static void main(String[] args) {
		new ClassPathXmlApplicationContext("beans.xml", Main.class);

		EntitlementCalculationService entitlementCalculationService =
				new StubEntitlementCalculationService();

		// the profiling aspect will be 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main(args: Array&lt;String&gt;) {
	ClassPathXmlApplicationContext("beans.xml")

	val entitlementCalculationService = StubEntitlementCalculationService()

	// the profiling aspect will be 'woven' around this method execution
	entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how, in the preceding program, we bootstrap the Spring container and
then create a new instance of the <code>StubEntitlementCalculationService</code> totally outside
the context of Spring. The profiling advice still gets woven in.</p>
</div>
<div class="paragraph">
<p>Admittedly, the example is simplistic. However, the basics of the LTW support in Spring
have all been introduced in the earlier example, and the rest of this section explains
the &#8220;why&#8221; behind each bit of configuration and usage in detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ProfilingAspect</code> used in this example may be basic, but it is quite useful. It is a
nice example of a development-time aspect that developers can use during development
and then easily exclude from builds of the application being deployed
into UAT or production.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>Aspects</h4>
<div class="paragraph">
<p>The aspects that you use in LTW have to be AspectJ aspects. You can write them in
either the AspectJ language itself, or you can write your aspects in the @AspectJ-style.
Your aspects are then both valid AspectJ and Spring AOP aspects.
Furthermore, the compiled aspect classes need to be available on the classpath.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a>'META-INF/aop.xml'</h4>
<div class="paragraph">
<p>The AspectJ LTW infrastructure is configured by using one or more <code>META-INF/aop.xml</code>
files that are on the Java classpath (either directly or, more typically, in jar files).</p>
</div>
<div class="paragraph">
<p>The structure and contents of this file is detailed in the LTW part of the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ reference
documentation</a>. Because the <code>aop.xml</code> file is 100% AspectJ, we do not describe it further here.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>Required libraries (JARS)</h4>
<div class="paragraph">
<p>At minimum, you need the following libraries to use the Spring Framework&#8217;s support
for AspectJ LTW:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code></p>
</li>
<li>
<p><code>aspectjweaver.jar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use the <a href="#aop-aj-ltw-environments-generic">Spring-provided agent to enable
instrumentation</a>, you also need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>Spring Configuration</h4>
<div class="paragraph">
<p>The key component in Spring&#8217;s LTW support is the <code>LoadTimeWeaver</code> interface (in the
<code>org.springframework.instrument.classloading</code> package), and the numerous implementations
of it that ship with the Spring distribution. A <code>LoadTimeWeaver</code> is responsible for
adding one or more <code>java.lang.instrument.ClassFileTransformers</code> to a <code>ClassLoader</code> at
runtime, which opens the door to all manner of interesting applications, one of which
happens to be the LTW of aspects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are unfamiliar with the idea of runtime class file transformation, see the
javadoc API documentation for the <code>java.lang.instrument</code> package before continuing.
While that documentation is not comprehensive, at least you can see the key interfaces
and classes (for reference as you read through this section).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuring a <code>LoadTimeWeaver</code> for a particular <code>ApplicationContext</code> can be as easy as
adding one line. (Note that you almost certainly need to use an
<code>ApplicationContext</code> as your Spring container&#8201;&#8212;&#8201;typically, a <code>BeanFactory</code> is not
enough because the LTW support uses <code>BeanFactoryPostProcessors</code>.)</p>
</div>
<div class="paragraph">
<p>To enable the Spring Framework&#8217;s LTW support, you need to configure a <code>LoadTimeWeaver</code>,
which typically is done by using the <code>@EnableLoadTimeWeaving</code> annotation, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableLoadTimeWeaving
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you prefer XML-based configuration, use the
<code>&lt;context:load-time-weaver/&gt;</code> element. Note that the element is defined in the
<code>context</code> namespace. The following example shows how to use <code>&lt;context:load-time-weaver/&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration automatically defines and registers a number of LTW-specific
infrastructure beans, such as a <code>LoadTimeWeaver</code> and an <code>AspectJWeavingEnabler</code>, for you.
The default <code>LoadTimeWeaver</code> is the <code>DefaultContextLoadTimeWeaver</code> class, which attempts
to decorate an automatically detected <code>LoadTimeWeaver</code>. The exact type of <code>LoadTimeWeaver</code>
that is &#8220;automatically detected&#8221; is dependent upon your runtime environment.
The following table summarizes various <code>LoadTimeWeaver</code> implementations:</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Runtime Environment</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code> implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://tomcat.apache.org/">Apache Tomcat</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://eclipse-ee4j.github.io/glassfish/">GlassFish</a> (limited to EAR deployments)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Red Hat&#8217;s <a href="https://www.jboss.org/jbossas/">JBoss AS</a> or <a href="https://www.wildfly.org/">WildFly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in IBM&#8217;s <a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s
  <a href="https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM started with Spring <code>InstrumentationSavingAgent</code>
  (<code>java -javaagent:path/to/spring-instrument.jar</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fallback, expecting the underlying ClassLoader to follow common conventions
  (namely <code>addTransformer</code> and optionally a <code>getThrowawayClassLoader</code> method)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that the table lists only the <code>LoadTimeWeavers</code> that are autodetected when you
use the <code>DefaultContextLoadTimeWeaver</code>. You can specify exactly which <code>LoadTimeWeaver</code>
implementation to use.</p>
</div>
<div class="paragraph">
<p>To specify a specific <code>LoadTimeWeaver</code> with Java configuration, implement the
<code>LoadTimeWeavingConfigurer</code> interface and override the <code>getLoadTimeWeaver()</code> method.
The following example specifies a <code>ReflectiveLoadTimeWeaver</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig implements LoadTimeWeavingConfigurer {

	@Override
	public LoadTimeWeaver getLoadTimeWeaver() {
		return new ReflectiveLoadTimeWeaver();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableLoadTimeWeaving
class AppConfig : LoadTimeWeavingConfigurer {

	override fun getLoadTimeWeaver(): LoadTimeWeaver {
		return ReflectiveLoadTimeWeaver()
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use XML-based configuration, you can specify the fully qualified classname
as the value of the <code>weaver-class</code> attribute on the <code>&lt;context:load-time-weaver/&gt;</code>
element. Again, the following example specifies a <code>ReflectiveLoadTimeWeaver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:load-time-weaver
			weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> that is defined and registered by the configuration can be later
retrieved from the Spring container by using the well known name, <code>loadTimeWeaver</code>.
Remember that the <code>LoadTimeWeaver</code> exists only as a mechanism for Spring&#8217;s LTW
infrastructure to add one or more <code>ClassFileTransformers</code>. The actual
<code>ClassFileTransformer</code> that does the LTW is the <code>ClassPreProcessorAgentAdapter</code> (from
the <code>org.aspectj.weaver.loadtime</code> package) class. See the class-level javadoc of the
<code>ClassPreProcessorAgentAdapter</code> class for further details, because the specifics of how
the weaving is actually effected is beyond the scope of this document.</p>
</div>
<div class="paragraph">
<p>There is one final attribute of the configuration left to discuss: the <code>aspectjWeaving</code>
attribute (or <code>aspectj-weaving</code> if you use XML). This attribute controls whether LTW
is enabled or not. It accepts one of three possible values, with the default value being
<code>autodetect</code> if the attribute is not present. The following table summarizes the three
possible values:</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. AspectJ weaving attribute values</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation Value</th>
<th class="tableblock halign-left valign-top">XML Value</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ weaving is on, and aspects are woven at load-time as appropriate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW is off. No aspect is woven at load-time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AUTODETECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autodetect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the Spring LTW infrastructure can find at least one <code>META-INF/aop.xml</code> file,
  then AspectJ weaving is on. Otherwise, it is off. This is the default value.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>Environment-specific Configuration</h4>
<div class="paragraph">
<p>This last section contains any additional settings and configuration that you need
when you use Spring&#8217;s LTW support in environments such as application servers and web
containers.</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments-tomcat-jboss-etc"><a class="anchor" href="#aop-aj-ltw-environments-tomcat-jboss-etc"></a>Tomcat, JBoss, WebSphere, WebLogic</h5>
<div class="paragraph">
<p>Tomcat, JBoss/WildFly, IBM WebSphere Application Server and Oracle WebLogic Server all
provide a general app <code>ClassLoader</code> that is capable of local instrumentation. Spring&#8217;s
native LTW may leverage those ClassLoader implementations to provide AspectJ weaving.
You can simply enable load-time weaving, as <a href="#aop-using-aspectj">described earlier</a>.
Specifically, you do not need to modify the JVM launch script to add
<code>-javaagent:path/to/spring-instrument.jar</code>.</p>
</div>
<div class="paragraph">
<p>Note that on JBoss, you may need to disable the app server scanning to prevent it from
loading the classes before the application actually starts. A quick workaround is to add
to your artifact a file named <code>WEB-INF/jboss-scanning.xml</code> with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;scanning xmlns="urn:jboss:scanning:1.0"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments-generic"><a class="anchor" href="#aop-aj-ltw-environments-generic"></a>Generic Java Applications</h5>
<div class="paragraph">
<p>When class instrumentation is required in environments that are not supported by
specific <code>LoadTimeWeaver</code> implementations, a JVM agent is the general solution.
For such cases, Spring provides <code>InstrumentationLoadTimeWeaver</code> which requires a
Spring-specific (but very general) JVM agent, <code>spring-instrument.jar</code>, autodetected
by common <code>@EnableLoadTimeWeaving</code> and <code>&lt;context:load-time-weaver/&gt;</code> setups.</p>
</div>
<div class="paragraph">
<p>To use it, you must start the virtual machine with the Spring agent by supplying
the following JVM options:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-javaagent:/path/to/spring-instrument.jar</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this requires modification of the JVM launch script, which may prevent you
from using this in application server environments (depending on your server and your
operation policies). That said, for one-app-per-JVM deployments such as standalone
Spring Boot applications, you typically control the entire JVM setup in any case.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-resources"><a class="anchor" href="#aop-resources"></a>Further Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>More information on AspectJ can be found on the <a href="https://www.eclipse.org/aspectj">AspectJ website</a>.</p>
</div>
<div class="paragraph">
<p><em>Eclipse AspectJ</em> by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a
comprehensive introduction and reference for the AspectJ language.</p>
</div>
<div class="paragraph">
<p><em>AspectJ in Action</em>, Second Edition by Ramnivas Laddad (Manning, 2009) comes highly
recommended. The focus of the book is on AspectJ, but a lot of general AOP themes are
explored (in some depth).</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
