<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Validation, Data Binding, and Type Conversion :: Spring</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../core.html">Core</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="beans/index.html">The IoC Container</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/container.html">Container Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/bean.html">Bean Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/dependencies.html">Bean Dependencies</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scopes.html">Bean Scopes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/customizing.html">Customizing the Nature of a Bean</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/inheritance.html">Bean Definition Inheritance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/extension.html">Container Extension Points</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/annotation.html">Annotation-based Container Configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/scanning.html">Classpath Scanning and Managed Components</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/jsr330.html">Using JSR 330 Standard Annotations</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/java.html">Java-based Container configuration</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/env.html">Environment Abstraction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/loadtimeweaver.html">Registering a LoadTimeWeaver</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/applicationcontext.html">Additional Capabilities of the ApplicationContext</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="beans/beanfactory.html">The BeanFactory</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="resources.html">Resources</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="validation.html">Validation, Data Binding, and Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="aop.html">Aspect Oriented Programming with Spring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="aop-api.html">Spring AOP APIs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="null-safety.html">Null-safety</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="databuffer-codec.html">Data Buffers and Codecs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spring-jcl.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="appendix.html">Appendix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3.8</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3.8</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/5.6.0/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/5.6.0/overview/prerequisites.html">5.6.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="../core.html">Core</a></li>
    <li><a href="validation.html">Validation, Data Binding, and Type Conversion</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/core/validation.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Validation, Data Binding, and Type Conversion</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>There are pros and cons for considering validation as business logic, and Spring offers
a design for validation (and data binding) that does not exclude either one of them.
Specifically, validation should not be tied to the web tier and should be easy to localize,
and it should be possible to plug in any available validator. Considering these concerns,
Spring provides a <code>Validator</code> contract that is both basic and eminently usable
in every layer of an application.</p>
</div>
<div class="paragraph">
<p>Data binding is useful for letting user input be dynamically bound to the domain
model of an application (or whatever objects you use to process user input). Spring
provides the aptly named <code>DataBinder</code> to do exactly that. The <code>Validator</code> and the
<code>DataBinder</code> make up the <code>validation</code> package, which is primarily used in but not
limited to the web layer.</p>
</div>
<div class="paragraph">
<p>The <code>BeanWrapper</code> is a fundamental concept in the Spring Framework and is used in a lot
of places. However, you probably do not need to use the <code>BeanWrapper</code>
directly. Because this is reference documentation, however, we felt that some explanation
might be in order. We explain the <code>BeanWrapper</code> in this chapter, since, if you are
going to use it at all, you are most likely do so when trying to bind data to objects.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>DataBinder</code> and the lower-level <code>BeanWrapper</code> both use <code>PropertyEditorSupport</code>
implementations to parse and format property values. The <code>PropertyEditor</code> and
<code>PropertyEditorSupport</code> types are part of the JavaBeans specification and are also
explained in this chapter. Spring 3 introduced a <code>core.convert</code> package that provides a
general type conversion facility, as well as a higher-level &#8220;format&#8221; package for
formatting UI field values. You can use these packages as simpler alternatives to
<code>PropertyEditorSupport</code> implementations. They are also discussed in this chapter.</p>
</div>
<div class="paragraph">
<p>Spring supports Java Bean Validation through setup infrastructure and an adaptor to
Spring&#8217;s own <code>Validator</code> contract. Applications can enable Bean Validation once globally,
as described in <a href="#validation-beanvalidation">Java Bean Validation</a>, and use it exclusively for all validation
needs. In the web layer, applications can further register controller-local Spring
<code>Validator</code> instances per <code>DataBinder</code>, as described in <a href="#validation-binder">Configuring a <code>DataBinder</code></a>, which can
be useful for plugging in custom validation logic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator"><a class="anchor" href="#validator"></a>Validation by Using Spring&#8217;s Validator Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring features a <code>Validator</code> interface that you can use to validate objects. The
<code>Validator</code> interface works by using an <code>Errors</code> object so that, while validating,
validators can report validation failures to the <code>Errors</code> object.</p>
</div>
<div class="paragraph">
<p>Consider the following example of a small data object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person {

	private String name;
	private int age;

	// the usual getters and setters...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Person(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example provides validation behavior for the <code>Person</code> class by implementing the
following two methods of the <code>org.springframework.validation.Validator</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code>: Can this <code>Validator</code> validate instances of the supplied <code>Class</code>?</p>
</li>
<li>
<p><code>validate(Object, org.springframework.validation.Errors)</code>: Validates the given object
and, in case of validation errors, registers those with the given <code>Errors</code> object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementing a <code>Validator</code> is fairly straightforward, especially when you know of the
<code>ValidationUtils</code> helper class that the Spring Framework also provides. The following
example implements <code>Validator</code> for <code>Person</code> instances:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonValidator implements Validator {

	/**
	 * This Validator validates only Person instances
	 */
	public boolean supports(Class clazz) {
		return Person.class.equals(clazz);
	}

	public void validate(Object obj, Errors e) {
		ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
		Person p = (Person) obj;
		if (p.getAge() &lt; 0) {
			e.rejectValue("age", "negativevalue");
		} else if (p.getAge() &gt; 110) {
			e.rejectValue("age", "too.darn.old");
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PersonValidator : Validator {

	/**
	 * This Validator validates only Person instances
	 */
	override fun supports(clazz: Class&lt;*&gt;): Boolean {
		return Person::class.java == clazz
	}

	override fun validate(obj: Any, e: Errors) {
		ValidationUtils.rejectIfEmpty(e, "name", "name.empty")
		val p = obj as Person
		if (p.age &lt; 0) {
			e.rejectValue("age", "negativevalue")
		} else if (p.age &gt; 110) {
			e.rejectValue("age", "too.darn.old")
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>static</code> <code>rejectIfEmpty(..)</code> method on the <code>ValidationUtils</code> class is used to
reject the <code>name</code> property if it is <code>null</code> or the empty string. Have a look at the
{api-spring-framework}/validation/ValidationUtils.html[<code>ValidationUtils</code>] javadoc
to see what functionality it provides besides the example shown previously.</p>
</div>
<div class="paragraph">
<p>While it is certainly possible to implement a single <code>Validator</code> class to validate each
of the nested objects in a rich object, it may be better to encapsulate the validation
logic for each nested class of object in its own <code>Validator</code> implementation. A simple
example of a &#8220;rich&#8221; object would be a <code>Customer</code> that is composed of two <code>String</code>
properties (a first and a second name) and a complex <code>Address</code> object. <code>Address</code> objects
may be used independently of <code>Customer</code> objects, so a distinct <code>AddressValidator</code>
has been implemented. If you want your <code>CustomerValidator</code> to reuse the logic contained
within the <code>AddressValidator</code> class without resorting to copy-and-paste, you can
dependency-inject or instantiate an <code>AddressValidator</code> within your <code>CustomerValidator</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomerValidator implements Validator {

	private final Validator addressValidator;

	public CustomerValidator(Validator addressValidator) {
		if (addressValidator == null) {
			throw new IllegalArgumentException("The supplied [Validator] is " +
				"required and must not be null.");
		}
		if (!addressValidator.supports(Address.class)) {
			throw new IllegalArgumentException("The supplied [Validator] must " +
				"support the validation of [Address] instances.");
		}
		this.addressValidator = addressValidator;
	}

	/**
	 * This Validator validates Customer instances, and any subclasses of Customer too
	 */
	public boolean supports(Class clazz) {
		return Customer.class.isAssignableFrom(clazz);
	}

	public void validate(Object target, Errors errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
		Customer customer = (Customer) target;
		try {
			errors.pushNestedPath("address");
			ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
		} finally {
			errors.popNestedPath();
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CustomerValidator(private val addressValidator: Validator) : Validator {

	init {
		if (addressValidator == null) {
			throw IllegalArgumentException("The supplied [Validator] is required and must not be null.")
		}
		if (!addressValidator.supports(Address::class.java)) {
			throw IllegalArgumentException("The supplied [Validator] must support the validation of [Address] instances.")
		}
	}

	/<strong>*
	* This Validator validates Customer instances, and any subclasses of Customer too
	*/
	override fun supports(clazz: Class&lt;</strong>&gt;): Boolean {
		return Customer::class.java.isAssignableFrom(clazz)
	}

	override fun validate(target: Any, errors: Errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required")
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required")
		val customer = target as Customer
		try {
			errors.pushNestedPath("address")
			ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors)
		} finally {
			errors.popNestedPath()
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Validation errors are reported to the <code>Errors</code> object passed to the validator. In the case
of Spring Web MVC, you can use the <code>&lt;spring:bind/&gt;</code> tag to inspect the error messages, but
you can also inspect the <code>Errors</code> object yourself. More information about the
methods it offers can be found in the {api-spring-framework}validation/Errors.html[javadoc].</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a>Resolving Codes to Error Messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We covered databinding and validation. This section covers outputting messages that correspond
to validation errors. In the example shown in the <a href="#validator">preceding section</a>,
we rejected the <code>name</code> and <code>age</code> fields. If we want to output the error messages by using a
<code>MessageSource</code>, we can do so using the error code we provide when rejecting the field
('name' and 'age' in this case). When you call (either directly, or indirectly, by using,
for example, the <code>ValidationUtils</code> class) <code>rejectValue</code> or one of the other <code>reject</code> methods
from the <code>Errors</code> interface, the underlying implementation not only registers the code you
passed in but also registers a number of additional error codes. The <code>MessageCodesResolver</code>
determines which error codes the <code>Errors</code> interface registers. By default, the
<code>DefaultMessageCodesResolver</code> is used, which (for example) not only registers a message
with the code you gave but also registers messages that include the field name you passed
to the reject method. So, if you reject a field by using <code>rejectValue("age", "too.darn.old")</code>,
apart from the <code>too.darn.old</code> code, Spring also registers <code>too.darn.old.age</code> and
<code>too.darn.old.age.int</code> (the first includes the field name and the second includes the type
of the field). This is done as a convenience to aid developers when targeting error messages.</p>
</div>
<div class="paragraph">
<p>More information on the <code>MessageCodesResolver</code> and the default strategy can be found
in the javadoc of
{api-spring-framework}/validation/MessageCodesResolver.html[<code>MessageCodesResolver</code>] and
{api-spring-framework}/validation/DefaultMessageCodesResolver.html[<code>DefaultMessageCodesResolver</code>],
respectively.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans-beans"><a class="anchor" href="#beans-beans"></a>Bean Manipulation and the <code>BeanWrapper</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>org.springframework.beans</code> package adheres to the JavaBeans standard.
A JavaBean is a class with a default no-argument constructor and that follows
a naming convention where (for example) a property named <code>bingoMadness</code> would
have a setter method <code>setBingoMadness(..)</code> and a getter method <code>getBingoMadness()</code>. For
more information about JavaBeans and the specification, see
<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a>.</p>
</div>
<div class="paragraph">
<p>One quite important class in the beans package is the <code>BeanWrapper</code> interface and its
corresponding implementation (<code>BeanWrapperImpl</code>). As quoted from the javadoc, the
<code>BeanWrapper</code> offers functionality to set and get property values (individually or in
bulk), get property descriptors, and query properties to determine if they are
readable or writable. Also, the <code>BeanWrapper</code> offers support for nested properties,
enabling the setting of properties on sub-properties to an unlimited depth. The
<code>BeanWrapper</code> also supports the ability to add standard JavaBeans <code>PropertyChangeListeners</code>
and <code>VetoableChangeListeners</code>, without the need for supporting code in the target class.
Last but not least, the <code>BeanWrapper</code> provides support for setting indexed properties.
The <code>BeanWrapper</code> usually is not used by application code directly but is used by the
<code>DataBinder</code> and the <code>BeanFactory</code>.</p>
</div>
<div class="paragraph">
<p>The way the <code>BeanWrapper</code> works is partly indicated by its name: it wraps a bean to
perform actions on that bean, such as setting and retrieving properties.</p>
</div>
<div class="sect2">
<h3 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a>Setting and Getting Basic and Nested Properties</h3>
<div class="paragraph">
<p>Setting and getting properties is done through the <code>setPropertyValue</code> and
<code>getPropertyValue</code> overloaded method variants of <code>BeanWrapper</code>. See their Javadoc for
details. The below table shows some examples of these conventions:</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Examples of properties</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the property <code>name</code> that corresponds to the <code>getName()</code> or <code>isName()</code>
  and <code>setName(..)</code> methods.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the nested property <code>name</code> of the property <code>account</code> that corresponds to
  (for example) the <code>getAccount().setName()</code> or <code>getAccount().getName()</code> methods.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the <em>third</em> element of the indexed property <code>account</code>. Indexed properties
  can be of type <code>array</code>, <code>list</code>, or other naturally ordered collection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the value of the map entry indexed by the <code>COMPANYNAME</code> key of the <code>account</code> <code>Map</code>
  property.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>(This next section is not vitally important to you if you do not plan to work with
the <code>BeanWrapper</code> directly. If you use only the <code>DataBinder</code> and the <code>BeanFactory</code>
and their default implementations, you should skip ahead to the
<a href="#beans-beans-conversion">section on <code>PropertyEditors</code></a>.)</p>
</div>
<div class="paragraph">
<p>The following two example classes use the <code>BeanWrapper</code> to get and set
properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Company {

	private String name;
	private Employee managingDirector;

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Employee getManagingDirector() {
		return this.managingDirector;
	}

	public void setManagingDirector(Employee managingDirector) {
		this.managingDirector = managingDirector;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Company {
	var name: String? = null
	var managingDirector: Employee? = null
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee {

	private String name;

	private float salary;

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public float getSalary() {
		return salary;
	}

	public void setSalary(float salary) {
		this.salary = salary;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Employee {
	var name: String? = null
	var salary: Float? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippets show some examples of how to retrieve and manipulate some of
the properties of instantiated <code>Companies</code> and <code>Employees</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue("managingDirector.salary");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val company = BeanWrapperImpl(Company())
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.")
// ... can also be done like this:
val value = PropertyValue("name", "Some Company Inc.")
company.setPropertyValue(value)

// ok, let's create the director and tie it to the company:
val jim = BeanWrapperImpl(Employee())
jim.setPropertyValue("name", "Jim Stravinsky")
company.setPropertyValue("managingDirector", jim.wrappedInstance)

// retrieving the salary of the managingDirector through the company
val salary = company.getPropertyValue("managingDirector.salary") as Float?</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a>Built-in <code>PropertyEditor</code> Implementations</h3>
<div class="paragraph">
<p>Spring uses the concept of a <code>PropertyEditor</code> to effect the conversion between an
<code>Object</code> and a <code>String</code>. It can be handy
to represent properties in a different way than the object itself. For example, a <code>Date</code>
can be represented in a human readable way (as the <code>String</code>: <code>'2007-14-09'</code>), while
we can still convert the human readable form back to the original date (or, even
better, convert any date entered in a human readable form back to <code>Date</code> objects). This
behavior can be achieved by registering custom editors of type
<code>java.beans.PropertyEditor</code>. Registering custom editors on a <code>BeanWrapper</code> or,
alternatively, in a specific IoC container (as mentioned in the previous chapter), gives it
the knowledge of how to convert properties to the desired type. For more about
<code>PropertyEditor</code>, see <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">the javadoc of the <code>java.beans</code> package from Oracle</a>.</p>
</div>
<div class="paragraph">
<p>A couple of examples where property editing is used in Spring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting properties on beans is done by using <code>PropertyEditor</code> implementations.
When you use <code>String</code> as the value of a property of some bean that you declare
in an XML file, Spring (if the setter of the corresponding property has a <code>Class</code>
parameter) uses <code>ClassEditor</code> to try to resolve the parameter to a <code>Class</code> object.</p>
</li>
<li>
<p>Parsing HTTP request parameters in Spring&#8217;s MVC framework is done by using all kinds
of <code>PropertyEditor</code> implementations that you can manually bind in all subclasses of the
<code>CommandController</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring has a number of built-in <code>PropertyEditor</code> implementations to make life easy.
They are all located in the <code>org.springframework.beans.propertyeditors</code>
package. Most, (but not all, as indicated in the following table) are, by default, registered by
<code>BeanWrapperImpl</code>. Where the property editor is configurable in some fashion, you can
still register your own variant to override the default one. The following table describes
the various <code>PropertyEditor</code> implementations that Spring provides:</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Built-in <code>PropertyEditor</code> Implementations</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Editor for byte arrays. Converts strings to their corresponding byte
  representations. Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClassEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses Strings that represent classes to actual classes and vice-versa. When a
  class is not found, an <code>IllegalArgumentException</code> is thrown. By default, registered by
  <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for <code>Boolean</code> properties. By default, registered by
  <code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a
  custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor for collections, converting any source <code>Collection</code> to a given target
  <code>Collection</code> type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for <code>java.util.Date</code>, supporting a custom <code>DateFormat</code>. NOT
  registered by default. Must be user-registered with the appropriate format as needed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for any <code>Number</code> subclass, such as <code>Integer</code>, <code>Long</code>, <code>Float</code>, or
  <code>Double</code>. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by
  registering a custom instance of it as a custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolves strings to <code>java.io.File</code> objects. By default, registered by
  <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One-way property editor that can take a string and produce (through an
  intermediate <code>ResourceEditor</code> and <code>Resource</code>) an <code>InputStream</code> so that <code>InputStream</code>
  properties may be directly set as strings. Note that the default usage does not close
  the <code>InputStream</code> for you. By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve strings to <code>Locale</code> objects and vice-versa (the string format is
  <code>[language]_[country]_[variant]</code>, same as the <code>toString()</code> method of
  <code>Locale</code>). Also accepts spaces as separators, as an alternative to underscores.
  By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve strings to <code>java.util.regex.Pattern</code> objects and vice-versa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can convert strings (formatted with the format defined in the javadoc of the
  <code>java.util.Properties</code> class) to <code>Properties</code> objects. By default, registered
  by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor that trims strings. Optionally allows transforming an empty string
  into a <code>null</code> value. NOT registered by default&#8201;&#8212;&#8201;must be user-registered.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve a string representation of a URL to an actual <code>URL</code> object.
  By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring uses the <code>java.beans.PropertyEditorManager</code> to set the search path for property
editors that might be needed. The search path also includes <code>sun.bean.editors</code>, which
includes <code>PropertyEditor</code> implementations for types such as <code>Font</code>, <code>Color</code>, and most of
the primitive types. Note also that the standard JavaBeans infrastructure
automatically discovers <code>PropertyEditor</code> classes (without you having to register them
explicitly) if they are in the same package as the class they handle and have the same
name as that class, with <code>Editor</code> appended. For example, one could have the following
class and package structure, which would be sufficient for the <code>SomethingEditor</code> class to be
recognized and used as the <code>PropertyEditor</code> for <code>Something</code>-typed properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can also use the standard <code>BeanInfo</code> JavaBeans mechanism here as well
(described to some extent
<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">here</a>). The
following example uses the <code>BeanInfo</code> mechanism to explicitly register one or more
<code>PropertyEditor</code> instances with the properties of an associated class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>The following Java source code for the referenced <code>SomethingBeanInfo</code> class
associates a <code>CustomNumberEditor</code> with the <code>age</code> property of the <code>Something</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SomethingBeanInfo extends SimpleBeanInfo {

	public PropertyDescriptor[] getPropertyDescriptors() {
		try {
			final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
			PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
				@Override
				public PropertyEditor createPropertyEditor(Object bean) {
					return numberPE;
				}
			};
			return new PropertyDescriptor[] { ageDescriptor };
		}
		catch (IntrospectionException ex) {
			throw new Error(ex.toString());
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SomethingBeanInfo : SimpleBeanInfo() {

	override fun getPropertyDescriptors(): Array&lt;PropertyDescriptor&gt; {
		try {
			val numberPE = CustomNumberEditor(Int::class.java, true)
			val ageDescriptor = object : PropertyDescriptor("age", Something::class.java) {
				override fun createPropertyEditor(bean: Any): PropertyEditor {
					return numberPE
				}
			}
			return arrayOf(ageDescriptor)
		} catch (ex: IntrospectionException) {
			throw Error(ex.toString())
		}

	}
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>Registering Additional Custom <code>PropertyEditor</code> Implementations</h4>
<div class="paragraph">
<p>When setting bean properties as string values, a Spring IoC container ultimately uses
standard JavaBeans <code>PropertyEditor</code> implementations to convert these strings to the complex type of the
property. Spring pre-registers a number of custom <code>PropertyEditor</code> implementations (for example, to
convert a class name expressed as a string into a <code>Class</code> object). Additionally,
Java&#8217;s standard JavaBeans <code>PropertyEditor</code> lookup mechanism lets a <code>PropertyEditor</code>
for a class be named appropriately and placed in the same package as the class
for which it provides support, so that it can be found automatically.</p>
</div>
<div class="paragraph">
<p>If there is a need to register other custom <code>PropertyEditors</code>, several mechanisms are
available. The most manual approach, which is not normally convenient or
recommended, is to use the <code>registerCustomEditor()</code> method of the
<code>ConfigurableBeanFactory</code> interface, assuming you have a <code>BeanFactory</code> reference.
Another (slightly more convenient) mechanism is to use a special bean factory
post-processor called <code>CustomEditorConfigurer</code>. Although you can use bean factory post-processors
with <code>BeanFactory</code> implementations, the <code>CustomEditorConfigurer</code> has a
nested property setup, so we strongly recommend that you use it with the
<code>ApplicationContext</code>, where you can deploy it in similar fashion to any other bean and
where it can be automatically detected and applied.</p>
</div>
<div class="paragraph">
<p>Note that all bean factories and application contexts automatically use a number of
built-in property editors, through their use of a <code>BeanWrapper</code> to
handle property conversions. The standard property editors that the <code>BeanWrapper</code>
registers are listed in the <a href="#beans-beans-conversion">previous section</a>.
Additionally, <code>ApplicationContexts</code> also override or add additional editors to handle
resource lookups in a manner appropriate to the specific application context type.</p>
</div>
<div class="paragraph">
<p>Standard JavaBeans <code>PropertyEditor</code> instances are used to convert property values
expressed as strings to the actual complex type of the property. You can use
<code>CustomEditorConfigurer</code>, a bean factory post-processor, to conveniently add
support for additional <code>PropertyEditor</code> instances to an <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following example, which defines a user class called <code>ExoticType</code> and
another class called <code>DependsOnExoticType</code>, which needs <code>ExoticType</code> set as a property:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package example;

public class ExoticType {

	private String name;

	public ExoticType(String name) {
		this.name = name;
	}
}

public class DependsOnExoticType {

	private ExoticType type;

	public void setType(ExoticType type) {
		this.type = type;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package example

class ExoticType(val name: String)

class DependsOnExoticType {

	var type: ExoticType? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When things are properly set up, we want to be able to assign the type property as a
string, which a <code>PropertyEditor</code> converts into an actual
<code>ExoticType</code> instance. The following bean definition shows how to set up this relationship:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
	&lt;property name="type" value="aNameForExoticType"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertyEditor</code> implementation could look similar to the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

	public void setAsText(String text) {
		setValue(new ExoticType(text.toUpperCase()));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// converts string representation to ExoticType object
package example

import java.beans.PropertyEditorSupport

class ExoticTypeEditor : PropertyEditorSupport() {

	override fun setAsText(text: String) {
		value = ExoticType(text.toUpperCase())
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following example shows how to use <code>CustomEditorConfigurer</code> to register the new <code>PropertyEditor</code> with the
<code>ApplicationContext</code>, which will then be able to use it as needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
	&lt;property name="customEditors"&gt;
		&lt;map&gt;
			&lt;entry key="example.ExoticType" value="example.ExoticTypeEditor"/&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>Using <code>PropertyEditorRegistrar</code></h5>
<div class="paragraph">
<p>Another mechanism for registering property editors with the Spring container is to
create and use a <code>PropertyEditorRegistrar</code>. This interface is particularly useful when
you need to use the same set of property editors in several different situations.
You can write a corresponding registrar and reuse it in each case.
<code>PropertyEditorRegistrar</code> instances work in conjunction with an interface called
<code>PropertyEditorRegistry</code>, an interface that is implemented by the Spring <code>BeanWrapper</code>
(and <code>DataBinder</code>). <code>PropertyEditorRegistrar</code> instances are particularly convenient
when used in conjunction with <code>CustomEditorConfigurer</code> (described
<a href="#beans-beans-conversion-customeditor-registration">here</a>), which exposes a property
called <code>setPropertyEditorRegistrars(..)</code>. <code>PropertyEditorRegistrar</code> instances added
to a <code>CustomEditorConfigurer</code> in this fashion can easily be shared with <code>DataBinder</code> and
Spring MVC controllers. Furthermore, it avoids the need for synchronization on custom
editors: A <code>PropertyEditorRegistrar</code> is expected to create fresh <code>PropertyEditor</code>
instances for each bean creation attempt.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create your own <code>PropertyEditorRegistrar</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

	public void registerCustomEditors(PropertyEditorRegistry registry) {

		// it is expected that new PropertyEditor instances are created
		registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

		// you could register as many custom property editors as are required here...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package com.foo.editors.spring

import org.springframework.beans.PropertyEditorRegistrar
import org.springframework.beans.PropertyEditorRegistry

class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {

	override fun registerCustomEditors(registry: PropertyEditorRegistry) {

		// it is expected that new PropertyEditor instances are created
		registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor())

		// you could register as many custom property editors as are required here...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <code>org.springframework.beans.support.ResourceEditorRegistrar</code> for an example
<code>PropertyEditorRegistrar</code> implementation. Notice how in its implementation of the
<code>registerCustomEditors(..)</code> method ,it creates new instances of each property editor.</p>
</div>
<div class="paragraph">
<p>The next example shows how to configure a <code>CustomEditorConfigurer</code> and inject an instance of our
<code>CustomPropertyEditorRegistrar</code> into it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
	&lt;property name="propertyEditorRegistrars"&gt;
		&lt;list&gt;
			&lt;ref bean="customPropertyEditorRegistrar"/&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="customPropertyEditorRegistrar"
	class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally (and in a bit of a departure from the focus of this chapter for those of you
using <a href="../web.html#mvc" class="page">Spring&#8217;s MVC web framework</a>), using <code>PropertyEditorRegistrars</code> in
conjunction with data-binding <code>Controllers</code> (such as <code>SimpleFormController</code>) can be very
convenient. The following example uses a <code>PropertyEditorRegistrar</code> in the
implementation of an <code>initBinder(..)</code> method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class RegisterUserController extends SimpleFormController {

	private final PropertyEditorRegistrar customPropertyEditorRegistrar;

	public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
		this.customPropertyEditorRegistrar = propertyEditorRegistrar;
	}

	protected void initBinder(HttpServletRequest request,
			ServletRequestDataBinder binder) throws Exception {
		this.customPropertyEditorRegistrar.registerCustomEditors(binder);
	}

	// other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class RegisterUserController(
	private val customPropertyEditorRegistrar: PropertyEditorRegistrar) : SimpleFormController() {

	protected fun initBinder(request: HttpServletRequest,
							binder: ServletRequestDataBinder) {
		this.customPropertyEditorRegistrar.registerCustomEditors(binder)
	}

	// other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This style of <code>PropertyEditor</code> registration can lead to concise code (the implementation
of <code>initBinder(..)</code> is only one line long) and lets common <code>PropertyEditor</code>
registration code be encapsulated in a class and then shared amongst as many
<code>Controllers</code> as needed.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-convert"><a class="anchor" href="#core-convert"></a>Spring Type Conversion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring 3 introduced a <code>core.convert</code> package that provides a general type conversion
system. The system defines an SPI to implement type conversion logic and an API
to perform type conversions at runtime. Within a Spring container, you can use this system
as an alternative to <code>PropertyEditor</code> implementations to convert externalized bean property value
strings to the required property types. You can also use the public API anywhere in your
application where type conversion is needed.</p>
</div>
<div class="sect2">
<h3 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a>Converter SPI</h3>
<div class="paragraph">
<p>The SPI to implement type conversion logic is simple and strongly typed, as the following
interface definition shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

	T convert(S source);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own converter, implement the <code>Converter</code> interface and parameterize <code>S</code>
as the type you are converting from and <code>T</code> as the type you are converting to. You can also transparently apply such a
converter if a collection or array of <code>S</code> needs to be
converted to an array or collection of <code>T</code>, provided that a delegating array or collection
converter has been registered as well (which <code>DefaultConversionService</code> does by default).</p>
</div>
<div class="paragraph">
<p>For each call to <code>convert(S)</code>, the source argument is guaranteed to not be null. Your
<code>Converter</code> may throw any unchecked exception if conversion fails. Specifically, it should throw an
<code>IllegalArgumentException</code> to report an invalid source value.
Take care to ensure that your <code>Converter</code> implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>Several converter implementations are provided in the <code>core.convert.support</code> package as
a convenience. These include converters from strings to numbers and other common types.
The following listing shows the <code>StringToInteger</code> class, which is a typical <code>Converter</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

	public Integer convert(String source) {
		return Integer.valueOf(source);
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a>Using <code>ConverterFactory</code></h3>
<div class="paragraph">
<p>When you need to centralize the conversion logic for an entire class hierarchy
(for example, when converting from <code>String</code> to <code>Enum</code> objects), you can implement
<code>ConverterFactory</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

	&lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parameterize S to be the type you are converting from and R to be the base type defining
the <em>range</em> of classes you can convert to. Then implement <code>getConverter(Class&lt;T&gt;)</code>,
where T is a subclass of R.</p>
</div>
<div class="paragraph">
<p>Consider the <code>StringToEnumConverterFactory</code> as an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

	public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
		return new StringToEnumConverter(targetType);
	}

	private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

		private Class&lt;T&gt; enumType;

		public StringToEnumConverter(Class&lt;T&gt; enumType) {
			this.enumType = enumType;
		}

		public T convert(String source) {
			return (T) Enum.valueOf(this.enumType, source.trim());
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a>Using <code>GenericConverter</code></h3>
<div class="paragraph">
<p>When you require a sophisticated <code>Converter</code> implementation, consider using the
<code>GenericConverter</code> interface. With a more flexible but less strongly typed signature
than <code>Converter</code>, a <code>GenericConverter</code> supports converting between multiple source and
target types. In addition, a <code>GenericConverter</code> makes available source and target field
context that you can use when you implement your conversion logic. Such context lets a
type conversion be driven by a field annotation or by generic information declared on a
field signature. The following listing shows the interface definition of <code>GenericConverter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert.converter;

public interface GenericConverter {

	public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

	Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement a <code>GenericConverter</code>, have <code>getConvertibleTypes()</code> return the supported
source&#8594;target type pairs. Then implement <code>convert(Object, TypeDescriptor,
TypeDescriptor)</code> to contain your conversion logic. The source <code>TypeDescriptor</code> provides
access to the source field that holds the value being converted. The target <code>TypeDescriptor</code>
provides access to the target field where the converted value is to be set.</p>
</div>
<div class="paragraph">
<p>A good example of a <code>GenericConverter</code> is a converter that converts between a Java array
and a collection. Such an <code>ArrayToCollectionConverter</code> introspects the field that declares
the target collection type to resolve the collection&#8217;s element type. This lets each
element in the source array be converted to the collection element type before the
collection is set on the target field.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because <code>GenericConverter</code> is a more complex SPI interface, you should use
it only when you need it. Favor <code>Converter</code> or <code>ConverterFactory</code> for basic type
conversion needs.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>Using <code>ConditionalGenericConverter</code></h4>
<div class="paragraph">
<p>Sometimes, you want a <code>Converter</code> to run only if a specific condition holds true. For
example, you might want to run a <code>Converter</code> only if a specific annotation is present
on the target field, or you might want to run a <code>Converter</code> only if a specific method
(such as a <code>static valueOf</code> method) is defined on the target class.
<code>ConditionalGenericConverter</code> is the union of the <code>GenericConverter</code> and
<code>ConditionalConverter</code> interfaces that lets you define such custom matching criteria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ConditionalConverter {

	boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A good example of a <code>ConditionalGenericConverter</code> is an <code>IdToEntityConverter</code> that converts
between a persistent entity identifier and an entity reference. Such an <code>IdToEntityConverter</code>
might match only if the target entity type declares a static finder method (for example,
<code>findAccount(Long)</code>). You might perform such a finder method check in the implementation of
<code>matches(TypeDescriptor, TypeDescriptor)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a>The <code>ConversionService</code> API</h3>
<div class="paragraph">
<p><code>ConversionService</code> defines a unified API for executing type conversion logic at
runtime. Converters are often run behind the following facade interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.core.convert;

public interface ConversionService {

	boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

	&lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

	boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

	Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most <code>ConversionService</code> implementations also implement <code>ConverterRegistry</code>, which
provides an SPI for registering converters. Internally, a <code>ConversionService</code>
implementation delegates to its registered converters to carry out type conversion logic.</p>
</div>
<div class="paragraph">
<p>A robust <code>ConversionService</code> implementation is provided in the <code>core.convert.support</code>
package. <code>GenericConversionService</code> is the general-purpose implementation suitable for
use in most environments. <code>ConversionServiceFactory</code> provides a convenient factory for
creating common <code>ConversionService</code> configurations.</p>
</div>
</div>
<div class="sect2">
<h3 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a>Configuring a <code>ConversionService</code></h3>
<div class="paragraph">
<p>A <code>ConversionService</code> is a stateless object designed to be instantiated at application
startup and then shared between multiple threads. In a Spring application, you typically
configure a <code>ConversionService</code> instance for each Spring container (or <code>ApplicationContext</code>).
Spring picks up that <code>ConversionService</code> and uses it whenever a type
conversion needs to be performed by the framework. You can also inject this
<code>ConversionService</code> into any of your beans and invoke it directly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If no <code>ConversionService</code> is registered with Spring, the original <code>PropertyEditor</code>-based
system is used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To register a default <code>ConversionService</code> with Spring, add the following bean definition
with an <code>id</code> of <code>conversionService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="conversionService"
	class="org.springframework.context.support.ConversionServiceFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A default <code>ConversionService</code> can convert between strings, numbers, enums, collections,
maps, and other common types. To supplement or override the default converters with your
own custom converters, set the <code>converters</code> property. Property values can implement
any of the <code>Converter</code>, <code>ConverterFactory</code>, or <code>GenericConverter</code> interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="conversionService"
		class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;
	&lt;property name="converters"&gt;
		&lt;set&gt;
			&lt;bean class="example.MyCustomConverter"/&gt;
		&lt;/set&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also common to use a <code>ConversionService</code> within a Spring MVC application. See
<a href="../web.html#mvc-config-conversion" class="page">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
<div class="paragraph">
<p>In certain situations, you may wish to apply formatting during conversion. See
<a href="#format-FormatterRegistry-SPI">The <code>FormatterRegistry</code> SPI</a> for details on using <code>FormattingConversionServiceFactoryBean</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a>Using a <code>ConversionService</code> Programmatically</h3>
<div class="paragraph">
<p>To work with a <code>ConversionService</code> instance programmatically, you can inject a reference to
it like you would for any other bean. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

	public MyService(ConversionService conversionService) {
		this.conversionService = conversionService;
	}

	public void doIt() {
		this.conversionService.convert(...)
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Service
class MyService(private val conversionService: ConversionService) {

	fun doIt() {
		conversionService.convert(...)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For most use cases, you can use the <code>convert</code> method that specifies the <code>targetType</code>, but it
does not work with more complex types, such as a collection of a parameterized element.
For example, if you want to convert a <code>List</code> of <code>Integer</code> to a <code>List</code> of <code>String</code> programmatically,
you need to provide a formal definition of the source and target types.</p>
</div>
<div class="paragraph">
<p>Fortunately, <code>TypeDescriptor</code> provides various options to make doing so straightforward,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DefaultConversionService cs = new DefaultConversionService();

List&lt;Integer&gt; input = ...
cs.convert(input,
	TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
	TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cs = DefaultConversionService()

val input: List&lt;Integer&gt; = ...
cs.convert(input,
		TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
		TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>DefaultConversionService</code> automatically registers converters that are
appropriate for most environments. This includes collection converters, scalar
converters, and basic <code>Object</code>-to-<code>String</code> converters. You can register the same converters
with any <code>ConverterRegistry</code> by using the static <code>addDefaultConverters</code>
method on the <code>DefaultConversionService</code> class.</p>
</div>
<div class="paragraph">
<p>Converters for value types are reused for arrays and collections, so there is
no need to create a specific converter to convert from a <code>Collection</code> of <code>S</code> to a
<code>Collection</code> of <code>T</code>, assuming that standard collection handling is appropriate.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="format"><a class="anchor" href="#format"></a>Spring Field Formatting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As discussed in the previous section, <a href="#core-convert"><code>core.convert</code></a> is a
general-purpose type conversion system. It provides a unified <code>ConversionService</code> API as
well as a strongly typed <code>Converter</code> SPI for implementing conversion logic from one type
to another. A Spring container uses this system to bind bean property values. In
addition, both the Spring Expression Language (SpEL) and <code>DataBinder</code> use this system to
bind field values. For example, when SpEL needs to coerce a <code>Short</code> to a <code>Long</code> to
complete an <code>expression.setValue(Object bean, Object value)</code> attempt, the <code>core.convert</code>
system performs the coercion.</p>
</div>
<div class="paragraph">
<p>Now consider the type conversion requirements of a typical client environment, such as a
web or desktop application. In such environments, you typically convert from <code>String</code>
to support the client postback process, as well as back to <code>String</code> to support the
view rendering process. In addition, you often need to localize <code>String</code> values. The more
general <code>core.convert</code> <code>Converter</code> SPI does not address such formatting requirements
directly. To directly address them, Spring 3 introduced a convenient <code>Formatter</code> SPI that
provides a simple and robust alternative to <code>PropertyEditor</code> implementations for client environments.</p>
</div>
<div class="paragraph">
<p>In general, you can use the <code>Converter</code> SPI when you need to implement general-purpose type
conversion logic&#8201;&#8212;&#8201;for example, for converting between a <code>java.util.Date</code> and a <code>Long</code>.
You can use the <code>Formatter</code> SPI when you work in a client environment (such as a web
application) and need to parse and print localized field values. The <code>ConversionService</code>
provides a unified type conversion API for both SPIs.</p>
</div>
<div class="sect2">
<h3 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a>The <code>Formatter</code> SPI</h3>
<div class="paragraph">
<p>The <code>Formatter</code> SPI to implement field formatting logic is simple and strongly typed. The
following listing shows the <code>Formatter</code> interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.format;

public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Formatter</code> extends from the <code>Printer</code> and <code>Parser</code> building-block interfaces. The
following listing shows the definitions of those two interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Printer&lt;T&gt; {

	String print(T fieldValue, Locale locale);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.text.ParseException;

public interface Parser&lt;T&gt; {

	T parse(String clientValue, Locale locale) throws ParseException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own <code>Formatter</code>, implement the <code>Formatter</code> interface shown earlier.
Parameterize <code>T</code> to be the type of object you wish to format&#8201;&#8212;&#8201;for example,
<code>java.util.Date</code>. Implement the <code>print()</code> operation to print an instance of <code>T</code> for
display in the client locale. Implement the <code>parse()</code> operation to parse an instance of
<code>T</code> from the formatted representation returned from the client locale. Your <code>Formatter</code>
should throw a <code>ParseException</code> or an <code>IllegalArgumentException</code> if a parse attempt fails. Take
care to ensure that your <code>Formatter</code> implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>The <code>format</code> subpackages provide several <code>Formatter</code> implementations as a convenience.
The <code>number</code> package provides <code>NumberStyleFormatter</code>, <code>CurrencyStyleFormatter</code>, and
<code>PercentStyleFormatter</code> to format <code>Number</code> objects that use a <code>java.text.NumberFormat</code>.
The <code>datetime</code> package provides a <code>DateFormatter</code> to format <code>java.util.Date</code> objects with
a <code>java.text.DateFormat</code>.</p>
</div>
<div class="paragraph">
<p>The following <code>DateFormatter</code> is an example <code>Formatter</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.format.datetime;

public final class DateFormatter implements Formatter&lt;Date&gt; {

	private String pattern;

	public DateFormatter(String pattern) {
		this.pattern = pattern;
	}

	public String print(Date date, Locale locale) {
		if (date == null) {
			return "";
		}
		return getDateFormat(locale).format(date);
	}

	public Date parse(String formatted, Locale locale) throws ParseException {
		if (formatted.length() == 0) {
			return null;
		}
		return getDateFormat(locale).parse(formatted);
	}

	protected DateFormat getDateFormat(Locale locale) {
		DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
		dateFormat.setLenient(false);
		return dateFormat;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class DateFormatter(private val pattern: String) : Formatter&lt;Date&gt; {

	override fun print(date: Date, locale: Locale)
			= getDateFormat(locale).format(date)

	@Throws(ParseException::class)
	override fun parse(formatted: String, locale: Locale)
			= getDateFormat(locale).parse(formatted)

	protected fun getDateFormat(locale: Locale): DateFormat {
		val dateFormat = SimpleDateFormat(this.pattern, locale)
		dateFormat.isLenient = false
		return dateFormat
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring team welcomes community-driven <code>Formatter</code> contributions. See
<a href="https://github.com/spring-projects/spring-framework/issues">GitHub Issues</a> to contribute.</p>
</div>
</div>
<div class="sect2">
<h3 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a>Annotation-driven Formatting</h3>
<div class="paragraph">
<p>Field formatting can be configured by field type or annotation. To bind
an annotation to a <code>Formatter</code>, implement <code>AnnotationFormatterFactory</code>. The following
listing shows the definition of the <code>AnnotationFormatterFactory</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.format;

public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {

	Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

	Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

	Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create an implementation:
. Parameterize A to be the field <code>annotationType</code> with which you wish to associate
formatting  logic&#8201;&#8212;&#8201;for example <code>org.springframework.format.annotation.DateTimeFormat</code>.
. Have <code>getFieldTypes()</code> return the types of fields on which the annotation can be used.
. Have <code>getPrinter()</code> return a <code>Printer</code> to print the value of an annotated field.
. Have <code>getParser()</code> return a <code>Parser</code> to parse a <code>clientValue</code> for an annotated field.</p>
</div>
<div class="paragraph">
<p>The following example <code>AnnotationFormatterFactory</code> implementation binds the <code>@NumberFormat</code>
annotation to a formatter to let a number style or pattern be
specified:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class NumberFormatAnnotationFormatterFactory
		implements AnnotationFormatterFactory&lt;NumberFormat&gt; {

	public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
		return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] {
			Short.class, Integer.class, Long.class, Float.class,
			Double.class, BigDecimal.class, BigInteger.class }));
	}

	public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
		return configureFormatterFrom(annotation, fieldType);
	}

	public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
		return configureFormatterFrom(annotation, fieldType);
	}

	private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation, Class&lt;?&gt; fieldType) {
		if (!annotation.pattern().isEmpty()) {
			return new NumberStyleFormatter(annotation.pattern());
		} else {
			Style style = annotation.style();
			if (style == Style.PERCENT) {
				return new PercentStyleFormatter();
			} else if (style == Style.CURRENCY) {
				return new CurrencyStyleFormatter();
			} else {
				return new NumberStyleFormatter();
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory&lt;NumberFormat&gt; {

	override fun getFieldTypes(): Set&lt;Class&lt;*&gt;&gt; {
		return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java)
	}

	override fun getPrinter(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Printer&lt;Number&gt; {
		return configureFormatterFrom(annotation, fieldType)
	}

	override fun getParser(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Parser&lt;Number&gt; {
		return configureFormatterFrom(annotation, fieldType)
	}

	private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Formatter&lt;Number&gt; {
		return if (annotation.pattern.isNotEmpty()) {
			NumberStyleFormatter(annotation.pattern)
		} else {
			val style = annotation.style
			when {
				style === NumberFormat.Style.PERCENT -&gt; PercentStyleFormatter()
				style === NumberFormat.Style.CURRENCY -&gt; CurrencyStyleFormatter()
				else -&gt; NumberStyleFormatter()
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To trigger formatting, you can annotate fields with @NumberFormat, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyModel {

	@NumberFormat(style=Style.CURRENCY)
	private BigDecimal decimal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyModel(
	@field:NumberFormat(style = Style.CURRENCY) private val decimal: BigDecimal
)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>Format Annotation API</h4>
<div class="paragraph">
<p>A portable format annotation API exists in the <code>org.springframework.format.annotation</code>
package. You can use <code>@NumberFormat</code> to format <code>Number</code> fields such as <code>Double</code> and
<code>Long</code>, and <code>@DateTimeFormat</code> to format <code>java.util.Date</code>, <code>java.util.Calendar</code>, <code>Long</code>
(for millisecond timestamps) as well as JSR-310 <code>java.time</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses <code>@DateTimeFormat</code> to format a <code>java.util.Date</code> as an ISO Date
(yyyy-MM-dd):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyModel {

	@DateTimeFormat(iso=ISO.DATE)
	private Date date;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyModel(
	@DateTimeFormat(iso= ISO.DATE) private val date: Date
)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a>The <code>FormatterRegistry</code> SPI</h3>
<div class="paragraph">
<p>The <code>FormatterRegistry</code> is an SPI for registering formatters and converters.
<code>FormattingConversionService</code> is an implementation of <code>FormatterRegistry</code> suitable for
most environments. You can programmatically or declaratively configure this variant
as a Spring bean, e.g. by using <code>FormattingConversionServiceFactoryBean</code>. Because this
implementation also implements <code>ConversionService</code>, you can directly configure it
for use with Spring&#8217;s <code>DataBinder</code> and the Spring Expression Language (SpEL).</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>FormatterRegistry</code> SPI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

	void addPrinter(Printer&lt;?&gt; printer);

	void addParser(Parser&lt;?&gt; parser);

	void addFormatter(Formatter&lt;?&gt; formatter);

	void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

	void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

	void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the preceding listing, you can register formatters by field type or by annotation.</p>
</div>
<div class="paragraph">
<p>The <code>FormatterRegistry</code> SPI lets you configure formatting rules centrally, instead of
duplicating such configuration across your controllers. For example, you might want to
enforce that all date fields are formatted a certain way or that fields with a specific
annotation are formatted in a certain way. With a shared <code>FormatterRegistry</code>, you define
these rules once, and they are applied whenever formatting is needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a>The <code>FormatterRegistrar</code> SPI</h3>
<div class="paragraph">
<p><code>FormatterRegistrar</code> is an SPI for registering formatters and converters through the
FormatterRegistry. The following listing shows its interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.format;

public interface FormatterRegistrar {

	void registerFormatters(FormatterRegistry registry);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>FormatterRegistrar</code> is useful when registering multiple related converters and
formatters for a given formatting category, such as date formatting. It can also be
useful where declarative registration is insufficient&#8201;&#8212;&#8201;for example, when a formatter
needs to be indexed under a specific field type different from its own <code>&lt;T&gt;</code> or when
registering a <code>Printer</code>/<code>Parser</code> pair. The next section provides more information on
converter and formatter registration.</p>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a>Configuring Formatting in Spring MVC</h3>
<div class="paragraph">
<p>See <a href="../web.html#mvc-config-conversion" class="page">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a>Configuring a Global Date and Time Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, date and time fields not annotated with <code>@DateTimeFormat</code> are converted from
strings by using the <code>DateFormat.SHORT</code> style. If you prefer, you can change this by
defining your own global format.</p>
</div>
<div class="paragraph">
<p>To do that, ensure that Spring does not register default formatters. Instead, register
formatters manually with the help of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.format.datetime.standard.DateTimeFormatterRegistrar</code></p>
</li>
<li>
<p><code>org.springframework.format.datetime.DateFormatterRegistrar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the following Java configuration registers a global <code>yyyyMMdd</code> format:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AppConfig {

	@Bean
	public FormattingConversionService conversionService() {

		// Use the DefaultFormattingConversionService but do not register defaults
		DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

		// Ensure @NumberFormat is still supported
		conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

		// Register JSR-310 date conversion with a specific global format
		DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
		registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"));
		registrar.registerFormatters(conversionService);

		// Register date conversion with a specific global format
		DateFormatterRegistrar registrar = new DateFormatterRegistrar();
		registrar.setFormatter(new DateFormatter("yyyyMMdd"));
		registrar.registerFormatters(conversionService);

		return conversionService;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class AppConfig {

	@Bean
	fun conversionService(): FormattingConversionService {
		// Use the DefaultFormattingConversionService but do not register defaults
		return DefaultFormattingConversionService(false).apply {

			// Ensure @NumberFormat is still supported
			addFormatterForFieldAnnotation(NumberFormatAnnotationFormatterFactory())

			// Register JSR-310 date conversion with a specific global format
			val registrar = DateTimeFormatterRegistrar()
			registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"))
			registrar.registerFormatters(this)

			// Register date conversion with a specific global format
			val registrar = DateFormatterRegistrar()
			registrar.setFormatter(DateFormatter("yyyyMMdd"))
			registrar.registerFormatters(this)
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML-based configuration, you can use a
<code>FormattingConversionServiceFactoryBean</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

	&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
		&lt;property name="registerDefaultFormatters" value="false" /&gt;
		&lt;property name="formatters"&gt;
			&lt;set&gt;
				&lt;bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" /&gt;
			&lt;/set&gt;
		&lt;/property&gt;
		&lt;property name="formatterRegistrars"&gt;
			&lt;set&gt;
				&lt;bean class="org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"&gt;
					&lt;property name="dateFormatter"&gt;
						&lt;bean class="org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean"&gt;
							&lt;property name="pattern" value="yyyyMMdd"/&gt;
						&lt;/bean&gt;
					&lt;/property&gt;
				&lt;/bean&gt;
			&lt;/set&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note there are extra considerations when configuring date and time formats in web
applications. Please see
<a href="../web.html#mvc-config-conversion" class="page">WebMVC Conversion and Formatting</a> or
<a href="../web-reactive.html#webflux-config-conversion" class="page">WebFlux Conversion and Formatting</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a>Java Bean Validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Framework provides support for the
<a href="https://beanvalidation.org/">Java Bean Validation</a> API.</p>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a>Overview of Bean Validation</h3>
<div class="paragraph">
<p>Bean Validation provides a common way of validation through constraint declaration and
metadata for Java applications. To use it, you annotate domain model properties with
declarative validation constraints which are then enforced by the runtime. There are
built-in constraints, and you can also define your own custom constraints.</p>
</div>
<div class="paragraph">
<p>Consider the following example, which shows a simple <code>PersonForm</code> model with two properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonForm {
	private String name;
	private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PersonForm(
		private val name: String,
		private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean Validation lets you declare constraints as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonForm {

	@NotNull
	@Size(max=64)
	private String name;

	@Min(0)
	private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PersonForm(
	@get:NotNull @get:Size(max=64)
	private val name: String,
	@get:Min(0)
	private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Bean Validation validator then validates instances of this class based on the declared
constraints. See <a href="https://beanvalidation.org/">Bean Validation</a> for general information about
the API. See the <a href="https://hibernate.org/validator/">Hibernate Validator</a> documentation for
specific constraints. To learn how to set up a bean validation provider as a Spring
bean, keep reading.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a>Configuring a Bean Validation Provider</h3>
<div class="paragraph">
<p>Spring provides full support for the Bean Validation API including the bootstrapping of a
Bean Validation provider as a Spring bean. This lets you inject a
<code>javax.validation.ValidatorFactory</code> or <code>javax.validation.Validator</code> wherever validation is
needed in your application.</p>
</div>
<div class="paragraph">
<p>You can use the <code>LocalValidatorFactoryBean</code> to configure a default Validator as a Spring
bean, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class AppConfig {

	@Bean
	public LocalValidatorFactoryBean validator() {
		return new LocalValidatorFactoryBean();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="validator"
	class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic configuration in the preceding example triggers bean validation to initialize by
using its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate
Validator, is expected to be present in the classpath and is automatically detected.</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>Injecting a Validator</h4>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code> implements both <code>javax.validation.ValidatorFactory</code> and
<code>javax.validation.Validator</code>, as well as Spring&#8217;s <code>org.springframework.validation.Validator</code>.
You can inject a reference to either of these interfaces into beans that need to invoke
validation logic.</p>
</div>
<div class="paragraph">
<p>You can inject a reference to <code>javax.validation.Validator</code> if you prefer to work with the Bean
Validation API directly, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.validation.Validator;

@Service
public class MyService {

	@Autowired
	private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import javax.validation.Validator;

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can inject a reference to <code>org.springframework.validation.Validator</code> if your bean
requires the Spring Validation API, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.validation.Validator;

@Service
public class MyService {

	@Autowired
	private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.validation.Validator

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>Configuring Custom Constraints</h4>
<div class="paragraph">
<p>Each bean validation constraint consists of two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>@Constraint</code> annotation that declares the constraint and its configurable properties.</p>
</li>
<li>
<p>An implementation of the <code>javax.validation.ConstraintValidator</code> interface that implements
the constraint&#8217;s behavior.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To associate a declaration with an implementation, each <code>@Constraint</code> annotation
references a corresponding <code>ConstraintValidator</code> implementation class. At runtime, a
<code>ConstraintValidatorFactory</code> instantiates the referenced implementation when the
constraint annotation is encountered in your domain model.</p>
</div>
<div class="paragraph">
<p>By default, the <code>LocalValidatorFactoryBean</code> configures a <code>SpringConstraintValidatorFactory</code>
that uses Spring to create <code>ConstraintValidator</code> instances. This lets your custom
<code>ConstraintValidators</code> benefit from dependency injection like any other Spring bean.</p>
</div>
<div class="paragraph">
<p>The following example shows a custom <code>@Constraint</code> declaration followed by an associated
<code>ConstraintValidator</code> implementation that uses Spring for dependency injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = MyConstraintValidator::class)
annotation class MyConstraint</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

	@Autowired;
	private Foo aDependency;

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import javax.validation.ConstraintValidator

class MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator {

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the preceding example shows, a <code>ConstraintValidator</code> implementation can have its dependencies
<code>@Autowired</code> as any other Spring bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a>Spring-driven Method Validation</h4>
<div class="paragraph">
<p>You can integrate the method validation feature supported by Bean Validation 1.1 (and, as
a custom extension, also by Hibernate Validator 4.3) into a Spring context through a
<code>MethodValidationPostProcessor</code> bean definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration
public class AppConfig {

	@Bean
	public MethodValidationPostProcessor validationPostProcessor() {
		return new MethodValidationPostProcessor();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To be eligible for Spring-driven method validation, all target classes need to be annotated
with Spring&#8217;s <code>@Validated</code> annotation, which can optionally also declare the validation
groups to use. See
{api-spring-framework}/validation/beanvalidation/MethodValidationPostProcessor.html[<code>MethodValidationPostProcessor</code>]
for setup details with the Hibernate Validator and Bean Validation 1.1 providers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Method validation relies on <a href="../core.html#aop-introduction-proxies" class="page">AOP Proxies</a> around the
target classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies.
There are certain limitations with the use of proxies, some of which are described in
<a href="../core.html#aop-understanding-aop-proxies" class="page">Understanding AOP Proxies</a>. In addition remember
to always use methods and accessors on proxied classes; direct field access will not work.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>Additional Configuration Options</h4>
<div class="paragraph">
<p>The default <code>LocalValidatorFactoryBean</code> configuration suffices for most
cases. There are a number of configuration options for various Bean Validation
constructs, from message interpolation to traversal resolution. See the
{api-spring-framework}/validation/beanvalidation/LocalValidatorFactoryBean.html[<code>LocalValidatorFactoryBean</code>]
javadoc for more information on these options.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validation-binder"><a class="anchor" href="#validation-binder"></a>Configuring a <code>DataBinder</code></h3>
<div class="paragraph">
<p>Since Spring 3, you can configure a <code>DataBinder</code> instance with a <code>Validator</code>. Once
configured, you can invoke the <code>Validator</code> by calling <code>binder.validate()</code>. Any validation
<code>Errors</code> are automatically added to the binder&#8217;s <code>BindingResult</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use a <code>DataBinder</code> programmatically to invoke validation
logic after binding to a target object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val target = Foo()
val binder = DataBinder(target)
binder.validator = FooValidator()

// bind to the target object
binder.bind(propertyValues)

// validate the target object
binder.validate()

// get BindingResult that includes any validation errors
val results = binder.bindingResult</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure a <code>DataBinder</code> with multiple <code>Validator</code> instances through
<code>dataBinder.addValidators</code> and <code>dataBinder.replaceValidators</code>. This is useful when
combining globally configured bean validation with a Spring <code>Validator</code> configured
locally on a DataBinder instance. See
<a href="../web.html#mvc-config-validation" class="page">Spring MVC Validation Configuration</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a>Spring MVC 3 Validation</h3>
<div class="paragraph">
<p>See <a href="../web.html#mvc-config-validation" class="page">Validation</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
