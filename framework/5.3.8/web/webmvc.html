<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring Web MVC :: Spring</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Spring</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Why Spring</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Reactive</a>
            <a class="navbar-item" href="#">Event Driven</a>
            <a class="navbar-item" href="#">Cloud</a>
            <a class="navbar-item" href="#">Web Applications</a>
            <a class="navbar-item" href="#">Serverless</a>
            <a class="navbar-item" href="#">Batch</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Quickstart</a>
            <a class="navbar-item" href="#">Guides</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Projects</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Spring Boot</a>
            <a class="navbar-item" href="#">...</a>
          </div>
        </div>

        <a class="navbar-item" href="#">Training</a>
        <a class="navbar-item" href="#">Support</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Overview</a>
            <a class="navbar-item" href="#">Events</a>
            <a class="navbar-item" href="#">Team</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework" data-version="5.3.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Spring Framework</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../core.html">Core</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../data-access.html">Data Access</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web.html">Web Servlet</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web-reactive.html">Web Reactive</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../integration.html">Integration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../languages.html">Languages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../appendix.html">Appendix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Spring Framework</span>
    <span class="version">5.3.8</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Spring Framework</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">5.3.8</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../security/5.6.0/overview/prerequisites.html">Spring Security</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../security/5.6.0/overview/prerequisites.html">5.6.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Spring Framework</a></li>
    <li><a href="webmvc.html">Spring Web MVC</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/rwinch/spring-framework/edit/antora-2.x/src/docs/antora/modules/ROOT/pages/web/webmvc.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Spring Web MVC</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Web MVC is the original web framework built on the Servlet API and has been included
in the Spring Framework from the very beginning. The formal name, &#8220;Spring Web MVC,&#8221;
comes from the name of its source module
({spring-framework-main-code}/spring-webmvc[<code>spring-webmvc</code>]),
but it is more commonly known as &#8220;Spring MVC&#8221;.</p>
</div>
<div class="paragraph">
<p>Parallel to Spring Web MVC, Spring Framework 5.0 introduced a reactive-stack web framework
whose name, &#8220;Spring WebFlux,&#8221; is also based on its source module
({spring-framework-main-code}/spring-webflux[<code>spring-webflux</code>]).
This section covers Spring Web MVC. The <a href="../web-reactive.html#spring-web-reactive" class="page">next section</a>
covers Spring WebFlux.</p>
</div>
<div class="paragraph">
<p>For baseline information and compatibility with Servlet container and Java EE version
ranges, see the Spring Framework
<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-servlet"><a class="anchor" href="#mvc-servlet"></a>DispatcherServlet</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-dispatcher-handler" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC, as many other web frameworks, is designed around the front controller
pattern where a central <code>Servlet</code>, the <code>DispatcherServlet</code>, provides a shared algorithm
for request processing, while actual work is performed by configurable delegate components.
This model is flexible and supports diverse workflows.</p>
</div>
<div class="paragraph">
<p>The <code>DispatcherServlet</code>, as any <code>Servlet</code>, needs to be declared and mapped according
to the Servlet specification by using Java configuration or in <code>web.xml</code>.
In turn, the <code>DispatcherServlet</code> uses Spring configuration to discover
the delegate components it needs for request mapping, view resolution, exception
handling, <a href="#mvc-servlet-special-bean-types">and more</a>.</p>
</div>
<div class="paragraph">
<p>The following example of the Java configuration registers and initializes
the <code>DispatcherServlet</code>, which is auto-detected by the Servlet container
(see <a href="#mvc-container-config">Servlet Config</a>):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWebApplicationInitializer implements WebApplicationInitializer {

	@Override
	public void onStartup(ServletContext servletContext) {

		// Load Spring web application configuration
		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
		context.register(AppConfig.class);

		// Create and register the DispatcherServlet
		DispatcherServlet servlet = new DispatcherServlet(context);
		ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
		registration.setLoadOnStartup(1);
		registration.addMapping("/app/*");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebApplicationInitializer : WebApplicationInitializer {

	override fun onStartup(servletContext: ServletContext) {

		// Load Spring web application configuration
		val context = AnnotationConfigWebApplicationContext()
		context.register(AppConfig::class.java)

		// Create and register the DispatcherServlet
		val servlet = DispatcherServlet(context)
		val registration = servletContext.addServlet("app", servlet)
		registration.setLoadOnStartup(1)
		registration.addMapping("/app/*")
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In addition to using the ServletContext API directly, you can also extend
<code>AbstractAnnotationConfigDispatcherServletInitializer</code> and override specific methods
(see the example under <a href="#mvc-servlet-context-hierarchy">Context Hierarchy</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example of <code>web.xml</code> configuration registers and initializes the <code>DispatcherServlet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app&gt;

	&lt;listener&gt;
		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
	&lt;/listener&gt;

	&lt;context-param&gt;
		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		&lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;
	&lt;/context-param&gt;

	&lt;servlet&gt;
		&lt;servlet-name&gt;app&lt;/servlet-name&gt;
		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
		&lt;init-param&gt;
			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
			&lt;param-value&gt;&lt;/param-value&gt;
		&lt;/init-param&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;app&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot follows a different initialization sequence. Rather than hooking into
the lifecycle of the Servlet container, Spring Boot uses Spring configuration to
bootstrap itself and the embedded Servlet container. <code>Filter</code> and <code>Servlet</code> declarations
are detected in Spring configuration and registered with the Servlet container.
For more details, see the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container">Spring Boot documentation</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mvc-servlet-context-hierarchy"><a class="anchor" href="#mvc-servlet-context-hierarchy"></a>Context Hierarchy</h3>
<div class="paragraph">
<p><code>DispatcherServlet</code> expects a <code>WebApplicationContext</code> (an extension of a plain
<code>ApplicationContext</code>) for its own configuration. <code>WebApplicationContext</code> has a link to the
<code>ServletContext</code> and the <code>Servlet</code> with which it is associated. It is also bound to the <code>ServletContext</code>
such that applications can use static methods on <code>RequestContextUtils</code> to look up the
<code>WebApplicationContext</code> if they need access to it.</p>
</div>
<div class="paragraph">
<p>For many applications, having a single <code>WebApplicationContext</code> is simple and suffices.
It is also possible to have a context hierarchy where one root <code>WebApplicationContext</code>
is shared across multiple <code>DispatcherServlet</code> (or other <code>Servlet</code>) instances, each with
its own child <code>WebApplicationContext</code> configuration.
See <a href="../core.html#context-introduction" class="page">Additional Capabilities of the <code>ApplicationContext</code></a>
for more on the context hierarchy feature.</p>
</div>
<div class="paragraph">
<p>The root <code>WebApplicationContext</code> typically contains infrastructure beans, such as data repositories and
business services that need to be shared across multiple <code>Servlet</code> instances. Those beans
are effectively inherited and can be overridden (that is, re-declared) in the Servlet-specific
child <code>WebApplicationContext</code>, which typically contains beans local to the given <code>Servlet</code>.
The following image shows this relationship:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/images/mvc-context-hierarchy.png" alt="mvc context hierarchy">
</div>
</div>
<div class="paragraph">
<p>The following example configures a <code>WebApplicationContext</code> hierarchy:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class&lt;?&gt;[] { RootConfig.class };
	}

	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return new Class&lt;?&gt;[] { App1Config.class };
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/app1/*" };
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

	override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt; {
		return arrayOf(RootConfig::class.java)
	}

	override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt; {
		return arrayOf(App1Config::class.java)
	}

	override fun getServletMappings(): Array&lt;String&gt; {
		return arrayOf("/app1/*")
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If an application context hierarchy is not required, applications can return all
configuration through <code>getRootConfigClasses()</code> and <code>null</code> from <code>getServletConfigClasses()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the <code>web.xml</code> equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app&gt;

	&lt;listener&gt;
		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
	&lt;/listener&gt;

	&lt;context-param&gt;
		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
		&lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;
	&lt;/context-param&gt;

	&lt;servlet&gt;
		&lt;servlet-name&gt;app1&lt;/servlet-name&gt;
		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
		&lt;init-param&gt;
			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
			&lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;
		&lt;/init-param&gt;
		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;app1&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If an application context hierarchy is not required, applications may configure a
&#8220;root&#8221; context only and leave the <code>contextConfigLocation</code> Servlet parameter empty.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-servlet-special-bean-types"><a class="anchor" href="#mvc-servlet-special-bean-types"></a>Special Bean Types</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-special-bean-types" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherServlet</code> delegates to special beans to process requests and render the
appropriate responses. By &#8220;special beans&#8221; we mean Spring-managed <code>Object</code> instances that
implement framework contracts. Those usually come with built-in contracts, but
you can customize their properties and extend or replace them.</p>
</div>
<div class="paragraph">
<p>The following table lists the special beans detected by the <code>DispatcherServlet</code>:</p>
</div>
<table id="mvc-webappctx-special-beans-tbl" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean type</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map a request to a handler along with a list of
  <a href="#mvc-handlermapping-interceptor">interceptors</a> for pre- and post-processing.
  The mapping is based on some criteria, the details of which vary by <code>HandlerMapping</code>
  implementation.</p>
<p class="tableblock">  The two main <code>HandlerMapping</code> implementations are <code>RequestMappingHandlerMapping</code>
  (which supports <code>@RequestMapping</code> annotated methods) and <code>SimpleUrlHandlerMapping</code>
  (which maintains explicit registrations of URI path patterns to handlers).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Help the <code>DispatcherServlet</code> to invoke a handler mapped to a request, regardless of
  how the handler is actually invoked. For example, invoking an annotated controller
  requires resolving annotations. The main purpose of a <code>HandlerAdapter</code> is
  to shield the <code>DispatcherServlet</code> from such details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strategy to resolve exceptions, possibly mapping them to handlers, to HTML error
  views, or other targets. See <a href="#mvc-exceptionhandlers">Exceptions</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-viewresolver"><code>ViewResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolve logical <code>String</code>-based view names returned from a handler to an actual <code>View</code>
  with which to render to the response. See <a href="#mvc-viewresolver">View Resolution</a> and <a href="#mvc-view">View Technologies</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-localeresolver"><code>LocaleResolver</code></a>, <a href="#mvc-timezone">LocaleContextResolver</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolve the <code>Locale</code> a client is using and possibly their time zone, in order to be able
  to offer internationalized views. See <a href="#mvc-localeresolver">Locale</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-themeresolver"><code>ThemeResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolve themes your web application can use&#8201;&#8212;&#8201;for example, to offer personalized layouts.
  See <a href="#mvc-themeresolver">Themes</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-multipart"><code>MultipartResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abstraction for parsing a multi-part request (for example, browser form file upload) with
  the help of some multipart parsing library. See <a href="#mvc-multipart">Multipart Resolver</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-flash-attributes"><code>FlashMapManager</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store and retrieve the &#8220;input&#8221; and the &#8220;output&#8221; <code>FlashMap</code> that can be used to pass
  attributes from one request to another, usually across a redirect.
  See <a href="#mvc-flash-attributes">Flash Attributes</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="mvc-servlet-config"><a class="anchor" href="#mvc-servlet-config"></a>Web MVC Config</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-framework-config" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Applications can declare the infrastructure beans listed in <a href="#mvc-servlet-special-bean-types">Special Bean Types</a>
that are required to process requests. The <code>DispatcherServlet</code> checks the
<code>WebApplicationContext</code> for each special bean. If there are no matching bean types,
it falls back on the default types listed in
{spring-framework-main-code}/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties[<code>DispatcherServlet.properties</code>].</p>
</div>
<div class="paragraph">
<p>In most cases, the <a href="#mvc-config">MVC Config</a> is the best starting point. It declares the required
beans in either Java or XML and provides a higher-level configuration callback API to
customize it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot relies on the MVC Java configuration to configure Spring MVC and
provides many extra convenient options.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-container-config"><a class="anchor" href="#mvc-container-config"></a>Servlet Config</h3>
<div class="paragraph">
<p>In a Servlet 3.0+ environment, you have the option of configuring the Servlet container
programmatically as an alternative or in combination with a <code>web.xml</code> file. The following
example registers a <code>DispatcherServlet</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

	@Override
	public void onStartup(ServletContext container) {
		XmlWebApplicationContext appContext = new XmlWebApplicationContext();
		appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

		ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
		registration.setLoadOnStartup(1);
		registration.addMapping("/");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.WebApplicationInitializer

class MyWebApplicationInitializer : WebApplicationInitializer {

	override fun onStartup(container: ServletContext) {
		val appContext = XmlWebApplicationContext()
		appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")

		val registration = container.addServlet("dispatcher", DispatcherServlet(appContext))
		registration.setLoadOnStartup(1)
		registration.addMapping("/")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebApplicationInitializer</code> is an interface provided by Spring MVC that ensures your
implementation is detected and automatically used to initialize any Servlet 3 container.
An abstract base class implementation of <code>WebApplicationInitializer</code> named
<code>AbstractDispatcherServletInitializer</code> makes it even easier to register the
<code>DispatcherServlet</code> by overriding methods to specify the servlet mapping and the
location of the <code>DispatcherServlet</code> configuration.</p>
</div>
<div class="paragraph">
<p>This is recommended for applications that use Java-based Spring configuration, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return null;
	}

	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return new Class&lt;?&gt;[] { MyWebConfig.class };
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

	override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
		return null
	}

	override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
		return arrayOf(MyWebConfig::class.java)
	}

	override fun getServletMappings(): Array&lt;String&gt; {
		return arrayOf("/")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use XML-based Spring configuration, you should extend directly from
<code>AbstractDispatcherServletInitializer</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

	@Override
	protected WebApplicationContext createRootApplicationContext() {
		return null;
	}

	@Override
	protected WebApplicationContext createServletApplicationContext() {
		XmlWebApplicationContext cxt = new XmlWebApplicationContext();
		cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
		return cxt;
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

	override fun createRootApplicationContext(): WebApplicationContext? {
		return null
	}

	override fun createServletApplicationContext(): WebApplicationContext {
		return XmlWebApplicationContext().apply {
			setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")
		}
	}

	override fun getServletMappings(): Array&lt;String&gt; {
		return arrayOf("/")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AbstractDispatcherServletInitializer</code> also provides a convenient way to add <code>Filter</code>
instances and have them be automatically mapped to the <code>DispatcherServlet</code>, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

	// ...

	@Override
	protected Filter[] getServletFilters() {
		return new Filter[] {
			new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

	// ...

	override fun getServletFilters(): Array&lt;Filter&gt; {
		return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter())
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each filter is added with a default name based on its concrete type and automatically
mapped to the <code>DispatcherServlet</code>.</p>
</div>
<div class="paragraph">
<p>The <code>isAsyncSupported</code> protected method of <code>AbstractDispatcherServletInitializer</code>
provides a single place to enable async support on the <code>DispatcherServlet</code> and all
filters mapped to it. By default, this flag is set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Finally, if you need to further customize the <code>DispatcherServlet</code> itself, you can
override the <code>createDispatcherServlet</code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-servlet-sequence"><a class="anchor" href="#mvc-servlet-sequence"></a>Processing</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-dispatcher-handler-sequence" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherServlet</code> processes requests as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>WebApplicationContext</code> is searched for and bound in the request as an attribute
that the controller and other elements in the process can use. It is bound by default
under the <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key.</p>
</li>
<li>
<p>The locale resolver is bound to the request to let elements in the process
resolve the locale to use when processing the request (rendering the view, preparing
data, and so on). If you do not need locale resolving, you do not need the locale resolver.</p>
</li>
<li>
<p>The theme resolver is bound to the request to let elements such as views determine
which theme to use. If you do not use themes, you can ignore it.</p>
</li>
<li>
<p>If you specify a multipart file resolver, the request is inspected for multiparts. If
multiparts are found, the request is wrapped in a <code>MultipartHttpServletRequest</code> for
further processing by other elements in the process. See <a href="#mvc-multipart">Multipart Resolver</a> for further
information about multipart handling.</p>
</li>
<li>
<p>An appropriate handler is searched for. If a handler is found, the execution chain
associated with the handler (preprocessors, postprocessors, and controllers) is
run to prepare a model for rendering. Alternatively, for annotated
controllers, the response can be rendered (within the <code>HandlerAdapter</code>) instead of
returning a view.</p>
</li>
<li>
<p>If a model is returned, the view is rendered. If no model is returned (maybe due to
a preprocessor or postprocessor intercepting the request, perhaps for security
reasons), no view is rendered, because the request could already have been fulfilled.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>HandlerExceptionResolver</code> beans declared in the <code>WebApplicationContext</code> are used to
resolve exceptions thrown during request processing. Those exception resolvers allow
customizing the logic to address exceptions. See <a href="#mvc-exceptionhandlers">Exceptions</a> for more details.</p>
</div>
<div class="paragraph">
<p>The Spring <code>DispatcherServlet</code> also supports the return of the
<code>last-modification-date</code>, as specified by the Servlet API. The process of determining
the last modification date for a specific request is straightforward: The
<code>DispatcherServlet</code> looks up an appropriate handler mapping and tests whether the
handler that is found implements the <code>LastModified</code> interface. If so, the value of the
<code>long getLastModified(request)</code> method of the <code>LastModified</code> interface is returned to
the client.</p>
</div>
<div class="paragraph">
<p>You can customize individual <code>DispatcherServlet</code> instances by adding Servlet
initialization parameters (<code>init-param</code> elements) to the Servlet declaration in the
<code>web.xml</code> file. The following table lists the supported parameters:</p>
</div>
<table id="mvc-disp-servlet-init-params-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. DispatcherServlet initialization parameters</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class that implements <code>ConfigurableWebApplicationContext</code>, to be instantiated and
  locally configured by this Servlet. By default, <code>XmlWebApplicationContext</code> is used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextConfigLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String that is passed to the context instance (specified by <code>contextClass</code>) to
  indicate where contexts can be found. The string consists potentially of multiple
  strings (using a comma as a delimiter) to support multiple contexts. In the case of
  multiple context locations with beans that are defined twice, the latest location
  takes precedence.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>namespace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespace of the <code>WebApplicationContext</code>. Defaults to <code>[servlet-name]-servlet</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>throwExceptionIfNoHandlerFound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to throw a <code>NoHandlerFoundException</code> when no handler was found for a request.
  The exception can then be caught with a <code>HandlerExceptionResolver</code> (for example, by using an
  <code>@ExceptionHandler</code> controller method) and handled as any others.</p>
<p class="tableblock">  By default, this is set to <code>false</code>, in which case the <code>DispatcherServlet</code> sets the
  response status to 404 (NOT_FOUND) without raising an exception.</p>
<p class="tableblock">  Note that, if <a href="#mvc-default-servlet-handler">default servlet handling</a>  is
  also configured, unresolved requests are always forwarded to the default servlet
  and a 404 is never raised.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="mvc-handlermapping-path"><a class="anchor" href="#mvc-handlermapping-path"></a>Path Matching</h3>
<div class="paragraph">
<p>The Servlet API exposes the full request path as <code>requestURI</code> and further sub-divides it
into <code>contextPath</code>, <code>servletPath</code>, and <code>pathInfo</code> whose values vary depending on how a
Servlet is mapped. From these inputs, Spring MVC needs to determine the lookup path to
use for handler mapping, which is the path within the mapping of the <code>DispatcherServlet</code>
itself, excluding the <code>contextPath</code> and any <code>servletMapping</code> prefix, if present.</p>
</div>
<div class="paragraph">
<p>The <code>servletPath</code> and <code>pathInfo</code> are decoded and that makes them impossible to compare
directly to the full <code>requestURI</code> in order to derive the lookupPath and that makes it
necessary to decode the <code>requestUri</code>. However this introduces its own issues because the
path may contain encoded reserved characters such as <code>"/"</code> or <code>";"</code> that can in turn
alter the structure of the path after they are decoded which can also lead to security
issues. In addition, Servlet containers may normalize the <code>servletPath</code> to varying
degrees which makes it further impossible to perform <code>startsWith</code> comparisons against
the <code>requestUri</code>.</p>
</div>
<div class="paragraph">
<p>This is why it is best to avoid reliance on the <code>servletPath</code> which comes with the
prefix-based <code>servletPath</code> mapping type. If the <code>DispatcherServlet</code> is mapped as the
default Servlet with <code>"/"</code> or otherwise without a prefix with <code>"/*"</code> and the Servlet
container is 4.0+ then Spring MVC is able to detect the Servlet mapping type and avoid
use of the <code>servletPath</code> and <code>pathInfo</code> altogether. On a 3.1 Servlet container,
assuming the same Servlet mapping types, the equivalent can be achieved by providing
a <code>UrlPathHelper</code> with <code>alwaysUseFullPath=true</code> via <a href="#mvc-config-path-matching">Path Matching</a> in
the MVC config.</p>
</div>
<div class="paragraph">
<p>Fortunately the default Servlet mapping <code>"/"</code> is a good choice. However, there is still
an issue in that the <code>requestUri</code> needs to be decoded to make it possible to compare to
controller mappings. This is again undesirable because of the potential to decode
reserved characters that alter the path structure. If such characters are not expected,
then you can reject them (like the Spring Security HTTP firewall), or you can configure
<code>UrlPathHelper</code> with <code>urlDecode=false</code> but controller mappings will need to match to the
encoded path which may not always work well. Furthermore, sometimes the
<code>DispatcherServlet</code> needs to share the URL space with another Servlet and may need to
be mapped by prefix.</p>
</div>
<div class="paragraph">
<p>The above issues can be addressed more comprehensively by switching from <code>PathMatcher</code> to
the parsed <code>PathPattern</code> available in 5.3 or higher, see
<a href="#mvc-ann-requestmapping-pattern-comparison">Pattern Comparison</a>. Unlike <code>AntPathMatcher</code> which needs
either the lookup path decoded or the controller mapping encoded, a parsed <code>PathPattern</code>
matches to a parsed representation of the path called <code>RequestPath</code>, one path segment
at a time. This allows decoding and sanitizing path segment values individually without
the risk of altering the structure of the path. Parsed <code>PathPattern</code> also supports
the use of <code>servletPath</code> prefix mapping as long as the prefix is kept simple and does
not have any characters that need to be encoded.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-handlermapping-interceptor"><a class="anchor" href="#mvc-handlermapping-interceptor"></a>Interception</h3>
<div class="paragraph">
<p>All <code>HandlerMapping</code> implementations support handler interceptors that are useful when
you want to apply specific functionality to certain requests&#8201;&#8212;&#8201;for example, checking for
a principal. Interceptors must implement <code>HandlerInterceptor</code> from the
<code>org.springframework.web.servlet</code> package with three methods that should provide enough
flexibility to do all kinds of pre-processing and post-processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>preHandle(..)</code>: Before the actual handler is run</p>
</li>
<li>
<p><code>postHandle(..)</code>: After the handler is run</p>
</li>
<li>
<p><code>afterCompletion(..)</code>: After the complete request has finished</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>preHandle(..)</code> method returns a boolean value. You can use this method to break or
continue the processing of the execution chain. When this method returns <code>true</code>, the
handler execution chain continues. When it returns false, the <code>DispatcherServlet</code>
assumes the interceptor itself has taken care of requests (and, for example, rendered an
appropriate view) and does not continue executing the other interceptors and the actual
handler in the execution chain.</p>
</div>
<div class="paragraph">
<p>See <a href="#mvc-config-interceptors">Interceptors</a> in the section on MVC configuration for examples of how to
configure interceptors. You can also register them directly by using setters on individual
<code>HandlerMapping</code> implementations.</p>
</div>
<div class="paragraph">
<p>Note that <code>postHandle</code> is less useful with <code>@ResponseBody</code> and <code>ResponseEntity</code> methods for
which the response is written and committed within the <code>HandlerAdapter</code> and before
<code>postHandle</code>. That means it is too late to make any changes to the response, such as adding
an extra header. For such scenarios, you can implement <code>ResponseBodyAdvice</code> and either
declare it as an <a href="#mvc-ann-controller-advice">Controller Advice</a> bean or configure it directly on
<code>RequestMappingHandlerAdapter</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-exceptionhandlers"><a class="anchor" href="#mvc-exceptionhandlers"></a>Exceptions</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-dispatcher-exceptions" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>If an exception occurs during request mapping or is thrown from a request handler (such as
a <code>@Controller</code>), the <code>DispatcherServlet</code> delegates to a chain of <code>HandlerExceptionResolver</code>
beans to resolve the exception and provide alternative handling, which is typically an
error response.</p>
</div>
<div class="paragraph">
<p>The following table lists the available <code>HandlerExceptionResolver</code> implementations:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. HandlerExceptionResolver implementations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>HandlerExceptionResolver</code></th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleMappingExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A mapping between exception class names and error view names. Useful for rendering
  error pages in a browser application.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{api-spring-framework}/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html[<code>DefaultHandlerExceptionResolver</code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolves exceptions raised by Spring MVC and maps them to HTTP status codes.
  See also alternative <code>ResponseEntityExceptionHandler</code> and <a href="#mvc-ann-rest-exceptions">REST API exceptions</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolves exceptions with the <code>@ResponseStatus</code> annotation and maps them to HTTP status
  codes based on the value in the annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionHandlerExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolves exceptions by invoking an <code>@ExceptionHandler</code> method in a <code>@Controller</code> or a
  <code>@ControllerAdvice</code> class. See <a href="#mvc-ann-exceptionhandler">@ExceptionHandler methods</a>.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="mvc-excetionhandlers-handling"><a class="anchor" href="#mvc-excetionhandlers-handling"></a>Chain of Resolvers</h4>
<div class="paragraph">
<p>You can form an exception resolver chain by declaring multiple <code>HandlerExceptionResolver</code>
beans in your Spring configuration and setting their <code>order</code> properties as needed.
The higher the order property, the later the exception resolver is positioned.</p>
</div>
<div class="paragraph">
<p>The contract of <code>HandlerExceptionResolver</code> specifies that it can return:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <code>ModelAndView</code> that points to an error view.</p>
</li>
<li>
<p>An empty <code>ModelAndView</code> if the exception was handled within the resolver.</p>
</li>
<li>
<p><code>null</code> if the exception remains unresolved, for subsequent resolvers to try, and, if the
exception remains at the end, it is allowed to bubble up to the Servlet container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <a href="#mvc-config">MVC Config</a> automatically declares built-in resolvers for default Spring MVC
exceptions, for <code>@ResponseStatus</code> annotated exceptions, and for support of
<code>@ExceptionHandler</code> methods. You can customize that list or replace it.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-customer-servlet-container-error-page"><a class="anchor" href="#mvc-ann-customer-servlet-container-error-page"></a>Container Error Page</h4>
<div class="paragraph">
<p>If an exception remains unresolved by any <code>HandlerExceptionResolver</code> and is, therefore,
left to propagate or if the response status is set to an error status (that is, 4xx, 5xx),
Servlet containers can render a default error page in HTML. To customize the default
error page of the container, you can declare an error page mapping in <code>web.xml</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;error-page&gt;
	&lt;location&gt;/error&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, when an exception bubbles up or the response has an error status, the
Servlet container makes an ERROR dispatch within the container to the configured URL
(for example, <code>/error</code>). This is then processed by the <code>DispatcherServlet</code>, possibly mapping it
to a <code>@Controller</code>, which could be implemented to return an error view name with a model
or to render a JSON response, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class ErrorController {

	@RequestMapping(path = "/error")
	public Map&lt;String, Object&gt; handle(HttpServletRequest request) {
		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
		map.put("status", request.getAttribute("javax.servlet.error.status_code"));
		map.put("reason", request.getAttribute("javax.servlet.error.message"));
		return map;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RestController
class ErrorController {

	@RequestMapping(path = ["/error"])
	fun handle(request: HttpServletRequest): Map&lt;String, Any&gt; {
		val map = HashMap&lt;String, Any&gt;()
		map["status"] = request.getAttribute("javax.servlet.error.status_code")
		map["reason"] = request.getAttribute("javax.servlet.error.message")
		return map
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Servlet API does not provide a way to create error page mappings in Java. You can,
however, use both a <code>WebApplicationInitializer</code> and a minimal <code>web.xml</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-viewresolver"><a class="anchor" href="#mvc-viewresolver"></a>View Resolution</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-viewresolution" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC defines the <code>ViewResolver</code> and <code>View</code> interfaces that let you render
models in a browser without tying you to a specific view technology. <code>ViewResolver</code>
provides a mapping between view names and actual views. <code>View</code> addresses the preparation
of data before handing over to a specific view technology.</p>
</div>
<div class="paragraph">
<p>The following table provides more details on the <code>ViewResolver</code> hierarchy:</p>
</div>
<table id="mvc-view-resolvers-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. ViewResolver implementations</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ViewResolver</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractCachingViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Subclasses of <code>AbstractCachingViewResolver</code> cache view instances that they resolve.
  Caching improves performance of certain view technologies. You can turn off the
  cache by setting the <code>cache</code> property to <code>false</code>. Furthermore, if you must refresh
  a certain view at runtime (for example, when a FreeMarker template is modified),
  you can use the <code>removeFromCache(String viewName, Locale loc)</code> method.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UrlBasedViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple implementation of the <code>ViewResolver</code> interface that affects the direct
  resolution of logical view names to URLs without an explicit mapping definition.
  This is appropriate if your logical names match the names of your view resources
  in a straightforward manner, without the need for arbitrary mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InternalResourceViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>InternalResourceView</code> (in
  effect, Servlets and JSPs) and subclasses such as <code>JstlView</code> and <code>TilesView</code>. You can
  specify the view class for all views generated by this resolver by using <code>setViewClass(..)</code>.
  See the {api-spring-framework}/web/reactive/result/view/UrlBasedViewResolver.html[<code>UrlBasedViewResolver</code>]
  javadoc for details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FreeMarkerViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>FreeMarkerView</code> and
  custom subclasses of them.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContentNegotiatingViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implementation of the <code>ViewResolver</code> interface that resolves a view based on the
  request file name or <code>Accept</code> header. See <a href="#mvc-multiple-representations">Content Negotiation</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implementation of the <code>ViewResolver</code> interface that interprets a view name as a
  bean name in the current application context. This is a very flexible variant which
  allows for mixing and matching different view types based on distinct view names.
  Each such <code>View</code> can be defined as a bean e.g. in XML or in configuration classes.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="mvc-viewresolver-handling"><a class="anchor" href="#mvc-viewresolver-handling"></a>Handling</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-viewresolution-handling" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can chain view resolvers by declaring more than one resolver bean and, if necessary, by
setting the <code>order</code> property to specify ordering. Remember, the higher the order property,
the later the view resolver is positioned in the chain.</p>
</div>
<div class="paragraph">
<p>The contract of a <code>ViewResolver</code> specifies that it can return null to indicate that the
view could not be found. However, in the case of JSPs and <code>InternalResourceViewResolver</code>,
the only way to figure out if a JSP exists is to perform a dispatch through
<code>RequestDispatcher</code>. Therefore, you must always configure an <code>InternalResourceViewResolver</code>
to be last in the overall order of view resolvers.</p>
</div>
<div class="paragraph">
<p>Configuring view resolution is as simple as adding <code>ViewResolver</code> beans to your Spring
configuration. The <a href="#mvc-config">MVC Config</a> provides a dedicated configuration API for
<a href="#mvc-config-view-resolvers">View Resolvers</a> and for adding logic-less
<a href="#mvc-config-view-controller">View Controllers</a> which are useful for HTML template
rendering without controller logic.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-redirecting-redirect-prefix"><a class="anchor" href="#mvc-redirecting-redirect-prefix"></a>Redirecting</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-redirecting-redirect-prefix" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The special <code>redirect:</code> prefix in a view name lets you perform a redirect. The
<code>UrlBasedViewResolver</code> (and its subclasses) recognize this as an instruction that a
redirect is needed. The rest of the view name is the redirect URL.</p>
</div>
<div class="paragraph">
<p>The net effect is the same as if the controller had returned a <code>RedirectView</code>, but now
the controller itself can operate in terms of logical view names. A logical view
name (such as <code>redirect:/myapp/some/resource</code>) redirects relative to the current
Servlet context, while a name such as <code>redirect:https://myhost.com/some/arbitrary/path</code>
redirects to an absolute URL.</p>
</div>
<div class="paragraph">
<p>Note that, if a controller method is annotated with the <code>@ResponseStatus</code>, the annotation
value takes precedence over the response status set by <code>RedirectView</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-redirecting-forward-prefix"><a class="anchor" href="#mvc-redirecting-forward-prefix"></a>Forwarding</h4>
<div class="paragraph">
<p>You can also use a special <code>forward:</code> prefix for view names that are
ultimately resolved by <code>UrlBasedViewResolver</code> and subclasses. This creates an
<code>InternalResourceView</code>, which does a <code>RequestDispatcher.forward()</code>.
Therefore, this prefix is not useful with <code>InternalResourceViewResolver</code> and
<code>InternalResourceView</code> (for JSPs), but it can be helpful if you use another view
technology but still want to force a forward of a resource to be handled by the
Servlet/JSP engine. Note that you may also chain multiple view resolvers, instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-multiple-representations"><a class="anchor" href="#mvc-multiple-representations"></a>Content Negotiation</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-multiple-representations" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>{api-spring-framework}/web/servlet/view/ContentNegotiatingViewResolver.html[<code>ContentNegotiatingViewResolver</code>]
does not resolve views itself but rather delegates
to other view resolvers and selects the view that resembles the representation requested
by the client. The representation can be determined from the <code>Accept</code> header or from a
query parameter (for example, <code>"/path?format=pdf"</code>).</p>
</div>
<div class="paragraph">
<p>The <code>ContentNegotiatingViewResolver</code> selects an appropriate <code>View</code> to handle the request
by comparing the request media types with the media type (also known as
<code>Content-Type</code>) supported by the <code>View</code> associated with each of its <code>ViewResolvers</code>. The
first <code>View</code> in the list that has a compatible <code>Content-Type</code> returns the representation
to the client. If a compatible view cannot be supplied by the <code>ViewResolver</code> chain,
the list of views specified through the <code>DefaultViews</code> property is consulted. This
latter option is appropriate for singleton <code>Views</code> that can render an appropriate
representation of the current resource regardless of the logical view name. The <code>Accept</code>
header can include wildcards (for example <code>text/*</code>), in which case a <code>View</code> whose
<code>Content-Type</code> is <code>text/xml</code> is a compatible match.</p>
</div>
<div class="paragraph">
<p>See <a href="#mvc-config-view-resolvers">View Resolvers</a> under <a href="#mvc-config">MVC Config</a> for configuration details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-localeresolver"><a class="anchor" href="#mvc-localeresolver"></a>Locale</h3>
<div class="paragraph">
<p>Most parts of Spring&#8217;s architecture support internationalization, as the Spring web
MVC framework does. <code>DispatcherServlet</code> lets you automatically resolve messages
by using the client&#8217;s locale. This is done with <code>LocaleResolver</code> objects.</p>
</div>
<div class="paragraph">
<p>When a request comes in, the <code>DispatcherServlet</code> looks for a locale resolver and, if it
finds one, it tries to use it to set the locale. By using the <code>RequestContext.getLocale()</code>
method, you can always retrieve the locale that was resolved by the locale resolver.</p>
</div>
<div class="paragraph">
<p>In addition to automatic locale resolution, you can also attach an interceptor to the
handler mapping (see <a href="#mvc-handlermapping-interceptor">Interception</a> for more information on handler
mapping interceptors) to change the locale under specific circumstances (for example,
based on a parameter in the request).</p>
</div>
<div class="paragraph">
<p>Locale resolvers and interceptors are defined in the
<code>org.springframework.web.servlet.i18n</code> package and are configured in your application
context in the normal way. The following selection of locale resolvers is included in
Spring.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-timezone">Time Zone</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-acceptheader">Header Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-cookie">Cookie Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-session">Session Resolver</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-interceptor">Locale Interceptor</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mvc-timezone"><a class="anchor" href="#mvc-timezone"></a>Time Zone</h4>
<div class="paragraph">
<p>In addition to obtaining the client&#8217;s locale, it is often useful to know its time zone.
The <code>LocaleContextResolver</code> interface offers an extension to <code>LocaleResolver</code> that lets
resolvers provide a richer <code>LocaleContext</code>, which may include time zone information.</p>
</div>
<div class="paragraph">
<p>When available, the user&#8217;s <code>TimeZone</code> can be obtained by using the
<code>RequestContext.getTimeZone()</code> method. Time zone information is automatically used
by any Date/Time <code>Converter</code> and <code>Formatter</code> objects that are registered with Spring&#8217;s
<code>ConversionService</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver-acceptheader"><a class="anchor" href="#mvc-localeresolver-acceptheader"></a>Header Resolver</h4>
<div class="paragraph">
<p>This locale resolver inspects the <code>accept-language</code> header in the request that was sent
by the client (for example, a web browser). Usually, this header field contains the locale of
the client&#8217;s operating system. Note that this resolver does not support time zone
information.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver-cookie"><a class="anchor" href="#mvc-localeresolver-cookie"></a>Cookie Resolver</h4>
<div class="paragraph">
<p>This locale resolver inspects a <code>Cookie</code> that might exist on the client to see if a
<code>Locale</code> or <code>TimeZone</code> is specified. If so, it uses the specified details. By using the
properties of this locale resolver, you can specify the name of the cookie as well as the
maximum age. The following example defines a <code>CookieLocaleResolver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;

	&lt;property name="cookieName" value="clientlanguage"/&gt;

	&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
	&lt;property name="cookieMaxAge" value="100000"/&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table describes the properties <code>CookieLocaleResolver</code>:</p>
</div>
<table id="mvc-cookie-locale-resolver-props-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. CookieLocaleResolver properties</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookieName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">classname + LOCALE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the cookie</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookieMaxAge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet container default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum time a cookie persists on the client. If <code>-1</code> is specified, the
  cookie will not be persisted. It is available only until the client shuts down
  the browser.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookiePath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limits the visibility of the cookie to a certain part of your site. When <code>cookiePath</code> is
  specified, the cookie is visible only to that path and the paths below it.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver-session"><a class="anchor" href="#mvc-localeresolver-session"></a>Session Resolver</h4>
<div class="paragraph">
<p>The <code>SessionLocaleResolver</code> lets you retrieve <code>Locale</code> and <code>TimeZone</code> from the
session that might be associated with the user&#8217;s request. In contrast to
<code>CookieLocaleResolver</code>, this strategy stores locally chosen locale settings in the
Servlet container&#8217;s <code>HttpSession</code>. As a consequence, those settings are temporary
for each session and are, therefore, lost when each session ends.</p>
</div>
<div class="paragraph">
<p>Note that there is no direct relationship with external session management mechanisms,
such as the Spring Session project. This <code>SessionLocaleResolver</code> evaluates and
modifies the corresponding <code>HttpSession</code> attributes against the current <code>HttpServletRequest</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver-interceptor"><a class="anchor" href="#mvc-localeresolver-interceptor"></a>Locale Interceptor</h4>
<div class="paragraph">
<p>You can enable changing of locales by adding the <code>LocaleChangeInterceptor</code> to one of the
<code>HandlerMapping</code> definitions. It detects a parameter in the request and changes the locale
accordingly, calling the <code>setLocale</code> method on the <code>LocaleResolver</code> in the dispatcher&#8217;s
application context. The next example shows that calls to all <code>*.view</code> resources
that contain a parameter named <code>siteLanguage</code> now changes the locale. So, for example,
a request for the URL, <code><a href="https://www.sf.net/home.view?siteLanguage=nl" class="bare">https://www.sf.net/home.view?siteLanguage=nl</a></code>, changes the site
language to Dutch. The following example shows how to intercept the locale:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="localeChangeInterceptor"
		class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
	&lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
		class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
		class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
	&lt;property name="interceptors"&gt;
		&lt;list&gt;
			&lt;ref bean="localeChangeInterceptor"/&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	&lt;property name="mappings"&gt;
		&lt;value&gt;/**/*.view=someController&lt;/value&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-themeresolver"><a class="anchor" href="#mvc-themeresolver"></a>Themes</h3>
<div class="paragraph">
<p>You can apply Spring Web MVC framework themes to set the overall look-and-feel of your
application, thereby enhancing user experience. A theme is a collection of static
resources, typically style sheets and images, that affect the visual style of the
application.</p>
</div>
<div class="sect3">
<h4 id="mvc-themeresolver-defining"><a class="anchor" href="#mvc-themeresolver-defining"></a>Defining a theme</h4>
<div class="paragraph">
<p>To use themes in your web application, you must set up an implementation of the
<code>org.springframework.ui.context.ThemeSource</code> interface. The <code>WebApplicationContext</code>
interface extends <code>ThemeSource</code> but delegates its responsibilities to a dedicated
implementation. By default, the delegate is an
<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code> implementation that
loads properties files from the root of the classpath. To use a custom <code>ThemeSource</code>
implementation or to configure the base name prefix of the <code>ResourceBundleThemeSource</code>,
you can register a bean in the application context with the reserved name, <code>themeSource</code>.
The web application context automatically detects a bean with that name and uses it.</p>
</div>
<div class="paragraph">
<p>When you use the <code>ResourceBundleThemeSource</code>, a theme is defined in a simple properties
file. The properties file lists the resources that make up the theme, as the following example shows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</pre>
</div>
</div>
<div class="paragraph">
<p>The keys of the properties are the names that refer to the themed elements from view
code. For a JSP, you typically do this using the <code>spring:theme</code> custom tag, which is
very similar to the <code>spring:message</code> tag. The following JSP fragment uses the theme
defined in the previous example to customize the look and feel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;
	&lt;/head&gt;
	&lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;
		...
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the <code>ResourceBundleThemeSource</code> uses an empty base name prefix. As a result,
the properties files are loaded from the root of the classpath. Thus, you would put the
<code>cool.properties</code> theme definition in a directory at the root of the classpath (for
example, in <code>/WEB-INF/classes</code>). The <code>ResourceBundleThemeSource</code> uses the standard Java
resource bundle loading mechanism, allowing for full internationalization of themes. For
example, we could have a <code>/WEB-INF/classes/cool_nl.properties</code> that references a special
background image with Dutch text on it.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-themeresolver-resolving"><a class="anchor" href="#mvc-themeresolver-resolving"></a>Resolving Themes</h4>
<div class="paragraph">
<p>After you define themes, as described in the <a href="#mvc-themeresolver-defining">preceding section</a>,
you decide which theme to use. The <code>DispatcherServlet</code> looks for a bean named <code>themeResolver</code>
to find out which <code>ThemeResolver</code> implementation to use. A theme resolver works in much the same
way as a <code>LocaleResolver</code>. It detects the theme to use for a particular request and can also
alter the request&#8217;s theme. The following table describes the theme resolvers provided by Spring:</p>
</div>
<table id="mvc-theme-resolver-impls-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. ThemeResolver implementations</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FixedThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Selects a fixed theme, set by using the <code>defaultThemeName</code> property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The theme is maintained in the user&#8217;s HTTP session. It needs to be set only once for
  each session but is not persisted between sessions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CookieThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The selected theme is stored in a cookie on the client.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring also provides a <code>ThemeChangeInterceptor</code> that lets theme changes on every
request with a simple request parameter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-multipart"><a class="anchor" href="#mvc-multipart"></a>Multipart Resolver</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-multipart" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>MultipartResolver</code> from the <code>org.springframework.web.multipart</code> package is a strategy
for parsing multipart requests including file uploads. There is one implementation
based on <a href="https://commons.apache.org/proper/commons-fileupload">Commons FileUpload</a> and
another based on Servlet 3.0 multipart request parsing.</p>
</div>
<div class="paragraph">
<p>To enable multipart handling, you need to declare a <code>MultipartResolver</code> bean in your
<code>DispatcherServlet</code> Spring configuration with a name of <code>multipartResolver</code>.
The <code>DispatcherServlet</code> detects it and applies it to the incoming request. When a POST with
content-type of <code>multipart/form-data</code> is received, the resolver parses the content and
wraps the current <code>HttpServletRequest</code> as <code>MultipartHttpServletRequest</code> to
provide access to resolved parts in addition to exposing them as request parameters.</p>
</div>
<div class="sect3">
<h4 id="mvc-multipart-resolver-commons"><a class="anchor" href="#mvc-multipart-resolver-commons"></a>Apache Commons <code>FileUpload</code></h4>
<div class="paragraph">
<p>To use Apache Commons <code>FileUpload</code>, you can configure a bean of type
<code>CommonsMultipartResolver</code> with a name of <code>multipartResolver</code>. You also need to
have <code>commons-fileupload</code> as a dependency on your classpath.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-multipart-resolver-standard"><a class="anchor" href="#mvc-multipart-resolver-standard"></a>Servlet 3.0</h4>
<div class="paragraph">
<p>Servlet 3.0 multipart parsing needs to be enabled through Servlet container configuration.
To do so:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In Java, set a <code>MultipartConfigElement</code> on the Servlet registration.</p>
</li>
<li>
<p>In <code>web.xml</code>, add a <code>"&lt;multipart-config&gt;"</code> section to the servlet declaration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to set a <code>MultipartConfigElement</code> on the Servlet registration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	// ...

	@Override
	protected void customizeRegistration(ServletRegistration.Dynamic registration) {

		// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
		registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
	}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

	// ...

	override fun customizeRegistration(registration: ServletRegistration.Dynamic) {

		// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
		registration.setMultipartConfig(MultipartConfigElement("/tmp"))
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the Servlet 3.0 configuration is in place, you can add a bean of type
<code>StandardServletMultipartResolver</code> with a name of <code>multipartResolver</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-logging"><a class="anchor" href="#mvc-logging"></a>Logging</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-logging" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>DEBUG-level logging in Spring MVC is designed to be compact, minimal, and
human-friendly. It focuses on high-value bits of information that are useful over and
over again versus others that are useful only when debugging a specific issue.</p>
</div>
<div class="paragraph">
<p>TRACE-level logging generally follows the same principles as DEBUG (and, for example, also
should not be a fire hose) but can be used for debugging any issue. In addition, some log
messages may show a different level of detail at TRACE versus DEBUG.</p>
</div>
<div class="paragraph">
<p>Good logging comes from the experience of using the logs. If you spot anything that does
not meet the stated goals, please let us know.</p>
</div>
<div class="sect3">
<h4 id="mvc-logging-sensitive-data"><a class="anchor" href="#mvc-logging-sensitive-data"></a>Sensitive Data</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-logging-sensitive-data" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>DEBUG and TRACE logging may log sensitive information. This is why request parameters and
headers are masked by default and their logging in full must be enabled explicitly
through the <code>enableLoggingRequestDetails</code> property on <code>DispatcherServlet</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so by using Java configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyInitializer
		extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return ... ;
	}

	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return ... ;
	}

	@Override
	protected String[] getServletMappings() {
		return ... ;
	}

	@Override
	protected void customizeRegistration(ServletRegistration.Dynamic registration) {
		registration.setInitParameter("enableLoggingRequestDetails", "true");
	}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

	override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
		return ...
	}

	override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
		return ...
	}

	override fun getServletMappings(): Array&lt;String&gt; {
		return ...
	}

	override fun customizeRegistration(registration: ServletRegistration.Dynamic) {
		registration.setInitParameter("enableLoggingRequestDetails", "true")
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="filters"><a class="anchor" href="#filters"></a>Filters</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-filters" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <code>spring-web</code> module provides some useful filters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#filters-http-put">Form Data</a></p>
</li>
<li>
<p><a href="#filters-forwarded-headers">Forwarded Headers</a></p>
</li>
<li>
<p><a href="#filters-shallow-etag">Shallow ETag</a></p>
</li>
<li>
<p><a href="#filters-cors">CORS</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="filters-http-put"><a class="anchor" href="#filters-http-put"></a>Form Data</h3>
<div class="paragraph">
<p>Browsers can submit form data only through HTTP GET or HTTP POST but non-browser clients can also
use HTTP PUT, PATCH, and DELETE. The Servlet API requires <code>ServletRequest.getParameter*()</code>
methods to support form field access only for HTTP POST.</p>
</div>
<div class="paragraph">
<p>The <code>spring-web</code> module provides <code>FormContentFilter</code> to intercept HTTP PUT, PATCH, and DELETE
requests with a content type of <code>application/x-www-form-urlencoded</code>, read the form data from
the body of the request, and wrap the <code>ServletRequest</code> to make the form data
available through the <code>ServletRequest.getParameter*()</code> family of methods.</p>
</div>
</div>
<div class="sect2">
<h3 id="filters-forwarded-headers"><a class="anchor" href="#filters-forwarded-headers"></a>Forwarded Headers</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-forwarded-headers" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>As a request goes through proxies (such as load balancers) the host, port, and
scheme may change, and that makes it a challenge to create links that point to the correct
host, port, and scheme from a client perspective.</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> defines the <code>Forwarded</code> HTTP header
that proxies can use to provide information about the original request. There are other
non-standard headers, too, including <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>,
<code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, and <code>X-Forwarded-Prefix</code>.</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderFilter</code> is a Servlet filter that modifies the request in order to
a) change the host, port, and scheme based on <code>Forwarded</code> headers, and b) to remove those
headers to eliminate further impact. The filter relies on wrapping the request, and
therefore it must be ordered ahead of other filters, such as <code>RequestContextFilter</code>, that
should work with the modified and not the original request.</p>
</div>
<div class="paragraph">
<p>There are security considerations for forwarded headers since an application cannot know
if the headers were added by a proxy, as intended, or by a malicious client. This is why
a proxy at the boundary of trust should be configured to remove untrusted <code>Forwarded</code>
headers that come from the outside. You can also configure the <code>ForwardedHeaderFilter</code>
with <code>removeOnly=true</code>, in which case it removes but does not use the headers.</p>
</div>
<div class="paragraph">
<p>In order to support <a href="#mvc-ann-async">asynchronous requests</a> and error dispatches this
filter should be mapped with <code>DispatcherType.ASYNC</code> and also <code>DispatcherType.ERROR</code>.
If using Spring Framework&#8217;s <code>AbstractAnnotationConfigDispatcherServletInitializer</code>
(see <a href="#mvc-container-config">Servlet Config</a>) all filters are automatically registered for all dispatch
types. However if registering the filter via <code>web.xml</code> or in Spring Boot via a
<code>FilterRegistrationBean</code> be sure to include <code>DispatcherType.ASYNC</code> and
<code>DispatcherType.ERROR</code> in addition to <code>DispatcherType.REQUEST</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="filters-shallow-etag"><a class="anchor" href="#filters-shallow-etag"></a>Shallow ETag</h3>
<div class="paragraph">
<p>The <code>ShallowEtagHeaderFilter</code> filter creates a &#8220;shallow&#8221; ETag by caching the content
written to the response and computing an MD5 hash from it. The next time a client sends,
it does the same, but it also compares the computed value against the <code>If-None-Match</code>
request header and, if the two are equal, returns a 304 (NOT_MODIFIED).</p>
</div>
<div class="paragraph">
<p>This strategy saves network bandwidth but not CPU, as the full response must be computed
for each request. Other strategies at the controller level, described earlier, can avoid
the computation. See <a href="#mvc-caching">HTTP Caching</a>.</p>
</div>
<div class="paragraph">
<p>This filter has a <code>writeWeakETag</code> parameter that configures the filter to write weak ETags
similar to the following: <code>W/"02a2d595e6ed9a0b24f027f2b63b134d6"</code> (as defined in
<a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232 Section 2.3</a>).</p>
</div>
<div class="paragraph">
<p>In order to support <a href="#mvc-ann-async">asynchronous requests</a> this filter must be mapped
with <code>DispatcherType.ASYNC</code> so that the filter can delay and successfully generate an
ETag to the end of the last async dispatch. If using Spring Framework&#8217;s
<code>AbstractAnnotationConfigDispatcherServletInitializer</code> (see <a href="#mvc-container-config">Servlet Config</a>)
all filters are automatically registered for all dispatch types. However if registering
the filter via <code>web.xml</code> or in Spring Boot via a <code>FilterRegistrationBean</code> be sure to include
<code>DispatcherType.ASYNC</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="filters-cors"><a class="anchor" href="#filters-cors"></a>CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-filters-cors" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC provides fine-grained support for CORS configuration through annotations on
controllers. However, when used with Spring Security, we advise relying on the built-in
<code>CorsFilter</code> that must be ordered ahead of Spring Security&#8217;s chain of filters.</p>
</div>
<div class="paragraph">
<p>See the sections on <a href="#mvc-cors">CORS</a> and the <a href="#mvc-cors-filter">CORS Filter</a> for more details.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-controller"><a class="anchor" href="#mvc-controller"></a>Annotated Controllers</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-controller" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC provides an annotation-based programming model where <code>@Controller</code> and
<code>@RestController</code> components use annotations to express request mappings, request input,
exception handling, and more. Annotated controllers have flexible method signatures and
do not have to extend base classes nor implement specific interfaces.
The following example shows a controller defined by annotations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class HelloController {

	@GetMapping("/hello")
	public String handle(Model model) {
		model.addAttribute("message", "Hello World!");
		return "index";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.ui.set

@Controller
class HelloController {

	@GetMapping("/hello")
	fun handle(model: Model): String {
		model["message"] = "Hello World!"
		return "index"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the method accepts a <code>Model</code> and returns a view name as a <code>String</code>,
but many other options exist and are explained later in this chapter.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Guides and tutorials on <a href="https://spring.io/guides">spring.io</a> use the annotation-based
programming model described in this section.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mvc-ann-controller"><a class="anchor" href="#mvc-ann-controller"></a>Declaration</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-controller" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can define controller beans by using a standard Spring bean definition in the
Servlet&#8217;s <code>WebApplicationContext</code>. The <code>@Controller</code> stereotype allows for auto-detection,
aligned with Spring general support for detecting <code>@Component</code> classes in the classpath
and auto-registering bean definitions for them. It also acts as a stereotype for the
annotated class, indicating its role as a web component.</p>
</div>
<div class="paragraph">
<p>To enable auto-detection of such <code>@Controller</code> beans, you can add component scanning to
your Java configuration, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan("org.example.web")
public class WebConfig {

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@ComponentScan("org.example.web")
class WebConfig {

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the XML configuration equivalent of the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		https://www.springframework.org/schema/context/spring-context.xsd"&gt;

	&lt;context:component-scan base-package="org.example.web"/&gt;

	&lt;!-- ... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code> is a <a href="../core.html#beans-meta-annotations" class="page">composed annotation</a> that is
itself meta-annotated with <code>@Controller</code> and <code>@ResponseBody</code> to indicate a controller whose
every method inherits the type-level <code>@ResponseBody</code> annotation and, therefore, writes
directly to the response body versus view resolution and rendering with an HTML template.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-proxying"><a class="anchor" href="#mvc-ann-requestmapping-proxying"></a>AOP Proxies</h4>
<div class="paragraph">
<p>In some cases, you may need to decorate a controller with an AOP proxy at runtime.
One example is if you choose to have <code>@Transactional</code> annotations directly on the
controller. When this is the case, for controllers specifically, we recommend
using class-based proxying. This is typically the default choice with controllers.
However, if a controller must implement an interface that is not a Spring Context
callback (such as <code>InitializingBean</code>, <code>*Aware</code>, and others), you may need to explicitly
configure class-based proxying. For example, with <code>&lt;tx:annotation-driven/&gt;</code> you can
change to <code>&lt;tx:annotation-driven proxy-target-class="true"/&gt;</code>, and with
<code>@EnableTransactionManagement</code> you can change to
<code>@EnableTransactionManagement(proxyTargetClass = true)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-requestmapping"><a class="anchor" href="#mvc-ann-requestmapping"></a>Request Mapping</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestMapping</code> annotation to map requests to controllers methods. It has
various attributes to match by URL, HTTP method, request parameters, headers, and media
types. You can use it at the class level to express shared mappings or at the method level
to narrow down to a specific endpoint mapping.</p>
</div>
<div class="paragraph">
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The shortcuts are <a href="#mvc-ann-requestmapping-composed">Custom Annotations</a> that are provided because,
arguably, most controller methods should be mapped to a specific HTTP method versus
using <code>@RequestMapping</code>, which, by default, matches to all HTTP methods. At the same,
a <code>@RequestMapping</code> is still needed at the class level to express shared mappings.</p>
</div>
<div class="paragraph">
<p>The following example has type and method level mappings:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@RequestMapping("/persons")
class PersonController {

	@GetMapping("/{id}")
	public Person getPerson(@PathVariable Long id) {
		// ...
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public void add(@RequestBody Person person) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RestController
@RequestMapping("/persons")
class PersonController {

	@GetMapping("/{id}")
	fun getPerson(@PathVariable id: Long): Person {
		// ...
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	fun add(@RequestBody person: Person) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-uri-templates"><a class="anchor" href="#mvc-ann-requestmapping-uri-templates"></a>URI patterns</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-uri-templates" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> methods can be mapped using URL patterns. There are two alternatives:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PathPattern</code>&#8201;&#8212;&#8201;a pre-parsed pattern matched against the URL path also pre-parsed as
<code>PathContainer</code>. Designed for web use, this solution deals effectively with encoding and
path parameters, and matches efficiently.</p>
</li>
<li>
<p><code>AntPathMatcher</code>&#8201;&#8212;&#8201;match String patterns against a String path. This is the original
solution also used in Spring configuration to select resources on the classpath, on the
filesystem, and other locations. It is less efficient and the String path input is a
challenge for dealing effectively with encoding and other issues with URLs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>PathPattern</code> is the recommended solution for web applications and it is the only choice in
Spring WebFlux. Prior to version 5.3, <code>AntPathMatcher</code> was the only choice in Spring MVC
and continues to be the default. However <code>PathPattern</code> can be enabled in the
<a href="#mvc-config-path-matching">MVC config</a>.</p>
</div>
<div class="paragraph">
<p><code>PathPattern</code> supports the same pattern syntax as <code>AntPathMatcher</code>. In addition it also
supports the capturing pattern, e.g. <code>{*spring}</code>, for matching 0 or more path segments
at the end of a path. <code>PathPattern</code> also restricts the use of <code>**</code> for matching multiple
path segments such that it&#8217;s only allowed at the end of a pattern. This eliminates many
cases of ambiguity when choosing the best matching pattern for a given request.
For full pattern syntax please refer to
{api-spring-framework}/web/util/pattern/PathPattern.html[PathPattern] and
{api-spring-framework}/util/AntPathMatcher.html[AntPathMatcher].</p>
</div>
<div class="paragraph">
<p>Some example patterns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>"/resources/ima?e.png"</code> - match one character in a path segment</p>
</li>
<li>
<p><code>"/resources/*.png"</code> - match zero or more characters in a path segment</p>
</li>
<li>
<p><code>"/resources/**"</code> - match multiple path segments</p>
</li>
<li>
<p><code>"/projects/{project}/versions"</code> - match a path segment and capture it as a variable</p>
</li>
<li>
<p><code>"/projects/{project:[a-z]+}/versions"</code> - match and capture a variable with a regex</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Captured URI variables can be accessed with <code>@PathVariable</code>. For example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can declare URI variables at the class and method levels, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@RequestMapping("/owners/{ownerId}")
public class OwnerController {

	@GetMapping("/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
@RequestMapping("/owners/{ownerId}")
class OwnerController {

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI variables are automatically converted to the appropriate type, or <code>TypeMismatchException</code>
is raised. Simple types (<code>int</code>, <code>long</code>, <code>Date</code>, and so on) are supported by default and you can
register support for any other data type.
See <a href="#mvc-ann-typeconversion">Type Conversion</a> and <a href="#mvc-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>You can explicitly name URI variables (for example, <code>@PathVariable("customId")</code>), but you can
leave that detail out if the names are the same and your code is compiled with debugging
information or with the <code>-parameters</code> compiler flag on Java 8.</p>
</div>
<div class="paragraph">
<p>The syntax <code>{varName:regex}</code> declares a URI variable with a regular expression that has
syntax of <code>{varName:regex}</code>. For example, given URL <code>"/spring-web-3.0.5.jar"</code>, the following method
extracts the name, version, and file extension:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
fun handle(@PathVariable name: String, @PathVariable version: String, @PathVariable ext: String) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI path patterns can also have embedded <code>${&#8230;&#8203;}</code> placeholders that are resolved on startup
by using <code>PropertyPlaceHolderConfigurer</code> against local, system, environment, and other property
sources. You can use this, for example, to parameterize a base URL based on some external
configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-pattern-comparison"><a class="anchor" href="#mvc-ann-requestmapping-pattern-comparison"></a>Pattern Comparison</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-pattern-comparison" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>When multiple patterns match a URL, the best match must be selected. This is done with
one of the following depending on whether use of parsed <code>PathPattern</code> is enabled for use or not:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{api-spring-framework}/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR[<code>PathPattern.SPECIFICITY_COMPARATOR</code>]</p>
</li>
<li>
<p>{api-spring-framework}/util/AntPathMatcher.html#getPatternComparator-java.lang.String-[<code>AntPathMatcher.getPatternComparator(String path)</code>]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both help to sorts patterns with more specific ones on top. A pattern is less specific if
it has a lower count of URI variables (counted as 1), single wildcards (counted as 1),
and double wildcards (counted as 2). Given an equal score, the longer pattern is chosen.
Given the same score and length, the pattern with more URI variables than wildcards is
chosen.</p>
</div>
<div class="paragraph">
<p>The default mapping pattern (<code>/**</code>) is excluded from scoring and always
sorted last. Also, prefix patterns (such as <code>/public/**</code>) are considered less
specific than other pattern that do not have double wildcards.</p>
</div>
<div class="paragraph">
<p>For the full details, follow the above links to the pattern Comparators.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-suffix-pattern-match"><a class="anchor" href="#mvc-ann-requestmapping-suffix-pattern-match"></a>Suffix Match</h4>
<div class="paragraph">
<p>Starting in 5.3, by default Spring MVC no longer performs <code>.*</code> suffix pattern
matching where a controller mapped to <code>/person</code> is also implicitly mapped to
<code>/person.*</code>. As a consequence path extensions are no longer used to interpret
the requested content type for the response&#8201;&#8212;&#8201;for example, <code>/person.pdf</code>, <code>/person.xml</code>,
and so on.</p>
</div>
<div class="paragraph">
<p>Using file extensions in this way was necessary when browsers used to send <code>Accept</code> headers
that were hard to interpret consistently. At present, that is no longer a necessity and
using the <code>Accept</code> header should be the preferred choice.</p>
</div>
<div class="paragraph">
<p>Over time, the use of file name extensions has proven problematic in a variety of ways.
It can cause ambiguity when overlain with the use of URI variables, path parameters, and
URI encoding. Reasoning about URL-based authorization
and security (see next section for more details) also become more difficult.</p>
</div>
<div class="paragraph">
<p>To completely disable the use of path extensions in versions prior to 5.3, set the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>useSuffixPatternMatching(false)</code>, see <a href="#mvc-config-path-matching">PathMatchConfigurer</a></p>
</li>
<li>
<p><code>favorPathExtension(false)</code>, see <a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Having a way to request content types other than through the <code>"Accept"</code> header can still
be useful, e.g. when typing a URL in a browser. A safe alternative to path extensions is
to use the query parameter strategy. If you must use file extensions, consider restricting
them to a list of explicitly registered extensions through the <code>mediaTypes</code> property of
<a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-rfd"><a class="anchor" href="#mvc-ann-requestmapping-rfd"></a>Suffix Match and RFD</h4>
<div class="paragraph">
<p>A reflected file download (RFD) attack is similar to XSS in that it relies on request input
(for example, a query parameter and a URI variable) being reflected in the response. However, instead of
inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a
download and treating the response as an executable script when double-clicked later.</p>
</div>
<div class="paragraph">
<p>In Spring MVC, <code>@ResponseBody</code> and <code>ResponseEntity</code> methods are at risk, because
they can render different content types, which clients can request through URL path extensions.
Disabling suffix pattern matching and using path extensions for content negotiation
lower the risk but are not sufficient to prevent RFD attacks.</p>
</div>
<div class="paragraph">
<p>To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a
<code>Content-Disposition:inline;filename=f.txt</code> header to suggest a fixed and safe download
file. This is done only if the URL path contains a file extension that is neither
allowed as safe nor explicitly registered for content negotiation. However, it can
potentially have side effects when URLs are typed directly into a browser.</p>
</div>
<div class="paragraph">
<p>Many common path extensions are allowed as safe by default. Applications with custom
<code>HttpMessageConverter</code> implementations can explicitly register file extensions for content
negotiation to avoid having a <code>Content-Disposition</code> header added for those extensions.
See <a href="#mvc-config-content-negotiation">Content Types</a>.</p>
</div>
<div class="paragraph">
<p>See <a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a> for additional
recommendations related to RFD.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-consumes"><a class="anchor" href="#mvc-ann-requestmapping-consumes"></a>Consumable Media Types</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-consumes" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Content-Type</code> of the request,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping(path = "/pets", consumes = "application/json") <i class="conum" data-value="1"></i><b>(1)</b>
public void addPet(@RequestBody Pet pet) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>consumes</code> attribute to narrow the mapping by the content type.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/pets", consumes = ["application/json"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun addPet(@RequestBody pet: Pet) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>consumes</code> attribute to narrow the mapping by the content type.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>consumes</code> attribute also supports negation expressions&#8201;&#8212;&#8201;for example, <code>!text/plain</code> means any
content type other than <code>text/plain</code>.</p>
</div>
<div class="paragraph">
<p>You can declare a shared <code>consumes</code> attribute at the class level. Unlike most other
request-mapping attributes, however, when used at the class level, a method-level <code>consumes</code> attribute
overrides rather than extends the class-level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> provides constants for commonly used media types, such as
<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-produces"><a class="anchor" href="#mvc-ann-requestmapping-produces"></a>Producible Media Types</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-produces" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Accept</code> request header and the list of
content types that a controller method produces, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping(path = "/pets/{petId}", produces = "application/json") <i class="conum" data-value="1"></i><b>(1)</b>
@ResponseBody
public Pet getPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>produces</code> attribute to narrow the mapping by the content type.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/pets/{petId}", produces = ["application/json"]) <i class="conum" data-value="1"></i><b>(1)</b>
@ResponseBody
fun getPet(@PathVariable petId: String): Pet {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>produces</code> attribute to narrow the mapping by the content type.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The media type can specify a character set. Negated expressions are supported&#8201;&#8212;&#8201;for example,
<code>!text/plain</code> means any content type other than "text/plain".</p>
</div>
<div class="paragraph">
<p>You can declare a shared <code>produces</code> attribute at the class level. Unlike most other
request-mapping attributes, however, when used at the class level, a method-level <code>produces</code> attribute
overrides rather than extends the class-level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> provides constants for commonly used media types, such as
<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-params-and-headers"><a class="anchor" href="#mvc-ann-requestmapping-params-and-headers"></a>Parameters, headers</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-params-and-headers" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow request mappings based on request parameter conditions. You can test for the
presence of a request parameter (<code>myParam</code>), for the absence of one (<code>!myParam</code>), or for a
specific value (<code>myParam=myValue</code>). The following example shows how to test for a specific value:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Testing whether <code>myParam</code> equals <code>myValue</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Testing whether <code>myParam</code> equals <code>myValue</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use the same with request header conditions, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping(path = "/pets", headers = "myHeader=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Testing whether <code>myHeader</code> equals <code>myValue</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/pets", headers = ["myHeader=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can match <code>Content-Type</code> and <code>Accept</code> with the headers condition, but it is better to use
<a href="#mvc-ann-requestmapping-consumes">consumes</a> and <a href="#mvc-ann-requestmapping-produces">produces</a>
instead.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-head-options"><a class="anchor" href="#mvc-ann-requestmapping-head-options"></a>HTTP HEAD, OPTIONS</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-head-options" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> (and <code>@RequestMapping(method=HttpMethod.GET)</code>) support HTTP HEAD
transparently for request mapping. Controller methods do not need to change.
A response wrapper, applied in <code>javax.servlet.http.HttpServlet</code>, ensures a <code>Content-Length</code>
header is set to the number of bytes written (without actually writing to the response).</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> (and <code>@RequestMapping(method=HttpMethod.GET)</code>) are implicitly mapped to
and support HTTP HEAD. An HTTP HEAD request is processed as if it were HTTP GET except
that, instead of writing the body, the number of bytes are counted and the <code>Content-Length</code>
header is set.</p>
</div>
<div class="paragraph">
<p>By default, HTTP OPTIONS is handled by setting the <code>Allow</code> response header to the list of HTTP
methods listed in all <code>@RequestMapping</code> methods that have matching URL patterns.</p>
</div>
<div class="paragraph">
<p>For a <code>@RequestMapping</code> without HTTP method declarations, the <code>Allow</code> header is set to
<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>. Controller methods should always declare the
supported HTTP methods (for example, by using the HTTP method specific variants:
<code>@GetMapping</code>, <code>@PostMapping</code>, and others).</p>
</div>
<div class="paragraph">
<p>You can explicitly map the <code>@RequestMapping</code> method to HTTP HEAD and HTTP OPTIONS, but that
is not necessary in the common case.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-composed"><a class="anchor" href="#mvc-ann-requestmapping-composed"></a>Custom Annotations</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#mvc-ann-requestmapping-head-options" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC supports the use of <a href="../core.html#beans-meta-annotations" class="page">composed annotations</a>
for request mapping. Those are annotations that are themselves meta-annotated with
<code>@RequestMapping</code> and composed to redeclare a subset (or all) of the <code>@RequestMapping</code>
attributes with a narrower, more specific purpose.</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, and <code>@PatchMapping</code> are
examples of composed annotations. They are provided because, arguably, most
controller methods should be mapped to a specific HTTP method versus using <code>@RequestMapping</code>,
which, by default, matches to all HTTP methods. If you need an example of composed
annotations, look at how those are declared.</p>
</div>
<div class="paragraph">
<p>Spring MVC also supports custom request-mapping attributes with custom request-matching
logic. This is a more advanced option that requires subclassing
<code>RequestMappingHandlerMapping</code> and overriding the <code>getCustomMethodCondition</code> method, where
you can check the custom attribute and return your own <code>RequestCondition</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping-registration"><a class="anchor" href="#mvc-ann-requestmapping-registration"></a>Explicit Registrations</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestmapping-registration" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can programmatically register handler methods, which you can use for dynamic
registrations or for advanced cases, such as different instances of the same handler
under different URLs. The following example registers a handler method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfig {

	@Autowired
	public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
			throws NoSuchMethodException {

		RequestMappingInfo info = RequestMappingInfo
				.paths("/user/{id}").methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

		Method method = UserHandler.class.getMethod("getUser", Long.class); <i class="conum" data-value="3"></i><b>(3)</b>

		mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the target handler and the handler mapping for controllers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Prepare the request mapping meta data.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the handler method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Add the registration.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class MyConfig {

	@Autowired
	fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { <i class="conum" data-value="1"></i><b>(1)</b>
		val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() <i class="conum" data-value="2"></i><b>(2)</b>
		val method = UserHandler::class.java.getMethod("getUser", Long::class.java) <i class="conum" data-value="3"></i><b>(3)</b>
		mapping.registerMapping(info, handler, method) <i class="conum" data-value="4"></i><b>(4)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the target handler and the handler mapping for controllers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Prepare the request mapping meta data.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the handler method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Add the registration.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-methods"><a class="anchor" href="#mvc-ann-methods"></a>Handler Methods</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-methods" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-arguments"><a class="anchor" href="#mvc-ann-arguments"></a>Method Arguments</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-arguments" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The next table describes the supported controller method arguments. Reactive types are not supported
for any arguments.</p>
</div>
<div class="paragraph">
<p>JDK 8&#8217;s <code>java.util.Optional</code> is supported as a method argument in combination with
annotations that have a <code>required</code> attribute (for example, <code>@RequestParam</code>, <code>@RequestHeader</code>,
and others) and is equivalent to <code>required=false</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code>, <code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generic access to request parameters and request and session attributes, without direct
  use of the Servlet API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Choose any specific request or response type&#8201;&#8212;&#8201;for example, <code>ServletRequest</code>, <code>HttpServletRequest</code>,
  or Spring&#8217;s <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.HttpSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>.
  Note that session access is not thread-safe. Consider setting the
  <code>RequestMappingHandlerAdapter</code> instance&#8217;s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple
  requests are allowed to concurrently access a session.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.PushBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes.
  Note that, per the Servlet specification, the injected <code>PushBuilder</code> instance can be null if the client
  does not support that HTTP/2 feature.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Currently authenticated user&#8201;&#8212;&#8201;possibly a specific <code>Principal</code> implementation class if known.</p>
<p class="tableblock">  Note that this argument is not resolved eagerly, if it is annotated in order to allow a custom resolver to resolve it
  before falling back on default resolution via <code>HttpServletRequest#getUserPrincipal</code>.
  For example, the Spring Security <code>Authentication</code> implements <code>Principal</code> and would be injected as such via
  <code>HttpServletRequest#getUserPrincipal</code>, unless it is also annotated with <code>@AuthenticationPrincipal</code> in which case it
  is resolved by a custom Spring Security resolver through <code>Authentication#getPrincipal</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available (in
  effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.InputStream</code>, <code>java.io.Reader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the raw request body as exposed by the Servlet API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the raw response body as exposed by the Servlet API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to URI template variables. See <a href="#mvc-ann-requestmapping-uri-templates">URI patterns</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to name-value pairs in URI path segments. See <a href="#mvc-ann-matrix-variables">Matrix Variables</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the Servlet request parameters, including multipart files. Parameter values
  are converted to the declared method argument type. See <a href="#mvc-ann-requestparam"><code>@RequestParam</code></a> as well
  as <a href="#mvc-multipart-forms">Multipart</a>.</p>
<p class="tableblock">  Note that use of <code>@RequestParam</code> is optional for simple parameter values.
  See &#8220;Any other argument&#8221;, at the end of this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers. Header values are converted to the declared method argument
  type. See <a href="#mvc-ann-requestheader"><code>@RequestHeader</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to cookies. Cookies values are converted to the declared method argument
  type. See <a href="#mvc-ann-cookievalue"><code>@CookieValue</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the HTTP request body. Body content is converted to the declared method
  argument type by using <code>HttpMessageConverter</code> implementations. See <a href="#mvc-ann-requestbody"><code>@RequestBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>.
  See <a href="#mvc-ann-httpentity">HttpEntity</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a part in a <code>multipart/form-data</code> request, converting the part&#8217;s body
  with an <code>HttpMessageConverter</code>. See <a href="#mvc-multipart-forms">Multipart</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the model that is used in HTML controllers and exposed to templates as
  part of view rendering.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify attributes to use in case of a redirect (that is, to be appended to the query
  string) and flash attributes to be stored temporarily until the request after redirect.
  See <a href="#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="#mvc-flash-attributes">Flash Attributes</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to an existing attribute in the model (instantiated if not present) with
  data binding and validation applied. See <a href="#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well as
  <a href="#mvc-ann-modelattrib-methods">Model</a> and <a href="#mvc-ann-initbinder"><code>DataBinder</code></a>.</p>
<p class="tableblock">  Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes).
  See &#8220;Any other argument&#8221; at the end of this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code>, <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to errors from validation and data binding for a command object
  (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or
  <code>@RequestPart</code> arguments. You must declare an <code>Errors</code>, or <code>BindingResult</code> argument
  immediately after the validated method argument.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For marking form processing complete, which triggers cleanup of session attributes
  declared through a class-level <code>@SessionAttributes</code> annotation. See
  <a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For preparing a URL relative to the current request&#8217;s host, port, scheme, context path, and
  the literal part of the servlet mapping. See <a href="#mvc-uri-building">URI Links</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute, in contrast to model attributes stored in the session
  as a result of a class-level <code>@SessionAttributes</code> declaration. See
  <a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes. See <a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a method argument is not matched to any of the earlier values in this table and it is
  a simple type (as determined by
	{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
  it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-ann-return-types"><a class="anchor" href="#mvc-ann-return-types"></a>Return Values</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-return-types" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The next table describes the supported controller method return values. Reactive types are
supported for all return values.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is converted through <code>HttpMessageConverter</code> implementations and written to the
  response. See <a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value that specifies the full response (including HTTP headers and body) is to be converted
  through <code>HttpMessageConverter</code> implementations and written to the response.
  See <a href="#mvc-ann-responseentity">ResponseEntity</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For returning a response with headers and no body.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit
  model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods. The handler
  method can also programmatically enrich the model by declaring a <code>Model</code> argument
  (see <a href="#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
  through command objects and <code>@ModelAttribute</code> methods. The handler method can also
  programmatically enrich the model by declaring a <code>Model</code> argument
  (see <a href="#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model, with the view name implicitly determined
  through a <code>RequestToViewNameTranslator</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An attribute to be added to the model, with the view name implicitly determined through
  a <code>RequestToViewNameTranslator</code>.</p>
<p class="tableblock">  Note that <code>@ModelAttribute</code> is optional. See "Any other return value" at the end of
  this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code> object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The view and model attributes to use and, optionally, a response status.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully
  handled the response if it also has a <code>ServletResponse</code>, an <code>OutputStream</code> argument, or
  an <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive
  <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="#mvc-caching-etag-lastmodified">Controllers</a> for details).</p>
<p class="tableblock">  If none of the above is true, a <code>void</code> return type can also indicate &#8220;no response body&#8221; for
  REST controllers or a default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DeferredResult&lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Produce any of the preceding return values asynchronously from any thread&#8201;&#8212;&#8201;for example, as a
  result of some event or callback. See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Callable&lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Produce any of the above return values asynchronously in a Spring MVC-managed thread.
  See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-callable"><code>Callable</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListenableFuture&lt;V&gt;</code>,
  <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>,
  <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alternative to <code>DeferredResult</code>, as a convenience (for example, when an underlying service
  returns one of those).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emit a stream of objects asynchronously to be written to the response with
  <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>.
  See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-http-streaming">HTTP Streaming</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamingResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a
  <code>ResponseEntity</code>. See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-http-streaming">HTTP Streaming</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactive types&#8201;&#8212;&#8201;Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>)
  collected to a <code>List</code>.</p>
<p class="tableblock">  For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>),
  <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code>
  blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied
  against the completion of each write.</p>
<p class="tableblock">  See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-reactive-types">Reactive Types</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any return value that does not match any of the earlier values in this table and that
  is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through
  <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty].
  Values that are simple types remain unresolved.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-ann-typeconversion"><a class="anchor" href="#mvc-ann-typeconversion"></a>Type Conversion</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-typeconversion" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Some annotated controller method arguments that represent <code>String</code>-based request input (such as
<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>)
can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</div>
<div class="paragraph">
<p>For such cases, type conversion is automatically applied based on the configured converters.
By default, simple types (<code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. You can customize
type conversion through a <code>WebDataBinder</code> (see <a href="#mvc-ann-initbinder"><code>DataBinder</code></a>) or by registering
<code>Formatters</code> with the <code>FormattingConversionService</code>.
See <a href="../core.html#format" class="page">Spring Field Formatting</a>.</p>
</div>
<div class="paragraph">
<p>A practical issue in type conversion is the treatment of an empty String source value.
Such a value is treated as missing if it becomes <code>null</code> as a result of type conversion.
This can be the case for <code>Long</code>, <code>UUID</code>, and other target types. If you want to allow <code>null</code>
to be injected, either use the <code>required</code> flag on the argument annotation, or declare the
argument as <code>@Nullable</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of 5.3, non-null arguments will be enforced even after type conversion. If your handler
method intends to accept a null value as well, either declare your argument as <code>@Nullable</code>
or mark it as <code>required=false</code> in the corresponding <code>@RequestParam</code> etc annotation. This is
a best practice and the recommended solution for regressions encountered in a 5.3 upgrade.</p>
</div>
<div class="paragraph">
<p>Alternatively, you may specifically handle e.g. the resulting <code>MissingPathVariableException</code>
in the case of a required <code>@PathVariable</code>. A null value after conversion will be treated like
an empty original value, so the corresponding <code>Missing&#8230;&#8203;Exception</code> variants will be thrown.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-matrix-variables"><a class="anchor" href="#mvc-ann-matrix-variables"></a>Matrix Variables</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-matrix-variables" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> discusses name-value pairs in
path segments. In Spring MVC, we refer to those as &#8220;matrix variables&#8221; based on an
<a href="https://www.w3.org/DesignIssues/MatrixURIs.html">&#8220;old post&#8221;</a> by Tim Berners-Lee, but they
can be also be referred to as URI path parameters.</p>
</div>
<div class="paragraph">
<p>Matrix variables can appear in any path segment, with each variable separated by a semicolon and
multiple values separated by comma (for example, <code>/cars;color=red,green;year=2012</code>). Multiple
values can also be specified through repeated variable names (for example,
<code>color=red;color=green;color=blue</code>).</p>
</div>
<div class="paragraph">
<p>If a URL is expected to contain matrix variables, the request mapping for a controller
method must use a URI variable to mask that variable content and ensure the request can
be matched successfully independent of matrix variable order and presence.
The following example uses a matrix variable:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

	// petId == 42
	// q == 11
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

	// petId == 42
	// q == 11
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that all path segments may contain matrix variables, you may sometimes need to
disambiguate which path variable the matrix variable is expected to be in.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
		@MatrixVariable(name="q", pathVar="ownerId") int q1,
		@MatrixVariable(name="q", pathVar="petId") int q2) {

	// q1 == 11
	// q2 == 22
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
		@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
		@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

	// q1 == 11
	// q2 == 22
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A matrix variable may be defined as optional and a default value specified, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

	// q == 1
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// GET /pets/42

@GetMapping("/pets/{petId}")
fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

	// q == 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get all matrix variables, you can use a <code>MultiValueMap</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
		@MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
		@MatrixVariable(pathVar="petId") MultiValueMap&lt;String, String&gt; petMatrixVars) {

	// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
	// petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
		@MatrixVariable matrixVars: MultiValueMap&lt;String, String&gt;,
		@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap&lt;String, String&gt;) {

	// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
	// petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you need to enable the use of matrix variables. In the MVC Java configuration,
you need to set a <code>UrlPathHelper</code> with <code>removeSemicolonContent=false</code> through
<a href="#mvc-config-path-matching">Path Matching</a>. In the MVC XML namespace, you can set
<code>&lt;mvc:annotation-driven enable-matrix-variables="true"/&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestparam"><a class="anchor" href="#mvc-ann-requestparam"></a><code>@RequestParam</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestparam" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestParam</code> annotation to bind Servlet request parameters (that is,
query parameters or form data) to a method argument in a controller.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

	// ...

	@GetMapping
	public String setupForm(@RequestParam("petId") int petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
		Pet pet = this.clinic.loadPet(petId);
		model.addAttribute("pet", pet);
		return "petForm";
	}

	// ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestParam</code> to bind <code>petId</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.ui.set

@Controller
@RequestMapping("/pets")
class EditPetForm {

	// ...

	@GetMapping
	fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { <i class="conum" data-value="1"></i><b>(1)</b>
		val pet = this.clinic.loadPet(petId);
		model["pet"] = pet
		return "petForm"
	}

	// ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestParam</code> to bind <code>petId</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, method parameters that use this annotation are required, but you can specify that
a method parameter is optional by setting the <code>@RequestParam</code> annotation&#8217;s <code>required</code> flag to
<code>false</code> or by declaring the argument with an <code>java.util.Optional</code> wrapper.</p>
</div>
<div class="paragraph">
<p>Type conversion is automatically applied if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">Type Conversion</a>.</p>
</div>
<div class="paragraph">
<p>Declaring the argument type as an array or list allows for resolving multiple parameter
values for the same parameter name.</p>
</div>
<div class="paragraph">
<p>When an <code>@RequestParam</code> annotation is declared as a <code>Map&lt;String, String&gt;</code> or
<code>MultiValueMap&lt;String, String&gt;</code>, without a parameter name specified in the annotation,
then the map is populated with the request parameter values for each given parameter name.</p>
</div>
<div class="paragraph">
<p>Note that use of <code>@RequestParam</code> is optional (for example, to set its attributes).
By default, any argument that is a simple value type (as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver, is treated as if it were annotated
with <code>@RequestParam</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestheader"><a class="anchor" href="#mvc-ann-requestheader"></a><code>@RequestHeader</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestheader" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a
controller.</p>
</div>
<div class="paragraph">
<p>Consider the following request, with headers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
<div class="paragraph">
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/demo")
public void handle(
		@RequestHeader("Accept-Encoding") String encoding, <i class="conum" data-value="1"></i><b>(1)</b>
		@RequestHeader("Keep-Alive") long keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>Accept-Encoding</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the value of the <code>Keep-Alive</code> header.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/demo")
fun handle(
		@RequestHeader("Accept-Encoding") encoding: String, <i class="conum" data-value="1"></i><b>(1)</b>
		@RequestHeader("Keep-Alive") keepAlive: Long) { <i class="conum" data-value="2"></i><b>(2)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>Accept-Encoding</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the value of the <code>Keep-Alive</code> header.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the target method parameter type is not
<code>String</code>, type conversion is automatically applied. See <a href="#mvc-ann-typeconversion">Type Conversion</a>.</p>
</div>
<div class="paragraph">
<p>When an <code>@RequestHeader</code> annotation is used on a <code>Map&lt;String, String&gt;</code>,
<code>MultiValueMap&lt;String, String&gt;</code>, or <code>HttpHeaders</code> argument, the map is populated
with all header values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with <code>@RequestHeader("Accept")</code> can be of type
<code>String</code> but also <code>String[]</code> or <code>List&lt;String&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-cookievalue"><a class="anchor" href="#mvc-ann-cookievalue"></a><code>@CookieValue</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-cookievalue" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@CookieValue</code> annotation to bind the value of an HTTP cookie to a method argument
in a controller.</p>
</div>
<div class="paragraph">
<p>Consider a request with the following cookie:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to get the cookie value:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>JSESSIONID</code> cookie.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/demo")
fun handle(@CookieValue("JSESSIONID") cookie: String) { <i class="conum" data-value="1"></i><b>(1)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>JSESSIONID</code> cookie.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the target method parameter type is not <code>String</code>, type conversion is applied automatically.
See <a href="#mvc-ann-typeconversion">Type Conversion</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-modelattrib-method-args"><a class="anchor" href="#mvc-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-modelattrib-method-args" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation on a method argument to access an attribute from
the model or have it be instantiated if not present. The model attribute is also overlain with
values from HTTP Servlet request parameters whose names match to field names. This is referred
to as data binding, and it saves you from having to deal with parsing and converting individual
query parameters and form fields. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) {
	// method logic...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String {
	// method logic...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Pet</code> instance above is sourced in one of the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Retrieved from the model where it may have been added by a
<a href="#mvc-ann-modelattrib-methods">@ModelAttribute method</a>.</p>
</li>
<li>
<p>Retrieved from the HTTP session if the model attribute was listed in
the class-level <a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> annotation.</p>
</li>
<li>
<p>Obtained through a <code>Converter</code> where the model attribute name matches the name of a
request value such as a path variable or a request parameter (see next example).</p>
</li>
<li>
<p>Instantiated using its default constructor.</p>
</li>
<li>
<p>Instantiated through a &#8220;primary constructor&#8221; with arguments that match to Servlet
request parameters. Argument names are determined through JavaBeans
<code>@ConstructorProperties</code> or through runtime-retained parameter names in the bytecode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One alternative to using a <a href="#mvc-ann-modelattrib-methods">@ModelAttribute method</a> to
supply it or relying on the framework to create the model attribute, is to have a
<code>Converter&lt;String, T&gt;</code> to provide the instance. This is applied when the model attribute
name matches to the name of a request value such as a path variable or a request
parameter, and there is a <code>Converter</code> from <code>String</code> to the model attribute type.
In the following example, the model attribute name is <code>account</code> which matches the URI
path variable <code>account</code>, and there is a registered <code>Converter&lt;String, Account&gt;</code> which
could load the <code>Account</code> from a data store:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PutMapping("/accounts/{account}")
public String save(@ModelAttribute("account") Account account) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PutMapping("/accounts/{account}")
fun save(@ModelAttribute("account") account: Account): String {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the model attribute instance is obtained, data binding is applied. The
<code>WebDataBinder</code> class matches Servlet request parameter names (query parameters and form
fields) to field names on the target <code>Object</code>. Matching fields are populated after type
conversion is applied, where necessary. For more on data binding (and validation), see
<a href="../core.html#validation" class="page">Validation</a>. For more on customizing data binding, see
<a href="#mvc-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>Data binding can result in errors. By default, a <code>BindException</code> is raised. However, to check
for such errors in the controller method, you can add a <code>BindingResult</code> argument immediately next
to the <code>@ModelAttribute</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm";
	}
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a <code>BindingResult</code> next to the <code>@ModelAttribute</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm"
	}
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a <code>BindingResult</code> next to the <code>@ModelAttribute</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases, you may want access to a model attribute without data binding. For such
cases, you can inject the <code>Model</code> into the controller and access it directly or,
alternatively, set <code>@ModelAttribute(binding=false)</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ModelAttribute
public AccountForm setUpForm() {
	return new AccountForm();
}

@ModelAttribute
public Account findAccount(@PathVariable String accountId) {
	return accountRepository.findOne(accountId);
}

@PostMapping("update")
public String update(@Valid AccountForm form, BindingResult result,
		@ModelAttribute(binding=false) Account account) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting <code>@ModelAttribute(binding=false)</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ModelAttribute
fun setUpForm(): AccountForm {
	return AccountForm()
}

@ModelAttribute
fun findAccount(@PathVariable accountId: String): Account {
	return accountRepository.findOne(accountId)
}

@PostMapping("update")
fun update(@Valid form: AccountForm, result: BindingResult,
		   @ModelAttribute(binding = false) account: Account): String { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting <code>@ModelAttribute(binding=false)</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can automatically apply validation after data binding by adding the
<code>javax.validation.Valid</code> annotation or Spring&#8217;s <code>@Validated</code> annotation (
<a href="../core.html#validation-beanvalidation" class="page">Bean Validation</a> and
<a href="../core.html#validation" class="page">Spring validation</a>). The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm";
	}
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Validate the <code>Pet</code> instance.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm"
	}
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that using <code>@ModelAttribute</code> is optional (for example, to set its attributes).
By default, any argument that is not a simple value type (as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@ModelAttribute</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-sessionattributes"><a class="anchor" href="#mvc-ann-sessionattributes"></a><code>@SessionAttributes</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-sessionattributes" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code> is used to store model attributes in the HTTP Servlet session between
requests. It is a type-level annotation that declares the session attributes used by a
specific controller. This typically lists the names of model attributes or types of
model attributes that should be transparently stored in the session for subsequent
requests to access.</p>
</div>
<div class="paragraph">
<p>The following example uses the <code>@SessionAttributes</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the first request, when a model attribute with the name, <code>pet</code>, is added to the model,
it is automatically promoted to and saved in the HTTP Servlet session. It remains there
until another controller method uses a <code>SessionStatus</code> method argument to clear the
storage, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	public String handle(Pet pet, BindingResult errors, SessionStatus status) {
		if (errors.hasErrors) {
			// ...
		}
			status.setComplete(); <i class="conum" data-value="2"></i><b>(2)</b>
			// ...
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Storing the <code>Pet</code> value in the Servlet session.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Clearing the <code>Pet</code> value from the Servlet session.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {
		if (errors.hasErrors()) {
			// ...
		}
		status.setComplete() <i class="conum" data-value="2"></i><b>(2)</b>
		// ...
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Storing the <code>Pet</code> value in the Servlet session.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Clearing the <code>Pet</code> value from the Servlet session.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-sessionattribute"><a class="anchor" href="#mvc-ann-sessionattribute"></a><code>@SessionAttribute</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-sessionattribute" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>If you need access to pre-existing session attributes that are managed globally
(that is, outside the controller&#8201;&#8212;&#8201;for example, by a filter) and may or may not be present,
you can use the <code>@SessionAttribute</code> annotation on a method parameter,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping("/")
public String handle(@SessionAttribute User user) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>@SessionAttribute</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RequestMapping("/")
fun handle(@SessionAttribute user: User): String { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For use cases that require adding or removing session attributes, consider injecting
<code>org.springframework.web.context.request.WebRequest</code> or
<code>javax.servlet.http.HttpSession</code> into the controller method.</p>
</div>
<div class="paragraph">
<p>For temporary storage of model attributes in the session as part of a controller
workflow, consider using <code>@SessionAttributes</code> as described in
<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestattrib"><a class="anchor" href="#mvc-ann-requestattrib"></a><code>@RequestAttribute</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestattrib" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Similar to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotations to
access pre-existing request attributes created earlier (for example, by a Servlet <code>Filter</code>
or <code>HandlerInterceptor</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@RequestAttribute</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/")
fun handle(@RequestAttribute client: Client): String { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@RequestAttribute</code> annotation.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-redirecting-passing-data"><a class="anchor" href="#mvc-redirecting-passing-data"></a>Redirect Attributes</h4>
<div class="paragraph">
<p>By default, all model attributes are considered to be exposed as URI template variables in
the redirect URL. Of the remaining attributes, those that are primitive types or
collections or arrays of primitive types are automatically appended as query parameters.</p>
</div>
<div class="paragraph">
<p>Appending primitive type attributes as query parameters can be the desired result if a
model instance was prepared specifically for the redirect. However, in annotated
controllers, the model can contain additional attributes added for rendering purposes (for example,
drop-down field values). To avoid the possibility of having such attributes appear in the
URL, a <code>@RequestMapping</code> method can declare an argument of type <code>RedirectAttributes</code> and
use it to specify the exact attributes to make available to <code>RedirectView</code>. If the method
does redirect, the content of <code>RedirectAttributes</code> is used.  Otherwise, the content of the
model is used.</p>
</div>
<div class="paragraph">
<p>The <code>RequestMappingHandlerAdapter</code> provides a flag called
<code>ignoreDefaultModelOnRedirect</code>, which you can use to indicate that the content of the default
<code>Model</code> should never be used if a controller method redirects. Instead, the controller
method should declare an attribute of type <code>RedirectAttributes</code> or, if it does not do so,
no attributes should be passed on to <code>RedirectView</code>. Both the MVC namespace and the MVC
Java configuration keep this flag set to <code>false</code>, to maintain backwards compatibility.
However, for new applications, we recommend setting it to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Note that URI template variables from the present request are automatically made
available when expanding a redirect URL, and you don&#8217;t need to explicitly add them
through <code>Model</code> or <code>RedirectAttributes</code>. The following example shows how to define a redirect:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/files/{path}")
public String upload(...) {
	// ...
	return "redirect:files/{path}";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/files/{path}")
fun upload(...): String {
	// ...
	return "redirect:files/{path}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way of passing data to the redirect target is by using flash attributes. Unlike
other redirect attributes, flash attributes are saved in the HTTP session (and, hence, do
not appear in the URL). See <a href="#mvc-flash-attributes">Flash Attributes</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-flash-attributes"><a class="anchor" href="#mvc-flash-attributes"></a>Flash Attributes</h4>
<div class="paragraph">
<p>Flash attributes provide a way for one request to store attributes that are intended for use in
another. This is most commonly needed when redirecting&#8201;&#8212;&#8201;for example, the
Post-Redirect-Get pattern. Flash attributes are saved temporarily before the
redirect (typically in the session) to be made available to the request after the
redirect and are removed immediately.</p>
</div>
<div class="paragraph">
<p>Spring MVC has two main abstractions in support of flash attributes. <code>FlashMap</code> is used
to hold flash attributes, while <code>FlashMapManager</code> is used to store, retrieve, and manage
<code>FlashMap</code> instances.</p>
</div>
<div class="paragraph">
<p>Flash attribute support is always &#8220;on&#8221; and does not need to be enabled explicitly.
However, if not used, it never causes HTTP session creation. On each request, there is an
&#8220;input&#8221; <code>FlashMap</code> with attributes passed from a previous request (if any) and an
&#8220;output&#8221; <code>FlashMap</code> with attributes to save for a subsequent request. Both <code>FlashMap</code>
instances are accessible from anywhere in Spring MVC through static methods in
<code>RequestContextUtils</code>.</p>
</div>
<div class="paragraph">
<p>Annotated controllers typically do not need to work with <code>FlashMap</code> directly. Instead, a
<code>@RequestMapping</code> method can accept an argument of type <code>RedirectAttributes</code> and use it
to add flash attributes for a redirect scenario. Flash attributes added through
<code>RedirectAttributes</code> are automatically propagated to the &#8220;output&#8221; FlashMap. Similarly,
after the redirect, attributes from the &#8220;input&#8221; <code>FlashMap</code> are automatically added to the
<code>Model</code> of the controller that serves the target URL.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Matching requests to flash attributes</div>
<div class="paragraph">
<p>The concept of flash attributes exists in many other web frameworks and has proven to sometimes
be exposed to concurrency issues. This is because, by definition, flash attributes
are to be stored until the next request. However the very &#8220;next&#8221; request may not be the
intended recipient but another asynchronous request (for example, polling or resource requests),
in which case the flash attributes are removed too early.</p>
</div>
<div class="paragraph">
<p>To reduce the possibility of such issues, <code>RedirectView</code> automatically &#8220;stamps&#8221;
<code>FlashMap</code> instances with the path and query parameters of the target redirect URL. In
turn, the default <code>FlashMapManager</code> matches that information to incoming requests when
it looks up the &#8220;input&#8221; <code>FlashMap</code>.</p>
</div>
<div class="paragraph">
<p>This does not entirely eliminate the possibility of a concurrency issue but
reduces it greatly with information that is already available in the redirect URL.
Therefore, we recommend that you use flash attributes mainly for redirect scenarios.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-multipart-forms"><a class="anchor" href="#mvc-multipart-forms"></a>Multipart</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-multipart-forms" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>After a <code>MultipartResolver</code> has been <a href="#mvc-multipart">enabled</a>, the content of POST
requests with <code>multipart/form-data</code> is parsed and accessible as regular request
parameters. The following example accesses one regular form field and one uploaded
file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class FileUploadController {

	@PostMapping("/form")
	public String handleFormUpload(@RequestParam("name") String name,
			@RequestParam("file") MultipartFile file) {

		if (!file.isEmpty()) {
			byte[] bytes = file.getBytes();
			// store the bytes somewhere
			return "redirect:uploadSuccess";
		}
		return "redirect:uploadFailure";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class FileUploadController {

	@PostMapping("/form")
	fun handleFormUpload(@RequestParam("name") name: String,
						@RequestParam("file") file: MultipartFile): String {

		if (!file.isEmpty) {
			val bytes = file.bytes
			// store the bytes somewhere
			return "redirect:uploadSuccess"
		}
		return "redirect:uploadFailure"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Declaring the argument type as a <code>List&lt;MultipartFile&gt;</code> allows for resolving multiple
files for the same parameter name.</p>
</div>
<div class="paragraph">
<p>When the <code>@RequestParam</code> annotation is declared as a <code>Map&lt;String, MultipartFile&gt;</code> or
<code>MultiValueMap&lt;String, MultipartFile&gt;</code>, without a parameter name specified in the annotation,
then the map is populated with the multipart files for each given parameter name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With Servlet 3.0 multipart parsing, you may also declare <code>javax.servlet.http.Part</code>
instead of Spring&#8217;s <code>MultipartFile</code>, as a method argument or collection value type.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use multipart content as part of data binding to a
<a href="#mvc-ann-modelattrib-method-args">command object</a>. For example, the form field
and file from the preceding example could be fields on a form object,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyForm {

	private String name;

	private MultipartFile file;

	// ...
}

@Controller
public class FileUploadController {

	@PostMapping("/form")
	public String handleFormUpload(MyForm form, BindingResult errors) {
		if (!form.getFile().isEmpty()) {
			byte[] bytes = form.getFile().getBytes();
			// store the bytes somewhere
			return "redirect:uploadSuccess";
		}
		return "redirect:uploadFailure";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyForm(val name: String, val file: MultipartFile, ...)

@Controller
class FileUploadController {

	@PostMapping("/form")
	fun handleFormUpload(form: MyForm, errors: BindingResult): String {
		if (!form.file.isEmpty) {
			val bytes = form.file.bytes
			// store the bytes somewhere
			return "redirect:uploadSuccess"
		}
		return "redirect:uploadFailure"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multipart requests can also be submitted from non-browser clients in a RESTful service
scenario. The following example shows a file with JSON:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
<div class="paragraph">
<p>You can access the "meta-data" part with <code>@RequestParam</code> as a <code>String</code> but you&#8217;ll
probably want it deserialized from JSON (similar to <code>@RequestBody</code>). Use the
<code>@RequestPart</code> annotation to access a multipart after converting it with an
<a href="../integration.html#rest-message-conversion" class="page">HttpMessageConverter</a>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata,
		@RequestPart("file-data") MultipartFile file) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestPart("meta-data") metadata: MetaData,
		@RequestPart("file-data") file: MultipartFile): String {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>@RequestPart</code> in combination with <code>javax.validation.Valid</code> or use Spring&#8217;s
<code>@Validated</code> annotation, both of which cause Standard Bean Validation to be applied.
By default, validation errors cause a <code>MethodArgumentNotValidException</code>, which is turned
into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or <code>BindingResult</code> argument,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
		BindingResult result) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/")
fun handle(@Valid @RequestPart("meta-data") metadata: MetaData,
		result: BindingResult): String {
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestbody"><a class="anchor" href="#mvc-ann-requestbody"></a><code>@RequestBody</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-requestbody" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestBody</code> annotation to have the request body read and deserialized into an
<code>Object</code> through an <a href="../integration.html#rest-message-conversion" class="page"><code>HttpMessageConverter</code></a>.
The following example uses a <code>@RequestBody</code> argument:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@RequestBody account: Account) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <a href="#mvc-config-message-converters">Message Converters</a> option of the <a href="#mvc-config">MVC Config</a> to
configure or customize message conversion.</p>
</div>
<div class="paragraph">
<p>You can use <code>@RequestBody</code> in combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, both of which cause Standard Bean Validation to be applied.
By default, validation errors cause a <code>MethodArgumentNotValidException</code>, which is turned
into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or <code>BindingResult</code> argument,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-httpentity"><a class="anchor" href="#mvc-ann-httpentity"></a>HttpEntity</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-httpentity" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code> is more or less identical to using <a href="#mvc-ann-requestbody"><code>@RequestBody</code></a> but is based on a
container object that exposes request headers and body. The following listing shows an example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping("/accounts")
fun handle(entity: HttpEntity&lt;Account&gt;) {
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-responsebody"><a class="anchor" href="#mvc-ann-responsebody"></a><code>@ResponseBody</code></h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-responsebody" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ResponseBody</code> annotation on a method to have the return serialized
to the response body through an
<a href="../integration.html#rest-message-conversion" class="page">HttpMessageConverter</a>.
The following listing shows an example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ResponseBody
fun handle(): Account {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of <code>@RestController</code>, which is nothing more
than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p>You can use <code>@ResponseBody</code> with reactive types.
See <a href="#mvc-ann-async">Asynchronous Requests</a> and <a href="#mvc-ann-async-reactive-types">Reactive Types</a> for more details.</p>
</div>
<div class="paragraph">
<p>You can use the <a href="#mvc-config-message-converters">Message Converters</a> option of the <a href="#mvc-config">MVC Config</a> to
configure or customize message conversion.</p>
</div>
<div class="paragraph">
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views.
See <a href="#mvc-ann-jackson">Jackson JSON</a> for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-responseentity"><a class="anchor" href="#mvc-ann-responseentity"></a>ResponseEntity</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-responseentity" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code> is like <a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
	String body = ... ;
	String etag = ... ;
	return ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/something")
fun handle(): ResponseEntity&lt;String&gt; {
	val body = ...
	val etag = ...
	return ResponseEntity.ok().eTag(etag).build(body)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC supports using a single value <a href="#mvc-ann-async-reactive-types">reactive type</a>
to produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive
types for the body. This allows the following types of async responses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ResponseEntity&lt;Mono&lt;T&gt;&gt;</code> or <code>ResponseEntity&lt;Flux&lt;T&gt;&gt;</code> make the response status and
headers known immediately while the body is provided asynchronously at a later point.
Use <code>Mono</code> if the body consists of 0..1 values or <code>Flux</code> if it can produce multiple values.</p>
</li>
<li>
<p><code>Mono&lt;ResponseEntity&lt;T&gt;&gt;</code> provides all three&#8201;&#8212;&#8201;response status, headers, and body,
asynchronously at a later point. This allows the response status and headers to vary
depending on the outcome of asynchronous request handling.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-jackson"><a class="anchor" href="#mvc-ann-jackson"></a>Jackson JSON</h4>
<div class="paragraph">
<p>Spring offers support for the Jackson JSON library.</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-jsonview"><a class="anchor" href="#mvc-ann-jsonview"></a>JSON Views</h5>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-jsonview" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC provides built-in support for
<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson&#8217;s Serialization Views</a>,
which allow rendering only a subset of all fields in an <code>Object</code>. To use it with
<code>@ResponseBody</code> or <code>ResponseEntity</code> controller methods, you can use Jackson&#8217;s
<code>@JsonView</code> annotation to activate a serialization view class, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class UserController {

	@GetMapping("/user")
	@JsonView(User.WithoutPasswordView.class)
	public User getUser() {
		return new User("eric", "7!jd#h23");
	}
}

public class User {

	public interface WithoutPasswordView {};
	public interface WithPasswordView extends WithoutPasswordView {};

	private String username;
	private String password;

	public User() {
	}

	public User(String username, String password) {
		this.username = username;
		this.password = password;
	}

	@JsonView(WithoutPasswordView.class)
	public String getUsername() {
		return this.username;
	}

	@JsonView(WithPasswordView.class)
	public String getPassword() {
		return this.password;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RestController
class UserController {

	@GetMapping("/user")
	@JsonView(User.WithoutPasswordView::class)
	fun getUser() = User("eric", "7!jd#h23")
}

class User(
		@JsonView(WithoutPasswordView::class) val username: String,
		@JsonView(WithPasswordView::class) val password: String) {

	interface WithoutPasswordView
	interface WithPasswordView : WithoutPasswordView
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@JsonView</code> allows an array of view classes, but you can specify only one per
controller method. If you need to activate multiple views, you can use a composite interface.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to do the above programmatically, instead of declaring an <code>@JsonView</code> annotation,
wrap the return value with <code>MappingJacksonValue</code> and use it to supply the serialization view:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class UserController {

	@GetMapping("/user")
	public MappingJacksonValue getUser() {
		User user = new User("eric", "7!jd#h23");
		MappingJacksonValue value = new MappingJacksonValue(user);
		value.setSerializationView(User.WithoutPasswordView.class);
		return value;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RestController
class UserController {

	@GetMapping("/user")
	fun getUser(): MappingJacksonValue {
		val value = MappingJacksonValue(User("eric", "7!jd#h23"))
		value.serializationView = User.WithoutPasswordView::class.java
		return value
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For controllers that rely on view resolution, you can add the serialization view class
to the model, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class UserController extends AbstractController {

	@GetMapping("/user")
	public String getUser(Model model) {
		model.addAttribute("user", new User("eric", "7!jd#h23"));
		model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
		return "userView";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.ui.set

@Controller
class UserController : AbstractController() {

	@GetMapping("/user")
	fun getUser(model: Model): String {
		model["user"] = User("eric", "7!jd#h23")
		model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java
		return "userView"
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-modelattrib-methods"><a class="anchor" href="#mvc-ann-modelattrib-methods"></a>Model</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-modelattrib-methods" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On a <a href="#mvc-ann-modelattrib-method-args">method argument</a> in <code>@RequestMapping</code> methods
to create or access an <code>Object</code> from the model and to bind it to the request through a
<code>WebDataBinder</code>.</p>
</li>
<li>
<p>As a method-level annotation in <code>@Controller</code> or <code>@ControllerAdvice</code> classes that help
to initialize the model prior to any <code>@RequestMapping</code> method invocation.</p>
</li>
<li>
<p>On a <code>@RequestMapping</code> method to mark its return value is a model attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section discusses <code>@ModelAttribute</code> methods&#8201;&#8212;&#8201;the second item in the preceding list.
A controller can have any number of <code>@ModelAttribute</code> methods. All such methods are
invoked before <code>@RequestMapping</code> methods in the same controller. A <code>@ModelAttribute</code>
method can also be shared across controllers through <code>@ControllerAdvice</code>. See the section on
<a href="#mvc-ann-controller-advice">Controller Advice</a> for more details.</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code> methods have flexible method signatures. They support many of the same
arguments as <code>@RequestMapping</code> methods, except for <code>@ModelAttribute</code> itself or anything
related to the request body.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>@ModelAttribute</code> method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
	model.addAttribute(accountRepository.findAccount(number));
	// add more ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ModelAttribute
fun populateModel(@RequestParam number: String, model: Model) {
	model.addAttribute(accountRepository.findAccount(number))
	// add more ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example adds only one attribute:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
	return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ModelAttribute
fun addAccount(@RequestParam number: String): Account {
	return accountRepository.findAccount(number)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a name is not explicitly specified, a default name is chosen based on the <code>Object</code>
type, as explained in the javadoc for {api-spring-framework}/core/Conventions.html[<code>Conventions</code>].
You can always assign an explicit name by using the overloaded <code>addAttribute</code> method or
through the <code>name</code> attribute on <code>@ModelAttribute</code> (for a return value).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use <code>@ModelAttribute</code> as a method-level annotation on <code>@RequestMapping</code> methods,
in which case the return value of the <code>@RequestMapping</code> method is interpreted as a model
attribute. This is typically not required, as it is the default behavior in HTML controllers,
unless the return value is a <code>String</code> that would otherwise be interpreted as a view name.
<code>@ModelAttribute</code> can also customize the model attribute name, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
	// ...
	return account;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
fun handle(): Account {
	// ...
	return account
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-initbinder"><a class="anchor" href="#mvc-ann-initbinder"></a><code>DataBinder</code></h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-initbinder" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> or <code>@ControllerAdvice</code> classes can have <code>@InitBinder</code> methods that
initialize instances of <code>WebDataBinder</code>, and those, in turn, can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bind request parameters (that is, form or query data) to a model object.</p>
</li>
<li>
<p>Convert String-based request values (such as request parameters, path variables,
headers, cookies, and others) to the target type of controller method arguments.</p>
</li>
<li>
<p>Format model object values as <code>String</code> values when rendering HTML forms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> methods can register controller-specific <code>java.beans.PropertyEditor</code> or
Spring <code>Converter</code> and <code>Formatter</code> components. In addition, you can use the
<a href="#mvc-config-conversion">MVC config</a> to register <code>Converter</code> and <code>Formatter</code>
types in a globally shared <code>FormattingConversionService</code>.</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> methods support many of the same arguments that <code>@RequestMapping</code> methods
do, except for <code>@ModelAttribute</code> (command object) arguments. Typically, they are declared
with a <code>WebDataBinder</code> argument (for registrations) and a <code>void</code> return value.
The following listing shows an example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class FormController {

	@InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
	public void initBinder(WebDataBinder binder) {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		dateFormat.setLenient(false);
		binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining an <code>@InitBinder</code> method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class FormController {

	@InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
	fun initBinder(binder: WebDataBinder) {
		val dateFormat = SimpleDateFormat("yyyy-MM-dd")
		dateFormat.isLenient = false
		binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining an <code>@InitBinder</code> method.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, when you use a <code>Formatter</code>-based setup through a shared
<code>FormattingConversionService</code>, you can re-use the same approach and register
controller-specific <code>Formatter</code> implementations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class FormController {

	@InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
	protected void initBinder(WebDataBinder binder) {
		binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining an <code>@InitBinder</code> method on a custom formatter.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class FormController {

	@InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
	protected fun initBinder(binder: WebDataBinder) {
		binder.addCustomFormatter(DateFormatter("yyyy-MM-dd"))
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining an <code>@InitBinder</code> method on a custom formatter.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-exceptionhandler"><a class="anchor" href="#mvc-ann-exceptionhandler"></a>Exceptions</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-controller-exceptions" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> and <a href="#mvc-ann-controller-advice">@ControllerAdvice</a> classes can have
<code>@ExceptionHandler</code> methods to handle exceptions from controller methods, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class SimpleController {

	// ...

	@ExceptionHandler
	public ResponseEntity&lt;String&gt; handle(IOException ex) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class SimpleController {

	// ...

	@ExceptionHandler
	fun handle(ex: IOException): ResponseEntity&lt;String&gt; {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The exception may match against a top-level exception being propagated (e.g. a direct
<code>IOException</code> being thrown) or against a nested cause within a wrapper exception (e.g.
an <code>IOException</code> wrapped inside an <code>IllegalStateException</code>). As of 5.3, this can match
at arbitrary cause levels, whereas previously only an immediate cause was considered.</p>
</div>
<div class="paragraph">
<p>For matching exception types, preferably declare the target exception as a method argument,
as the preceding example shows. When multiple exception methods match, a root exception match is
generally preferred to a cause exception match. More specifically, the <code>ExceptionDepthComparator</code>
is used to sort exceptions based on their depth from the thrown exception type.</p>
</div>
<div class="paragraph">
<p>Alternatively, the annotation declaration may narrow the exception types to match,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(IOException ex) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExceptionHandler(FileSystemException::class, RemoteException::class)
fun handle(ex: IOException): ResponseEntity&lt;String&gt; {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even use a list of specific exception types with a very generic argument signature,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(Exception ex) {
	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExceptionHandler(FileSystemException::class, RemoteException::class)
fun handle(ex: Exception): ResponseEntity&lt;String&gt; {
	// ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The distinction between root and cause exception matching can be surprising.</p>
</div>
<div class="paragraph">
<p>In the <code>IOException</code> variant shown earlier, the method is typically called with
the actual <code>FileSystemException</code> or <code>RemoteException</code> instance as the argument,
since both of them extend from <code>IOException</code>. However, if any such matching
exception is propagated within a wrapper exception which is itself an <code>IOException</code>,
the passed-in exception instance is that wrapper exception.</p>
</div>
<div class="paragraph">
<p>The behavior is even simpler in the <code>handle(Exception)</code> variant. This is
always invoked with the wrapper exception in a wrapping scenario, with the
actually matching exception to be found through <code>ex.getCause()</code> in that case.
The passed-in exception is the actual <code>FileSystemException</code> or
<code>RemoteException</code> instance only when these are thrown as top-level exceptions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We generally recommend that you be as specific as possible in the argument signature,
reducing the potential for mismatches between root and cause exception types.
Consider breaking a multi-matching method into individual <code>@ExceptionHandler</code>
methods, each matching a single specific exception type through its signature.</p>
</div>
<div class="paragraph">
<p>In a multi-<code>@ControllerAdvice</code> arrangement, we recommend declaring your primary root exception
mappings on a <code>@ControllerAdvice</code> prioritized with a corresponding order. While a root
exception match is preferred to a cause, this is defined among the methods of a given
controller or <code>@ControllerAdvice</code> class. This means a cause match on a higher-priority
<code>@ControllerAdvice</code> bean is preferred to any match (for example, root) on a lower-priority
<code>@ControllerAdvice</code> bean.</p>
</div>
<div class="paragraph">
<p>Last but not least, an <code>@ExceptionHandler</code> method implementation can choose to back
out of dealing with a given exception instance by rethrowing it in its original form.
This is useful in scenarios where you are interested only in root-level matches or in
matches within a specific context that cannot be statically determined. A rethrown
exception is propagated through the remaining resolution chain, as though
the given <code>@ExceptionHandler</code> method would not have matched in the first place.</p>
</div>
<div class="paragraph">
<p>Support for <code>@ExceptionHandler</code> methods in Spring MVC is built on the <code>DispatcherServlet</code>
level, <a href="#mvc-exceptionhandlers">HandlerExceptionResolver</a> mechanism.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-exceptionhandler-args"><a class="anchor" href="#mvc-ann-exceptionhandler-args"></a>Method Arguments</h4>
<div class="paragraph">
<p><code>@ExceptionHandler</code> methods support the following arguments:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the raised exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the controller method that raised the exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code>, <code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generic access to request parameters and request and session attributes without direct
  use of the Servlet API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Choose any specific request or response type (for example, <code>ServletRequest</code> or
  <code>HttpServletRequest</code> or Spring&#8217;s <code>MultipartRequest</code> or <code>MultipartHttpServletRequest</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.HttpSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>.<br>
  Note that session access is not thread-safe. Consider setting the
  <code>RequestMappingHandlerAdapter</code> instance&#8217;s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple
  requests are allowed to access a session concurrently.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Currently authenticated user&#8201;&#8212;&#8201;possibly a specific <code>Principal</code> implementation class if known.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available&#8201;&#8212;&#8201;in
  effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the raw response body, as exposed by the Servlet API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the model for an error response. Always empty.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify attributes to use in case of a redirect&#8201;&#8212;&#8201;(that is to be appended to the query
  string) and flash attributes to be stored temporarily until the request after the redirect.
  See <a href="#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="#mvc-flash-attributes">Flash Attributes</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute, in contrast to model attributes stored in the
  session as a result of a class-level <code>@SessionAttributes</code> declaration.
  See <a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes. See <a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-ann-exceptionhandler-return-values"><a class="anchor" href="#mvc-ann-exceptionhandler-return-values"></a>Return Values</h4>
<div class="paragraph">
<p><code>@ExceptionHandler</code> methods support the following return values:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is converted through <code>HttpMessageConverter</code> instances and written to the
  response. See <a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value specifies that the full response (including the HTTP headers and the body)
  be converted through <code>HttpMessageConverter</code> instances and written to the response.
  See <a href="#mvc-ann-responseentity">ResponseEntity</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the
  implicit model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods.
  The handler method can also programmatically enrich the model by declaring a <code>Model</code>
  argument (described earlier).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
  through command objects and <code>@ModelAttribute</code> methods. The handler method may also
  programmatically enrich the model by declaring a <code>Model</code> argument (descried earlier).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model with the view name implicitly determined
  through a <code>RequestToViewNameTranslator</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An attribute to be added to the model with the view name implicitly determined through
  a <code>RequestToViewNameTranslator</code>.</p>
<p class="tableblock">  Note that <code>@ModelAttribute</code> is optional. See &#8220;Any other return value&#8221; at the end of
  this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code> object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The view and model attributes to use and, optionally, a response status.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully
  handled the response if it also has a <code>ServletResponse</code> an <code>OutputStream</code> argument, or
  a <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive
  <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="#mvc-caching-etag-lastmodified">Controllers</a> for details).</p>
<p class="tableblock">  If none of the above is true, a <code>void</code> return type can also indicate &#8220;no response body&#8221; for
  REST controllers or default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a return value is not matched to any of the above and is not a simple type (as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]),
  by default, it is treated as a model attribute to be added to the model. If it is a simple type,
  it remains unresolved.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-ann-rest-exceptions"><a class="anchor" href="#mvc-ann-rest-exceptions"></a>REST API exceptions</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-rest-exceptions" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>A common requirement for REST services is to include error details in the body of the
response. The Spring Framework does not automatically do this because the representation
of error details in the response body is application-specific. However, a
<code>@RestController</code> may use <code>@ExceptionHandler</code> methods with a <code>ResponseEntity</code> return
value to set the status and the body of the response. Such methods can also be declared
in <code>@ControllerAdvice</code> classes to apply them globally.</p>
</div>
<div class="paragraph">
<p>Applications that implement global exception handling with error details in the response
body should consider extending
{api-spring-framework}/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html[<code>ResponseEntityExceptionHandler</code>],
which provides handling for exceptions that Spring MVC raises and provides hooks to
customize the response body. To make use of this, create a subclass of
<code>ResponseEntityExceptionHandler</code>, annotate it with <code>@ControllerAdvice</code>, override the
necessary methods, and declare it as a Spring bean.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-controller-advice"><a class="anchor" href="#mvc-ann-controller-advice"></a>Controller Advice</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-ann-controller-advice" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Typically <code>@ExceptionHandler</code>, <code>@InitBinder</code>, and <code>@ModelAttribute</code> methods apply within
the <code>@Controller</code> class (or class hierarchy) in which they are declared. If you want such
methods to apply more globally (across controllers), you can declare them in a class
annotated with <code>@ControllerAdvice</code> or <code>@RestControllerAdvice</code>.</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code> is annotated with <code>@Component</code>, which means such classes can be
registered as Spring beans through <a href="../core.html#beans-java-instantiating-container-scan" class="page">component scanning</a>. <code>@RestControllerAdvice</code> is a composed annotation that is annotated
with both <code>@ControllerAdvice</code> and <code>@ResponseBody</code>, which essentially means
<code>@ExceptionHandler</code> methods are rendered to the response body through message conversion
(versus view resolution or template rendering).</p>
</div>
<div class="paragraph">
<p>On startup, the infrastructure classes for <code>@RequestMapping</code> and <code>@ExceptionHandler</code>
methods detect Spring beans annotated with <code>@ControllerAdvice</code> and then apply their
methods at runtime. Global <code>@ExceptionHandler</code> methods (from a <code>@ControllerAdvice</code>) are
applied <em>after</em> local ones (from the <code>@Controller</code>). By contrast, global <code>@ModelAttribute</code>
and <code>@InitBinder</code> methods are applied <em>before</em> local ones.</p>
</div>
<div class="paragraph">
<p>By default, <code>@ControllerAdvice</code> methods apply to every request (that is, all controllers),
but you can narrow that down to a subset of controllers by using attributes on the
annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = [RestController::class])
class ExampleAdvice1

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
class ExampleAdvice2

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
class ExampleAdvice3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The selectors in the preceding example are evaluated at runtime and may negatively impact
performance if used extensively. See the
{api-spring-framework}/web/bind/annotation/ControllerAdvice.html[<code>@ControllerAdvice</code>]
javadoc for more details.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webmvc-fn"><a class="anchor" href="#webmvc-fn"></a>Functional Endpoints</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring Web MVC includes WebMvc.fn, a lightweight functional programming model in which functions
are used to route and handle requests and contracts are designed for immutability.
It is an alternative to the annotation-based programming model but otherwise runs on
the same <a href="../web.html#mvc-servlet" class="page">web.adoc#mvc-servlet</a>.</p>
</div>
<div class="sect2">
<h3 id="webmvc-fn-overview"><a class="anchor" href="#webmvc-fn-overview"></a>Overview</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn-overview" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>In WebMvc.fn, an HTTP request is handled with a <code>HandlerFunction</code>: a function that takes
<code>ServerRequest</code> and returns a <code>ServerResponse</code>.
Both the request and the response object have immutable contracts that offer JDK 8-friendly
access to the HTTP request and response.
<code>HandlerFunction</code> is the equivalent of the body of a <code>@RequestMapping</code> method in the
annotation-based programming model.</p>
</div>
<div class="paragraph">
<p>Incoming requests are routed to a handler function with a <code>RouterFunction</code>: a function that
takes <code>ServerRequest</code> and returns an optional <code>HandlerFunction</code> (i.e. <code>Optional&lt;HandlerFunction&gt;</code>).
When the router function matches, a handler function is returned; otherwise an empty Optional.
<code>RouterFunction</code> is the equivalent of a <code>@RequestMapping</code> annotation, but with the major
difference that router functions provide not just data, but also behavior.</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route()</code> provides a router builder that facilitates the creation of routers,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;
import static org.springframework.web.servlet.function.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
	.GET("/person", accept(APPLICATION_JSON), handler::listPeople)
	.POST("/person", handler::createPerson)
	.build();


public class PersonHandler {

	// ...

	public ServerResponse listPeople(ServerRequest request) {
		// ...
	}

	public ServerResponse createPerson(ServerRequest request) {
		// ...
	}

	public ServerResponse getPerson(ServerRequest request) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val repository: PersonRepository = ...
val handler = PersonHandler(repository)

val route = router { <i class="conum" data-value="1"></i><b>(1)</b>
	accept(APPLICATION_JSON).nest {
		GET("/person/{id}", handler::getPerson)
		GET("/person", handler::listPeople)
	}
	POST("/person", handler::createPerson)
}


class PersonHandler(private val repository: PersonRepository) {

	// ...

	fun listPeople(request: ServerRequest): ServerResponse {
		// ...
	}

	fun createPerson(request: ServerRequest): ServerResponse {
		// ...
	}

	fun getPerson(request: ServerRequest): ServerResponse {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create router using the router DSL.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you register the <code>RouterFunction</code> as a bean, for instance by exposing it in a
@Configuration class, it will be auto-detected by the servlet, as explained in <a href="#webmvc-fn-running">Running a Server</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-fn-handler-functions"><a class="anchor" href="#webmvc-fn-handler-functions"></a>HandlerFunction</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn-handler-functions" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerRequest</code> and <code>ServerResponse</code> are immutable interfaces that offer JDK 8-friendly
access to the HTTP request and response, including headers, body, method, and status code.</p>
</div>
<div class="sect3">
<h4 id="webmvc-fn-request"><a class="anchor" href="#webmvc-fn-request"></a>ServerRequest</h4>
<div class="paragraph">
<p><code>ServerRequest</code> provides access to the HTTP method, URI, headers, and query parameters,
while access to the body is provided through the <code>body</code> methods.</p>
</div>
<div class="paragraph">
<p>The following example extracts the request body to a <code>String</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String string = request.body(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val string = request.body&lt;String&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example extracts the body to a <code>List&lt;Person&gt;</code>,
where <code>Person</code> objects are decoded from a serialized form, such as JSON or XML:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Person&gt; people = request.body(new ParameterizedTypeReference&lt;List&lt;Person&gt;&gt;() {});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val people = request.body&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to access parameters:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MultiValueMap&lt;String, String&gt; params = request.params();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val map = request.params()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-response"><a class="anchor" href="#webmvc-fn-response"></a>ServerResponse</h4>
<div class="paragraph">
<p><code>ServerResponse</code> provides access to the HTTP response and, since it is immutable, you can use
a <code>build</code> method to create it. You can use the builder to set the response status, to add response
headers, or to provide a body. The following example creates a 200 (OK) response with JSON
content:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Person person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val person: Person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to build a 201 (CREATED) response with a <code>Location</code> header and no body:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI location = ...
ServerResponse.created(location).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val location: URI = ...
ServerResponse.created(location).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use an asynchronous result as the body, in the form of a <code>CompletableFuture</code>,
<code>Publisher</code>, or any other type supported by the <code>ReactiveAdapterRegistry</code>. For instance:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;Person&gt; person = webClient.get().retrieve().bodyToMono(Person.class);
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val person = webClient.get().retrieve().awaitBody&lt;Person&gt;()
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If not just the body, but also the status or headers are based on an asynchronous type,
you can use the static <code>async</code> method on <code>ServerResponse</code>, which
accepts <code>CompletableFuture&lt;ServerResponse&gt;</code>, <code>Publisher&lt;ServerResponse&gt;</code>, or
any other asynchronous type supported by the <code>ReactiveAdapterRegistry</code>. For instance:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;ServerResponse&gt; asyncResponse = webClient.get().retrieve().bodyToMono(Person.class)
  .map(p -&gt; ServerResponse.ok().header("Name", p.name()).body(p));
ServerResponse.async(asyncResponse);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a> can be provided via the
static <code>sse</code> method on <code>ServerResponse</code>. The builder provided by that method
allows you to send Strings, or other objects as JSON. For example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public RouterFunction&lt;ServerResponse&gt; sse() {
       return route(GET("/sse"), request -&gt; ServerResponse.sse(sseBuilder -&gt; {
               	// Save the sseBuilder object somewhere..
               }));
}

// In some other thread, sending a String
sseBuilder.send("Hello world");

// Or an object, which will be transformed into JSON
   Person person = ...
sseBuilder.send(person);

   // Customize the event by using the other methods
   sseBuilder.id("42")
           .event("sse event")
           .data(person);

// and done at some point
sseBuilder.complete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">   fun sse(): RouterFunction&lt;ServerResponse&gt; = router {
       GET("/sse") { request -&gt; ServerResponse.sse { sseBuilder -&gt;
           // Save the sseBuilder object somewhere..
       }
   }

// In some other thread, sending a String
sseBuilder.send("Hello world")

// Or an object, which will be transformed into JSON
   val person = ...
sseBuilder.send(person)

   // Customize the event by using the other methods
   sseBuilder.id("42")
           .event("sse event")
           .data(person)

// and done at some point
sseBuilder.complete()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-handler-classes"><a class="anchor" href="#webmvc-fn-handler-classes"></a>Handler Classes</h4>
<div class="paragraph">
<p>We can write a handler function as a lambda, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body("Hello World");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val helloWorld: (ServerRequest) -&gt; ServerResponse =
  { ServerResponse.ok().body("Hello World") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is convenient, but in an application we need multiple functions, and multiple inline
lambda&#8217;s can get messy.
Therefore, it is useful to group related handler functions together into a handler class, which
has a similar role as  <code>@Controller</code> in an annotation-based application.
For example, the following class exposes a reactive <code>Person</code> repository:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

	private final PersonRepository repository;

	public PersonHandler(PersonRepository repository) {
		this.repository = repository;
	}

	public ServerResponse listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
		List&lt;Person&gt; people = repository.allPeople();
		return ok().contentType(APPLICATION_JSON).body(people);
	}

	public ServerResponse createPerson(ServerRequest request) throws Exception { <i class="conum" data-value="2"></i><b>(2)</b>
		Person person = request.body(Person.class);
		repository.savePerson(person);
		return ok().build();
	}

	public ServerResponse getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
		int personId = Integer.parseInt(request.pathVariable("id"));
		Person person = repository.getPerson(personId);
		if (person != null) {
			return ok().contentType(APPLICATION_JSON).body(person);
		}
		else {
			return ServerResponse.notFound().build();
		}
	}

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>listPeople</code> is a handler function that returns all <code>Person</code> objects found in the repository as
JSON.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>createPerson</code> is a handler function that stores a new <code>Person</code> contained in the request body.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>getPerson</code> is a handler function that returns a single person, identified by the <code>id</code> path
variable. We retrieve that <code>Person</code> from the repository and create a JSON response, if it is
found. If it is not found, we return a 404 Not Found response.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

	fun listPeople(request: ServerRequest): ServerResponse { <i class="conum" data-value="1"></i><b>(1)</b>
		val people: List&lt;Person&gt; = repository.allPeople()
		return ok().contentType(APPLICATION_JSON).body(people);
	}

	fun createPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="2"></i><b>(2)</b>
		val person = request.body&lt;Person&gt;()
		repository.savePerson(person)
		return ok().build()
	}

	fun getPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="3"></i><b>(3)</b>
		val personId = request.pathVariable("id").toInt()
		return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).body(it) }
				?: ServerResponse.notFound().build()

	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>listPeople</code> is a handler function that returns all <code>Person</code> objects found in the repository as
JSON.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>createPerson</code> is a handler function that stores a new <code>Person</code> contained in the request body.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>getPerson</code> is a handler function that returns a single person, identified by the <code>id</code> path
variable. We retrieve that <code>Person</code> from the repository and create a JSON response, if it is
found. If it is not found, we return a 404 Not Found response.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-handler-validation"><a class="anchor" href="#webmvc-fn-handler-validation"></a>Validation</h4>
<div class="paragraph">
<p>A functional endpoint can use Spring&#8217;s <a href="../core.html#validation" class="page">validation facilities</a> to
apply validation to the request body. For example, given a custom Spring
<a href="../core.html#validation" class="page">Validator</a> implementation for a <code>Person</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonHandler {

	private final Validator validator = new PersonValidator(); <i class="conum" data-value="1"></i><b>(1)</b>

	// ...

	public ServerResponse createPerson(ServerRequest request) {
		Person person = request.body(Person.class);
		validate(person); <i class="conum" data-value="2"></i><b>(2)</b>
		repository.savePerson(person);
		return ok().build();
	}

	private void validate(Person person) {
		Errors errors = new BeanPropertyBindingResult(person, "person");
		validator.validate(person, errors);
		if (errors.hasErrors()) {
			throw new ServerWebInputException(errors.toString()); <i class="conum" data-value="3"></i><b>(3)</b>
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create <code>Validator</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apply validation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Raise exception for a 400 response.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

	private val validator = PersonValidator() <i class="conum" data-value="1"></i><b>(1)</b>

	// ...

	fun createPerson(request: ServerRequest): ServerResponse {
		val person = request.body&lt;Person&gt;()
		validate(person) <i class="conum" data-value="2"></i><b>(2)</b>
		repository.savePerson(person)
		return ok().build()
	}

	private fun validate(person: Person) {
		val errors: Errors = BeanPropertyBindingResult(person, "person")
		validator.validate(person, errors)
		if (errors.hasErrors()) {
			throw ServerWebInputException(errors.toString()) <i class="conum" data-value="3"></i><b>(3)</b>
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create <code>Validator</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apply validation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Raise exception for a 400 response.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Handlers can also use the standard bean validation API (JSR-303) by creating and injecting
a global <code>Validator</code> instance based on <code>LocalValidatorFactoryBean</code>.
See <a href="../core.html#validation-beanvalidation" class="page">Spring Validation</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-fn-router-functions"><a class="anchor" href="#webmvc-fn-router-functions"></a><code>RouterFunction</code></h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn-router-functions" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Router functions are used to route the requests to the corresponding <code>HandlerFunction</code>.
Typically, you do not write router functions yourself, but rather use a method on the
<code>RouterFunctions</code> utility class to create one.
<code>RouterFunctions.route()</code> (no parameters) provides you with a fluent builder for creating a router
function, whereas <code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> offers a direct way
to create a router.</p>
</div>
<div class="paragraph">
<p>Generally, it is recommended to use the <code>route()</code> builder, as it provides
convenient short-cuts for typical mapping scenarios without requiring hard-to-discover
static imports.
For instance, the router function builder offers the method <code>GET(String, HandlerFunction)</code> to create a mapping for GET requests; and <code>POST(String, HandlerFunction)</code> for POSTs.</p>
</div>
<div class="paragraph">
<p>Besides HTTP method-based mapping, the route builder offers a way to introduce additional
predicates when mapping to requests.
For each HTTP method there is an overloaded variant that takes a <code>RequestPredicate</code> as a
parameter, though which additional constraints can be expressed.</p>
</div>
<div class="sect3">
<h4 id="webmvc-fn-predicates"><a class="anchor" href="#webmvc-fn-predicates"></a>Predicates</h4>
<div class="paragraph">
<p>You can write your own <code>RequestPredicate</code>, but the <code>RequestPredicates</code> utility class
offers commonly used implementations, based on the request path, HTTP method, content-type,
and so on.
The following example uses a request predicate to create a constraint based on the <code>Accept</code>
header:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
	.GET("/hello-world", accept(MediaType.TEXT_PLAIN),
		request -&gt; ServerResponse.ok().body("Hello World")).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
	GET("/hello-world", accept(TEXT_PLAIN)) {
		ServerResponse.ok().body("Hello World")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can compose multiple request predicates together by using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code>&#8201;&#8212;&#8201;both must match.</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code>&#8201;&#8212;&#8201;either can match.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many of the predicates from <code>RequestPredicates</code> are composed.
For example, <code>RequestPredicates.GET(String)</code> is composed from <code>RequestPredicates.method(HttpMethod)</code>
and <code>RequestPredicates.path(String)</code>.
The example shown above also uses two request predicates, as the builder uses
<code>RequestPredicates.GET</code> internally, and composes that with the <code>accept</code> predicate.</p>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-routes"><a class="anchor" href="#webmvc-fn-routes"></a>Routes</h4>
<div class="paragraph">
<p>Router functions are evaluated in order: if the first route does not match, the
second is evaluated, and so on.
Therefore, it makes sense to declare more specific routes before general ones.
This is also important when registering router functions as Spring beans, as will
be described later.
Note that this behavior is different from the annotation-based programming model, where the
"most specific" controller method is picked automatically.</p>
</div>
<div class="paragraph">
<p>When using the router function builder, all defined routes are composed into one
<code>RouterFunction</code> that is returned from <code>build()</code>.
There are also other ways to compose multiple router functions together:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>add(RouterFunction)</code> on the <code>RouterFunctions.route()</code> builder</p>
</li>
<li>
<p><code>RouterFunction.and(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code>&#8201;&#8212;&#8201;shortcut for
<code>RouterFunction.and()</code> with nested <code>RouterFunctions.route()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows the composition of four routes:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
	.GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
	.POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
	.add(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b>
	.build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>GET /person/{id}</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>GET /person</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>POST /person</code> with no additional predicates is mapped to
<code>PersonHandler.createPerson</code>, and</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>otherRoute</code> is a router function that is created elsewhere, and added to the route built.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.http.MediaType.APPLICATION_JSON
import org.springframework.web.servlet.function.router

val repository: PersonRepository = ...
val handler = PersonHandler(repository);

val otherRoute = router {  }

val route = router {
	GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
	GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
	POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
}.and(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>GET /person/{id}</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>GET /person</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>POST /person</code> with no additional predicates is mapped to
<code>PersonHandler.createPerson</code>, and</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>otherRoute</code> is a router function that is created elsewhere, and added to the route built.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_nested_routes"><a class="anchor" href="#_nested_routes"></a>Nested Routes</h4>
<div class="paragraph">
<p>It is common for a group of router functions to have a shared predicate, for instance a shared
path.
In the example above, the shared predicate would be a path predicate that matches <code>/person</code>,
used by three of the routes.
When using annotations, you would remove this duplication by using a type-level <code>@RequestMapping</code>
 annotation that maps to <code>/person</code>.
In WebMvc.fn, path predicates can be shared through the <code>path</code> method on the router function builder.
For instance, the last few lines of the example above can be improved in the following way by using nested routes:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
	.path("/person", builder -&gt; builder <i class="conum" data-value="1"></i><b>(1)</b>
		.GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
		.GET(accept(APPLICATION_JSON), handler::listPeople)
		.POST("/person", handler::createPerson))
	.build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note that second parameter of <code>path</code> is a consumer that takes the router builder.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
	"/person".nest {
		GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
		GET(accept(APPLICATION_JSON), handler::listPeople)
		POST("/person", handler::createPerson)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Though path-based nesting is the most common, you can nest on any kind of predicate by using
the <code>nest</code> method on the builder.
The above still contains some duplication in the form of the shared <code>Accept</code>-header predicate.
We can further improve by using the <code>nest</code> method together with <code>accept</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
	.path("/person", b1 -&gt; b1
		.nest(accept(APPLICATION_JSON), b2 -&gt; b2
			.GET("/{id}", handler::getPerson)
			.GET(handler::listPeople))
		.POST("/person", handler::createPerson))
	.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
	"/person".nest {
		accept(APPLICATION_JSON).nest {
			GET("/{id}", handler::getPerson)
			GET("", handler::listPeople)
			POST("/person", handler::createPerson)
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-fn-running"><a class="anchor" href="#webmvc-fn-running"></a>Running a Server</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn-running" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You typically run router functions in a <a href="../web.html#mvc-servlet" class="page"><code>DispatcherHandler</code></a>-based setup through the
<a href="../web.html#mvc-config" class="page">web.adoc#mvc-config</a>, which uses Spring configuration to declare the
components required to process requests. The MVC Java configuration declares the following
infrastructure components to support functional endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code>: Detects one or more <code>RouterFunction&lt;?&gt;</code> beans in the Spring
configuration, <a href="../core.html#beans-factory-ordered" class="page">orders them</a>, combines them through
<code>RouterFunction.andOther</code>, and routes requests to the resulting composed <code>RouterFunction</code>.</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code>: Simple adapter that lets <code>DispatcherHandler</code> invoke
a <code>HandlerFunction</code> that was mapped to a request.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The preceding components let functional endpoints fit within the <code>DispatcherServlet</code> request
processing lifecycle and also (potentially) run side by side with annotated controllers, if
any are declared. It is also how functional endpoints are enabled by the Spring Boot Web
starter.</p>
</div>
<div class="paragraph">
<p>The following example shows a WebFlux Java configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableMvc
public class WebConfig implements WebMvcConfigurer {

	@Bean
	public RouterFunction&lt;?&gt; routerFunctionA() {
		// ...
	}

	@Bean
	public RouterFunction&lt;?&gt; routerFunctionB() {
		// ...
	}

	// ...

	@Override
	public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
		// configure message conversion...
	}

	@Override
	public void addCorsMappings(CorsRegistry registry) {
		// configure CORS...
	}

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		// configure view resolution for HTML rendering...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableMvc
class WebConfig : WebMvcConfigurer {

	@Bean
	fun routerFunctionA(): RouterFunction&lt;*&gt; {
		// ...
	}

	@Bean
	fun routerFunctionB(): RouterFunction&lt;*&gt; {
		// ...
	}

	// ...

	override fun configureMessageConverters(converters: List&lt;HttpMessageConverter&lt;*&gt;&gt;) {
		// configure message conversion...
	}

	override fun addCorsMappings(registry: CorsRegistry) {
		// configure CORS...
	}

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		// configure view resolution for HTML rendering...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-fn-handler-filter-function"><a class="anchor" href="#webmvc-fn-handler-filter-function"></a>Filtering Handler Functions</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-fn-handler-filter-function" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can filter handler functions by using the <code>before</code>, <code>after</code>, or <code>filter</code> methods on the routing
function builder.
With annotations, you can achieve similar functionality by using <code>@ControllerAdvice</code>, a <code>ServletFilter</code>, or both.
The filter will apply to all routes that are built by the builder.
This means that filters defined in nested routes do not apply to "top-level" routes.
For instance, consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
	.path("/person", b1 -&gt; b1
		.nest(accept(APPLICATION_JSON), b2 -&gt; b2
			.GET("/{id}", handler::getPerson)
			.GET(handler::listPeople)
			.before(request -&gt; ServerRequest.from(request) <i class="conum" data-value="1"></i><b>(1)</b>
				.header("X-RequestHeader", "Value")
				.build()))
		.POST("/person", handler::createPerson))
	.after((request, response) -&gt; logResponse(response)) <i class="conum" data-value="2"></i><b>(2)</b>
	.build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>before</code> filter that adds a custom request header is only applied to the two GET routes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>after</code> filter that logs the response is applied to all routes, including the nested ones.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
	"/person".nest {
		GET("/{id}", handler::getPerson)
		GET(handler::listPeople)
		before { <i class="conum" data-value="1"></i><b>(1)</b>
			ServerRequest.from(it)
					.header("X-RequestHeader", "Value").build()
		}
		POST("/person", handler::createPerson)
		after { _, response -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
			logResponse(response)
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>before</code> filter that adds a custom request header is only applied to the two GET routes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>after</code> filter that logs the response is applied to all routes, including the nested ones.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>filter</code> method on the router builder takes a <code>HandlerFilterFunction</code>: a
function that takes a <code>ServerRequest</code> and <code>HandlerFunction</code> and returns a <code>ServerResponse</code>.
The handler function parameter represents the next element in the chain.
This is typically the handler that is routed to, but it can also be another
filter if multiple are applied.</p>
</div>
<div class="paragraph">
<p>Now we can add a simple security filter to our route, assuming that we have a <code>SecurityManager</code> that
can determine whether a particular path is allowed.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
	.path("/person", b1 -&gt; b1
		.nest(accept(APPLICATION_JSON), b2 -&gt; b2
			.GET("/{id}", handler::getPerson)
			.GET(handler::listPeople))
		.POST("/person", handler::createPerson))
	.filter((request, next) -&gt; {
		if (securityManager.allowAccessTo(request.path())) {
			return next.handle(request);
		}
		else {
			return ServerResponse.status(UNAUTHORIZED).build();
		}
	})
	.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.web.servlet.function.router

val securityManager: SecurityManager = ...

val route = router {
	("/person" and accept(APPLICATION_JSON)).nest {
		GET("/{id}", handler::getPerson)
		GET("", handler::listPeople)
		POST("/person", handler::createPerson)
		filter { request, next -&gt;
			if (securityManager.allowAccessTo(request.path())) {
				next(request)
			}
			else {
				status(UNAUTHORIZED).build();
			}
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example demonstrates that invoking the <code>next.handle(ServerRequest)</code> is optional.
We only let the handler function be run when access is allowed.</p>
</div>
<div class="paragraph">
<p>Besides using the <code>filter</code> method on the router function builder, it is possible to apply a
filter to an existing router function via <code>RouterFunction.filter(HandlerFilterFunction)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
CORS support for functional endpoints is provided through a dedicated
<a href="#webmvc-cors.adoc#mvc-cors-filter" class="page unresolved"><code>CorsFilter</code></a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-uri-building"><a class="anchor" href="#mvc-uri-building"></a>URI Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-uri-building" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>This section describes various options available in the Spring Framework to work with URI&#8217;s.</p>
</div>
<div class="sect2">
<h3 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a>UriComponents</h3>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> helps to build URI&#8217;s from URI templates with variables, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UriComponents uriComponents = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
		.queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
		.encode() <i class="conum" data-value="3"></i><b>(3)</b>
		.build(); <i class="conum" data-value="4"></i><b>(4)</b>

URI uri = uriComponents.expand("Westin", "123").toUri();  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Static factory method with a URI template.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add or replace URI components.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Request to have the URI template and URI variables encoded.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Build a <code>UriComponents</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Expand variables and obtain the <code>URI</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uriComponents = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
		.queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
		.encode() <i class="conum" data-value="3"></i><b>(3)</b>
		.build() <i class="conum" data-value="4"></i><b>(4)</b>

val uri = uriComponents.expand("Westin", "123").toUri()  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Static factory method with a URI template.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add or replace URI components.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Request to have the URI template and URI variables encoded.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Build a <code>UriComponents</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Expand variables and obtain the <code>URI</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding example can be consolidated into one chain and shortened with <code>buildAndExpand</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")
		.queryParam("q", "{q}")
		.encode()
		.buildAndExpand("Westin", "123")
		.toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")
		.queryParam("q", "{q}")
		.encode()
		.buildAndExpand("Westin", "123")
		.toUri()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten it further by going directly to a URI (which implies encoding),
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")
		.queryParam("q", "{q}")
		.build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}")
		.queryParam("q", "{q}")
		.build("Westin", "123")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten it further still with a full URI template, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder
		.fromUriString("https://example.com/hotels/{hotel}?q={q}")
		.build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder
	.fromUriString("https://example.com/hotels/{hotel}?q={q}")
	.build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a>UriBuilder</h3>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a> implements <code>UriBuilder</code>. You can create a
<code>UriBuilder</code>, in turn, with a <code>UriBuilderFactory</code>. Together, <code>UriBuilderFactory</code> and
<code>UriBuilder</code> provide a pluggable mechanism to build URIs from URI templates, based on
shared configuration, such as a base URL, encoding preferences, and other details.</p>
</div>
<div class="paragraph">
<p>You can configure <code>RestTemplate</code> and <code>WebClient</code> with a <code>UriBuilderFactory</code>
to customize the preparation of URIs. <code>DefaultUriBuilderFactory</code> is a default
implementation of <code>UriBuilderFactory</code> that uses <code>UriComponentsBuilder</code> internally and
exposes shared configuration options.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>RestTemplate</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val restTemplate = RestTemplate()
restTemplate.uriTemplateHandler = factory</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example configures a <code>WebClient</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you can also use <code>DefaultUriBuilderFactory</code> directly. It is similar to using
<code>UriComponentsBuilder</code> but, instead of static factory methods, it is an actual instance
that holds configuration and preferences, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
		.queryParam("q", "{q}")
		.build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val baseUrl = "https://example.com"
val uriBuilderFactory = DefaultUriBuilderFactory(baseUrl)

val uri = uriBuilderFactory.uriString("/hotels/{hotel}")
		.queryParam("q", "{q}")
		.build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a>URI Encoding</h3>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> exposes encoding options at two levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{api-spring-framework}/web/util/UriComponentsBuilder.html#encode--[UriComponentsBuilder#encode()]:
Pre-encodes the URI template first and then strictly encodes URI variables when expanded.</p>
</li>
<li>
<p>{api-spring-framework}/web/util/UriComponents.html#encode--[UriComponents#encode()]:
Encodes URI components <em>after</em> URI variables are expanded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both options replace non-ASCII and illegal characters with escaped octets. However, the first option
also replaces characters with reserved meaning that appear in URI variables.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Consider ";", which is legal in a path but has reserved meaning. The first option replaces
";" with "%3B" in URI variables but not in the URI template. By contrast, the second option never
replaces ";", since it is a legal character in a path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For most cases, the first option is likely to give the expected result, because it treats URI
variables as opaque data to be fully encoded, while the second option is useful if URI
variables do intentionally contain reserved characters. The second option is also useful
when not expanding URI variables at all since that will also encode anything that
incidentally looks like a URI variable.</p>
</div>
<div class="paragraph">
<p>The following example uses the first option:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
		.queryParam("q", "{q}")
		.encode()
		.buildAndExpand("New York", "foo+bar")
		.toUri();

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
		.queryParam("q", "{q}")
		.encode()
		.buildAndExpand("New York", "foo+bar")
		.toUri()

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten the preceding example by going directly to the URI (which implies encoding),
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
		.queryParam("q", "{q}")
		.build("New York", "foo+bar");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
		.queryParam("q", "{q}")
		.build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten it further still with a full URI template, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URI uri = UriComponentsBuilder.fromUriString("/hotel list/{city}?q={q}")
		.build("New York", "foo+bar");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uri = UriComponentsBuilder.fromUriString("/hotel list/{city}?q={q}")
		.build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>WebClient</code> and the <code>RestTemplate</code> expand and encode URI templates internally through
the <code>UriBuilderFactory</code> strategy. Both can be configured with a custom strategy.
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

// Customize the RestTemplate..
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);

// Customize the WebClient..
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val baseUrl = "https://example.com"
val factory = DefaultUriBuilderFactory(baseUrl).apply {
	encodingMode = EncodingMode.TEMPLATE_AND_VALUES
}

// Customize the RestTemplate..
val restTemplate = RestTemplate().apply {
	uriTemplateHandler = factory
}

// Customize the WebClient..
val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultUriBuilderFactory</code> implementation uses <code>UriComponentsBuilder</code> internally to
expand and encode URI templates. As a factory, it provides a single place to configure
the approach to encoding, based on one of the below encoding modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code>: Uses <code>UriComponentsBuilder#encode()</code>, corresponding to
the first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when
expanded.</p>
</li>
<li>
<p><code>VALUES_ONLY</code>: Does not encode the URI template and, instead, applies strict encoding
to URI variables through <code>UriUtils#encodeUriVariables</code> prior to expanding them into the
template.</p>
</li>
<li>
<p><code>URI_COMPONENT</code>: Uses <code>UriComponents#encode()</code>, corresponding to the second option in the earlier list, to
encode URI component value <em>after</em> URI variables are expanded.</p>
</li>
<li>
<p><code>NONE</code>: No encoding is applied.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>RestTemplate</code> is set to <code>EncodingMode.URI_COMPONENT</code> for historic
reasons and for backwards compatibility. The <code>WebClient</code> relies on the default value
in <code>DefaultUriBuilderFactory</code>, which was changed from <code>EncodingMode.URI_COMPONENT</code> in
5.0.x to <code>EncodingMode.TEMPLATE_AND_VALUES</code> in 5.1.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-servleturicomponentsbuilder"><a class="anchor" href="#mvc-servleturicomponentsbuilder"></a>Relative Servlet Requests</h3>
<div class="paragraph">
<p>You can use <code>ServletUriComponentsBuilder</code> to create URIs relative to the current request,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HttpServletRequest request = ...

// Re-uses host, scheme, port, path and query string...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
		.replaceQueryParam("accountId", "{id}").build()
		.expand("123")
		.encode();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val request: HttpServletRequest = ...

// Re-uses host, scheme, port, path and query string...

val ucb = ServletUriComponentsBuilder.fromRequest(request)
		.replaceQueryParam("accountId", "{id}").build()
		.expand("123")
		.encode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create URIs relative to the context path, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Re-uses host, port and context path...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
		.path("/accounts").build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Re-uses host, port and context path...

val ucb = ServletUriComponentsBuilder.fromContextPath(request)
		.path("/accounts").build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create URIs relative to a Servlet (for example, <code>/main/*</code>),
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Re-uses host, port, context path, and Servlet prefix...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
		.path("/accounts").build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Re-uses host, port, context path, and Servlet prefix...

val ucb = ServletUriComponentsBuilder.fromServletMapping(request)
		.path("/accounts").build()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of 5.1, <code>ServletUriComponentsBuilder</code> ignores information from the <code>Forwarded</code> and
<code>X-Forwarded-*</code> headers, which specify the client-originated address. Consider using the
<a href="#filters-forwarded-headers"><code>ForwardedHeaderFilter</code></a> to extract and use or to discard
such headers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-links-to-controllers"><a class="anchor" href="#mvc-links-to-controllers"></a>Links to Controllers</h3>
<div class="paragraph">
<p>Spring MVC provides a mechanism to prepare links to controller methods. For example,
the following MVC controller allows for link creation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

	@GetMapping("/bookings/{booking}")
	public ModelAndView getBooking(@PathVariable Long booking) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
@RequestMapping("/hotels/{hotel}")
class BookingController {

	@GetMapping("/bookings/{booking}")
	fun getBooking(@PathVariable booking: Long): ModelAndView {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can prepare a link by referring to the method by name, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder
	.fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uriComponents = MvcUriComponentsBuilder
	.fromMethodName(BookingController::class.java, "getBooking", 21).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we provide actual method argument values (in this case, the long value: <code>21</code>)
to be used as a path variable and inserted into the URL. Furthermore, we provide the
value, <code>42</code>, to fill in any remaining URI variables, such as the <code>hotel</code> variable inherited
from the type-level request mapping. If the method had more arguments, we could supply null for
arguments not needed for the URL. In general, only <code>@PathVariable</code> and <code>@RequestParam</code> arguments
are relevant for constructing the URL.</p>
</div>
<div class="paragraph">
<p>There are additional ways to use <code>MvcUriComponentsBuilder</code>. For example, you can use a technique
akin to mock testing through proxies to avoid referring to the controller method by name, as the following example shows
(the example assumes static import of <code>MvcUriComponentsBuilder.on</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder
	.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val uriComponents = MvcUriComponentsBuilder
	.fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Controller method signatures are limited in their design when they are supposed to be usable for
link creation with <code>fromMethodCall</code>. Aside from needing a proper parameter signature,
there is a technical limitation on the return type (namely, generating a runtime proxy
for link builder invocations), so the return type must not be <code>final</code>. In particular,
the common <code>String</code> return type for view names does not work here. You should use <code>ModelAndView</code>
or even plain <code>Object</code> (with a <code>String</code> return value) instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The earlier examples use static methods in <code>MvcUriComponentsBuilder</code>. Internally, they rely
on <code>ServletUriComponentsBuilder</code> to prepare a base URL from the scheme, host, port,
context path, and servlet path of the current request. This works well in most cases.
However, sometimes, it can be insufficient. For example, you may be outside the context of
a request (such as a batch process that prepares links) or perhaps you need to insert a path
prefix (such as a locale prefix that was removed from the request path and needs to be
re-inserted into links).</p>
</div>
<div class="paragraph">
<p>For such cases, you can use the static <code>fromXxx</code> overloaded methods that accept a
<code>UriComponentsBuilder</code> to use a base URL. Alternatively, you can create an instance of <code>MvcUriComponentsBuilder</code>
with a base URL and then use the instance-based <code>withXxx</code> methods. For example, the
following listing uses <code>withMethodCall</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en")
val builder = MvcUriComponentsBuilder.relativeTo(base)
builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of 5.1, <code>MvcUriComponentsBuilder</code> ignores information from the <code>Forwarded</code> and
<code>X-Forwarded-*</code> headers, which specify the client-originated address. Consider using the
<a href="#filters-forwarded-headers">ForwardedHeaderFilter</a> to extract and use or to discard
such headers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-links-to-controllers-from-views"><a class="anchor" href="#mvc-links-to-controllers-from-views"></a>Links in Views</h3>
<div class="paragraph">
<p>In views such as Thymeleaf, FreeMarker, or JSP, you can build links to annotated controllers
by referring to the implicitly or explicitly assigned name for each request mapping.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping("/people/{id}/addresses")
public class PersonAddressController {

	@RequestMapping("/{country}")
	public HttpEntity&lt;PersonAddress&gt; getAddress(@PathVariable String country) { ... }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RequestMapping("/people/{id}/addresses")
class PersonAddressController {

	@RequestMapping("/{country}")
	fun getAddress(@PathVariable country: String): HttpEntity&lt;PersonAddress&gt; { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given the preceding controller, you can prepare a link from a JSP, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;
...
&lt;a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}"&gt;Get Address&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example relies on the <code>mvcUrl</code> function declared in the Spring tag library
(that is, META-INF/spring.tld), but it is easy to define your own function or prepare a
similar one for other templating technologies.</p>
</div>
<div class="paragraph">
<p>Here is how this works. On startup, every <code>@RequestMapping</code> is assigned a default name
through <code>HandlerMethodMappingNamingStrategy</code>, whose default implementation uses the
capital letters of the class and the method name (for example, the <code>getThing</code> method in
<code>ThingController</code> becomes "TC#getThing"). If there is a name clash, you can use
<code>@RequestMapping(name="..")</code> to assign an explicit name or implement your own
<code>HandlerMethodMappingNamingStrategy</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-ann-async"><a class="anchor" href="#mvc-ann-async"></a>Asynchronous Requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC has an extensive integration with Servlet 3.0 asynchronous request
<a href="#mvc-ann-async-processing">processing</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a> and <a href="#mvc-ann-async-callable"><code>Callable</code></a>
return values in controller methods and provide basic support for a single asynchronous
return value.</p>
</li>
<li>
<p>Controllers can <a href="#mvc-ann-async-http-streaming">stream</a> multiple values, including
<a href="#mvc-ann-async-sse">SSE</a> and <a href="#mvc-ann-async-output-stream">raw data</a>.</p>
</li>
<li>
<p>Controllers can use reactive clients and return
<a href="#mvc-ann-async-reactive-types">reactive types</a> for response handling.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-deferredresult"><a class="anchor" href="#mvc-ann-async-deferredresult"></a><code>DeferredResult</code></h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Once the asynchronous request processing feature is <a href="#mvc-ann-async-configuration">enabled</a>
in the Servlet container, controller methods can wrap any supported controller method
return value with <code>DeferredResult</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/quotes")
@ResponseBody
public DeferredResult&lt;String&gt; quotes() {
	DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();
	// Save the deferredResult somewhere..
	return deferredResult;
}

// From some other thread...
deferredResult.setResult(result);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/quotes")
@ResponseBody
fun quotes(): DeferredResult&lt;String&gt; {
	val deferredResult = DeferredResult&lt;String&gt;()
	// Save the deferredResult somewhere..
	return deferredResult
}

// From some other thread...
deferredResult.setResult(result)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller can produce the return value asynchronously, from a different thread&#8201;&#8212;&#8201;for
example, in response to an external event (JMS message), a scheduled task, or other event.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-callable"><a class="anchor" href="#mvc-ann-async-callable"></a><code>Callable</code></h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>A controller can wrap any supported return value with <code>java.util.concurrent.Callable</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PostMapping
public Callable&lt;String&gt; processUpload(final MultipartFile file) {

	return new Callable&lt;String&gt;() {
		public String call() throws Exception {
			// ...
			return "someView";
		}
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@PostMapping
fun processUpload(file: MultipartFile) = Callable&lt;String&gt; {
	// ...
	"someView"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value can then be obtained by running the given task through the
<a href="#mvc-ann-async-configuration-spring-mvc">configured</a> <code>TaskExecutor</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-processing"><a class="anchor" href="#mvc-ann-async-processing"></a>Processing</h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Here is a very concise overview of Servlet asynchronous request processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>ServletRequest</code> can be put in asynchronous mode by calling <code>request.startAsync()</code>.
The main effect of doing so is that the Servlet (as well as any filters) can exit, but
the response remains open to let processing complete later.</p>
</li>
<li>
<p>The call to <code>request.startAsync()</code> returns <code>AsyncContext</code>, which you can use for
further control over asynchronous processing. For example, it provides the <code>dispatch</code> method,
which is similar to a forward from the Servlet API, except that it lets an
application resume request processing on a Servlet container thread.</p>
</li>
<li>
<p>The <code>ServletRequest</code> provides access to the current <code>DispatcherType</code>, which you can
use to distinguish between processing the initial request, an asynchronous
dispatch, a forward, and other dispatcher types.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DeferredResult</code> processing works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The controller returns a <code>DeferredResult</code> and saves it in some in-memory
queue or list where it can be accessed.</p>
</li>
<li>
<p>Spring MVC calls <code>request.startAsync()</code>.</p>
</li>
<li>
<p>Meanwhile, the <code>DispatcherServlet</code> and all configured filters exit the request
processing thread, but the response remains open.</p>
</li>
<li>
<p>The application sets the <code>DeferredResult</code> from some thread, and Spring MVC
dispatches the request back to the Servlet container.</p>
</li>
<li>
<p>The <code>DispatcherServlet</code> is invoked again, and processing resumes with the
asynchronously produced return value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Callable</code> processing works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The controller returns a <code>Callable</code>.</p>
</li>
<li>
<p>Spring MVC calls <code>request.startAsync()</code> and submits the <code>Callable</code> to
a <code>TaskExecutor</code> for processing in a separate thread.</p>
</li>
<li>
<p>Meanwhile, the <code>DispatcherServlet</code> and all filters exit the Servlet container thread,
but the response remains open.</p>
</li>
<li>
<p>Eventually the <code>Callable</code> produces a result, and Spring MVC dispatches the request back
to the Servlet container to complete processing.</p>
</li>
<li>
<p>The <code>DispatcherServlet</code> is invoked again, and processing resumes with the
asynchronously produced return value from the <code>Callable</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For further background and context, you can also read
<a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">the
blog posts</a> that introduced asynchronous request processing support in Spring MVC 3.2.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-exceptions"><a class="anchor" href="#mvc-ann-async-exceptions"></a>Exception Handling</h4>
<div class="paragraph">
<p>When you use a <code>DeferredResult</code>, you can choose whether to call <code>setResult</code> or
<code>setErrorResult</code> with an exception. In both cases, Spring MVC dispatches the request back
to the Servlet container to complete processing. It is then treated either as if the
controller method returned the given value or as if it produced the given exception.
The exception then goes through the regular exception handling mechanism (for example, invoking
<code>@ExceptionHandler</code> methods).</p>
</div>
<div class="paragraph">
<p>When you use <code>Callable</code>, similar processing logic occurs, the main difference being that
the result is returned from the <code>Callable</code> or an exception is raised by it.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-interception"><a class="anchor" href="#mvc-ann-async-interception"></a>Interception</h4>
<div class="paragraph">
<p><code>HandlerInterceptor</code> instances can be of type <code>AsyncHandlerInterceptor</code>, to receive the
<code>afterConcurrentHandlingStarted</code> callback on the initial request that starts asynchronous
processing (instead of <code>postHandle</code> and <code>afterCompletion</code>).</p>
</div>
<div class="paragraph">
<p><code>HandlerInterceptor</code> implementations can also register a <code>CallableProcessingInterceptor</code>
or a <code>DeferredResultProcessingInterceptor</code>, to integrate more deeply with the
lifecycle of an asynchronous request (for example, to handle a timeout event). See
{api-spring-framework}/web/servlet/AsyncHandlerInterceptor.html[<code>AsyncHandlerInterceptor</code>]
for more details.</p>
</div>
<div class="paragraph">
<p><code>DeferredResult</code> provides <code>onTimeout(Runnable)</code> and <code>onCompletion(Runnable)</code> callbacks.
See the {api-spring-framework}/web/context/request/async/DeferredResult.html[javadoc of <code>DeferredResult</code>]
for more details. <code>Callable</code> can be substituted for <code>WebAsyncTask</code> that exposes additional
methods for timeout and completion callbacks.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-vs-webflux"><a class="anchor" href="#mvc-ann-async-vs-webflux"></a>Compared to WebFlux</h4>
<div class="paragraph">
<p>The Servlet API was originally built for making a single pass through the Filter-Servlet
chain. Asynchronous request processing, added in Servlet 3.0, lets applications exit
the Filter-Servlet chain but leave the response open for further processing. The Spring MVC
asynchronous support is built around that mechanism. When a controller returns a <code>DeferredResult</code>,
the Filter-Servlet chain is exited, and the Servlet container thread is released. Later, when
the <code>DeferredResult</code> is set, an <code>ASYNC</code> dispatch (to the same URL) is made, during which the
controller is mapped again but, rather than invoking it, the <code>DeferredResult</code> value is used
(as if the controller returned it) to resume processing.</p>
</div>
<div class="paragraph">
<p>By contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an
asynchronous request processing feature, because it is asynchronous by design. Asynchronous
handling is built into all framework contracts and is intrinsically supported through all
stages of request processing.</p>
</div>
<div class="paragraph">
<p>From a programming model perspective, both Spring MVC and Spring WebFlux support
asynchronous and <a href="#mvc-ann-async-reactive-types">Reactive Types</a> as return values in controller methods.
Spring MVC even supports streaming, including reactive back pressure. However, individual
writes to the response remain blocking (and are performed on a separate thread), unlike WebFlux,
which relies on non-blocking I/O and does not need an extra thread for each write.</p>
</div>
<div class="paragraph">
<p>Another fundamental difference is that Spring MVC does not support asynchronous or reactive
types in controller method arguments (for example, <code>@RequestBody</code>, <code>@RequestPart</code>, and others),
nor does it have any explicit support for asynchronous and reactive types as model attributes.
Spring WebFlux does support all that.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-http-streaming"><a class="anchor" href="#mvc-ann-async-http-streaming"></a>HTTP Streaming</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-codecs-streaming" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can use <code>DeferredResult</code> and <code>Callable</code> for a single asynchronous return value.
What if you want to produce multiple asynchronous values and have those written to the
response? This section describes how to do so.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-objects"><a class="anchor" href="#mvc-ann-async-objects"></a>Objects</h4>
<div class="paragraph">
<p>You can use the <code>ResponseBodyEmitter</code> return value to produce a stream of objects, where
each object is serialized with an
<a href="../integration.html#rest-message-conversion" class="page"><code>HttpMessageConverter</code></a> and written to the
response, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/events")
public ResponseBodyEmitter handle() {
	ResponseBodyEmitter emitter = new ResponseBodyEmitter();
	// Save the emitter somewhere..
	return emitter;
}

// In some other thread
emitter.send("Hello once");

// and again later on
emitter.send("Hello again");

// and done at some point
emitter.complete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/events")
fun handle() = ResponseBodyEmitter().apply {
	// Save the emitter somewhere..
}

// In some other thread
emitter.send("Hello once")

// and again later on
emitter.send("Hello again")

// and done at some point
emitter.complete()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <code>ResponseBodyEmitter</code> as the body in a <code>ResponseEntity</code>, letting you
customize the status and headers of the response.</p>
</div>
<div class="paragraph">
<p>When an <code>emitter</code> throws an <code>IOException</code> (for example, if the remote client went away), applications
are not responsible for cleaning up the connection and should not invoke <code>emitter.complete</code>
or <code>emitter.completeWithError</code>. Instead, the servlet container automatically initiates an
<code>AsyncListener</code> error notification, in which Spring MVC makes a <code>completeWithError</code> call.
This call, in turn, performs one final <code>ASYNC</code> dispatch to the application, during which Spring MVC
invokes the configured exception resolvers and completes the request.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-sse"><a class="anchor" href="#mvc-ann-async-sse"></a>SSE</h4>
<div class="paragraph">
<p><code>SseEmitter</code> (a subclass of <code>ResponseBodyEmitter</code>) provides support for
<a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a>, where events sent from the server
are formatted according to the W3C SSE specification. To produce an SSE
stream from a controller, return <code>SseEmitter</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
public SseEmitter handle() {
	SseEmitter emitter = new SseEmitter();
	// Save the emitter somewhere..
	return emitter;
}

// In some other thread
emitter.send("Hello once");

// and again later on
emitter.send("Hello again");

// and done at some point
emitter.complete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/events", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
fun handle() = SseEmitter().apply {
	// Save the emitter somewhere..
}

// In some other thread
emitter.send("Hello once")

// and again later on
emitter.send("Hello again")

// and done at some point
emitter.complete()</code></pre>
</div>
</div>
<div class="paragraph">
<p>While SSE is the main option for streaming into browsers, note that Internet Explorer
does not support Server-Sent Events. Consider using Spring&#8217;s
<a href="../web.html#websocket" class="page">WebSocket messaging</a> with
<a href="../web.html#websocket-fallback" class="page">SockJS fallback</a> transports (including SSE) that target
a wide range of browsers.</p>
</div>
<div class="paragraph">
<p>See also <a href="#mvc-ann-async-objects">previous section</a> for notes on exception handling.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-output-stream"><a class="anchor" href="#mvc-ann-async-output-stream"></a>Raw Data</h4>
<div class="paragraph">
<p>Sometimes, it is useful to bypass message conversion and stream directly to the response
<code>OutputStream</code> (for example, for a file download). You can use the <code>StreamingResponseBody</code>
return value type to do so, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/download")
public StreamingResponseBody handle() {
	return new StreamingResponseBody() {
		@Override
		public void writeTo(OutputStream outputStream) throws IOException {
			// write...
		}
	};
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/download")
fun handle() = StreamingResponseBody {
	// write...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>StreamingResponseBody</code> as the body in a <code>ResponseEntity</code> to
customize the status and headers of the response.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-reactive-types"><a class="anchor" href="#mvc-ann-async-reactive-types"></a>Reactive Types</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-codecs-streaming" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC supports use of reactive client libraries in a controller (also read
<a href="../web-reactive.html#webflux-reactive-libraries" class="page">Reactive Libraries</a> in the WebFlux section).
This includes the <code>WebClient</code> from <code>spring-webflux</code> and others, such as Spring Data
reactive data repositories. In such scenarios, it is convenient to be able to return
reactive types from the controller method.</p>
</div>
<div class="paragraph">
<p>Reactive return values are handled as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single-value promise is adapted to, similar to using <code>DeferredResult</code>. Examples
include <code>Mono</code> (Reactor) or <code>Single</code> (RxJava).</p>
</li>
<li>
<p>A multi-value stream with a streaming media type (such as <code>application/x-ndjson</code>
or <code>text/event-stream</code>) is adapted to, similar to using <code>ResponseBodyEmitter</code> or
<code>SseEmitter</code>. Examples include <code>Flux</code> (Reactor) or <code>Observable</code> (RxJava).
Applications can also return <code>Flux&lt;ServerSentEvent&gt;</code> or <code>Observable&lt;ServerSentEvent&gt;</code>.</p>
</li>
<li>
<p>A multi-value stream with any other media type (such as <code>application/json</code>) is adapted
to, similar to using <code>DeferredResult&lt;List&lt;?&gt;&gt;</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC supports Reactor and RxJava through the
{api-spring-framework}/core/ReactiveAdapterRegistry.html[<code>ReactiveAdapterRegistry</code>] from
<code>spring-core</code>, which lets it adapt from multiple reactive libraries.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For streaming to the response, reactive back pressure is supported, but writes to the
response are still blocking and are run on a separate thread through the
<a href="#mvc-ann-async-configuration-spring-mvc">configured</a> <code>TaskExecutor</code>, to avoid
blocking the upstream source (such as a <code>Flux</code> returned from <code>WebClient</code>).
By default, <code>SimpleAsyncTaskExecutor</code> is used for the blocking writes, but that is not
suitable under load. If you plan to stream with a reactive type, you should use the
<a href="#mvc-ann-async-configuration-spring-mvc">MVC configuration</a> to configure a task executor.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-disconnects"><a class="anchor" href="#mvc-ann-async-disconnects"></a>Disconnects</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-codecs-streaming" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The Servlet API does not provide any notification when a remote client goes away.
Therefore, while streaming to the response, whether through <a href="#mvc-ann-async-sse">SseEmitter</a>
or <a href="#mvc-ann-async-reactive-types">reactive types</a>, it is important to send data periodically,
since the write fails if the client has disconnected. The send could take the form of an
empty (comment-only) SSE event or any other data that the other side would have to interpret
as a heartbeat and ignore.</p>
</div>
<div class="paragraph">
<p>Alternatively, consider using web messaging solutions (such as
<a href="#websocket-stomp">STOMP over WebSocket</a> or WebSocket with <a href="#websocket-fallback">SockJS</a>)
that have a built-in heartbeat mechanism.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async-configuration"><a class="anchor" href="#mvc-ann-async-configuration"></a>Configuration</h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">Compared to WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The asynchronous request processing feature must be enabled at the Servlet container level.
The MVC configuration also exposes several options for asynchronous requests.</p>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-configuration-servlet3"><a class="anchor" href="#mvc-ann-async-configuration-servlet3"></a>Servlet Container</h4>
<div class="paragraph">
<p>Filter and Servlet declarations have an <code>asyncSupported</code> flag that needs to be set to <code>true</code>
to enable asynchronous request processing. In addition, Filter mappings should be
declared to handle the <code>ASYNC</code> <code>javax.servlet.DispatchType</code>.</p>
</div>
<div class="paragraph">
<p>In Java configuration, when you use <code>AbstractAnnotationConfigDispatcherServletInitializer</code>
to initialize the Servlet container, this is done automatically.</p>
</div>
<div class="paragraph">
<p>In <code>web.xml</code> configuration, you can add <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> to the
<code>DispatcherServlet</code> and to <code>Filter</code> declarations and add
<code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code> to filter mappings.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-configuration-spring-mvc"><a class="anchor" href="#mvc-ann-async-configuration-spring-mvc"></a>Spring MVC</h4>
<div class="paragraph">
<p>The MVC configuration exposes the following options related to asynchronous request processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java configuration: Use the <code>configureAsyncSupport</code> callback on <code>WebMvcConfigurer</code>.</p>
</li>
<li>
<p>XML namespace: Use the <code>&lt;async-support&gt;</code> element under <code>&lt;mvc:annotation-driven&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Default timeout value for async requests, which if not set, depends
on the underlying Servlet container.</p>
</li>
<li>
<p><code>AsyncTaskExecutor</code> to use for blocking writes when streaming with
<a href="#mvc-ann-async-reactive-types">Reactive Types</a> and for executing <code>Callable</code> instances returned from
controller methods. We highly recommended configuring this property if you
stream with reactive types or have controller methods that return <code>Callable</code>, since
by default, it is a <code>SimpleAsyncTaskExecutor</code>.</p>
</li>
<li>
<p><code>DeferredResultProcessingInterceptor</code> implementations and <code>CallableProcessingInterceptor</code> implementations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that you can also set the default timeout value on a <code>DeferredResult</code>,
a <code>ResponseBodyEmitter</code>, and an <code>SseEmitter</code>. For a <code>Callable</code>, you can use
<code>WebAsyncTask</code> to provide a timeout value.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-cors"><a class="anchor" href="#mvc-cors"></a>CORS</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC lets you handle CORS (Cross-Origin Resource Sharing). This section
describes how to do so.</p>
</div>
<div class="sect2">
<h3 id="mvc-cors-intro"><a class="anchor" href="#mvc-cors-intro"></a>Introduction</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors-intro" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>For security reasons, browsers prohibit AJAX calls to resources outside the current origin.
For example, you could have your bank account in one tab and evil.com in another. Scripts
from evil.com should not be able to make AJAX requests to your bank API with your
credentials&#8201;&#8212;&#8201;for example withdrawing money from your account!</p>
</div>
<div class="paragraph">
<p>Cross-Origin Resource Sharing (CORS) is a <a href="https://www.w3.org/TR/cors/">W3C specification</a>
implemented by <a href="https://caniuse.com/#feat=cors">most browsers</a> that lets you specify
what kind of cross-domain requests are authorized, rather than using less secure and less
powerful workarounds based on IFRAME or JSONP.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors-processing"><a class="anchor" href="#mvc-cors-processing"></a>Processing</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors-processing" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The CORS specification distinguishes between preflight, simple, and actual requests.
To learn how CORS works, you can read
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">this article</a>, among
many others, or see the specification for more details.</p>
</div>
<div class="paragraph">
<p>Spring MVC <code>HandlerMapping</code> implementations provide built-in support for CORS. After successfully
mapping a request to a handler, <code>HandlerMapping</code> implementations check the CORS configuration for the
given request and handler and take further actions. Preflight requests are handled
directly, while simple and actual CORS requests are intercepted, validated, and have
required CORS response headers set.</p>
</div>
<div class="paragraph">
<p>In order to enable cross-origin requests (that is, the <code>Origin</code> header is present and
differs from the host of the request), you need to have some explicitly declared CORS
configuration. If no matching CORS configuration is found, preflight requests are
rejected. No CORS headers are added to the responses of simple and actual CORS requests
and, consequently, browsers reject them.</p>
</div>
<div class="paragraph">
<p>Each <code>HandlerMapping</code> can be
{api-spring-framework}/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-[configured]
individually with URL pattern-based <code>CorsConfiguration</code> mappings. In most cases, applications
use the MVC Java configuration or the XML namespace to declare such mappings, which results
in a single global map being passed to all <code>HandlerMappping</code> instances.</p>
</div>
<div class="paragraph">
<p>You can combine global CORS configuration at the <code>HandlerMapping</code> level with more
fine-grained, handler-level CORS configuration. For example, annotated controllers can use
class- or method-level <code>@CrossOrigin</code> annotations (other handlers can implement
<code>CorsConfigurationSource</code>).</p>
</div>
<div class="paragraph">
<p>The rules for combining global and local configuration are generally additive&#8201;&#8212;&#8201;for example,
all global and all local origins. For those attributes where only a single value can be
accepted, e.g. <code>allowCredentials</code> and <code>maxAge</code>, the local overrides the global value. See
{api-spring-framework}/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-[<code>CorsConfiguration#combine(CorsConfiguration)</code>]
for more details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To learn more from the source or make advanced customizations, check the code behind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code>, <code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors-controller"><a class="anchor" href="#mvc-cors-controller"></a><code>@CrossOrigin</code></h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors-controller" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The {api-spring-framework}/web/bind/annotation/CrossOrigin.html[<code>@CrossOrigin</code>]
annotation enables cross-origin requests on annotated controller methods,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@RequestMapping("/account")
public class AccountController {

	@CrossOrigin
	@GetMapping("/{id}")
	public Account retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public void remove(@PathVariable Long id) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RestController
@RequestMapping("/account")
class AccountController {

	@CrossOrigin
	@GetMapping("/{id}")
	fun retrieve(@PathVariable id: Long): Account {
		// ...
	}

	@DeleteMapping("/{id}")
	fun remove(@PathVariable id: Long) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>@CrossOrigin</code> allows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p>All HTTP methods to which the controller method is mapped.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowCredentials</code> is not enabled by default, since that establishes a trust level
that exposes sensitive user-specific information (such as cookies and CSRF tokens) and
should only be used where appropriate. When it is enabled either <code>allowOrigins</code> must be
set to one or more specific domain (but not the special value <code>"*"</code>) or alternatively
the <code>allowOriginPatterns</code> property may be used to match to a dynamic set of origins.</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> is set to 30 minutes.</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code> is supported at the class level, too, and is inherited by all methods,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

	@GetMapping("/{id}")
	public Account retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public void remove(@PathVariable Long id) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@CrossOrigin(origins = ["https://domain2.com"], maxAge = 3600)
@RestController
@RequestMapping("/account")
class AccountController {

	@GetMapping("/{id}")
	fun retrieve(@PathVariable id: Long): Account {
		// ...
	}

	@DeleteMapping("/{id}")
	fun remove(@PathVariable id: Long) {
		// ...
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>@CrossOrigin</code> at both the class level and the method level,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

	@CrossOrigin("https://domain2.com")
	@GetMapping("/{id}")
	public Account retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public void remove(@PathVariable Long id) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
class AccountController {

	@CrossOrigin("https://domain2.com")
	@GetMapping("/{id}")
	fun retrieve(@PathVariable id: Long): Account {
		// ...
	}

	@DeleteMapping("/{id}")
	fun remove(@PathVariable id: Long) {
		// ...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors-global"><a class="anchor" href="#mvc-cors-global"></a>Global Configuration</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors-global" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>In addition to fine-grained, controller method level configuration, you probably want to
define some global CORS configuration, too. You can set URL-based <code>CorsConfiguration</code>
mappings individually on any <code>HandlerMapping</code>. Most applications, however, use the
MVC Java configuration or the MVC XML namespace to do that.</p>
</div>
<div class="paragraph">
<p>By default, global configuration enables the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p><code>GET</code>, <code>HEAD</code>, and <code>POST</code> methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowCredentials</code> is not enabled by default, since that establishes a trust level
that exposes sensitive user-specific information (such as cookies and CSRF tokens) and
should only be used where appropriate. When it is enabled either <code>allowOrigins</code> must be
set to one or more specific domain (but not the special value <code>"*"</code>) or alternatively
the <code>allowOriginPatterns</code> property may be used to match to a dynamic set of origins.</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> is set to 30 minutes.</p>
</div>
<div class="sect3">
<h4 id="mvc-cors-global-java"><a class="anchor" href="#mvc-cors-global-java"></a>Java Configuration</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-cors-global" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>To enable CORS in the MVC Java config, you can use the <code>CorsRegistry</code> callback,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addCorsMappings(CorsRegistry registry) {

		registry.addMapping("/api/**")
			.allowedOrigins("https://domain2.com")
			.allowedMethods("PUT", "DELETE")
			.allowedHeaders("header1", "header2", "header3")
			.exposedHeaders("header1", "header2")
			.allowCredentials(true).maxAge(3600);

		// Add more mappings...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addCorsMappings(registry: CorsRegistry) {

		registry.addMapping("/api/**")
				.allowedOrigins("https://domain2.com")
				.allowedMethods("PUT", "DELETE")
				.allowedHeaders("header1", "header2", "header3")
				.exposedHeaders("header1", "header2")
				.allowCredentials(true).maxAge(3600)

		// Add more mappings...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-global-xml"><a class="anchor" href="#mvc-cors-global-xml"></a>XML Configuration</h4>
<div class="paragraph">
<p>To enable CORS in the XML namespace, you can use the <code>&lt;mvc:cors&gt;</code> element,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:cors&gt;

	&lt;mvc:mapping path="/api/**"
		allowed-origins="https://domain1.com, https://domain2.com"
		allowed-methods="GET, PUT"
		allowed-headers="header1, header2, header3"
		exposed-headers="header1, header2" allow-credentials="true"
		max-age="123" /&gt;

	&lt;mvc:mapping path="/resources/**"
		allowed-origins="https://domain1.com" /&gt;

&lt;/mvc:cors&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors-filter"><a class="anchor" href="#mvc-cors-filter"></a>CORS Filter</h3>
<div class="paragraph">
<p><span class="small"><a href="#webflux-cors.adoc#webflux-cors-webfilter" class="page unresolved">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can apply CORS support through the built-in
{api-spring-framework}/web/filter/CorsFilter.html[<code>CorsFilter</code>].</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you try to use the <code>CorsFilter</code> with Spring Security, keep in mind that
Spring Security has
<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">built-in support</a>
for CORS.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To configure the filter, pass a
<code>CorsConfigurationSource</code> to its constructor, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CorsConfiguration config = new CorsConfiguration();

// Possibly...
// config.applyPermitDefaultValues()

config.setAllowCredentials(true);
config.addAllowedOrigin("https://domain1.com");
config.addAllowedHeader("*");
config.addAllowedMethod("*");

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", config);

CorsFilter filter = new CorsFilter(source);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val config = CorsConfiguration()

// Possibly...
// config.applyPermitDefaultValues()

config.allowCredentials = true
config.addAllowedOrigin("https://domain1.com")
config.addAllowedHeader("*")
config.addAllowedMethod("*")

val source = UrlBasedCorsConfigurationSource()
source.registerCorsConfiguration("/**", config)

val filter = CorsFilter(source)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-web-security"><a class="anchor" href="#mvc-web-security"></a>Web Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-web-security" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <a href="https://projects.spring.io/spring-security/">Spring Security</a> project provides support
for protecting web applications from malicious exploits. See the Spring Security
reference documentation, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#mvc[Spring MVC Security]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#test-mockmvc[Spring MVC Test Support]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#csrf[CSRF protection]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#headers[Security Response Headers]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://hdiv.org/">HDIV</a> is another web security framework that integrates with Spring MVC.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-caching"><a class="anchor" href="#mvc-caching"></a>HTTP Caching</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-caching" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>HTTP caching can significantly improve the performance of a web application. HTTP caching
revolves around the <code>Cache-Control</code> response header and, subsequently, conditional request
headers (such as <code>Last-Modified</code> and <code>ETag</code>). <code>Cache-Control</code> advises private (for example, browser)
and public (for example, proxy) caches on how to cache and re-use responses. An <code>ETag</code> header is used
to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,
if the content has not changed. <code>ETag</code> can be seen as a more sophisticated successor to
the <code>Last-Modified</code> header.</p>
</div>
<div class="paragraph">
<p>This section describes the HTTP caching-related options that are available in Spring Web MVC.</p>
</div>
<div class="sect2">
<h3 id="mvc-caching-cachecontrol"><a class="anchor" href="#mvc-caching-cachecontrol"></a><code>CacheControl</code></h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-caching-cachecontrol" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>{api-spring-framework}/http/CacheControl.html[<code>CacheControl</code>] provides support for
configuring settings related to the <code>Cache-Control</code> header and is accepted as an argument
in a number of places:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{api-spring-framework}/web/servlet/mvc/WebContentInterceptor.html[<code>WebContentInterceptor</code>]</p>
</li>
<li>
<p>{api-spring-framework}/web/servlet/support/WebContentGenerator.html[<code>WebContentGenerator</code>]</p>
</li>
<li>
<p><a href="#mvc-caching-etag-lastmodified">Controllers</a></p>
</li>
<li>
<p><a href="#mvc-caching-static-resources">Static Resources</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While <a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a> describes all possible
directives for the <code>Cache-Control</code> response header, the <code>CacheControl</code> type takes a
use case-oriented approach that focuses on the common scenarios:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

// Prevent caching - "Cache-Control: no-store"
CacheControl ccNoStore = CacheControl.noStore();

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Cache for an hour - "Cache-Control: max-age=3600"
val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

// Prevent caching - "Cache-Control: no-store"
val ccNoStore = CacheControl.noStore()

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebContentGenerator</code> also accept a simpler <code>cachePeriod</code> property (defined in seconds) that
works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>-1</code> value does not generate a <code>Cache-Control</code> response header.</p>
</li>
<li>
<p>A <code>0</code> value prevents caching by using the <code>'Cache-Control: no-store'</code> directive.</p>
</li>
<li>
<p>An <code>n &gt; 0</code> value caches the given response for <code>n</code> seconds by using the
<code>'Cache-Control: max-age=n'</code> directive.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mvc-caching-etag-lastmodified"><a class="anchor" href="#mvc-caching-etag-lastmodified"></a>Controllers</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-caching-etag-lastmodified" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Controllers can add explicit support for HTTP caching. We recommended doing so, since the
<code>lastModified</code> or <code>ETag</code> value for a resource needs to be calculated before it can be compared
against conditional request headers. A controller can add an <code>ETag</code> header and <code>Cache-Control</code>
settings to a <code>ResponseEntity</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/book/{id}")
public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) {

	Book book = findBook(id);
	String version = book.getVersion();

	return ResponseEntity
			.ok()
			.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
			.eTag(version) // lastModified is also available
			.body(book);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/book/{id}")
fun showBook(@PathVariable id: Long): ResponseEntity&lt;Book&gt; {

	val book = findBook(id);
	val version = book.getVersion()

	return ResponseEntity
			.ok()
			.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
			.eTag(version) // lastModified is also available
			.body(book)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example sends an 304 (NOT_MODIFIED) response with an empty body if the comparison
to the conditional request headers indicates that the content has not changed. Otherwise, the
<code>ETag</code> and <code>Cache-Control</code> headers are added to the response.</p>
</div>
<div class="paragraph">
<p>You can also make the check against conditional request headers in the controller,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping
public String myHandleMethod(WebRequest request, Model model) {

	long eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

	if (request.checkNotModified(eTag)) {
		return null; <i class="conum" data-value="2"></i><b>(2)</b>
	}

	model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
	return "myViewName";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Application-specific calculation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The response has been set to 304 (NOT_MODIFIED)&#8201;&#8212;&#8201;no further processing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Continue with the request processing.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RequestMapping
fun myHandleMethod(request: WebRequest, model: Model): String? {

	val eTag: Long = ... <i class="conum" data-value="1"></i><b>(1)</b>

	if (request.checkNotModified(eTag)) {
		return null <i class="conum" data-value="2"></i><b>(2)</b>
	}

	model[...] = ... <i class="conum" data-value="3"></i><b>(3)</b>
	return "myViewName"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Application-specific calculation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The response has been set to 304 (NOT_MODIFIED)&#8201;&#8212;&#8201;no further processing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Continue with the request processing.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are three variants for checking conditional requests against <code>eTag</code> values, <code>lastModified</code>
values, or both. For conditional <code>GET</code> and <code>HEAD</code> requests, you can set the response to
304 (NOT_MODIFIED). For conditional <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>, you can instead set the response
to 412 (PRECONDITION_FAILED), to prevent concurrent modification.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-caching-static-resources"><a class="anchor" href="#mvc-caching-static-resources"></a>Static Resources</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-caching-static-resources" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You should serve static resources with a <code>Cache-Control</code> and conditional response headers
for optimal performance. See the section on configuring <a href="#mvc-config-static-resources">Static Resources</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-httpcaching-shallowetag"><a class="anchor" href="#mvc-httpcaching-shallowetag"></a><code>ETag</code> Filter</h3>
<div class="paragraph">
<p>You can use the <code>ShallowEtagHeaderFilter</code> to add &#8220;shallow&#8221; <code>eTag</code> values that are computed from the
response content and, thus, save bandwidth but not CPU time. See <a href="#filters-shallow-etag">Shallow ETag</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-view"><a class="anchor" href="#mvc-view"></a>View Technologies</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The use of view technologies in Spring MVC is pluggable. Whether you decide to use
Thymeleaf, Groovy Markup Templates, JSPs, or other technologies is primarily a matter of
a configuration change. This chapter covers view technologies integrated with Spring MVC.
We assume you are already familiar with <a href="#mvc-viewresolver">View Resolution</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The views of a Spring MVC application live within the internal trust boundaries
of that application. Views have access to all the beans of your application context. As
such, it is not recommended to use Spring MVC&#8217;s template support in applications where
the templates are editable by external sources, since this can have security implications.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mvc-view-thymeleaf"><a class="anchor" href="#mvc-view-thymeleaf"></a>Thymeleaf</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-thymeleaf" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML
templates that can be previewed in a browser by double-clicking, which is very helpful
for independent work on UI templates (for example, by a designer) without the need for
a running server. If you want to replace JSPs, Thymeleaf offers one of the most
extensive sets of features to make such a transition easier. Thymeleaf is actively
developed and maintained. For a more complete introduction, see the
<a href="https://www.thymeleaf.org/">Thymeleaf</a> project home page.</p>
</div>
<div class="paragraph">
<p>The Thymeleaf integration with Spring MVC is managed by the Thymeleaf project.
The configuration involves a few bean declarations, such as
<code>ServletContextTemplateResolver</code>, <code>SpringTemplateEngine</code>, and <code>ThymeleafViewResolver</code>.
See <a href="https://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a> for more details.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-freemarker"><a class="anchor" href="#mvc-view-freemarker"></a>FreeMarker</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-freemarker" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://freemarker.apache.org/">Apache FreeMarker</a> is a template engine for generating any
kind of text output from HTML to email and others. The Spring Framework has built-in
integration for using Spring MVC with FreeMarker templates.</p>
</div>
<div class="sect3">
<h4 id="mvc-view-freemarker-contextconfig"><a class="anchor" href="#mvc-view-freemarker-contextconfig"></a>View Configuration</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-freemarker-contextconfig" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The following example shows how to configure FreeMarker as a view technology:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.freeMarker();
	}

	// Configure FreeMarker...

	@Bean
	public FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setTemplateLoaderPath("/WEB-INF/freemarker");
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.freeMarker()
	}

	// Configure FreeMarker...

	@Bean
	fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
		setTemplateLoaderPath("/WEB-INF/freemarker")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure the same in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
	&lt;mvc:freemarker/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;!-- Configure FreeMarker... --&gt;
&lt;mvc:freemarker-configurer&gt;
	&lt;mvc:template-loader-path location="/WEB-INF/freemarker"/&gt;
&lt;/mvc:freemarker-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can also declare the <code>FreeMarkerConfigurer</code> bean for full control over all
properties, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
	&lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your templates need to be stored in the directory specified by the <code>FreeMarkerConfigurer</code>
shown in the preceding example. Given the preceding configuration, if your controller
returns a view name of <code>welcome</code>, the resolver looks for the
<code>/WEB-INF/freemarker/welcome.ftl</code> template.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-views-freemarker"><a class="anchor" href="#mvc-views-freemarker"></a>FreeMarker Configuration</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-views-freemarker" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker
<code>Configuration</code> object (which is managed by Spring) by setting the appropriate bean
properties on the <code>FreeMarkerConfigurer</code> bean. The <code>freemarkerSettings</code> property requires
a <code>java.util.Properties</code> object, and the <code>freemarkerVariables</code> property requires a
<code>java.util.Map</code>. The following example shows how to use a <code>FreeMarkerConfigurer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
	&lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
	&lt;property name="freemarkerVariables"&gt;
		&lt;map&gt;
			&lt;entry key="xml_escape" value-ref="fmXmlEscape"/&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the FreeMarker documentation for details of settings and variables as they apply to
the <code>Configuration</code> object.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-freemarker-forms"><a class="anchor" href="#mvc-view-freemarker-forms"></a>Form Handling</h4>
<div class="paragraph">
<p>Spring provides a tag library for use in JSPs that contains, among others, a
<code>&lt;spring:bind/&gt;</code> element. This element primarily lets forms display values from
form-backing objects and show the results of failed validations from a <code>Validator</code> in the
web or business tier. Spring also has support for the same functionality in FreeMarker,
with additional convenience macros for generating form input elements themselves.</p>
</div>
<div class="sect4">
<h5 id="mvc-view-bind-macros"><a class="anchor" href="#mvc-view-bind-macros"></a>The Bind Macros</h5>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-bind-macros" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>A standard set of macros are maintained within the <code>spring-webmvc.jar</code> file for
FreeMarker, so they are always available to a suitably configured application.</p>
</div>
<div class="paragraph">
<p>Some of the macros defined in the Spring templating libraries are considered internal
(private), but no such scoping exists in the macro definitions, making all macros visible
to calling code and user templates. The following sections concentrate only on the macros
you need to directly call from within your templates. If you wish to view the macro code
directly, the file is called <code>spring.ftl</code> and is in the
<code>org.springframework.web.servlet.view.freemarker</code> package.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-simple-binding"><a class="anchor" href="#mvc-view-simple-binding"></a>Simple Binding</h5>
<div class="paragraph">
<p>In your HTML forms based on FreeMarker templates that act as a form view for a Spring MVC
controller, you can use code similar to the next example to bind to field values and
display error messages for each input field in similar fashion to the JSP equivalent. The
following example shows a <code>personForm</code> view:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- FreeMarker macros have to be imported into a namespace.
	We strongly recommend sticking to 'spring'. --&gt;
&lt;#import "/spring.ftl" as spring/&gt;
&lt;html&gt;
	...
	&lt;form action="" method="POST"&gt;
		Name:
		&lt;@spring.bind "personForm.name"/&gt;
		&lt;input type="text"
			name="${spring.status.expression}"
			value="${spring.status.value?html}"/&gt;&lt;br /&gt;
		&lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br /&gt; &lt;/#list&gt;
		&lt;br /&gt;
		...
		&lt;input type="submit" value="submit"/&gt;
	&lt;/form&gt;
	...
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;@spring.bind&gt;</code> requires a 'path' argument, which consists of the name of your command
object (it is 'command', unless you changed it in your controller configuration) followed
by a period and the name of the field on the command object to which you wish to bind. You
can also use nested fields, such as <code>command.address.street</code>. The <code>bind</code> macro assumes the
default HTML escaping behavior specified by the <code>ServletContext</code> parameter
<code>defaultHtmlEscape</code> in <code>web.xml</code>.</p>
</div>
<div class="paragraph">
<p>An alternative form of the macro called <code>&lt;@spring.bindEscaped&gt;</code> takes a second argument
that explicitly specifies whether HTML escaping should be used in the status error
messages or values. You can set it to <code>true</code> or <code>false</code> as required. Additional form
handling macros simplify the use of HTML escaping, and you should use these macros
wherever possible. They are explained in the next section.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-views-form-macros"><a class="anchor" href="#mvc-views-form-macros"></a>Input Macros</h5>
<div class="paragraph">
<p>Additional convenience macros for FreeMarker simplify both binding and form generation
(including validation error display). It is never necessary to use these macros to
generate form input fields, and you can mix and match them with simple HTML or direct
calls to the Spring bind macros that we highlighted previously.</p>
</div>
<div class="paragraph">
<p>The following table of available macros shows the FreeMarker Template (FTL) definitions
and the parameter list that each takes:</p>
</div>
<table id="views-macros-defs-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Table of macro definitions</caption>
<colgroup>
<col style="width: 75%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">macro</th>
<th class="tableblock halign-left valign-top">FTL definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message</code> (output a string from a resource bundle based on the code parameter)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.message code/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>messageText</code> (output a string from a resource bundle based on the code parameter,
  falling back to the value of the default parameter)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.messageText code, text/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code> (prefix a relative URL with the application&#8217;s context root)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.url relativeUrl/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formInput</code> (standard input field for gathering user input)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formInput path, attributes, fieldType/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formHiddenInput</code> (hidden input field for submitting non-user input)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formHiddenInput path, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formPasswordInput</code> (standard input field for gathering passwords. Note that no
  value is ever populated in fields of this type.)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formPasswordInput path, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formTextarea</code> (large text field for gathering long, freeform text input)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formTextarea path, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formSingleSelect</code> (drop down box of options that let a single required value be
  selected)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formSingleSelect path, options, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formMultiSelect</code> (a list box of options that let the user select 0 or more values)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formMultiSelect path, options, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formRadioButtons</code> (a set of radio buttons that let a single selection be made
  from the available choices)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formRadioButtons path, options separator, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckboxes</code> (a set of checkboxes that let 0 or more values be selected)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formCheckboxes path, options, separator, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckbox</code> (a single checkbox)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.formCheckbox path, attributes/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>showErrors</code> (simplify display of validation errors for the bound field)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@spring.showErrors separator, classOrStyle/&gt;</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In FreeMarker templates, <code>formHiddenInput</code> and <code>formPasswordInput</code> are not actually
required, as you can use the normal <code>formInput</code> macro, specifying <code>hidden</code> or <code>password</code>
as the value for the <code>fieldType</code> parameter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parameters to any of the above macros have consistent meanings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path</code>: The name of the field to bind to (ie "command.name")</p>
</li>
<li>
<p><code>options</code>: A <code>Map</code> of all the available values that can be selected from in the input
field. The keys to the map represent the values that are POSTed back from the form
and bound to the command object. Map objects stored against the keys are the labels
displayed on the form to the user and may be different from the corresponding values
posted back by the form. Usually, such a map is supplied as reference data by the
controller. You can use any <code>Map</code> implementation, depending on required behavior.
For strictly sorted maps, you can use a <code>SortedMap</code> (such as a <code>TreeMap</code>) with a
suitable <code>Comparator</code> and, for arbitrary Maps that should return values in insertion
order, use a <code>LinkedHashMap</code> or a <code>LinkedMap</code> from <code>commons-collections</code>.</p>
</li>
<li>
<p><code>separator</code>: Where multiple options are available as discreet elements (radio buttons
or checkboxes), the sequence of characters used to separate each one in the list
(such as <code>&lt;br&gt;</code>).</p>
</li>
<li>
<p><code>attributes</code>: An additional string of arbitrary tags or text to be included within
the HTML tag itself. This string is echoed literally by the macro. For example, in a
<code>textarea</code> field, you may supply attributes (such as 'rows="5" cols="60"'), or you
could pass style information such as 'style="border:1px solid silver"'.</p>
</li>
<li>
<p><code>classOrStyle</code>: For the <code>showErrors</code> macro, the name of the CSS class that the <code>span</code>
element that wraps each error uses. If no information is supplied (or the value is
empty), the errors are wrapped in <code>&lt;b&gt;&lt;/b&gt;</code> tags.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections outline examples of the macros.</p>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros-input"><a class="anchor" href="#mvc-views-form-macros-input"></a>Input Fields</h6>
<div class="paragraph">
<p>The <code>formInput</code> macro takes the <code>path</code> parameter (<code>command.name</code>) and an additional <code>attributes</code>
parameter (which is empty in the upcoming example). The macro, along with all other form
generation macros, performs an implicit Spring bind on the path parameter. The binding
remains valid until a new bind occurs, so the <code>showErrors</code> macro does not need to pass the
path parameter again&#8201;&#8212;&#8201;it operates on the field for which a binding was last created.</p>
</div>
<div class="paragraph">
<p>The <code>showErrors</code> macro takes a separator parameter (the characters that are used to
separate multiple errors on a given field) and also accepts a second parameter&#8201;&#8212;&#8201;this
time, a class name or style attribute. Note that FreeMarker can specify default
values for the attributes parameter. The following example shows how to use the <code>formInput</code>
and <code>showErrors</code> macros:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;@spring.formInput "command.name"/&gt;
&lt;@spring.showErrors "&lt;br&gt;"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example shows the output of the form fragment, generating the name field and displaying a
validation error after the form was submitted with no value in the field. Validation
occurs through Spring&#8217;s Validation framework.</p>
</div>
<div class="paragraph">
<p>The generated HTML resembles the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">Name:
&lt;input type="text" name="name" value=""&gt;
&lt;br&gt;
	&lt;b&gt;required&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>formTextarea</code> macro works the same way as the <code>formInput</code> macro and accepts the same
parameter list. Commonly, the second parameter (<code>attributes</code>) is used to pass style
information or <code>rows</code> and <code>cols</code> attributes for the <code>textarea</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros-select"><a class="anchor" href="#mvc-views-form-macros-select"></a>Selection Fields</h6>
<div class="paragraph">
<p>You can use four selection field macros to generate common UI value selection inputs in
your HTML forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>formSingleSelect</code></p>
</li>
<li>
<p><code>formMultiSelect</code></p>
</li>
<li>
<p><code>formRadioButtons</code></p>
</li>
<li>
<p><code>formCheckboxes</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of the four macros accepts a <code>Map</code> of options that contains the value for the form
field and the label that corresponds to that value. The value and the label can be the
same.</p>
</div>
<div class="paragraph">
<p>The next example is for radio buttons in FTL. The form-backing object specifies a default
value of 'London' for this field, so no validation is necessary. When the form is
rendered, the entire list of cities to choose from is supplied as reference data in the
model under the name 'cityMap'. The following listing shows the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">...
Town:
&lt;@spring.formRadioButtons "command.address.town", cityMap, ""/&gt;&lt;br&gt;&lt;br&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding listing renders a line of radio buttons, one for each value in <code>cityMap</code>, and uses a
separator of <code>""</code>. No additional attributes are supplied (the last parameter to the macro is
missing). The <code>cityMap</code> uses the same <code>String</code> for each key-value pair in the map. The map&#8217;s
keys are what the form actually submits as <code>POST</code> request parameters. The map values are the
labels that the user sees. In the preceding example, given a list of three well known cities
and a default value in the form backing object, the HTML resembles the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">Town:
&lt;input type="radio" name="address.town" value="London"&gt;London&lt;/input&gt;
&lt;input type="radio" name="address.town" value="Paris" checked="checked"&gt;Paris&lt;/input&gt;
&lt;input type="radio" name="address.town" value="New York"&gt;New York&lt;/input&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your application expects to handle cities by internal codes (for example), you can create the map of
codes with suitable keys, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">protected Map&lt;String, ?&gt; referenceData(HttpServletRequest request) throws Exception {
	Map&lt;String, String&gt; cityMap = new LinkedHashMap&lt;&gt;();
	cityMap.put("LDN", "London");
	cityMap.put("PRS", "Paris");
	cityMap.put("NYC", "New York");

	Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();
	model.put("cityMap", cityMap);
	return model;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">protected fun referenceData(request: HttpServletRequest): Map&lt;String, *&gt; {
	val cityMap = linkedMapOf(
			"LDN" to "London",
			"PRS" to "Paris",
			"NYC" to "New York"
	)
	return hashMapOf("cityMap" to cityMap)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code now produces output where the radio values are the relevant codes, but the
user still sees the more user-friendly city names, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">Town:
&lt;input type="radio" name="address.town" value="LDN"&gt;London&lt;/input&gt;
&lt;input type="radio" name="address.town" value="PRS" checked="checked"&gt;Paris&lt;/input&gt;
&lt;input type="radio" name="address.town" value="NYC"&gt;New York&lt;/input&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-views-form-macros-html-escaping"><a class="anchor" href="#mvc-views-form-macros-html-escaping"></a>HTML Escaping</h5>
<div class="paragraph">
<p>Default usage of the form macros described earlier results in HTML elements that are HTML 4.01
compliant and that use the default value for HTML escaping defined in your <code>web.xml</code> file, as
used by Spring&#8217;s bind support. To make the elements be XHTML compliant or to override
the default HTML escaping value, you can specify two variables in your template (or in
your model, where they are visible to your templates). The advantage of specifying
them in the templates is that they can be changed to different values later in the
template processing to provide different behavior for different fields in your form.</p>
</div>
<div class="paragraph">
<p>To switch to XHTML compliance for your tags, specify a value of <code>true</code> for a
model or context variable named <code>xhtmlCompliant</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">&lt;#-- for FreeMarker --&gt;
&lt;#assign xhtmlCompliant = true&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>After processing this directive, any elements generated by the Spring macros are now XHTML
compliant.</p>
</div>
<div class="paragraph">
<p>In similar fashion, you can specify HTML escaping per field, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp hljs" data-lang="jsp">&lt;#-- until this point, default HTML escaping is used --&gt;

&lt;#assign htmlEscape = true&gt;
&lt;#-- next field will use HTML escaping --&gt;
&lt;@spring.formInput "command.name"/&gt;

&lt;#assign htmlEscape = false in spring&gt;
&lt;#-- all future fields will be bound with HTML escaping off --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-groovymarkup"><a class="anchor" href="#mvc-view-groovymarkup"></a>Groovy Markup</h3>
<div class="paragraph">
<p>The <a href="http://groovy-lang.org/templating.html#_the_markuptemplateengine">Groovy Markup Template Engine</a>
is primarily aimed at generating XML-like markup (XML, XHTML, HTML5, and others), but you can
use it to generate any text-based content. The Spring Framework has a built-in
integration for using Spring MVC with Groovy Markup.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Groovy Markup Template engine requires Groovy 2.3.1+.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="mvc-view-groovymarkup-configuration"><a class="anchor" href="#mvc-view-groovymarkup-configuration"></a>Configuration</h4>
<div class="paragraph">
<p>The following example shows how to configure the Groovy Markup Template Engine:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.groovy();
	}

	// Configure the Groovy Markup Template Engine...

	@Bean
	public GroovyMarkupConfigurer groovyMarkupConfigurer() {
		GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();
		configurer.setResourceLoaderPath("/WEB-INF/");
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.groovy()
	}

	// Configure the Groovy Markup Template Engine...

	@Bean
	fun groovyMarkupConfigurer() = GroovyMarkupConfigurer().apply {
		resourceLoaderPath = "/WEB-INF/"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure the same in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
	&lt;mvc:groovy/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;!-- Configure the Groovy Markup Template Engine... --&gt;
&lt;mvc:groovy-configurer resource-loader-path="/WEB-INF/"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-groovymarkup-example"><a class="anchor" href="#mvc-view-groovymarkup-example"></a>Example</h4>
<div class="paragraph">
<p>Unlike traditional template engines, Groovy Markup relies on a DSL that uses a builder
syntax. The following example shows a sample template for an HTML page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">yieldUnescaped '&lt;!DOCTYPE html&gt;'
html(lang:'en') {
	head {
		meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')
		title('My page')
	}
	body {
		p('This is an example of HTML contents')
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-script"><a class="anchor" href="#mvc-view-script"></a>Script Views</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-script" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework has a built-in integration for using Spring MVC with any
templating library that can run on top of the
<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java scripting engine. We have tested the following
templating libraries on different script engines:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Scripting Library</th>
<th class="tableblock halign-left valign-top">Scripting Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://handlebarsjs.com/">Handlebars</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">Mustache</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://facebook.github.io/react/">React</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.stuartellis.name/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jruby.org">JRuby</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">String templates</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jython.org/">Jython</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://kotlinlang.org/">Kotlin</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The basic rule for integrating any other script engine is that it must implement the
<code>ScriptEngine</code> and <code>Invocable</code> interfaces.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="mvc-view-script-dependencies"><a class="anchor" href="#mvc-view-script-dependencies"></a>Requirements</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-script-dependencies" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You need to have the script engine on your classpath, the details of which vary by script engine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript engine is provided with
Java 8+. Using the latest update release available is highly recommended.</p>
</li>
<li>
<p><a href="https://www.jruby.org">JRuby</a> should be added as a dependency for Ruby support.</p>
</li>
<li>
<p><a href="https://www.jython.org">Jython</a> should be added as a dependency for Python support.</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code> dependency and a <code>META-INF/services/javax.script.ScriptEngineFactory</code>
file containing a <code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>
line should be added for Kotlin script support. See
<a href="https://github.com/sdeleuze/kotlin-script-templating">this example</a> for more details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to have the script templating library. One way to do that for Javascript is
through <a href="https://www.webjars.org/">WebJars</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-script-integrate"><a class="anchor" href="#mvc-view-script-integrate"></a>Script Templates</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-script-integrate" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can declare a <code>ScriptTemplateConfigurer</code> bean to specify the script engine to use,
the script files to load, what function to call to render templates, and so on.
The following example uses Mustache templates and the Nashorn JavaScript engine:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.scriptTemplate();
	}

	@Bean
	public ScriptTemplateConfigurer configurer() {
		ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
		configurer.setEngineName("nashorn");
		configurer.setScripts("mustache.js");
		configurer.setRenderObject("Mustache");
		configurer.setRenderFunction("render");
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.scriptTemplate()
	}

	@Bean
	fun configurer() = ScriptTemplateConfigurer().apply {
		engineName = "nashorn"
		setScripts("mustache.js")
		renderObject = "Mustache"
		renderFunction = "render"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the same arrangement in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
	&lt;mvc:script-template/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render"&gt;
	&lt;mvc:script location="mustache.js"/&gt;
&lt;/mvc:script-template-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller would look no different for the Java and XML configurations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class SampleController {

	@GetMapping("/sample")
	public String test(Model model) {
		model.addAttribute("title", "Sample title");
		model.addAttribute("body", "Sample body");
		return "template";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class SampleController {

	@GetMapping("/sample")
	fun test(model: Model): String {
		model["title"] = "Sample title"
		model["body"] = "Sample body"
		return "template"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Mustache template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;{{title}}&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;{{body}}&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The render function is called with the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code>: The template content</p>
</li>
<li>
<p><code>Map model</code>: The view model</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code>: The
{api-spring-framework}/web/servlet/view/script/RenderingContext.html[<code>RenderingContext</code>]
that gives access to the application context, the locale, the template loader, and the
URL (since 5.0)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code> is natively compatible with this signature, so you can call it directly.</p>
</div>
<div class="paragraph">
<p>If your templating technology requires some customization, you can provide a script that
implements a custom render function. For example, <a href="https://handlebarsjs.com">Handlerbars</a>
needs to compile templates before using them and requires a
<a href="https://en.wikipedia.org/wiki/Polyfill">polyfill</a> to emulate some
browser facilities that are not available in the server-side script engine.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.scriptTemplate();
	}

	@Bean
	public ScriptTemplateConfigurer configurer() {
		ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
		configurer.setEngineName("nashorn");
		configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
		configurer.setRenderFunction("render");
		configurer.setSharedEngine(false);
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.scriptTemplate()
	}

	@Bean
	fun configurer() = ScriptTemplateConfigurer().apply {
		engineName = "nashorn"
		setScripts("polyfill.js", "handlebars.js", "render.js")
		renderFunction = "render"
		isSharedEngine = false
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting the <code>sharedEngine</code> property to <code>false</code> is required when using non-thread-safe
script engines with templating libraries not designed for concurrency, such as Handlebars or
React running on Nashorn. In that case, Java SE 8 update 60 is required, due to
<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">this bug</a>, but it is generally
recommended to use a recent Java SE patch release in any case.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code> defines only the <code>window</code> object needed by Handlebars to run properly, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var window = {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This basic <code>render.js</code> implementation compiles the template before using it. A production-ready
implementation should also store any reused cached templates or pre-compiled templates.
You can do so on the script side (and handle any customization you need&#8201;&#8212;&#8201;managing
template engine configuration, for example). The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">function render(template, model) {
	var compiledTemplate = Handlebars.compile(template);
	return compiledTemplate(model);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check out the Spring Framework unit tests,
{spring-framework-main-code}/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script[Java], and
{spring-framework-main-code}/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script[resources],
for more configuration examples.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-jsp"><a class="anchor" href="#mvc-view-jsp"></a>JSP and JSTL</h3>
<div class="paragraph">
<p>The Spring Framework has a built-in integration for using Spring MVC with JSP and JSTL.</p>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp-resolver"><a class="anchor" href="#mvc-view-jsp-resolver"></a>View Resolvers</h4>
<div class="paragraph">
<p>When developing with JSPs, you typically declare an <code>InternalResourceViewResolver</code> bean.</p>
</div>
<div class="paragraph">
<p><code>InternalResourceViewResolver</code> can be used for dispatching to any Servlet resource but in
particular for JSPs. As a best practice, we strongly encourage placing your JSP files in
a directory under the <code>'WEB-INF'</code> directory so there can be no direct access by clients.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
	&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
	&lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
	&lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp-jstl"><a class="anchor" href="#mvc-view-jsp-jstl"></a>JSPs versus JSTL</h4>
<div class="paragraph">
<p>When using the JSP Standard Tag Library (JSTL) you must use a special view class, the
<code>JstlView</code>, as JSTL needs some preparation before things such as the I18N features can
work.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp-tags"><a class="anchor" href="#mvc-view-jsp-tags"></a>Spring&#8217;s JSP Tag Library</h4>
<div class="paragraph">
<p>Spring provides data binding of request parameters to command objects, as described in
earlier chapters. To facilitate the development of JSP pages in combination with those
data binding features, Spring provides a few tags that make things even easier. All
Spring tags have HTML escaping features to enable or disable escaping of characters.</p>
</div>
<div class="paragraph">
<p>The <code>spring.tld</code> tag library descriptor (TLD) is included in the <code>spring-webmvc.jar</code>.
For a comprehensive reference on individual tags, browse the
{api-spring-framework}/web/servlet/tags/package-summary.html#package.description[API reference]
or see the tag library description.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp-formtaglib"><a class="anchor" href="#mvc-view-jsp-formtaglib"></a>Spring&#8217;s form tag library</h4>
<div class="paragraph">
<p>As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for
handling form elements when using JSP and Spring Web MVC. Each tag provides support for
the set of attributes of its corresponding HTML tag counterpart, making the tags
familiar and intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.</p>
</div>
<div class="paragraph">
<p>Unlike other form/input tag libraries, Spring&#8217;s form tag library is integrated with
Spring Web MVC, giving the tags access to the command object and reference data your
controller deals with. As we show in the following examples, the form tags make
JSPs easier to develop, read, and maintain.</p>
</div>
<div class="paragraph">
<p>We go through the form tags and look at an example of how each tag is used. We have
included generated HTML snippets where certain tags require further commentary.</p>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-configuration"><a class="anchor" href="#mvc-view-jsp-formtaglib-configuration"></a>Configuration</h5>
<div class="paragraph">
<p>The form tag library comes bundled in <code>spring-webmvc.jar</code>. The library descriptor is
called <code>spring-form.tld</code>.</p>
</div>
<div class="paragraph">
<p>To use the tags from this library, add the following directive to the top of your JSP
page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>form</code> is the tag name prefix you want to use for the tags from this library.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-formtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-formtag"></a>The Form Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML 'form' element and exposes a binding path to inner tags for
binding. It puts the command object in the <code>PageContext</code> so that the command object can
be accessed by inner tags. All the other tags in this library are nested tags of the
<code>form</code> tag.</p>
</div>
<div class="paragraph">
<p>Assume that we have a domain object called <code>User</code>. It is a JavaBean with properties
such as <code>firstName</code> and <code>lastName</code>. We can use it as the form-backing object of our
form controller, which returns <code>form.jsp</code>. The following example shows what <code>form.jsp</code> could
look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="2"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>firstName</code> and <code>lastName</code> values are retrieved from the command object placed in
the <code>PageContext</code> by the page controller. Keep reading to see more complex examples of
how inner tags are used with the <code>form</code> tag.</p>
</div>
<div class="paragraph">
<p>The following listing shows the generated HTML, which looks like a standard form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form method="POST"&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="firstName" type="text" value="Harry"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="lastName" type="text" value="Potter"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="2"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding JSP assumes that the variable name of the form-backing object is
<code>command</code>. If you have put the form-backing object into the model under another name
(definitely a best practice), you can bind the form to the named variable, as the
following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form modelAttribute="user"&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="2"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-inputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-inputtag"></a>The <code>input</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>input</code> element with the bound value and <code>type='text'</code> by default.
For an example of this tag, see <a href="#mvc-view-jsp-formtaglib-formtag">The Form Tag</a>. You can also use
HTML5-specific types, such as <code>email</code>, <code>tel</code>, <code>date</code>, and others.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-checkboxtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxtag"></a>The <code>checkbox</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>input</code> tag with the <code>type</code> set to <code>checkbox</code>.</p>
</div>
<div class="paragraph">
<p>Assume that our <code>User</code> has preferences such as newsletter subscription and a list of
hobbies. The following example shows the <code>Preferences</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Preferences {

	private boolean receiveNewsletter;
	private String[] interests;
	private String favouriteWord;

	public boolean isReceiveNewsletter() {
		return receiveNewsletter;
	}

	public void setReceiveNewsletter(boolean receiveNewsletter) {
		this.receiveNewsletter = receiveNewsletter;
	}

	public String[] getInterests() {
		return interests;
	}

	public void setInterests(String[] interests) {
		this.interests = interests;
	}

	public String getFavouriteWord() {
		return favouriteWord;
	}

	public void setFavouriteWord(String favouriteWord) {
		this.favouriteWord = favouriteWord;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Preferences(
		var receiveNewsletter: Boolean,
		var interests: StringArray,
		var favouriteWord: String
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>form.jsp</code> could then resemble the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;Subscribe to newsletter?:&lt;/td&gt;
			&lt;%-- Approach 1: Property is of type java.lang.Boolean --%&gt;
			&lt;td&gt;&lt;form:checkbox path="preferences.receiveNewsletter"/&gt;&lt;/td&gt;
		&lt;/tr&gt;

		&lt;tr&gt;
			&lt;td&gt;Interests:&lt;/td&gt;
			&lt;%-- Approach 2: Property is of an array or of type java.util.Collection --%&gt;
			&lt;td&gt;
				Quidditch: &lt;form:checkbox path="preferences.interests" value="Quidditch"/&gt;
				Herbology: &lt;form:checkbox path="preferences.interests" value="Herbology"/&gt;
				Defence Against the Dark Arts: &lt;form:checkbox path="preferences.interests" value="Defence Against the Dark Arts"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;

		&lt;tr&gt;
			&lt;td&gt;Favourite Word:&lt;/td&gt;
			&lt;%-- Approach 3: Property is of type java.lang.Object --%&gt;
			&lt;td&gt;
				Magic: &lt;form:checkbox path="preferences.favouriteWord" value="Magic"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three approaches to the <code>checkbox</code> tag, which should meet all your checkbox needs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Approach One: When the bound value is of type <code>java.lang.Boolean</code>, the
<code>input(checkbox)</code> is marked as <code>checked</code> if the bound value is <code>true</code>. The <code>value</code>
attribute corresponds to the resolved value of the <code>setValue(Object)</code> value property.</p>
</li>
<li>
<p>Approach Two: When the bound value is of type <code>array</code> or <code>java.util.Collection</code>, the
<code>input(checkbox)</code> is marked as <code>checked</code> if the configured <code>setValue(Object)</code> value is
present in the bound <code>Collection</code>.</p>
</li>
<li>
<p>Approach Three: For any other bound value type, the <code>input(checkbox)</code> is marked as
<code>checked</code> if the configured <code>setValue(Object)</code> is equal to the bound value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that, regardless of the approach, the same HTML structure is generated. The following
HTML snippet defines some checkboxes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Interests:&lt;/td&gt;
	&lt;td&gt;
		Quidditch: &lt;input name="preferences.interests" type="checkbox" value="Quidditch"/&gt;
		&lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
		Herbology: &lt;input name="preferences.interests" type="checkbox" value="Herbology"/&gt;
		&lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
		Defence Against the Dark Arts: &lt;input name="preferences.interests" type="checkbox" value="Defence Against the Dark Arts"/&gt;
		&lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might not expect to see the additional hidden field after each checkbox.
When a checkbox in an HTML page is not checked, its value is not sent to the
server as part of the HTTP request parameters once the form is submitted, so we need a
workaround for this quirk in HTML for Spring form data binding to work. The
<code>checkbox</code> tag follows the existing Spring convention of including a hidden parameter
prefixed by an underscore (<code>_</code>) for each checkbox. By doing this, you are effectively
telling Spring that &#8220;the checkbox was visible in the form, and I want my object to
which the form data binds to reflect the state of the checkbox, no matter what.&#8221;</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-checkboxestag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxestag"></a>The <code>checkboxes</code> Tag</h5>
<div class="paragraph">
<p>This tag renders multiple HTML <code>input</code> tags with the <code>type</code> set to <code>checkbox</code>.</p>
</div>
<div class="paragraph">
<p>This section build on the example from the previous <code>checkbox</code> tag section. Sometimes, you prefer
not to have to list all the possible hobbies in your JSP page. You would rather provide
a list at runtime of the available options and pass that in to the tag. That is the
purpose of the <code>checkboxes</code> tag. You can pass in an <code>Array</code>, a <code>List</code>, or a <code>Map</code> that contains
the available options in the <code>items</code> property. Typically, the bound property is a
collection so that it can hold multiple values selected by the user. The following example
shows a JSP that uses this tag:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;Interests:&lt;/td&gt;
			&lt;td&gt;
				&lt;%-- Property is of an array or of type java.util.Collection --%&gt;
				&lt;form:checkboxes path="preferences.interests" items="${interestList}"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example assumes that the <code>interestList</code> is a <code>List</code> available as a model attribute
that contains strings of the values to be selected from. If you use a <code>Map</code>,
the map entry key is used as the value, and the map entry&#8217;s value is used as
the label to be displayed. You can also use a custom object where you can provide the
property names for the value by using <code>itemValue</code> and the label by using <code>itemLabel</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-radiobuttontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttontag"></a>The <code>radiobutton</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>input</code> element with the <code>type</code> set to <code>radio</code>.</p>
</div>
<div class="paragraph">
<p>A typical usage pattern involves multiple tag instances bound to the same property
but with different values, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Sex:&lt;/td&gt;
	&lt;td&gt;
		Male: &lt;form:radiobutton path="sex" value="M"/&gt; &lt;br/&gt;
		Female: &lt;form:radiobutton path="sex" value="F"/&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-radiobuttonstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttonstag"></a>The <code>radiobuttons</code> Tag</h5>
<div class="paragraph">
<p>This tag renders multiple HTML <code>input</code> elements with the <code>type</code> set to <code>radio</code>.</p>
</div>
<div class="paragraph">
<p>As with the <a href="#mvc-view-jsp-formtaglib-checkboxestag"><code>checkboxes</code> tag</a>, you might want to
pass in the available options as a runtime variable. For this usage, you can use the
<code>radiobuttons</code> tag. You pass in an <code>Array</code>, a <code>List</code>, or a <code>Map</code> that contains the
available options in the <code>items</code> property. If you use a <code>Map</code>, the map entry key is
used as the value and the map entry&#8217;s value are used as the label to be displayed.
You can also use a custom object where you can provide the property names for the value
by using <code>itemValue</code> and the label by using <code>itemLabel</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Sex:&lt;/td&gt;
	&lt;td&gt;&lt;form:radiobuttons path="sex" items="${sexOptions}"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-passwordtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-passwordtag"></a>The <code>password</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>input</code> tag with the type set to <code>password</code> with the bound value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Password:&lt;/td&gt;
	&lt;td&gt;
		&lt;form:password path="password"/&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, by default, the password value is not shown. If you do want the
password value to be shown, you can set the value of the <code>showPassword</code> attribute to
<code>true</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Password:&lt;/td&gt;
	&lt;td&gt;
		&lt;form:password path="password" value="^76525bvHGq" showPassword="true"/&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-selecttag"><a class="anchor" href="#mvc-view-jsp-formtaglib-selecttag"></a>The <code>select</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML 'select' element. It supports data binding to the selected
option as well as the use of nested <code>option</code> and <code>options</code> tags.</p>
</div>
<div class="paragraph">
<p>Assume that a <code>User</code> has a list of skills. The corresponding HTML could be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Skills:&lt;/td&gt;
	&lt;td&gt;&lt;form:select path="skills" items="${skills}"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>User&#8217;s</code> skill are in Herbology, the HTML source of the 'Skills' row could be
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Skills:&lt;/td&gt;
	&lt;td&gt;
		&lt;select name="skills" multiple="true"&gt;
			&lt;option value="Potions"&gt;Potions&lt;/option&gt;
			&lt;option value="Herbology" selected="selected"&gt;Herbology&lt;/option&gt;
			&lt;option value="Quidditch"&gt;Quidditch&lt;/option&gt;
		&lt;/select&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-optiontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optiontag"></a>The <code>option</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>option</code> element. It sets <code>selected</code>, based on the bound
value. The following HTML shows typical output for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;House:&lt;/td&gt;
	&lt;td&gt;
		&lt;form:select path="house"&gt;
			&lt;form:option value="Gryffindor"/&gt;
			&lt;form:option value="Hufflepuff"/&gt;
			&lt;form:option value="Ravenclaw"/&gt;
			&lt;form:option value="Slytherin"/&gt;
		&lt;/form:select&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>User&#8217;s</code> house was in Gryffindor, the HTML source of the 'House' row would be
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;House:&lt;/td&gt;
	&lt;td&gt;
		&lt;select name="house"&gt;
			&lt;option value="Gryffindor" selected="selected"&gt;Gryffindor&lt;/option&gt; <i class="conum" data-value="1"></i><b>(1)</b>
			&lt;option value="Hufflepuff"&gt;Hufflepuff&lt;/option&gt;
			&lt;option value="Ravenclaw"&gt;Ravenclaw&lt;/option&gt;
			&lt;option value="Slytherin"&gt;Slytherin&lt;/option&gt;
		&lt;/select&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the addition of a <code>selected</code> attribute.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-optionstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optionstag"></a>The <code>options</code> Tag</h5>
<div class="paragraph">
<p>This tag renders a list of HTML <code>option</code> elements. It sets the <code>selected</code> attribute,
based on the bound value. The following HTML shows typical output for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Country:&lt;/td&gt;
	&lt;td&gt;
		&lt;form:select path="country"&gt;
			&lt;form:option value="-" label="--Please Select"/&gt;
			&lt;form:options items="${countryList}" itemValue="code" itemLabel="name"/&gt;
		&lt;/form:select&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>User</code> lived in the UK, the HTML source of the 'Country' row would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Country:&lt;/td&gt;
	&lt;td&gt;
		&lt;select name="country"&gt;
			&lt;option value="-"&gt;--Please Select&lt;/option&gt;
			&lt;option value="AT"&gt;Austria&lt;/option&gt;
			&lt;option value="UK" selected="selected"&gt;United Kingdom&lt;/option&gt; <i class="conum" data-value="1"></i><b>(1)</b>
			&lt;option value="US"&gt;United States&lt;/option&gt;
		&lt;/select&gt;
	&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the addition of a <code>selected</code> attribute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As the preceding example shows, the combined usage of an <code>option</code> tag with the <code>options</code> tag
generates the same standard HTML but lets you explicitly specify a value in the
JSP that is for display only (where it belongs), such as the default string in the
example: "-- Please Select".</p>
</div>
<div class="paragraph">
<p>The <code>items</code> attribute is typically populated with a collection or array of item objects.
<code>itemValue</code> and <code>itemLabel</code> refer to bean properties of those item objects, if
specified. Otherwise, the item objects themselves are turned into strings. Alternatively,
you can specify a <code>Map</code> of items, in which case the map keys are interpreted as option
values and the map values correspond to option labels. If <code>itemValue</code> or <code>itemLabel</code> (or both)
happen to be specified as well, the item value property applies to the map key, and
the item label property applies to the map value.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-textareatag"><a class="anchor" href="#mvc-view-jsp-formtaglib-textareatag"></a>The <code>textarea</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>textarea</code> element. The following HTML shows typical output for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;tr&gt;
	&lt;td&gt;Notes:&lt;/td&gt;
	&lt;td&gt;&lt;form:textarea path="notes" rows="3" cols="20"/&gt;&lt;/td&gt;
	&lt;td&gt;&lt;form:errors path="notes"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-hiddeninputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-hiddeninputtag"></a>The <code>hidden</code> Tag</h5>
<div class="paragraph">
<p>This tag renders an HTML <code>input</code> tag with the <code>type</code> set to <code>hidden</code> with the bound value. To submit
an unbound hidden value, use the HTML <code>input</code> tag with the <code>type</code> set to <code>hidden</code>.
The following HTML shows typical output for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:hidden path="house"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we choose to submit the <code>house</code> value as a hidden one, the HTML would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;input name="house" type="hidden" value="Gryffindor"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-errorstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-errorstag"></a>The <code>errors</code> Tag</h5>
<div class="paragraph">
<p>This tag renders field errors in an HTML <code>span</code> element. It provides access to the errors
created in your controller or those that were created by any validators associated with
your controller.</p>
</div>
<div class="paragraph">
<p>Assume that we want to display all error messages for the <code>firstName</code> and <code>lastName</code>
fields once we submit the form. We have a validator for instances of the <code>User</code> class
called <code>UserValidator</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserValidator implements Validator {

	public boolean supports(Class candidate) {
		return User.class.isAssignableFrom(candidate);
	}

	public void validate(Object obj, Errors errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserValidator : Validator {

	override fun supports(candidate: Class&lt;*&gt;): Boolean {
		return User::class.java.isAssignableFrom(candidate)
	}

	override fun validate(obj: Any, errors: Errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.")
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>form.jsp</code> could be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
			&lt;%-- Show errors for firstName field --%&gt;
			&lt;td&gt;&lt;form:errors path="firstName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;

		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
			&lt;%-- Show errors for lastName field --%&gt;
			&lt;td&gt;&lt;form:errors path="lastName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="3"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we submit a form with empty values in the <code>firstName</code> and <code>lastName</code> fields,
the HTML would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form method="POST"&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
			&lt;%-- Associated errors to firstName field displayed --%&gt;
			&lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
		&lt;/tr&gt;

		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
			&lt;%-- Associated errors to lastName field displayed --%&gt;
			&lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="3"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if we want to display the entire list of errors for a given page? The next example
shows that the <code>errors</code> tag also supports some basic wildcarding functionality.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path="*"</code>: Displays all errors.</p>
</li>
<li>
<p><code>path="lastName"</code>: Displays all errors associated with the <code>lastName</code> field.</p>
</li>
<li>
<p>If <code>path</code> is omitted, only object errors are displayed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example displays a list of errors at the top of the page, followed by
field-specific errors next to the fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form&gt;
	&lt;form:errors path="*" cssClass="errorBox"/&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
			&lt;td&gt;&lt;form:errors path="firstName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
			&lt;td&gt;&lt;form:errors path="lastName"/&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="3"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The HTML would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form method="POST"&gt;
	&lt;span name="*.errors" class="errorBox"&gt;Field is required.&lt;br/&gt;Field is required.&lt;/span&gt;
	&lt;table&gt;
		&lt;tr&gt;
			&lt;td&gt;First Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
			&lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
		&lt;/tr&gt;

		&lt;tr&gt;
			&lt;td&gt;Last Name:&lt;/td&gt;
			&lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
			&lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan="3"&gt;
				&lt;input type="submit" value="Save Changes"/&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-form.tld</code> tag library descriptor (TLD) is included in the <code>spring-webmvc.jar</code>.
For a comprehensive reference on individual tags, browse the
{api-spring-framework}/web/servlet/tags/form/package-summary.html#package.description[API reference]
or see the tag library description.</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-rest-method-conversion"><a class="anchor" href="#mvc-rest-method-conversion"></a>HTTP Method Conversion</h5>
<div class="paragraph">
<p>A key principle of REST is the use of the &#8220;Uniform Interface&#8221;. This means that all
resources (URLs) can be manipulated by using the same four HTTP methods: GET, PUT, POST,
and DELETE. For each method, the HTTP specification defines the exact semantics. For
instance, a GET should always be a safe operation, meaning that it has no side effects,
and a PUT or DELETE should be idempotent, meaning that you can repeat these operations
over and over again, but the end result should be the same. While HTTP defines these
four methods, HTML only supports two: GET and POST. Fortunately, there are two possible
workarounds: you can either use JavaScript to do your PUT or DELETE, or you can do a POST
with the &#8220;real&#8221; method as an additional parameter (modeled as a hidden input field in an
HTML form). Spring&#8217;s <code>HiddenHttpMethodFilter</code> uses this latter trick. This
filter is a plain Servlet filter and, therefore, it can be used in combination with any
web framework (not just Spring MVC). Add this filter to your web.xml, and a POST
with a hidden <code>method</code> parameter is converted into the corresponding HTTP method
request.</p>
</div>
<div class="paragraph">
<p>To support HTTP method conversion, the Spring MVC form tag was updated to support setting
the HTTP method. For example, the following snippet comes from the Pet Clinic sample:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form:form method="delete"&gt;
	&lt;p class="submit"&gt;&lt;input type="submit" value="Delete Pet"/&gt;&lt;/p&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example performs an HTTP POST, with the &#8220;real&#8221; DELETE method hidden behind
a request parameter. It is picked up by the <code>HiddenHttpMethodFilter</code>, which is defined in
web.xml, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;filter&gt;
	&lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
	&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
	&lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
	&lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding <code>@Controller</code> method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping(method = RequestMethod.DELETE)
public String deletePet(@PathVariable int ownerId, @PathVariable int petId) {
	this.clinic.deletePet(petId);
	return "redirect:/owners/" + ownerId;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RequestMapping(method = [RequestMethod.DELETE])
fun deletePet(@PathVariable ownerId: Int, @PathVariable petId: Int): String {
	clinic.deletePet(petId)
	return "redirect:/owners/$ownerId"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib-html5"><a class="anchor" href="#mvc-view-jsp-formtaglib-html5"></a>HTML5 Tags</h5>
<div class="paragraph">
<p>The Spring form tag library allows entering dynamic attributes, which means you can
enter any HTML5 specific attributes.</p>
</div>
<div class="paragraph">
<p>The form <code>input</code> tag supports entering a type attribute other than <code>text</code>. This is
intended to allow rendering new HTML5 specific input types, such as <code>email</code>, <code>date</code>,
<code>range</code>, and others. Note that entering <code>type='text'</code> is not required, since <code>text</code>
is the default type.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-tiles"><a class="anchor" href="#mvc-view-tiles"></a>Tiles</h3>
<div class="paragraph">
<p>You can integrate Tiles - just as any other view technology - in web
applications that use Spring. This section describes, in a broad way, how to do so.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This section focuses on Spring&#8217;s support for Tiles version 3 in the
<code>org.springframework.web.servlet.view.tiles3</code> package.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="mvc-view-tiles-dependencies"><a class="anchor" href="#mvc-view-tiles-dependencies"></a>Dependencies</h4>
<div class="paragraph">
<p>To be able to use Tiles, you have to add a dependency on Tiles version 3.0.1 or higher
and <a href="https://tiles.apache.org/framework/dependency-management.html">its transitive dependencies</a>
to your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-tiles-integrate"><a class="anchor" href="#mvc-view-tiles-integrate"></a>Configuration</h4>
<div class="paragraph">
<p>To be able to use Tiles, you have to configure it by using files that contain definitions
(for basic information on definitions and other Tiles concepts, see
<a href="https://tiles.apache.org" class="bare">https://tiles.apache.org</a>). In Spring, this is done by using the <code>TilesConfigurer</code>.
The following example <code>ApplicationContext</code> configuration shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
	&lt;property name="definitions"&gt;
		&lt;list&gt;
			&lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example defines five files that contain definitions. The files are all
located in the <code>WEB-INF/defs</code> directory. At initialization of the <code>WebApplicationContext</code>,
the files are loaded, and the definitions factory are initialized. After that has
been done, the Tiles included in the definition files can be used as views within your
Spring web application. To be able to use the views, you have to have a <code>ViewResolver</code>
as with any other view technology in Spring : typically a convenient <code>TilesViewResolver</code>.</p>
</div>
<div class="paragraph">
<p>You can specify locale-specific Tiles definitions by adding an underscore and then
the locale, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
	&lt;property name="definitions"&gt;
		&lt;list&gt;
			&lt;value&gt;/WEB-INF/defs/tiles.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/tiles_fr_FR.xml&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the preceding configuration, <code>tiles_fr_FR.xml</code> is used for requests with the <code>fr_FR</code> locale,
and <code>tiles.xml</code> is used by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since underscores are used to indicate locales, we recommended not using
them otherwise in the file names for Tiles definitions.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-url"><a class="anchor" href="#mvc-view-tiles-url"></a><code>UrlBasedViewResolver</code></h5>
<div class="paragraph">
<p>The <code>UrlBasedViewResolver</code> instantiates the given <code>viewClass</code> for each view it has to
resolve. The following bean defines a <code>UrlBasedViewResolver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
	&lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-preparer"><a class="anchor" href="#mvc-view-tiles-preparer"></a><code>SimpleSpringPreparerFactory</code> and <code>SpringBeanPreparerFactory</code></h5>
<div class="paragraph">
<p>As an advanced feature, Spring also supports two special Tiles <code>PreparerFactory</code>
implementations. See the Tiles documentation for details on how to use
<code>ViewPreparer</code> references in your Tiles definition files.</p>
</div>
<div class="paragraph">
<p>You can specify <code>SimpleSpringPreparerFactory</code> to autowire <code>ViewPreparer</code> instances based on
specified preparer classes, applying Spring&#8217;s container callbacks as well as applying
configured Spring BeanPostProcessors. If Spring&#8217;s context-wide annotation configuration has
been activated, annotations in <code>ViewPreparer</code> classes are automatically detected and
applied. Note that this expects preparer classes in the Tiles definition files, as
the default <code>PreparerFactory</code> does.</p>
</div>
<div class="paragraph">
<p>You can specify <code>SpringBeanPreparerFactory</code> to operate on specified preparer names (instead
of classes), obtaining the corresponding Spring bean from the DispatcherServlet&#8217;s
application context. The full bean creation process is in the control of the Spring
application context in this case, allowing for the use of explicit dependency injection
configuration, scoped beans, and so on. Note that you need to define one Spring bean definition
for each preparer name (as used in your Tiles definitions). The following example shows
how to define a <code>SpringBeanPreparerFactory</code> property on a <code>TilesConfigurer</code> bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
	&lt;property name="definitions"&gt;
		&lt;list&gt;
			&lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
			&lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;

	&lt;!-- resolving preparer names as Spring bean definition names --&gt;
	&lt;property name="preparerFactoryClass"
			value="org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory"/&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-feeds"><a class="anchor" href="#mvc-view-feeds"></a>RSS and Atom</h3>
<div class="paragraph">
<p>Both <code>AbstractAtomFeedView</code> and <code>AbstractRssFeedView</code> inherit from the
<code>AbstractFeedView</code> base class and are used to provide Atom and RSS Feed views, respectively. They
are based on <a href="https://rometools.github.io/rome/">ROME</a> project and are located in the
package <code>org.springframework.web.servlet.view.feed</code>.</p>
</div>
<div class="paragraph">
<p><code>AbstractAtomFeedView</code> requires you to implement the <code>buildFeedEntries()</code> method and
optionally override the <code>buildFeedMetadata()</code> method (the default implementation is
empty). The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SampleContentAtomView extends AbstractAtomFeedView {

	@Override
	protected void buildFeedMetadata(Map&lt;String, Object&gt; model,
			Feed feed, HttpServletRequest request) {
		// implementation omitted
	}

	@Override
	protected List&lt;Entry&gt; buildFeedEntries(Map&lt;String, Object&gt; model,
			HttpServletRequest request, HttpServletResponse response) throws Exception {
		// implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SampleContentAtomView : AbstractAtomFeedView() {

	override fun buildFeedMetadata(model: Map&lt;String, Any&gt;,
			feed: Feed, request: HttpServletRequest) {
		// implementation omitted
	}

	override fun buildFeedEntries(model: Map&lt;String, Any&gt;,
			request: HttpServletRequest, response: HttpServletResponse): List&lt;Entry&gt; {
		// implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar requirements apply for implementing <code>AbstractRssFeedView</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SampleContentRssView extends AbstractRssFeedView {

	@Override
	protected void buildFeedMetadata(Map&lt;String, Object&gt; model,
			Channel feed, HttpServletRequest request) {
		// implementation omitted
	}

	@Override
	protected List&lt;Item&gt; buildFeedItems(Map&lt;String, Object&gt; model,
			HttpServletRequest request, HttpServletResponse response) throws Exception {
		// implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class SampleContentRssView : AbstractRssFeedView() {

	override fun buildFeedMetadata(model: Map&lt;String, Any&gt;,
								feed: Channel, request: HttpServletRequest) {
		// implementation omitted
	}

	override fun buildFeedItems(model: Map&lt;String, Any&gt;,
			request: HttpServletRequest, response: HttpServletResponse): List&lt;Item&gt; {
		// implementation omitted
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>buildFeedItems()</code> and <code>buildFeedEntries()</code> methods pass in the HTTP request, in case
you need to access the Locale. The HTTP response is passed in only for the setting of
cookies or other HTTP headers. The feed is automatically written to the response
object after the method returns.</p>
</div>
<div class="paragraph">
<p>For an example of creating an Atom view, see Alef Arendsen&#8217;s Spring Team Blog
<a href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">entry</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-document"><a class="anchor" href="#mvc-view-document"></a>PDF and Excel</h3>
<div class="paragraph">
<p>Spring offers ways to return output other than HTML, including PDF and Excel spreadsheets.
This section describes how to use those features.</p>
</div>
<div class="sect3">
<h4 id="mvc-view-document-intro"><a class="anchor" href="#mvc-view-document-intro"></a>Introduction to Document Views</h4>
<div class="paragraph">
<p>An HTML page is not always the best way for the user to view the model output,
and Spring makes it simple to generate a PDF document or an Excel spreadsheet
dynamically from the model data. The document is the view and is streamed from the
server with the correct content type, to (hopefully) enable the client PC to run their
spreadsheet or PDF viewer application in response.</p>
</div>
<div class="paragraph">
<p>In order to use Excel views, you need to add the Apache POI library to your classpath.
For PDF generation, you need to add (preferably) the OpenPDF library.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should use the latest versions of the underlying document-generation libraries,
if possible. In particular, we strongly recommend OpenPDF (for example, OpenPDF 1.2.12)
instead of the outdated original iText 2.1.7, since OpenPDF is actively maintained and
fixes an important vulnerability for untrusted PDF content.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-document-pdf"><a class="anchor" href="#mvc-view-document-pdf"></a>PDF Views</h4>
<div class="paragraph">
<p>A simple PDF view for a word list could extend
<code>org.springframework.web.servlet.view.document.AbstractPdfView</code> and implement the
<code>buildPdfDocument()</code> method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PdfWordList extends AbstractPdfView {

	protected void buildPdfDocument(Map&lt;String, Object&gt; model, Document doc, PdfWriter writer,
			HttpServletRequest request, HttpServletResponse response) throws Exception {

		List&lt;String&gt; words = (List&lt;String&gt;) model.get("wordList");
		for (String word : words) {
			doc.add(new Paragraph(word));
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PdfWordList : AbstractPdfView() {

	override fun buildPdfDocument(model: Map&lt;String, Any&gt;, doc: Document, writer: PdfWriter,
			request: HttpServletRequest, response: HttpServletResponse) {

		val words = model["wordList"] as List&lt;String&gt;
		for (word in words) {
			doc.add(Paragraph(word))
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A controller can return such a view either from an external view definition
(referencing it by name) or as a <code>View</code> instance from the handler method.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-document-excel"><a class="anchor" href="#mvc-view-document-excel"></a>Excel Views</h4>
<div class="paragraph">
<p>Since Spring Framework 4.2,
<code>org.springframework.web.servlet.view.document.AbstractXlsView</code> is provided as a base
class for Excel views. It is based on Apache POI, with specialized subclasses (<code>AbstractXlsxView</code>
and <code>AbstractXlsxStreamingView</code>) that supersede the outdated <code>AbstractExcelView</code> class.</p>
</div>
<div class="paragraph">
<p>The programming model is similar to <code>AbstractPdfView</code>, with <code>buildExcelDocument()</code>
as the central template method and controllers being able to return such a view from
an external definition (by name) or as a <code>View</code> instance from the handler method.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-jackson"><a class="anchor" href="#mvc-view-jackson"></a>Jackson</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-httpmessagewriter" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Spring offers support for the Jackson JSON library.</p>
</div>
<div class="sect3">
<h4 id="mvc-view-json-mapping"><a class="anchor" href="#mvc-view-json-mapping"></a>Jackson-based JSON MVC Views</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-httpmessagewriter" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The <code>MappingJackson2JsonView</code> uses the Jackson library&#8217;s <code>ObjectMapper</code> to render the response
content as JSON. By default, the entire contents of the model map (with the exception of
framework-specific classes) are encoded as JSON. For cases where the contents of the
map need to be filtered, you can specify a specific set of model attributes to encode
by using the <code>modelKeys</code> property. You can also use the <code>extractValueFromSingleKeyModel</code>
property to have the value in single-key models extracted and serialized directly rather
than as a map of model attributes.</p>
</div>
<div class="paragraph">
<p>You can customize JSON mapping as needed by using Jackson&#8217;s provided
annotations. When you need further control, you can inject a custom <code>ObjectMapper</code>
through the <code>ObjectMapper</code> property, for cases where you need to provide custom JSON
serializers and deserializers for specific types.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xml-mapping"><a class="anchor" href="#mvc-view-xml-mapping"></a>Jackson-based XML Views</h4>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-view-httpmessagewriter" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>MappingJackson2XmlView</code> uses the
<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML extension&#8217;s</a> <code>XmlMapper</code>
to render the response content as XML. If the model contains multiple entries, you should
explicitly set the object to be serialized by using the <code>modelKey</code> bean property. If the
model contains a single entry, it is serialized automatically.</p>
</div>
<div class="paragraph">
<p>You can customized XML mapping as needed by using JAXB or Jackson&#8217;s provided
annotations. When you need further control, you can inject a custom <code>XmlMapper</code>
through the <code>ObjectMapper</code> property, for cases where custom XML
you need to provide serializers and deserializers for specific types.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-xml-marshalling"><a class="anchor" href="#mvc-view-xml-marshalling"></a>XML Marshalling</h3>
<div class="paragraph">
<p>The <code>MarshallingView</code> uses an XML <code>Marshaller</code> (defined in the <code>org.springframework.oxm</code>
package) to render the response content as XML. You can explicitly set the object to be
marshalled by using a <code>MarshallingView</code> instance&#8217;s <code>modelKey</code> bean property. Alternatively,
the view iterates over all model properties and marshals the first type that is supported
by the <code>Marshaller</code>. For more information on the functionality in the
<code>org.springframework.oxm</code> package, see <a href="../data-access.html#oxm" class="page">Marshalling XML using O/X Mappers</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view-xslt"><a class="anchor" href="#mvc-view-xslt"></a>XSLT Views</h3>
<div class="paragraph">
<p>XSLT is a transformation language for XML and is popular as a view technology within web
applications. XSLT can be a good choice as a view technology if your application
naturally deals with XML or if your model can easily be converted to XML. The following
section shows how to produce an XML document as model data and have it transformed with
XSLT in a Spring Web MVC application.</p>
</div>
<div class="paragraph">
<p>This example is a trivial Spring application that creates a list of words in the
<code>Controller</code> and adds them to the model map. The map is returned, along with the view
name of our XSLT view. See <a href="#mvc-controller">Annotated Controllers</a> for details of Spring Web MVC&#8217;s
<code>Controller</code> interface. The XSLT controller turns the list of words into a simple XML
document ready for transformation.</p>
</div>
<div class="sect3">
<h4 id="mvc-view-xslt-beandefs"><a class="anchor" href="#mvc-view-xslt-beandefs"></a>Beans</h4>
<div class="paragraph">
<p>Configuration is standard for a simple Spring web application: The MVC configuration
has to define an <code>XsltViewResolver</code> bean and regular MVC annotation configuration.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebMvc
@ComponentScan
@Configuration
public class WebConfig implements WebMvcConfigurer {

	@Bean
	public XsltViewResolver xsltViewResolver() {
		XsltViewResolver viewResolver = new XsltViewResolver();
		viewResolver.setPrefix("/WEB-INF/xsl/");
		viewResolver.setSuffix(".xslt");
		return viewResolver;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@EnableWebMvc
@ComponentScan
@Configuration
class WebConfig : WebMvcConfigurer {

	@Bean
	fun xsltViewResolver() = XsltViewResolver().apply {
		setPrefix("/WEB-INF/xsl/")
		setSuffix(".xslt")
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xslt-controllercode"><a class="anchor" href="#mvc-view-xslt-controllercode"></a>Controller</h4>
<div class="paragraph">
<p>We also need a Controller that encapsulates our word-generation logic.</p>
</div>
<div class="paragraph">
<p>The controller logic is encapsulated in a <code>@Controller</code> class, with the
handler method being defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class XsltController {

	@RequestMapping("/")
	public String home(Model model) throws Exception {
		Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
		Element root = document.createElement("wordList");

		List&lt;String&gt; words = Arrays.asList("Hello", "Spring", "Framework");
		for (String word : words) {
			Element wordNode = document.createElement("word");
			Text textNode = document.createTextNode(word);
			wordNode.appendChild(textNode);
			root.appendChild(wordNode);
		}

		model.addAttribute("wordList", root);
		return "home";
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.ui.set

@Controller
class XsltController {

	@RequestMapping("/")
	fun home(model: Model): String {
		val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()
		val root = document.createElement("wordList")

		val words = listOf("Hello", "Spring", "Framework")
		for (word in words) {
			val wordNode = document.createElement("word")
			val textNode = document.createTextNode(word)
			wordNode.appendChild(textNode)
			root.appendChild(wordNode)
		}

		model["wordList"] = root
		return "home"
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far, we have only created a DOM document and added it to the Model map. Note that you
can also load an XML file as a <code>Resource</code> and use it instead of a custom DOM document.</p>
</div>
<div class="paragraph">
<p>There are software packages available that automatically 'domify'
an object graph, but, within Spring, you have complete flexibility to create the DOM
from your model in any way you choose. This prevents the transformation of XML playing
too great a part in the structure of your model data, which is a danger when using tools
to manage the DOMification process.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xslt-transforming"><a class="anchor" href="#mvc-view-xslt-transforming"></a>Transformation</h4>
<div class="paragraph">
<p>Finally, the <code>XsltViewResolver</code> resolves the &#8220;home&#8221; XSLT template file and merges the
DOM document into it to generate our view. As shown in the <code>XsltViewResolver</code>
configuration, XSLT templates live in the <code>war</code> file in the <code>WEB-INF/xsl</code> directory
and end with an <code>xslt</code> file extension.</p>
</div>
<div class="paragraph">
<p>The following example shows an XSLT transform:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

	&lt;xsl:output method="html" omit-xml-declaration="yes"/&gt;

	&lt;xsl:template match="/"&gt;
		&lt;html&gt;
			&lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
			&lt;body&gt;
				&lt;h1&gt;My First Words&lt;/h1&gt;
				&lt;ul&gt;
					&lt;xsl:apply-templates/&gt;
				&lt;/ul&gt;
			&lt;/body&gt;
		&lt;/html&gt;
	&lt;/xsl:template&gt;

	&lt;xsl:template match="word"&gt;
		&lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
	&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding transform is rendered as the following HTML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;html&gt;
	&lt;head&gt;
		&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
		&lt;title&gt;Hello!&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;My First Words&lt;/h1&gt;
		&lt;ul&gt;
			&lt;li&gt;Hello&lt;/li&gt;
			&lt;li&gt;Spring&lt;/li&gt;
			&lt;li&gt;Framework&lt;/li&gt;
		&lt;/ul&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-config"><a class="anchor" href="#mvc-config"></a>MVC Config</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The MVC Java configuration and the MVC XML namespace provide default configuration
suitable for most applications and a configuration API to customize it.</p>
</div>
<div class="paragraph">
<p>For more advanced customizations, which are not available in the configuration API,
see <a href="#mvc-config-advanced-java">Advanced Java Config</a> and <a href="#mvc-config-advanced-xml">Advanced XML Config</a>.</p>
</div>
<div class="paragraph">
<p>You do not need to understand the underlying beans created by the MVC Java configuration
and the MVC namespace. If you want to learn more, see <a href="#mvc-servlet-special-bean-types">Special Bean Types</a>
and <a href="#mvc-servlet-config">Web MVC Config</a>.</p>
</div>
<div class="sect2">
<h3 id="mvc-config-enable"><a class="anchor" href="#mvc-config-enable"></a>Enable MVC Configuration</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-enable" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>In Java configuration, you can use the <code>@EnableWebMvc</code> annotation to enable MVC
configuration, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>In XML configuration, you can use the <code>&lt;mvc:annotation-driven&gt;</code> element to enable MVC
configuration, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/mvc
		https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

	&lt;mvc:annotation-driven/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example registers a number of Spring MVC
<a href="#mvc-servlet-special-bean-types">infrastructure beans</a> and adapts to dependencies
available on the classpath (for example, payload converters for JSON, XML, and others).</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-customize"><a class="anchor" href="#mvc-config-customize"></a>MVC Config API</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-customize" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>In Java configuration, you can implement the <code>WebMvcConfigurer</code> interface, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	// Implement configuration methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {
	// Implement configuration methods...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In XML, you can check attributes and sub-elements of <code>&lt;mvc:annotation-driven/&gt;</code>. You can
view the <a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a> or use
the code completion feature of your IDE to discover what attributes and
sub-elements are available.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-conversion"><a class="anchor" href="#mvc-config-conversion"></a>Type Conversion</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-conversion" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>By default, formatters for various number and date types are installed, along with support
for customization via <code>@NumberFormat</code> and <code>@DateTimeFormat</code> on fields.</p>
</div>
<div class="paragraph">
<p>To register custom formatters and converters in Java config, use the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addFormatters(FormatterRegistry registry) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addFormatters(registry: FormatterRegistry) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To do the same in XML config, use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/mvc
		https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

	&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;

	&lt;bean id="conversionService"
			class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
		&lt;property name="converters"&gt;
			&lt;set&gt;
				&lt;bean class="org.example.MyConverter"/&gt;
			&lt;/set&gt;
		&lt;/property&gt;
		&lt;property name="formatters"&gt;
			&lt;set&gt;
				&lt;bean class="org.example.MyFormatter"/&gt;
				&lt;bean class="org.example.MyAnnotationFormatterFactory"/&gt;
			&lt;/set&gt;
		&lt;/property&gt;
		&lt;property name="formatterRegistrars"&gt;
			&lt;set&gt;
				&lt;bean class="org.example.MyFormatterRegistrar"/&gt;
			&lt;/set&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default Spring MVC considers the request Locale when parsing and formatting date
values. This works for forms where dates are represented as Strings with "input" form
fields. For "date" and "time" form fields, however, browsers use a fixed format defined
in the HTML spec. For such cases date and time formatting can be customized as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addFormatters(FormatterRegistry registry) {
		DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
		registrar.setUseIsoFormat(true);
		registrar.registerFormatters(registry);
     	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addFormatters(registry: FormatterRegistry) {
		val registrar = DateTimeFormatterRegistrar()
		registrar.setUseIsoFormat(true)
		registrar.registerFormatters(registry)
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See <a href="../core.html#format-FormatterRegistrar-SPI" class="page">the <code>FormatterRegistrar</code> SPI</a>
and the <code>FormattingConversionServiceFactoryBean</code> for more information on when to use
FormatterRegistrar implementations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-validation"><a class="anchor" href="#mvc-config-validation"></a>Validation</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-validation" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>By default, if <a href="../core.html#validation-beanvalidation-overview" class="page">Bean Validation</a> is present
on the classpath (for example, Hibernate Validator), the <code>LocalValidatorFactoryBean</code> is
registered as a global <a href="../core.html#validator" class="page">Validator</a> for use with <code>@Valid</code> and
<code>Validated</code> on controller method arguments.</p>
</div>
<div class="paragraph">
<p>In Java configuration, you can customize the global <code>Validator</code> instance, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public Validator getValidator() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun getValidator(): Validator {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/mvc
		https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

	&lt;mvc:annotation-driven validator="globalValidator"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can also register <code>Validator</code> implementations locally, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class MyController {

	@InitBinder
	protected void initBinder(WebDataBinder binder) {
		binder.addValidators(new FooValidator());
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Controller
class MyController {

	@InitBinder
	protected fun initBinder(binder: WebDataBinder) {
		binder.addValidators(FooValidator())
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you need to have a <code>LocalValidatorFactoryBean</code> injected somewhere, create a bean and
mark it with <code>@Primary</code> in order to avoid conflict with the one declared in the MVC configuration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-interceptors"><a class="anchor" href="#mvc-config-interceptors"></a>Interceptors</h3>
<div class="paragraph">
<p>In Java configuration, you can register interceptors to apply to incoming requests, as
the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(new LocaleChangeInterceptor());
		registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
		registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addInterceptors(registry: InterceptorRegistry) {
		registry.addInterceptor(LocaleChangeInterceptor())
		registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**")
		registry.addInterceptor(SecurityInterceptor()).addPathPatterns("/secure/*")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:interceptors&gt;
	&lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;
	&lt;mvc:interceptor&gt;
		&lt;mvc:mapping path="/**"/&gt;
		&lt;mvc:exclude-mapping path="/admin/**"/&gt;
		&lt;bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/&gt;
	&lt;/mvc:interceptor&gt;
	&lt;mvc:interceptor&gt;
		&lt;mvc:mapping path="/secure/*"/&gt;
		&lt;bean class="org.example.SecurityInterceptor"/&gt;
	&lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-content-negotiation"><a class="anchor" href="#mvc-config-content-negotiation"></a>Content Types</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-content-negotiation" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can configure how Spring MVC determines the requested media types from the request
(for example, <code>Accept</code> header, URL path extension, query parameter, and others).</p>
</div>
<div class="paragraph">
<p>By default, the URL path extension is checked first&#8201;&#8212;&#8201;with <code>json</code>, <code>xml</code>, <code>rss</code>, and <code>atom</code>
registered as known extensions (depending on classpath dependencies). The <code>Accept</code> header
is checked second.</p>
</div>
<div class="paragraph">
<p>Consider changing those defaults to <code>Accept</code> header only, and, if you must use URL-based
content type resolution, consider using the query parameter strategy over path extensions. See
<a href="#mvc-ann-requestmapping-suffix-pattern-match">Suffix Match</a> and <a href="#mvc-ann-requestmapping-rfd">Suffix Match and RFD</a> for
more details.</p>
</div>
<div class="paragraph">
<p>In Java configuration, you can customize requested content type resolution, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
		configurer.mediaType("json", MediaType.APPLICATION_JSON);
		configurer.mediaType("xml", MediaType.APPLICATION_XML);
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) {
		configurer.mediaType("json", MediaType.APPLICATION_JSON)
		configurer.mediaType("xml", MediaType.APPLICATION_XML)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/&gt;

&lt;bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean"&gt;
	&lt;property name="mediaTypes"&gt;
		&lt;value&gt;
			json=application/json
			xml=application/xml
		&lt;/value&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-message-converters"><a class="anchor" href="#mvc-config-message-converters"></a>Message Converters</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-message-codecs" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can customize <code>HttpMessageConverter</code> in Java configuration by overriding
{api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-[<code>configureMessageConverters()</code>]
(to replace the default converters created by Spring MVC) or by overriding
{api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-[<code>extendMessageConverters()</code>]
(to customize the default converters or add additional converters to the default ones).</p>
</div>
<div class="paragraph">
<p>The following example adds XML and Jackson JSON converters with a customized
<code>ObjectMapper</code> instead of the default ones:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfiguration implements WebMvcConfigurer {

	@Override
	public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
		Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
				.indentOutput(true)
				.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
				.modulesToInstall(new ParameterNamesModule());
		converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
		converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfiguration : WebMvcConfigurer {

	override fun configureMessageConverters(converters: MutableList&lt;HttpMessageConverter&lt;*&gt;&gt;) {
		val builder = Jackson2ObjectMapperBuilder()
				.indentOutput(true)
				.dateFormat(SimpleDateFormat("yyyy-MM-dd"))
				.modulesToInstall(ParameterNamesModule())
		converters.add(MappingJackson2HttpMessageConverter(builder.build()))
		converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example,
{api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[<code>Jackson2ObjectMapperBuilder</code>]
is used to create a common configuration for both <code>MappingJackson2HttpMessageConverter</code> and
<code>MappingJackson2XmlHttpMessageConverter</code> with indentation enabled, a customized date format,
and the registration of
<a href="https://github.com/FasterXML/jackson-module-parameter-names"><code>jackson-module-parameter-names</code></a>,
Which adds support for accessing parameter names (a feature added in Java 8).</p>
</div>
<div class="paragraph">
<p>This builder customizes Jackson&#8217;s default properties as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</p>
</li>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also automatically registers the following well-known modules if they are detected on the classpath:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>: Support for Joda-Time types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>: Support for Java 8 Date and Time API types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>: Support for other Java 8 types, such as <code>Optional</code>.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-module-kotlin"><code>jackson-module-kotlin</code></a>: Support for Kotlin classes and data classes.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Enabling indentation with Jackson XML support requires
<a href="https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22"><code>woodstox-core-asl</code></a>
dependency in addition to <a href="https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22"><code>jackson-dataformat-xml</code></a> one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Other interesting Jackson modules are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a>: Support for <code>javax.money</code> types (unofficial module).</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a>: Support for Hibernate-specific types and properties (including lazy-loading aspects).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven&gt;
	&lt;mvc:message-converters&gt;
		&lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt;
			&lt;property name="objectMapper" ref="objectMapper"/&gt;
		&lt;/bean&gt;
		&lt;bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"&gt;
			&lt;property name="objectMapper" ref="xmlMapper"/&gt;
		&lt;/bean&gt;
	&lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;

&lt;bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
	  p:indentOutput="true"
	  p:simpleDateFormat="yyyy-MM-dd"
	  p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/&gt;

&lt;bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-view-controller"><a class="anchor" href="#mvc-config-view-controller"></a>View Controllers</h3>
<div class="paragraph">
<p>This is a shortcut for defining a <code>ParameterizableViewController</code> that immediately
forwards to a view when invoked. You can use it in static cases when there is no Java controller
logic to run before the view generates the response.</p>
</div>
<div class="paragraph">
<p>The following example of Java configuration forwards a request for <code>/</code> to a view called <code>home</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController("/").setViewName("home");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addViewControllers(registry: ViewControllerRegistry) {
		registry.addViewController("/").setViewName("home")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example achieves the same thing as the preceding example, but with XML, by
using the <code>&lt;mvc:view-controller&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:view-controller path="/" view-name="home"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an <code>@RequestMapping</code> method is mapped to a URL for any HTTP method then a view
controller cannot be used to handle the same URL. This is because a match by URL to an
annotated controller is considered a strong enough indication of endpoint ownership so
that a 405 (METHOD_NOT_ALLOWED), a 415 (UNSUPPORTED_MEDIA_TYPE), or similar response can
be sent to the client to help with debugging. For this reason it is recommended to avoid
splitting URL handling across an annotated controller and a view controller.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-view-resolvers"><a class="anchor" href="#mvc-config-view-resolvers"></a>View Resolvers</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-view-resolvers" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>The MVC configuration simplifies the registration of view resolvers.</p>
</div>
<div class="paragraph">
<p>The following Java configuration example configures content negotiation view
resolution by using JSP and Jackson as a default <code>View</code> for JSON rendering:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.enableContentNegotiation(new MappingJackson2JsonView());
		registry.jsp();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.enableContentNegotiation(MappingJackson2JsonView())
		registry.jsp()
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:view-resolvers&gt;
	&lt;mvc:content-negotiation&gt;
		&lt;mvc:default-views&gt;
			&lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt;
		&lt;/mvc:default-views&gt;
	&lt;/mvc:content-negotiation&gt;
	&lt;mvc:jsp/&gt;
&lt;/mvc:view-resolvers&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, however, that FreeMarker, Tiles, Groovy Markup, and script templates also require
configuration of the underlying view technology.</p>
</div>
<div class="paragraph">
<p>The MVC namespace provides dedicated elements. The following example works with FreeMarker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:view-resolvers&gt;
	&lt;mvc:content-negotiation&gt;
		&lt;mvc:default-views&gt;
			&lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt;
		&lt;/mvc:default-views&gt;
	&lt;/mvc:content-negotiation&gt;
	&lt;mvc:freemarker cache="false"/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;mvc:freemarker-configurer&gt;
	&lt;mvc:template-loader-path location="/freemarker"/&gt;
&lt;/mvc:freemarker-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Java configuration, you can add the respective <code>Configurer</code> bean,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.enableContentNegotiation(new MappingJackson2JsonView());
		registry.freeMarker().cache(false);
	}

	@Bean
	public FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setTemplateLoaderPath("/freemarker");
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureViewResolvers(registry: ViewResolverRegistry) {
		registry.enableContentNegotiation(MappingJackson2JsonView())
		registry.freeMarker().cache(false)
	}

	@Bean
	fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
		setTemplateLoaderPath("/freemarker")
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-static-resources"><a class="anchor" href="#mvc-config-static-resources"></a>Static Resources</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-static-resources" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>This option provides a convenient way to serve static resources from a list of
{api-spring-framework}/core/io/Resource.html[<code>Resource</code>]-based locations.</p>
</div>
<div class="paragraph">
<p>In the next example, given a request that starts with <code>/resources</code>, the relative path is
used to find and serve static resources relative to <code>/public</code> under the web application
root or on the classpath under <code>/static</code>. The resources are served with a one-year future
expiration to ensure maximum use of the browser cache and a reduction in HTTP requests
made by the browser. The <code>Last-Modified</code> information is deduced from <code>Resource#lastModified</code>
so that HTTP conditional requests are supported with <code>"Last-Modified"</code> headers.</p>
</div>
<div class="paragraph">
<p>The following listing shows how to do so with Java configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/resources/**")
			.addResourceLocations("/public", "classpath:/static/")
			.setCacheControl(CacheControl.maxAge(Duration.ofDays(365)));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
		registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public", "classpath:/static/")
				.setCacheControl(CacheControl.maxAge(Duration.ofDays(365)))
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:resources mapping="/resources/**"
	location="/public, classpath:/static/"
	cache-period="31556926" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also
<a href="#mvc-caching-static-resources">HTTP caching support for static resources</a>.</p>
</div>
<div class="paragraph">
<p>The resource handler also supports a chain of
{api-spring-framework}/web/servlet/resource/ResourceResolver.html[<code>ResourceResolver</code>] implementations and
{api-spring-framework}/web/servlet/resource/ResourceTransformer.html[<code>ResourceTransformer</code>] implementations,
which you can use to create a toolchain for working with optimized resources.</p>
</div>
<div class="paragraph">
<p>You can use the <code>VersionResourceResolver</code> for versioned resource URLs based on an MD5 hash
computed from the content, a fixed application version, or other. A
<code>ContentVersionStrategy</code> (MD5 hash) is a good choice&#8201;&#8212;&#8201;with some notable exceptions, such as
JavaScript resources used with a module loader.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>VersionResourceResolver</code> in Java configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public/")
				.resourceChain(true)
				.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
		registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public/")
				.resourceChain(true)
				.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:resources mapping="/resources/**" location="/public/"&gt;
	&lt;mvc:resource-chain resource-cache="true"&gt;
		&lt;mvc:resolvers&gt;
			&lt;mvc:version-resolver&gt;
				&lt;mvc:content-version-strategy patterns="/**"/&gt;
			&lt;/mvc:version-resolver&gt;
		&lt;/mvc:resolvers&gt;
	&lt;/mvc:resource-chain&gt;
&lt;/mvc:resources&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use <code>ResourceUrlProvider</code> to rewrite URLs and apply the full chain of resolvers and
transformers&#8201;&#8212;&#8201;for example, to insert versions. The MVC configuration provides a <code>ResourceUrlProvider</code>
bean so that it can be injected into others. You can also make the rewrite transparent with the
<code>ResourceUrlEncodingFilter</code> for Thymeleaf, JSPs, FreeMarker, and others with URL tags that
rely on <code>HttpServletResponse#encodeURL</code>.</p>
</div>
<div class="paragraph">
<p>Note that, when using both <code>EncodedResourceResolver</code> (for example, for serving gzipped or
brotli-encoded resources) and <code>VersionResourceResolver</code>, you must register them in this order.
That ensures content-based versions are always computed reliably, based on the unencoded file.</p>
</div>
<div class="paragraph">
<p><a href="https://www.webjars.org/documentation">WebJars</a> are also supported through the
<code>WebJarsResourceResolver</code> which is automatically registered when the
<code>org.webjars:webjars-locator-core</code> library is present on the classpath. The resolver can
re-write URLs to include the version of the jar and can also match against incoming URLs
without versions&#8201;&#8212;&#8201;for example, from <code>/jquery/jquery.min.js</code> to
<code>/jquery/1.2.0/jquery.min.js</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-default-servlet-handler"><a class="anchor" href="#mvc-default-servlet-handler"></a>Default Servlet</h3>
<div class="paragraph">
<p>Spring MVC allows for mapping the <code>DispatcherServlet</code> to <code>/</code> (thus overriding the mapping
of the container&#8217;s default Servlet), while still allowing static resource requests to be
handled by the container&#8217;s default Servlet. It configures a
<code>DefaultServletHttpRequestHandler</code> with a URL mapping of <code>/**</code> and the lowest priority
relative to other URL mappings.</p>
</div>
<div class="paragraph">
<p>This handler forwards all requests to the default Servlet. Therefore, it must
remain last in the order of all other URL <code>HandlerMappings</code>. That is the
case if you use <code>&lt;mvc:annotation-driven&gt;</code>. Alternatively, if you set up your
own customized <code>HandlerMapping</code> instance, be sure to set its <code>order</code> property to a value
lower than that of the <code>DefaultServletHttpRequestHandler</code>, which is <code>Integer.MAX_VALUE</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to enable the feature by using the default setup:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
		configurer.enable()
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:default-servlet-handler/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The caveat to overriding the <code>/</code> Servlet mapping is that the <code>RequestDispatcher</code> for the
default Servlet must be retrieved by name rather than by path. The
<code>DefaultServletHttpRequestHandler</code> tries to auto-detect the default Servlet for
the container at startup time, using a list of known names for most of the major Servlet
containers (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere).
If the default Servlet has been custom-configured with a different name, or if a
different Servlet container is being used where the default Servlet name is unknown,
then you must explicitly provide the default Servlet&#8217;s name, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable("myCustomDefaultServlet");
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
		configurer.enable("myCustomDefaultServlet")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-path-matching"><a class="anchor" href="#mvc-config-path-matching"></a>Path Matching</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-path-matching" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>You can customize options related to path matching and treatment of the URL.
For details on the individual options, see the
{api-spring-framework}/web/servlet/config/annotation/PathMatchConfigurer.html[<code>PathMatchConfigurer</code>] javadoc.</p>
</div>
<div class="paragraph">
<p>The following example shows how to customize path matching in Java configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void configurePathMatch(PathMatchConfigurer configurer) {
		configurer
			.setPatternParser(new PathPatternParser())
			.addPathPrefix("/api", HandlerTypePredicate.forAnnotation(RestController.class));
	}

	private PathPatternParser patternParser() {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

	override fun configurePathMatch(configurer: PathMatchConfigurer) {
		configurer
			.setPatternParser(patternParser)
			.addPathPrefix("/api", HandlerTypePredicate.forAnnotation(RestController::class.java))
	}

	fun patternParser(): PathPatternParser {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to achieve the same configuration in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven&gt;
	&lt;mvc:path-matching
		trailing-slash="false"
		path-helper="pathHelper"
		path-matcher="pathMatcher"/&gt;
&lt;/mvc:annotation-driven&gt;

&lt;bean id="pathHelper" class="org.example.app.MyPathHelper"/&gt;
&lt;bean id="pathMatcher" class="org.example.app.MyPathMatcher"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-advanced-java"><a class="anchor" href="#mvc-config-advanced-java"></a>Advanced Java Config</h3>
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-config-advanced-java" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebMvc</code> imports <code>DelegatingWebMvcConfiguration</code>, which:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provides default Spring configuration for Spring MVC applications</p>
</li>
<li>
<p>Detects and delegates to <code>WebMvcConfigurer</code> implementations to customize that configuration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For advanced mode, you can remove <code>@EnableWebMvc</code> and extend directly from
<code>DelegatingWebMvcConfiguration</code> instead of implementing <code>WebMvcConfigurer</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebConfig extends DelegatingWebMvcConfiguration {

	// ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class WebConfig : DelegatingWebMvcConfiguration() {

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can keep existing methods in <code>WebConfig</code>, but you can now also override bean declarations
from the base class, and you can still have any number of other <code>WebMvcConfigurer</code> implementations on
the classpath.</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config-advanced-xml"><a class="anchor" href="#mvc-config-advanced-xml"></a>Advanced XML Config</h3>
<div class="paragraph">
<p>The MVC namespace does not have an advanced mode. If you need to customize a property on
a bean that you cannot change otherwise, you can use the <code>BeanPostProcessor</code> lifecycle
hook of the Spring <code>ApplicationContext</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyPostProcessor implements BeanPostProcessor {

	public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Component
class MyPostProcessor : BeanPostProcessor {

	override fun postProcessBeforeInitialization(bean: Any, name: String): Any {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you need to declare <code>MyPostProcessor</code> as a bean, either explicitly in XML or
by letting it be detected through a <code>&lt;component-scan/&gt;</code> declaration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc-http2"><a class="anchor" href="#mvc-http2"></a>HTTP/2</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="../web-reactive.html#webflux-http2" class="page">WebFlux</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4 containers are required to support HTTP/2, and Spring Framework 5 is compatible
with Servlet API 4. From a programming model perspective, there is nothing specific that
applications need to do. However, there are considerations related to server configuration.
For more details, see the
<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 wiki page</a>.</p>
</div>
<div class="paragraph">
<p>The Servlet API does expose one construct related to HTTP/2. You can use the
<code>javax.servlet.http.PushBuilder</code> to proactively push resources to clients, and it
is supported as a <a href="#mvc-ann-arguments">method argument</a> to <code>@RequestMapping</code> methods.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
